/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fworkspaces%2Feburondual%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fworkspaces%2Feburondual%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/page.tsx */ \"(app-pages-browser)/./app/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGd29ya3NwYWNlcyUyRmVidXJvbmR1YWwlMkZhcHAlMkZwYWdlLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLHNKQUF3RSIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL3dvcmtzcGFjZXMvZWJ1cm9uZHVhbC9hcHAvcGFnZS50c3hcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fworkspaces%2Feburondual%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/Icon.js":
/*!****************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/Icon.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Icon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultAttributes.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js\");\n/* harmony import */ var _shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/src/utils.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js\");\n/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \n\n\nconst Icon = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(_c = (param, ref)=>{\n    let { color = \"currentColor\", size = 24, strokeWidth = 2, absoluteStrokeWidth, className = \"\", children, iconNode, ...rest } = param;\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"svg\", {\n        ref,\n        ..._defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n        width: size,\n        height: size,\n        stroke: color,\n        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,\n        className: (0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.mergeClasses)(\"lucide\", className),\n        ...rest\n    }, [\n        ...iconNode.map((param)=>{\n            let [tag, attrs] = param;\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(tag, attrs);\n        }),\n        ...Array.isArray(children) ? children : [\n            children\n        ]\n    ]);\n});\n_c1 = Icon;\n //# sourceMappingURL=Icon.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Icon$forwardRef\");\n$RefreshReg$(_c1, \"Icon\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vSWNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBLENBQU0sU0FBTyx3RUFDWCxRQVdFLEdBQ0c7UUFYSCxFQUNFLEtBQVEsbUJBQ1IsSUFBTyxPQUNQLFdBQWMsTUFDZCxxQkFDQSxTQUFZLE9BQ1osVUFDQSxVQUNBLEdBQUc7SUFJRSwyRUFDTCxNQUNBO1FBQ0U7UUFDQSxHQUFHO1FBQ0gsS0FBTztRQUNQLE1BQVE7UUFDUixNQUFRO1FBQ1IsWUFBYSxxQkFBdUIsUUFBTyxFQUFXLFlBQUksSUFBTSxVQUFPLENBQUksSUFBSTtRQUMvRSxVQUFXLG1FQUFhLFdBQVUsU0FBUztRQUMzQyxHQUFHO0lBQ0wsR0FDQTtXQUNLLENBQVMsWUFBSTtnQkFBQyxDQUFDLENBQUssS0FBSyxLQUFNO2lDQUFBLHFEQUFjLEdBQUssT0FBSyxDQUFDOztXQUN2RCxLQUFNLFNBQVEsUUFBUSxDQUFJLGNBQVc7WUFBQyxRQUFRO1NBQUE7S0FDcEQ7QUFFSiIsInNvdXJjZXMiOlsiL3NyYy9JY29uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGZvcndhcmRSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgZGVmYXVsdEF0dHJpYnV0ZXMgZnJvbSAnLi9kZWZhdWx0QXR0cmlidXRlcyc7XG5pbXBvcnQgeyBJY29uTm9kZSwgTHVjaWRlUHJvcHMgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IG1lcmdlQ2xhc3NlcyB9IGZyb20gJ0BsdWNpZGUvc2hhcmVkJztcblxuaW50ZXJmYWNlIEljb25Db21wb25lbnRQcm9wcyBleHRlbmRzIEx1Y2lkZVByb3BzIHtcbiAgaWNvbk5vZGU6IEljb25Ob2RlO1xufVxuXG4vKipcbiAqIEx1Y2lkZSBpY29uIGNvbXBvbmVudFxuICpcbiAqIEBjb21wb25lbnQgSWNvblxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMuY29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIGljb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBwcm9wcy5zaXplIC0gVGhlIHNpemUgb2YgdGhlIGljb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBwcm9wcy5zdHJva2VXaWR0aCAtIFRoZSBzdHJva2Ugd2lkdGggb2YgdGhlIGljb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJvcHMuYWJzb2x1dGVTdHJva2VXaWR0aCAtIFdoZXRoZXIgdG8gdXNlIGFic29sdXRlIHN0cm9rZSB3aWR0aFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BzLmNsYXNzTmFtZSAtIFRoZSBjbGFzcyBuYW1lIG9mIHRoZSBpY29uXG4gKiBAcGFyYW0ge0ljb25Ob2RlfSBwcm9wcy5jaGlsZHJlbiAtIFRoZSBjaGlsZHJlbiBvZiB0aGUgaWNvblxuICogQHBhcmFtIHtJY29uTm9kZX0gcHJvcHMuaWNvbk5vZGUgLSBUaGUgaWNvbiBub2RlIG9mIHRoZSBpY29uXG4gKlxuICogQHJldHVybnMge0ZvcndhcmRSZWZFeG90aWNDb21wb25lbnR9IEx1Y2lkZUljb25cbiAqL1xuY29uc3QgSWNvbiA9IGZvcndhcmRSZWY8U1ZHU1ZHRWxlbWVudCwgSWNvbkNvbXBvbmVudFByb3BzPihcbiAgKFxuICAgIHtcbiAgICAgIGNvbG9yID0gJ2N1cnJlbnRDb2xvcicsXG4gICAgICBzaXplID0gMjQsXG4gICAgICBzdHJva2VXaWR0aCA9IDIsXG4gICAgICBhYnNvbHV0ZVN0cm9rZVdpZHRoLFxuICAgICAgY2xhc3NOYW1lID0gJycsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGljb25Ob2RlLFxuICAgICAgLi4ucmVzdFxuICAgIH0sXG4gICAgcmVmLFxuICApID0+IHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChcbiAgICAgICdzdmcnLFxuICAgICAge1xuICAgICAgICByZWYsXG4gICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGVzLFxuICAgICAgICB3aWR0aDogc2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBzaXplLFxuICAgICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogYWJzb2x1dGVTdHJva2VXaWR0aCA/IChOdW1iZXIoc3Ryb2tlV2lkdGgpICogMjQpIC8gTnVtYmVyKHNpemUpIDogc3Ryb2tlV2lkdGgsXG4gICAgICAgIGNsYXNzTmFtZTogbWVyZ2VDbGFzc2VzKCdsdWNpZGUnLCBjbGFzc05hbWUpLFxuICAgICAgICAuLi5yZXN0LFxuICAgICAgfSxcbiAgICAgIFtcbiAgICAgICAgLi4uaWNvbk5vZGUubWFwKChbdGFnLCBhdHRyc10pID0+IGNyZWF0ZUVsZW1lbnQodGFnLCBhdHRycykpLFxuICAgICAgICAuLi4oQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbiA6IFtjaGlsZHJlbl0pLFxuICAgICAgXSxcbiAgICApO1xuICB9LFxuKTtcblxuZXhwb3J0IGRlZmF1bHQgSWNvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/Icon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/createLucideIcon.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ createLucideIcon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/src/utils.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js\");\n/* harmony import */ var _Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Icon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/Icon.js\");\n/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \n\n\nconst createLucideIcon = (iconName, iconNode)=>{\n    const Component = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((param, ref)=>{\n        let { className, ...props } = param;\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(_Icon_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n            ref,\n            iconNode,\n            className: (0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.mergeClasses)(\"lucide-\".concat((0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.toKebabCase)(iconName)), className),\n            ...props\n        });\n    });\n    Component.displayName = \"\".concat(iconName);\n    return Component;\n};\n //# sourceMappingURL=createLucideIcon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vY3JlYXRlTHVjaWRlSWNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBV00sdUJBQW1CLEdBQUMsVUFBa0IsUUFBdUI7SUFDakUsTUFBTSxDQUFZLG1GQUFpRTtZQUF6QixFQUFFLENBQVcsV0FBRyxRQUFTOzZCQUNqRixvREFBYSxDQUFDLGdEQUFNO1lBQ2xCO1lBQ0E7WUFDQSxXQUFXLGtFQUFhLFdBQStCLE9BQXJCLGlFQUFXLENBQUMsUUFBUSxDQUFDLEdBQUksU0FBUztZQUNwRSxHQUFHO1FBQUEsQ0FDSjs7SUFHTyx3QkFBYyxDQUFHLEVBQVEsT0FBUixRQUFRO0lBRTVCO0FBQ1QiLCJzb3VyY2VzIjpbIi9zcmMvY3JlYXRlTHVjaWRlSWNvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbWVyZ2VDbGFzc2VzLCB0b0tlYmFiQ2FzZSB9IGZyb20gJ0BsdWNpZGUvc2hhcmVkJztcbmltcG9ydCB7IEljb25Ob2RlLCBMdWNpZGVQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi9JY29uJztcblxuLyoqXG4gKiBDcmVhdGUgYSBMdWNpZGUgaWNvbiBjb21wb25lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBpY29uTmFtZVxuICogQHBhcmFtIHthcnJheX0gaWNvbk5vZGVcbiAqIEByZXR1cm5zIHtGb3J3YXJkUmVmRXhvdGljQ29tcG9uZW50fSBMdWNpZGVJY29uXG4gKi9cbmNvbnN0IGNyZWF0ZUx1Y2lkZUljb24gPSAoaWNvbk5hbWU6IHN0cmluZywgaWNvbk5vZGU6IEljb25Ob2RlKSA9PiB7XG4gIGNvbnN0IENvbXBvbmVudCA9IGZvcndhcmRSZWY8U1ZHU1ZHRWxlbWVudCwgTHVjaWRlUHJvcHM+KCh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PlxuICAgIGNyZWF0ZUVsZW1lbnQoSWNvbiwge1xuICAgICAgcmVmLFxuICAgICAgaWNvbk5vZGUsXG4gICAgICBjbGFzc05hbWU6IG1lcmdlQ2xhc3NlcyhgbHVjaWRlLSR7dG9LZWJhYkNhc2UoaWNvbk5hbWUpfWAsIGNsYXNzTmFtZSksXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KSxcbiAgKTtcblxuICBDb21wb25lbnQuZGlzcGxheU5hbWUgPSBgJHtpY29uTmFtZX1gO1xuXG4gIHJldHVybiBDb21wb25lbnQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVMdWNpZGVJY29uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/defaultAttributes.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ defaultAttributes)\n/* harmony export */ });\n/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ var defaultAttributes = {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: 24,\n    height: 24,\n    viewBox: \"0 0 24 24\",\n    fill: \"none\",\n    stroke: \"currentColor\",\n    strokeWidth: 2,\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n};\n //# sourceMappingURL=defaultAttributes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vZGVmYXVsdEF0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0lBQUEsQ0FBZTtJQUNiLEtBQU87SUFDUCxLQUFPO0lBQ1AsTUFBUTtJQUNSLE9BQVM7SUFDVCxJQUFNO0lBQ04sTUFBUTtJQUNSLFdBQWE7SUFDYixhQUFlO0lBQ2YsY0FBZ0I7QUFDbEIiLCJzb3VyY2VzIjpbIi9zcmMvZGVmYXVsdEF0dHJpYnV0ZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1xuICB4bWxuczogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgd2lkdGg6IDI0LFxuICBoZWlnaHQ6IDI0LFxuICB2aWV3Qm94OiAnMCAwIDI0IDI0JyxcbiAgZmlsbDogJ25vbmUnLFxuICBzdHJva2U6ICdjdXJyZW50Q29sb3InLFxuICBzdHJva2VXaWR0aDogMixcbiAgc3Ryb2tlTGluZWNhcDogJ3JvdW5kJyxcbiAgc3Ryb2tlTGluZWpvaW46ICdyb3VuZCcsXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/chevron-down.js":
/*!******************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/chevron-down.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ChevronDown)\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst ChevronDown = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ChevronDown\", [\n    [\n        \"path\",\n        {\n            d: \"m6 9 6 6 6-6\",\n            key: \"qrunsl\"\n        }\n    ]\n]);\n //# sourceMappingURL=chevron-down.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvY2hldnJvbi1kb3duLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBYU0sb0JBQWMsZ0VBQWdCLENBQUMsYUFBZTtJQUNsRDtRQUFDLE1BQVE7UUFBQTtZQUFFLEdBQUcsQ0FBZ0I7WUFBQSxLQUFLO1FBQUEsQ0FBVTtLQUFBO0NBQzlDIiwic291cmNlcyI6WyIvc3JjL2ljb25zL2NoZXZyb24tZG93bi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uJztcblxuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIENoZXZyb25Eb3duXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSnROaUE1SURZZ05pQTJMVFlpSUM4K0Nqd3ZjM1puUGdvPSkgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvY2hldnJvbi1kb3duXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgQ2hldnJvbkRvd24gPSBjcmVhdGVMdWNpZGVJY29uKCdDaGV2cm9uRG93bicsIFtcbiAgWydwYXRoJywgeyBkOiAnbTYgOSA2IDYgNi02Jywga2V5OiAncXJ1bnNsJyB9XSxcbl0pO1xuXG5leHBvcnQgZGVmYXVsdCBDaGV2cm9uRG93bjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/chevron-down.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/clock.js":
/*!***********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/clock.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Clock)\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Clock = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Clock\", [\n    [\n        \"circle\",\n        {\n            cx: \"12\",\n            cy: \"12\",\n            r: \"10\",\n            key: \"1mglay\"\n        }\n    ],\n    [\n        \"polyline\",\n        {\n            points: \"12 6 12 12 16 14\",\n            key: \"68esgv\"\n        }\n    ]\n]);\n //# sourceMappingURL=clock.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvY2xvY2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFhTSxjQUFRLGdFQUFnQixDQUFDLE9BQVM7SUFDdEM7UUFBQyxRQUFVO1FBQUE7WUFBRSxFQUFJO1lBQU0sQ0FBSSxRQUFNO1lBQUEsQ0FBRztZQUFNLEdBQUs7UUFBQSxDQUFVO0tBQUE7SUFDekQ7UUFBQyxVQUFZO1FBQUE7WUFBRSxRQUFRLENBQW9CO1lBQUEsS0FBSztRQUFBLENBQVU7S0FBQTtDQUMzRCIsInNvdXJjZXMiOlsiL3NyYy9pY29ucy9jbG9jay50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uJztcblxuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIENsb2NrXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThZMmx5WTJ4bElHTjRQU0l4TWlJZ1kzazlJakV5SWlCeVBTSXhNQ0lnTHo0S0lDQThjRzlzZVd4cGJtVWdjRzlwYm5SelBTSXhNaUEySURFeUlERXlJREUySURFMElpQXZQZ284TDNOMlp6NEspIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL2Nsb2NrXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgQ2xvY2sgPSBjcmVhdGVMdWNpZGVJY29uKCdDbG9jaycsIFtcbiAgWydjaXJjbGUnLCB7IGN4OiAnMTInLCBjeTogJzEyJywgcjogJzEwJywga2V5OiAnMW1nbGF5JyB9XSxcbiAgWydwb2x5bGluZScsIHsgcG9pbnRzOiAnMTIgNiAxMiAxMiAxNiAxNCcsIGtleTogJzY4ZXNndicgfV0sXG5dKTtcblxuZXhwb3J0IGRlZmF1bHQgQ2xvY2s7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/clock.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/printer.js":
/*!*************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/printer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Printer)\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Printer = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Printer\", [\n    [\n        \"path\",\n        {\n            d: \"M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2\",\n            key: \"143wyd\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M6 9V3a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v6\",\n            key: \"1itne7\"\n        }\n    ],\n    [\n        \"rect\",\n        {\n            x: \"6\",\n            y: \"14\",\n            width: \"12\",\n            height: \"8\",\n            rx: \"1\",\n            key: \"1ue0tg\"\n        }\n    ]\n]);\n //# sourceMappingURL=printer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvcHJpbnRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWFNLGdCQUFVLGdFQUFnQixDQUFDLFNBQVc7SUFDMUM7UUFDRTtRQUNBO1lBQ0UsQ0FBRztZQUNILEdBQUs7UUFDUDtLQUNGO0lBQ0E7UUFBQyxNQUFRO1FBQUE7WUFBRSxHQUFHLENBQTJDO1lBQUEsS0FBSztRQUFBLENBQVU7S0FBQTtJQUN4RTtRQUFDLE9BQVE7UUFBQTtZQUFFLEdBQUc7WUFBSyxDQUFHO1lBQU0sQ0FBTztZQUFNLFFBQVEsQ0FBSztZQUFBLElBQUksQ0FBSztZQUFBLEtBQUs7UUFBQSxDQUFVO0tBQUE7Q0FDL0UiLCJzb3VyY2VzIjpbIi9zcmMvaWNvbnMvcHJpbnRlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uJztcblxuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIFByaW50ZXJcbiAqIEBkZXNjcmlwdGlvbiBMdWNpZGUgU1ZHIGljb24gY29tcG9uZW50LCByZW5kZXJzIFNWRyBFbGVtZW50IHdpdGggY2hpbGRyZW4uXG4gKlxuICogQHByZXZpZXcgIVtpbWddKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklnb2dJSGRwWkhSb1BTSXlOQ0lLSUNCb1pXbG5hSFE5SWpJMElnb2dJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lLSUNCbWFXeHNQU0p1YjI1bElnb2dJSE4wY205clpUMGlJekF3TUNJZ2MzUjViR1U5SW1KaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNObVptWTdJR0p2Y21SbGNpMXlZV1JwZFhNNklESndlQ0lLSUNCemRISnZhMlV0ZDJsa2RHZzlJaklpQ2lBZ2MzUnliMnRsTFd4cGJtVmpZWEE5SW5KdmRXNWtJZ29nSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlDajRLSUNBOGNHRjBhQ0JrUFNKTk5pQXhPRWcwWVRJZ01pQXdJREFnTVMweUxUSjJMVFZoTWlBeUlEQWdNQ0F4SURJdE1tZ3hObUV5SURJZ01DQXdJREVnTWlBeWRqVmhNaUF5SURBZ01DQXhMVElnTW1ndE1pSWdMejRLSUNBOGNHRjBhQ0JrUFNKTk5pQTVWak5oTVNBeElEQWdNQ0F4SURFdE1XZ3hNR0V4SURFZ01DQXdJREVnTVNBeGRqWWlJQzgrQ2lBZ1BISmxZM1FnZUQwaU5pSWdlVDBpTVRRaUlIZHBaSFJvUFNJeE1pSWdhR1ZwWjJoMFBTSTRJaUJ5ZUQwaU1TSWdMejRLUEM5emRtYytDZz09KSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy9wcmludGVyXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgUHJpbnRlciA9IGNyZWF0ZUx1Y2lkZUljb24oJ1ByaW50ZXInLCBbXG4gIFtcbiAgICAncGF0aCcsXG4gICAge1xuICAgICAgZDogJ002IDE4SDRhMiAyIDAgMCAxLTItMnYtNWEyIDIgMCAwIDEgMi0yaDE2YTIgMiAwIDAgMSAyIDJ2NWEyIDIgMCAwIDEtMiAyaC0yJyxcbiAgICAgIGtleTogJzE0M3d5ZCcsXG4gICAgfSxcbiAgXSxcbiAgWydwYXRoJywgeyBkOiAnTTYgOVYzYTEgMSAwIDAgMSAxLTFoMTBhMSAxIDAgMCAxIDEgMXY2Jywga2V5OiAnMWl0bmU3JyB9XSxcbiAgWydyZWN0JywgeyB4OiAnNicsIHk6ICcxNCcsIHdpZHRoOiAnMTInLCBoZWlnaHQ6ICc4Jywgcng6ICcxJywga2V5OiAnMXVlMHRnJyB9XSxcbl0pO1xuXG5leHBvcnQgZGVmYXVsdCBQcmludGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/printer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/settings.js":
/*!**************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/settings.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Settings)\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Settings = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Settings\", [\n    [\n        \"path\",\n        {\n            d: \"M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z\",\n            key: \"1qme2f\"\n        }\n    ],\n    [\n        \"circle\",\n        {\n            cx: \"12\",\n            cy: \"12\",\n            r: \"3\",\n            key: \"1v7zrd\"\n        }\n    ]\n]);\n //# sourceMappingURL=settings.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvc2V0dGluZ3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFhTSxpQkFBVyxnRUFBZ0IsQ0FBQyxVQUFZO0lBQzVDO1FBQ0U7UUFDQTtZQUNFLENBQUc7WUFDSCxHQUFLO1FBQ1A7S0FDRjtJQUNBO1FBQUMsUUFBVTtRQUFBO1lBQUUsRUFBSTtZQUFNLENBQUksUUFBTTtZQUFBLENBQUc7WUFBSyxHQUFLO1FBQUEsQ0FBVTtLQUFBO0NBQ3pEIiwic291cmNlcyI6WyIvc3JjL2ljb25zL3NldHRpbmdzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgU2V0dGluZ3NcbiAqIEBkZXNjcmlwdGlvbiBMdWNpZGUgU1ZHIGljb24gY29tcG9uZW50LCByZW5kZXJzIFNWRyBFbGVtZW50IHdpdGggY2hpbGRyZW4uXG4gKlxuICogQHByZXZpZXcgIVtpbWddKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklnb2dJSGRwWkhSb1BTSXlOQ0lLSUNCb1pXbG5hSFE5SWpJMElnb2dJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lLSUNCbWFXeHNQU0p1YjI1bElnb2dJSE4wY205clpUMGlJekF3TUNJZ2MzUjViR1U5SW1KaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNObVptWTdJR0p2Y21SbGNpMXlZV1JwZFhNNklESndlQ0lLSUNCemRISnZhMlV0ZDJsa2RHZzlJaklpQ2lBZ2MzUnliMnRsTFd4cGJtVmpZWEE5SW5KdmRXNWtJZ29nSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlDajRLSUNBOGNHRjBhQ0JrUFNKTk1USXVNaklnTW1ndExqUTBZVElnTWlBd0lEQWdNQzB5SURKMkxqRTRZVElnTWlBd0lEQWdNUzB4SURFdU56TnNMUzQwTXk0eU5XRXlJRElnTUNBd0lERXRNaUF3YkMwdU1UVXRMakE0WVRJZ01pQXdJREFnTUMweUxqY3pMamN6YkMwdU1qSXVNemhoTWlBeUlEQWdNQ0F3SUM0M015QXlMamN6YkM0eE5TNHhZVElnTWlBd0lEQWdNU0F4SURFdU56SjJMalV4WVRJZ01pQXdJREFnTVMweElERXVOelJzTFM0eE5TNHdPV0V5SURJZ01DQXdJREF0TGpjeklESXVOek5zTGpJeUxqTTRZVElnTWlBd0lEQWdNQ0F5TGpjekxqY3piQzR4TlMwdU1EaGhNaUF5SURBZ01DQXhJRElnTUd3dU5ETXVNalZoTWlBeUlEQWdNQ0F4SURFZ01TNDNNMVl5TUdFeUlESWdNQ0F3SURBZ01pQXlhQzQwTkdFeUlESWdNQ0F3SURBZ01pMHlkaTB1TVRoaE1pQXlJREFnTUNBeElERXRNUzQzTTJ3dU5ETXRMakkxWVRJZ01pQXdJREFnTVNBeUlEQnNMakUxTGpBNFlUSWdNaUF3SURBZ01DQXlMamN6TFM0M00yd3VNakl0TGpNNVlUSWdNaUF3SURBZ01DMHVOek10TWk0M00yd3RMakUxTFM0d09HRXlJRElnTUNBd0lERXRNUzB4TGpjMGRpMHVOV0V5SURJZ01DQXdJREVnTVMweExqYzBiQzR4TlMwdU1EbGhNaUF5SURBZ01DQXdJQzQzTXkweUxqY3piQzB1TWpJdExqTTRZVElnTWlBd0lEQWdNQzB5TGpjekxTNDNNMnd0TGpFMUxqQTRZVElnTWlBd0lEQWdNUzB5SURCc0xTNDBNeTB1TWpWaE1pQXlJREFnTUNBeExURXRNUzQzTTFZMFlUSWdNaUF3SURBZ01DMHlMVEo2SWlBdlBnb2dJRHhqYVhKamJHVWdZM2c5SWpFeUlpQmplVDBpTVRJaUlISTlJak1pSUM4K0Nqd3ZjM1puUGdvPSkgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvc2V0dGluZ3NcbiAqIEBzZWUgaHR0cHM6Ly9sdWNpZGUuZGV2L2d1aWRlL3BhY2thZ2VzL2x1Y2lkZS1yZWFjdCAtIERvY3VtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBMdWNpZGUgaWNvbnMgcHJvcHMgYW5kIGFueSB2YWxpZCBTVkcgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9IEpTWCBFbGVtZW50XG4gKlxuICovXG5jb25zdCBTZXR0aW5ncyA9IGNyZWF0ZUx1Y2lkZUljb24oJ1NldHRpbmdzJywgW1xuICBbXG4gICAgJ3BhdGgnLFxuICAgIHtcbiAgICAgIGQ6ICdNMTIuMjIgMmgtLjQ0YTIgMiAwIDAgMC0yIDJ2LjE4YTIgMiAwIDAgMS0xIDEuNzNsLS40My4yNWEyIDIgMCAwIDEtMiAwbC0uMTUtLjA4YTIgMiAwIDAgMC0yLjczLjczbC0uMjIuMzhhMiAyIDAgMCAwIC43MyAyLjczbC4xNS4xYTIgMiAwIDAgMSAxIDEuNzJ2LjUxYTIgMiAwIDAgMS0xIDEuNzRsLS4xNS4wOWEyIDIgMCAwIDAtLjczIDIuNzNsLjIyLjM4YTIgMiAwIDAgMCAyLjczLjczbC4xNS0uMDhhMiAyIDAgMCAxIDIgMGwuNDMuMjVhMiAyIDAgMCAxIDEgMS43M1YyMGEyIDIgMCAwIDAgMiAyaC40NGEyIDIgMCAwIDAgMi0ydi0uMThhMiAyIDAgMCAxIDEtMS43M2wuNDMtLjI1YTIgMiAwIDAgMSAyIDBsLjE1LjA4YTIgMiAwIDAgMCAyLjczLS43M2wuMjItLjM5YTIgMiAwIDAgMC0uNzMtMi43M2wtLjE1LS4wOGEyIDIgMCAwIDEtMS0xLjc0di0uNWEyIDIgMCAwIDEgMS0xLjc0bC4xNS0uMDlhMiAyIDAgMCAwIC43My0yLjczbC0uMjItLjM4YTIgMiAwIDAgMC0yLjczLS43M2wtLjE1LjA4YTIgMiAwIDAgMS0yIDBsLS40My0uMjVhMiAyIDAgMCAxLTEtMS43M1Y0YTIgMiAwIDAgMC0yLTJ6JyxcbiAgICAgIGtleTogJzFxbWUyZicsXG4gICAgfSxcbiAgXSxcbiAgWydjaXJjbGUnLCB7IGN4OiAnMTInLCBjeTogJzEyJywgcjogJzMnLCBrZXk6ICcxdjd6cmQnIH1dLFxuXSk7XG5cbmV4cG9ydCBkZWZhdWx0IFNldHRpbmdzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/settings.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/volume-2.js":
/*!**************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/volume-2.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Volume2)\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Volume2 = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Volume2\", [\n    [\n        \"path\",\n        {\n            d: \"M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z\",\n            key: \"uqj9uw\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M16 9a5 5 0 0 1 0 6\",\n            key: \"1q6k2b\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M19.364 18.364a9 9 0 0 0 0-12.728\",\n            key: \"ijwkga\"\n        }\n    ]\n]);\n //# sourceMappingURL=volume-2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvdm9sdW1lLTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFhTSxnQkFBVSxnRUFBZ0IsQ0FBQyxTQUFXO0lBQzFDO1FBQ0U7UUFDQTtZQUNFLENBQUc7WUFDSCxHQUFLO1FBQ1A7S0FDRjtJQUNBO1FBQUMsTUFBUTtRQUFBO1lBQUUsR0FBRyxDQUF1QjtZQUFBLEtBQUs7UUFBQSxDQUFVO0tBQUE7SUFDcEQ7UUFBQyxNQUFRO1FBQUE7WUFBRSxHQUFHLENBQXFDO1lBQUEsS0FBSztRQUFBLENBQVU7S0FBQTtDQUNuRSIsInNvdXJjZXMiOlsiL3NyYy9pY29ucy92b2x1bWUtMi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uJztcblxuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIFZvbHVtZTJcbiAqIEBkZXNjcmlwdGlvbiBMdWNpZGUgU1ZHIGljb24gY29tcG9uZW50LCByZW5kZXJzIFNWRyBFbGVtZW50IHdpdGggY2hpbGRyZW4uXG4gKlxuICogQHByZXZpZXcgIVtpbWddKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklnb2dJSGRwWkhSb1BTSXlOQ0lLSUNCb1pXbG5hSFE5SWpJMElnb2dJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lLSUNCbWFXeHNQU0p1YjI1bElnb2dJSE4wY205clpUMGlJekF3TUNJZ2MzUjViR1U5SW1KaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNObVptWTdJR0p2Y21SbGNpMXlZV1JwZFhNNklESndlQ0lLSUNCemRISnZhMlV0ZDJsa2RHZzlJaklpQ2lBZ2MzUnliMnRsTFd4cGJtVmpZWEE5SW5KdmRXNWtJZ29nSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlDajRLSUNBOGNHRjBhQ0JrUFNKTk1URWdOQzQzTURKaExqY3dOUzQzTURVZ01DQXdJREF0TVM0eU1ETXRMalE1T0V3MkxqUXhNeUEzTGpVNE4wRXhMalFnTVM0MElEQWdNQ0F4SURVdU5ERTJJRGhJTTJFeElERWdNQ0F3SURBdE1TQXhkalpoTVNBeElEQWdNQ0F3SURFZ01XZ3lMalF4Tm1FeExqUWdNUzQwSURBZ01DQXhJQzQ1T1RjdU5ERXpiRE11TXpneklETXVNemcwUVM0M01EVXVOekExSURBZ01DQXdJREV4SURFNUxqSTVPSG9pSUM4K0NpQWdQSEJoZEdnZ1pEMGlUVEUySURsaE5TQTFJREFnTUNBeElEQWdOaUlnTHo0S0lDQThjR0YwYUNCa1BTSk5NVGt1TXpZMElERTRMak0yTkdFNUlEa2dNQ0F3SURBZ01DMHhNaTQzTWpnaUlDOCtDand2YzNablBnbz0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL3ZvbHVtZS0yXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgVm9sdW1lMiA9IGNyZWF0ZUx1Y2lkZUljb24oJ1ZvbHVtZTInLCBbXG4gIFtcbiAgICAncGF0aCcsXG4gICAge1xuICAgICAgZDogJ00xMSA0LjcwMmEuNzA1LjcwNSAwIDAgMC0xLjIwMy0uNDk4TDYuNDEzIDcuNTg3QTEuNCAxLjQgMCAwIDEgNS40MTYgOEgzYTEgMSAwIDAgMC0xIDF2NmExIDEgMCAwIDAgMSAxaDIuNDE2YTEuNCAxLjQgMCAwIDEgLjk5Ny40MTNsMy4zODMgMy4zODRBLjcwNS43MDUgMCAwIDAgMTEgMTkuMjk4eicsXG4gICAgICBrZXk6ICd1cWo5dXcnLFxuICAgIH0sXG4gIF0sXG4gIFsncGF0aCcsIHsgZDogJ00xNiA5YTUgNSAwIDAgMSAwIDYnLCBrZXk6ICcxcTZrMmInIH1dLFxuICBbJ3BhdGgnLCB7IGQ6ICdNMTkuMzY0IDE4LjM2NGE5IDkgMCAwIDAgMC0xMi43MjgnLCBrZXk6ICdpandrZ2EnIH1dLFxuXSk7XG5cbmV4cG9ydCBkZWZhdWx0IFZvbHVtZTI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/volume-2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js":
/*!*******************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/x.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ X)\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst X = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"X\", [\n    [\n        \"path\",\n        {\n            d: \"M18 6 6 18\",\n            key: \"1bl5f8\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"m6 6 12 12\",\n            key: \"d8bk6v\"\n        }\n    ]\n]);\n //# sourceMappingURL=x.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMveC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWFNLFVBQUksZ0VBQWdCLENBQUMsR0FBSztJQUM5QjtRQUFDLE1BQVE7UUFBQTtZQUFFLEdBQUcsQ0FBYztZQUFBLEtBQUs7UUFBQSxDQUFVO0tBQUE7SUFDM0M7UUFBQyxNQUFRO1FBQUE7WUFBRSxHQUFHLENBQWM7WUFBQSxLQUFLO1FBQUEsQ0FBVTtLQUFBO0NBQzVDIiwic291cmNlcyI6WyIvc3JjL2ljb25zL3gudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbic7XG5cbi8qKlxuICogQGNvbXBvbmVudCBAbmFtZSBYXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5NVGdnTmlBMklERTRJaUF2UGdvZ0lEeHdZWFJvSUdROUltMDJJRFlnTVRJZ01USWlJQzgrQ2p3dmMzWm5QZ289KSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy94XG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgWCA9IGNyZWF0ZUx1Y2lkZUljb24oJ1gnLCBbXG4gIFsncGF0aCcsIHsgZDogJ00xOCA2IDYgMTgnLCBrZXk6ICcxYmw1ZjgnIH1dLFxuICBbJ3BhdGgnLCB7IGQ6ICdtNiA2IDEyIDEyJywga2V5OiAnZDhiazZ2JyB9XSxcbl0pO1xuXG5leHBvcnQgZGVmYXVsdCBYO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/shared/src/utils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mergeClasses: () => (/* binding */ mergeClasses),\n/* harmony export */   toKebabCase: () => (/* binding */ toKebabCase)\n/* harmony export */ });\n/**\n * @license lucide-react v0.468.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ const toKebabCase = (string)=>string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\nconst mergeClasses = function() {\n    for(var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++){\n        classes[_key] = arguments[_key];\n    }\n    return classes.filter((className, index, array)=>{\n        return Boolean(className) && className.trim() !== \"\" && array.indexOf(className) === index;\n    }).join(\" \").trim();\n};\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vc2hhcmVkL3NyYy91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0lBUWEsb0JBQWMsQ0FBQyxNQUMxQixVQUFPLFFBQVEsb0JBQXNCLFNBQU8sRUFBRSxXQUFZO0FBK0IvQyxtQkFBZSxJQUEyQzs7UUFBQSxPQUNyRTs7V0FBQSxRQUNHLE9BQU8sQ0FBQyxXQUFXLE9BQU8sS0FBVTtRQUVqQyxlQUFRLFNBQVMsRUFDaEIsWUFBcUIsWUFBVyxDQUNqQyxXQUFNLE9BQVEsRUFBUyxTQUFNO0lBRWpDLENBQUMsQ0FDQSxNQUFLLENBQUcsSUFDUixDQUFLIiwic291cmNlcyI6WyIvc2hhcmVkL3NyYy91dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDYW1lbFRvUGFzY2FsIH0gZnJvbSAnLi91dGlsaXR5LXR5cGVzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBzdHJpbmcgdG8ga2ViYWIgY2FzZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEga2ViYWJpemVkIHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgdG9LZWJhYkNhc2UgPSAoc3RyaW5nOiBzdHJpbmcpID0+XG4gIHN0cmluZy5yZXBsYWNlKC8oW2EtejAtOV0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuXG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBjYW1lbCBjYXNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gQSBjYW1lbGl6ZWQgc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCB0b0NhbWVsQ2FzZSA9IDxUIGV4dGVuZHMgc3RyaW5nPihzdHJpbmc6IFQpID0+XG4gIHN0cmluZy5yZXBsYWNlKC9eKFtBLVpdKXxbXFxzLV9dKyhcXHcpL2csIChtYXRjaCwgcDEsIHAyKSA9PlxuICAgIHAyID8gcDIudG9VcHBlckNhc2UoKSA6IHAxLnRvTG93ZXJDYXNlKCksXG4gICk7XG5cbi8qKlxuICogQ29udmVydHMgc3RyaW5nIHRvIHBhc2NhbCBjYXNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gQSBwYXNjYWxpemVkIHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgdG9QYXNjYWxDYXNlID0gPFQgZXh0ZW5kcyBzdHJpbmc+KHN0cmluZzogVCk6IENhbWVsVG9QYXNjYWw8VD4gPT4ge1xuICBjb25zdCBjYW1lbENhc2UgPSB0b0NhbWVsQ2FzZShzdHJpbmcpO1xuXG4gIHJldHVybiAoY2FtZWxDYXNlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2FtZWxDYXNlLnNsaWNlKDEpKSBhcyBDYW1lbFRvUGFzY2FsPFQ+O1xufTtcblxuLyoqXG4gKiBNZXJnZXMgY2xhc3NlcyBpbnRvIGEgc2luZ2xlIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7YXJyYXl9IGNsYXNzZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5nIG9mIGNsYXNzZXNcbiAqL1xuZXhwb3J0IGNvbnN0IG1lcmdlQ2xhc3NlcyA9IDxDbGFzc1R5cGUgPSBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsPiguLi5jbGFzc2VzOiBDbGFzc1R5cGVbXSkgPT5cbiAgY2xhc3Nlc1xuICAgIC5maWx0ZXIoKGNsYXNzTmFtZSwgaW5kZXgsIGFycmF5KSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBCb29sZWFuKGNsYXNzTmFtZSkgJiZcbiAgICAgICAgKGNsYXNzTmFtZSBhcyBzdHJpbmcpLnRyaW0oKSAhPT0gJycgJiZcbiAgICAgICAgYXJyYXkuaW5kZXhPZihjbGFzc05hbWUpID09PSBpbmRleFxuICAgICAgKTtcbiAgICB9KVxuICAgIC5qb2luKCcgJylcbiAgICAudHJpbSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRCIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZWJ1cm9uZHVhbC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9uYXZpZ2F0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4uL2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb24nO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYXZpZ2F0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Home)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _barrel_optimize_names_ChevronDown_Clock_Printer_Settings_Volume2_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=ChevronDown,Clock,Printer,Settings,Volume2,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/clock.js\");\n/* harmony import */ var _barrel_optimize_names_ChevronDown_Clock_Printer_Settings_Volume2_X_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=ChevronDown,Clock,Printer,Settings,Volume2,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/printer.js\");\n/* harmony import */ var _barrel_optimize_names_ChevronDown_Clock_Printer_Settings_Volume2_X_lucide_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=ChevronDown,Clock,Printer,Settings,Volume2,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/settings.js\");\n/* harmony import */ var _barrel_optimize_names_ChevronDown_Clock_Printer_Settings_Volume2_X_lucide_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! __barrel_optimize__?names=ChevronDown,Clock,Printer,Settings,Volume2,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js\");\n/* harmony import */ var _barrel_optimize_names_ChevronDown_Clock_Printer_Settings_Volume2_X_lucide_react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! __barrel_optimize__?names=ChevronDown,Clock,Printer,Settings,Volume2,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/volume-2.js\");\n/* harmony import */ var _barrel_optimize_names_ChevronDown_Clock_Printer_Settings_Volume2_X_lucide_react__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! __barrel_optimize__?names=ChevronDown,Clock,Printer,Settings,Volume2,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/chevron-down.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../types */ \"(app-pages-browser)/./types.ts\");\n/* harmony import */ var _services_geminiLiveService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../services/geminiLiveService */ \"(app-pages-browser)/./services/geminiLiveService.ts\");\n/* harmony import */ var _components_TranslationColumn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/TranslationColumn */ \"(app-pages-browser)/./components/TranslationColumn.tsx\");\n/* harmony import */ var _components_LanguageSelector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../components/LanguageSelector */ \"(app-pages-browser)/./components/LanguageSelector.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nconst AVAILABLE_VOICES = [\n    {\n        id: 'Kore',\n        name: 'Kore (Balanced)'\n    },\n    {\n        id: 'Zephyr',\n        name: 'Zephyr (Bright)'\n    },\n    {\n        id: 'Puck',\n        name: 'Puck (Soft)'\n    },\n    {\n        id: 'Charon',\n        name: 'Charon (Deep)'\n    },\n    {\n        id: 'Fenrir',\n        name: 'Fenrir (Strong)'\n    }\n];\nfunction Home() {\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const [appState, setAppState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(_types__WEBPACK_IMPORTED_MODULE_3__.AppState.LOGIN);\n    const [loginCode, setLoginCode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [staffLang, setStaffLang] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('nl-BE');\n    const [visitorLang, setVisitorLang] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('en-US');\n    const [staffSpeaker, setStaffSpeaker] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [visitorSpeaker, setVisitorSpeaker] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Voice Configuration State\n    const [selectedVoice, setSelectedVoice] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('Kore');\n    const [isListening, setIsListening] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [currentInput, setCurrentInput] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [currentOutput, setCurrentOutput] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    // UI States\n    const [showHistory, setShowHistory] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showSettings, setShowSettings] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [history, setHistory] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [expandedSessionId, setExpandedSessionId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const liveService = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            const saved = localStorage.getItem('succes_history');\n            if (saved) {\n                try {\n                    setHistory(JSON.parse(saved));\n                } catch (e) {\n                    console.error('Failed to load history', e);\n                }\n            }\n            const savedVoice = localStorage.getItem('succes_voice');\n            if (savedVoice) setSelectedVoice(savedVoice);\n        }\n    }[\"Home.useEffect\"], []);\n    const handleLogin = (e)=>{\n        e.preventDefault();\n        const clean = loginCode.trim().toUpperCase();\n        if (clean === '//ADMIN') {\n            router.push('/admin');\n            return;\n        }\n        let validStockCodes = [];\n        try {\n            const stored = localStorage.getItem('succes_access_codes');\n            if (stored) {\n                const parsed = JSON.parse(stored);\n                validStockCodes = parsed.map((item)=>item.code);\n            }\n        } catch (e) {\n            console.error('Error reading stock codes', e);\n        }\n        const isMaster = clean === 'SUCCES2025';\n        const isStockCode = validStockCodes.includes(clean);\n        const isLegacy = /^(SI[A-Z]{2}\\d{6}|AR\\d{6}|DEBUG)$/.test(clean);\n        if (isMaster || isStockCode || isLegacy) {\n            setAppState(_types__WEBPACK_IMPORTED_MODULE_3__.AppState.TRANSLATOR);\n            setError(null);\n        } else {\n            setError('Invalid Access Code.');\n        }\n    };\n    const handleStoreLog = ()=>{\n        if (messages.length === 0) return;\n        const newSession = {\n            id: Date.now().toString(),\n            timestamp: Date.now(),\n            preview: messages[messages.length - 1].originalText.substring(0, 50) + '...',\n            messages: [\n                ...messages\n            ]\n        };\n        const updatedHistory = [\n            newSession,\n            ...history\n        ];\n        setHistory(updatedHistory);\n        localStorage.setItem('succes_history', JSON.stringify(updatedHistory));\n        alert('Log stored.');\n    };\n    const clearHistory = ()=>{\n        if (confirm('Clear history?')) {\n            setHistory([]);\n            localStorage.removeItem('succes_history');\n        }\n    };\n    const toggleMic = async ()=>{\n        if (isListening) {\n            var _liveService_current;\n            (_liveService_current = liveService.current) === null || _liveService_current === void 0 ? void 0 : _liveService_current.disconnect();\n            setIsListening(false);\n        } else {\n            var _LANGUAGES_find, _LANGUAGES_find1;\n            if (!liveService.current) liveService.current = new _services_geminiLiveService__WEBPACK_IMPORTED_MODULE_4__.GeminiLiveService();\n            const sLang = ((_LANGUAGES_find = _types__WEBPACK_IMPORTED_MODULE_3__.LANGUAGES.find((l)=>l.code === staffLang)) === null || _LANGUAGES_find === void 0 ? void 0 : _LANGUAGES_find.name) || 'Flemish';\n            const vLang = ((_LANGUAGES_find1 = _types__WEBPACK_IMPORTED_MODULE_3__.LANGUAGES.find((l)=>l.code === visitorLang)) === null || _LANGUAGES_find1 === void 0 ? void 0 : _LANGUAGES_find1.name) || 'English';\n            try {\n                await liveService.current.connect({\n                    staffLanguage: sLang,\n                    visitorLanguage: vLang,\n                    voiceName: selectedVoice,\n                    onTranscription: (text, isInput)=>{\n                        if (isInput) setCurrentInput((prev)=>prev + text);\n                        else setCurrentOutput((prev)=>prev + text);\n                    },\n                    onTurnComplete: ()=>{},\n                    onError: ()=>setIsListening(false)\n                });\n                setIsListening(true);\n            } catch (err) {\n                setError('Mic error.');\n            }\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            if ((currentInput || currentOutput) && isListening) {\n                const timeout = setTimeout({\n                    \"Home.useEffect.timeout\": ()=>{\n                        const newMessage = {\n                            id: Math.random().toString(36).substr(2, 6).toUpperCase(),\n                            sender: currentInput ? 'staff' : 'visitor',\n                            originalText: currentInput || '...',\n                            translatedText: currentOutput || '...',\n                            timestamp: Date.now()\n                        };\n                        setMessages({\n                            \"Home.useEffect.timeout\": (prev)=>[\n                                    ...prev,\n                                    newMessage\n                                ]\n                        }[\"Home.useEffect.timeout\"]);\n                        setCurrentInput('');\n                        setCurrentOutput('');\n                    }\n                }[\"Home.useEffect.timeout\"], 3500);\n                return ({\n                    \"Home.useEffect\": ()=>clearTimeout(timeout)\n                })[\"Home.useEffect\"];\n            }\n        }\n    }[\"Home.useEffect\"], [\n        currentInput,\n        currentOutput,\n        isListening\n    ]);\n    if (appState === _types__WEBPACK_IMPORTED_MODULE_3__.AppState.LOGIN) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"flex flex-col items-center justify-center min-h-screen bg-neutral-100 p-6\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-full max-w-sm\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-center mb-10\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"w-20 h-20 bg-blue-600 rounded-[2rem] flex items-center justify-center mx-auto mb-6 shadow-xl\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                    xmlns: \"http://www.w3.org/2000/svg\",\n                                    className: \"h-10 w-10 text-white\",\n                                    fill: \"none\",\n                                    viewBox: \"0 0 24 24\",\n                                    stroke: \"currentColor\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                        strokeLinecap: \"round\",\n                                        strokeLinejoin: \"round\",\n                                        strokeWidth: 2.5,\n                                        d: \"M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129\"\n                                    }, void 0, false, {\n                                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                        lineNumber: 165,\n                                        columnNumber: 17\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                    lineNumber: 164,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                lineNumber: 163,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                className: \"text-4xl font-black tracking-tighter text-neutral-900\",\n                                children: \"Succes Dual\"\n                            }, void 0, false, {\n                                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                lineNumber: 168,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-neutral-500 font-bold uppercase tracking-widest text-[10px] mt-2\",\n                                children: \"Professional Translator\"\n                            }, void 0, false, {\n                                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                lineNumber: 169,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                        lineNumber: 162,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-white p-8 rounded-[2.5rem] shadow-2xl border border-black/5\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                            onSubmit: handleLogin,\n                            className: \"space-y-6\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                    type: \"text\",\n                                    value: loginCode,\n                                    onChange: (e)=>setLoginCode(e.target.value),\n                                    placeholder: \"ACCESS CODE\",\n                                    className: \"w-full px-6 py-5 rounded-3xl bg-neutral-50 border-none focus:ring-4 focus:ring-blue-500/10 outline-none text-center font-black text-2xl tracking-tighter uppercase\",\n                                    autoFocus: true\n                                }, void 0, false, {\n                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                    lineNumber: 173,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    type: \"submit\",\n                                    className: \"w-full bg-blue-600 hover:bg-blue-700 text-white font-black py-5 rounded-3xl transition-all text-lg uppercase\",\n                                    children: \"Sign In\"\n                                }, void 0, false, {\n                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                    lineNumber: 181,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                            lineNumber: 172,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                        lineNumber: 171,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                lineNumber: 161,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/workspaces/eburondual/app/page.tsx\",\n            lineNumber: 160,\n            columnNumber: 7\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col h-screen bg-neutral-100 overflow-hidden select-none relative\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n                className: \"px-6 py-4 flex flex-col md:flex-row items-center justify-between gap-4 bg-white border-b border-black/10 no-print z-40 relative\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex items-center gap-4 w-full md:w-auto\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex items-center gap-3 h-11\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"w-10 h-10 bg-blue-600 rounded-xl flex items-center justify-center shadow-lg shadow-blue-500/10\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                            xmlns: \"http://www.w3.org/2000/svg\",\n                                            className: \"h-6 w-6 text-white\",\n                                            fill: \"none\",\n                                            viewBox: \"0 0 24 24\",\n                                            stroke: \"currentColor\",\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                                strokeLinecap: \"round\",\n                                                strokeLinejoin: \"round\",\n                                                strokeWidth: 2.5,\n                                                d: \"M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129\"\n                                            }, void 0, false, {\n                                                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                lineNumber: 198,\n                                                columnNumber: 17\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                            lineNumber: 197,\n                                            columnNumber: 15\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                        lineNumber: 196,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"text-blue-600 font-black tracking-tighter text-2xl leading-none\",\n                                        children: \"SUCCES DUAL\"\n                                    }, void 0, false, {\n                                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                        lineNumber: 201,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                lineNumber: 195,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"hidden md:block\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_LanguageSelector__WEBPACK_IMPORTED_MODULE_6__.LanguageSelector, {\n                                    label: \"Ours (Staff)\",\n                                    value: staffLang,\n                                    onChange: setStaffLang,\n                                    color: \"blue\"\n                                }, void 0, false, {\n                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                    lineNumber: 204,\n                                    columnNumber: 13\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                lineNumber: 203,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                        lineNumber: 194,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex items-center gap-4 w-full md:w-auto justify-end\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"hidden md:block\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_LanguageSelector__WEBPACK_IMPORTED_MODULE_6__.LanguageSelector, {\n                                    label: \"Theirs (Visitor)\",\n                                    value: visitorLang,\n                                    onChange: setVisitorLang,\n                                    color: \"green\"\n                                }, void 0, false, {\n                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                    lineNumber: 210,\n                                    columnNumber: 13\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                lineNumber: 209,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex md:hidden gap-2 w-full\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_LanguageSelector__WEBPACK_IMPORTED_MODULE_6__.LanguageSelector, {\n                                        label: \"Ours\",\n                                        value: staffLang,\n                                        onChange: setStaffLang,\n                                        color: \"blue\"\n                                    }, void 0, false, {\n                                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                        lineNumber: 214,\n                                        columnNumber: 14\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_LanguageSelector__WEBPACK_IMPORTED_MODULE_6__.LanguageSelector, {\n                                        label: \"Theirs\",\n                                        value: visitorLang,\n                                        onChange: setVisitorLang,\n                                        color: \"green\"\n                                    }, void 0, false, {\n                                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                        lineNumber: 215,\n                                        columnNumber: 14\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                lineNumber: 213,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex items-center gap-2 border-l border-black/10 pl-4 h-11\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        onClick: ()=>setShowHistory(true),\n                                        className: \"p-3 hover:bg-blue-50 text-neutral-400 hover:text-blue-600 rounded-xl transition-all flex items-center justify-center h-11 w-11\",\n                                        title: \"History\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ChevronDown_Clock_Printer_Settings_Volume2_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                            className: \"w-5 h-5\"\n                                        }, void 0, false, {\n                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                            lineNumber: 220,\n                                            columnNumber: 15\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                        lineNumber: 219,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        onClick: ()=>window.print(),\n                                        className: \"p-3 hover:bg-neutral-100 text-neutral-400 hover:text-neutral-800 rounded-xl transition-all flex items-center justify-center h-11 w-11\",\n                                        title: \"Print Log\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ChevronDown_Clock_Printer_Settings_Volume2_X_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                            className: \"w-5 h-5\"\n                                        }, void 0, false, {\n                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                            lineNumber: 223,\n                                            columnNumber: 15\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                        lineNumber: 222,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        onClick: ()=>setShowSettings(true),\n                                        className: \"p-3 hover:bg-neutral-100 text-neutral-400 hover:text-neutral-900 rounded-xl transition-all flex items-center justify-center h-11 w-11\",\n                                        title: \"Settings\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ChevronDown_Clock_Printer_Settings_Volume2_X_lucide_react__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                                            className: \"w-5 h-5\"\n                                        }, void 0, false, {\n                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                            lineNumber: 226,\n                                            columnNumber: 15\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                        lineNumber: 225,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                lineNumber: 218,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                        lineNumber: 208,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                lineNumber: 193,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                className: \"flex-1 flex flex-col lg:flex-row gap-4 p-4 overflow-hidden relative\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex-1 h-1/2 lg:h-full\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_TranslationColumn__WEBPACK_IMPORTED_MODULE_5__.TranslationColumn, {\n                            title: \"Ours\",\n                            subtitle: \"STAFF\",\n                            messages: messages,\n                            type: \"staff\",\n                            language: staffLang,\n                            setLanguage: setStaffLang,\n                            speakerOn: staffSpeaker,\n                            setSpeakerOn: setStaffSpeaker\n                        }, void 0, false, {\n                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                            lineNumber: 234,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                        lineNumber: 233,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex-1 h-1/2 lg:h-full\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_TranslationColumn__WEBPACK_IMPORTED_MODULE_5__.TranslationColumn, {\n                            title: \"Theirs\",\n                            subtitle: \"VISITOR\",\n                            messages: messages,\n                            type: \"visitor\",\n                            language: visitorLang,\n                            setLanguage: setVisitorLang,\n                            speakerOn: visitorSpeaker,\n                            setSpeakerOn: setVisitorSpeaker\n                        }, void 0, false, {\n                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                            lineNumber: 246,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                        lineNumber: 245,\n                        columnNumber: 9\n                    }, this),\n                    (currentInput || currentOutput) && isListening && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-50 w-full max-w-lg px-6 no-print message-enter\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"bg-[#1D1D1F] text-white p-6 rounded-[2.5rem] shadow-2xl border border-white/10 ring-8 ring-black/5\",\n                            children: [\n                                currentInput && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"mb-4\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"text-[10px] font-black text-blue-500 uppercase tracking-widest block mb-1\",\n                                            children: \"STT Transcription:\"\n                                        }, void 0, false, {\n                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                            lineNumber: 263,\n                                            columnNumber: 21\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"text-lg font-bold text-neutral-200\",\n                                            children: [\n                                                '\"',\n                                                currentInput,\n                                                '\"'\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                            lineNumber: 264,\n                                            columnNumber: 21\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                    lineNumber: 262,\n                                    columnNumber: 19\n                                }, this),\n                                currentOutput && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"\".concat(currentInput ? 'mt-4 pt-4 border-t border-white/10' : ''),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"text-[10px] font-black text-green-500 uppercase tracking-widest block mb-1\",\n                                            children: \"Live Translation:\"\n                                        }, void 0, false, {\n                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                            lineNumber: 269,\n                                            columnNumber: 21\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"text-xl font-black text-green-400 italic\",\n                                            children: [\n                                                '\"',\n                                                currentOutput,\n                                                '\"'\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                            lineNumber: 270,\n                                            columnNumber: 21\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                    lineNumber: 268,\n                                    columnNumber: 20\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                            lineNumber: 260,\n                            columnNumber: 15\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                        lineNumber: 259,\n                        columnNumber: 12\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                lineNumber: 232,\n                columnNumber: 7\n            }, this),\n            showHistory && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-0 z-50 bg-black/20 backdrop-blur-sm flex justify-end\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"w-full max-w-md h-full bg-white shadow-2xl flex flex-col transform slide-in-from-right\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"p-5 border-b flex items-center justify-between\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                    className: \"text-xl font-black tracking-tight flex items-center gap-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ChevronDown_Clock_Printer_Settings_Volume2_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                            className: \"w-5 h-5\"\n                                        }, void 0, false, {\n                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                            lineNumber: 283,\n                                            columnNumber: 89\n                                        }, this),\n                                        \" History\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                    lineNumber: 283,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: ()=>setShowHistory(false),\n                                    className: \"p-2\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ChevronDown_Clock_Printer_Settings_Volume2_X_lucide_react__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n                                        className: \"w-6 h-6\"\n                                    }, void 0, false, {\n                                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                        lineNumber: 284,\n                                        columnNumber: 77\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                    lineNumber: 284,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                            lineNumber: 282,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex-1 overflow-y-auto p-4 bg-neutral-50\",\n                            children: history.length === 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-center text-neutral-400 py-10 font-black uppercase text-xs\",\n                                children: \"No logs found\"\n                            }, void 0, false, {\n                                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                lineNumber: 287,\n                                columnNumber: 39\n                            }, this) : history.map((session)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"bg-white p-4 rounded-xl mb-4 border shadow-sm\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"text-[10px] font-black text-blue-600 mb-1\",\n                                            children: new Date(session.timestamp).toLocaleString()\n                                        }, void 0, false, {\n                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                            lineNumber: 290,\n                                            columnNumber: 21\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"text-sm italic text-neutral-600 line-clamp-2\",\n                                            children: [\n                                                '\"',\n                                                session.preview,\n                                                '\"'\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                            lineNumber: 291,\n                                            columnNumber: 21\n                                        }, this)\n                                    ]\n                                }, session.id, true, {\n                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                    lineNumber: 289,\n                                    columnNumber: 19\n                                }, this))\n                        }, void 0, false, {\n                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                            lineNumber: 286,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"p-4 border-t\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: clearHistory,\n                                className: \"w-full text-red-500 py-3 font-black text-xs uppercase tracking-widest hover:bg-red-50 rounded-xl transition-all\",\n                                children: \"Clear Logs\"\n                            }, void 0, false, {\n                                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                lineNumber: 297,\n                                columnNumber: 16\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                            lineNumber: 296,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                    lineNumber: 281,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                lineNumber: 280,\n                columnNumber: 9\n            }, this),\n            showSettings && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-0 z-50 bg-black/20 backdrop-blur-sm flex justify-end\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"w-full max-w-md h-full bg-white shadow-2xl flex flex-col transform slide-in-from-right\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"p-5 border-b flex items-center justify-between bg-neutral-50/50\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                    className: \"text-xl font-black tracking-tight flex items-center gap-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ChevronDown_Clock_Printer_Settings_Volume2_X_lucide_react__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                                            className: \"w-5 h-5 text-blue-600\"\n                                        }, void 0, false, {\n                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                            lineNumber: 309,\n                                            columnNumber: 17\n                                        }, this),\n                                        \" Settings\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                    lineNumber: 308,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: ()=>setShowSettings(false),\n                                    className: \"p-2 hover:bg-black/5 rounded-full transition-colors\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ChevronDown_Clock_Printer_Settings_Volume2_X_lucide_react__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n                                        className: \"w-6 h-6 text-neutral-500\"\n                                    }, void 0, false, {\n                                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                        lineNumber: 311,\n                                        columnNumber: 126\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                    lineNumber: 311,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                            lineNumber: 307,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex-1 p-6 space-y-10 overflow-y-auto\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"flex items-center gap-2 mb-6\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ChevronDown_Clock_Printer_Settings_Volume2_X_lucide_react__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                                    className: \"w-4 h-4 text-blue-500\"\n                                                }, void 0, false, {\n                                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                    lineNumber: 317,\n                                                    columnNumber: 21\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                                    className: \"text-xs font-black uppercase tracking-widest text-neutral-400\",\n                                                    children: \"Voice Configuration\"\n                                                }, void 0, false, {\n                                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                    lineNumber: 318,\n                                                    columnNumber: 21\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                            lineNumber: 316,\n                                            columnNumber: 18\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"space-y-6\",\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                                        className: \"block text-[10px] font-black text-neutral-500 uppercase tracking-widest mb-2 ml-1\",\n                                                        children: \"Translation Output Voice\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                        lineNumber: 323,\n                                                        columnNumber: 22\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"relative\",\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                                                                value: selectedVoice,\n                                                                onChange: (e)=>{\n                                                                    setSelectedVoice(e.target.value);\n                                                                    localStorage.setItem('succes_voice', e.target.value);\n                                                                },\n                                                                className: \"w-full bg-neutral-100 hover:bg-white border border-black/5 text-neutral-900 font-bold py-4 px-5 rounded-2xl appearance-none cursor-pointer transition-all focus:ring-4 focus:ring-blue-500/10 outline-none\",\n                                                                children: AVAILABLE_VOICES.map((v)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                                        value: v.id,\n                                                                        children: v.name\n                                                                    }, v.id, false, {\n                                                                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                                        lineNumber: 333,\n                                                                        columnNumber: 54\n                                                                    }, this))\n                                                            }, void 0, false, {\n                                                                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                                lineNumber: 325,\n                                                                columnNumber: 25\n                                                            }, this),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                className: \"absolute right-4 top-1/2 -translate-y-1/2 pointer-events-none opacity-50\",\n                                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ChevronDown_Clock_Printer_Settings_Volume2_X_lucide_react__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n                                                                    className: \"w-5 h-5\"\n                                                                }, void 0, false, {\n                                                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                                    lineNumber: 335,\n                                                                    columnNumber: 115\n                                                                }, this)\n                                                            }, void 0, false, {\n                                                                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                                lineNumber: 335,\n                                                                columnNumber: 25\n                                                            }, this)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                        lineNumber: 324,\n                                                        columnNumber: 22\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                        className: \"mt-3 text-[10px] text-neutral-400 font-medium leading-relaxed italic px-1\",\n                                                        children: \"* Change will apply upon the next microphone activation. High-fidelity Orus lexicon parameters are maintained across all voice types.\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                        lineNumber: 337,\n                                                        columnNumber: 22\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                lineNumber: 322,\n                                                columnNumber: 20\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                            lineNumber: 321,\n                                            columnNumber: 18\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                    lineNumber: 315,\n                                    columnNumber: 16\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                                    className: \"pt-10 border-t border-black/5\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                            className: \"text-[10px] font-black uppercase tracking-widest text-neutral-400 mb-4 ml-1\",\n                                            children: \"Platform Details\"\n                                        }, void 0, false, {\n                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                            lineNumber: 345,\n                                            columnNumber: 18\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"bg-neutral-50 rounded-2xl p-5 border border-black/5 space-y-3\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"flex justify-between items-center\",\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                            className: \"text-[10px] font-bold text-neutral-500 uppercase\",\n                                                            children: \"Engine\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                            lineNumber: 348,\n                                                            columnNumber: 22\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                            className: \"text-[10px] font-black text-blue-600\",\n                                                            children: \"Gemini 2.5 Live\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                            lineNumber: 349,\n                                                            columnNumber: 22\n                                                        }, this)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                    lineNumber: 347,\n                                                    columnNumber: 20\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"flex justify-between items-center\",\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                            className: \"text-[10px] font-bold text-neutral-500 uppercase\",\n                                                            children: \"Lexicon\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                            lineNumber: 352,\n                                                            columnNumber: 22\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                            className: \"text-[10px] font-black text-green-600\",\n                                                            children: \"Orus Library V4.2\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                            lineNumber: 353,\n                                                            columnNumber: 22\n                                                        }, this)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                    lineNumber: 351,\n                                                    columnNumber: 20\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"flex justify-between items-center\",\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                            className: \"text-[10px] font-bold text-neutral-500 uppercase\",\n                                                            children: \"Mode\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                            lineNumber: 356,\n                                                            columnNumber: 22\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                            className: \"text-[10px] font-black text-neutral-800\",\n                                                            children: \"Dual Native (nl-BE/Multi)\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                            lineNumber: 357,\n                                                            columnNumber: 22\n                                                        }, this)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                                    lineNumber: 355,\n                                                    columnNumber: 20\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                            lineNumber: 346,\n                                            columnNumber: 18\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                    lineNumber: 344,\n                                    columnNumber: 16\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                            lineNumber: 314,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"p-6 border-t bg-neutral-50/50\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>setShowSettings(false),\n                                className: \"w-full bg-neutral-900 text-white font-black py-4 rounded-2xl uppercase tracking-widest text-xs hover:bg-black transition-all active:scale-[0.98]\",\n                                children: \"Done\"\n                            }, void 0, false, {\n                                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                lineNumber: 364,\n                                columnNumber: 16\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                            lineNumber: 363,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                    lineNumber: 306,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                lineNumber: 305,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"footer\", {\n                className: \"px-6 py-6 sm:py-10 bg-white border-t flex items-center justify-center relative no-print\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: handleStoreLog,\n                        className: \"absolute left-6 bg-neutral-100 hover:bg-neutral-200 px-6 py-3 rounded-xl font-black text-[10px] uppercase tracking-widest transition-all\",\n                        children: \"Store Session\"\n                    }, void 0, false, {\n                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                        lineNumber: 376,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: toggleMic,\n                        className: \"relative flex items-center justify-center w-24 h-24 sm:w-28 sm:h-28 rounded-full transition-all duration-500 transform active:scale-90 \".concat(isListening ? 'mic-active' : 'bg-blue-600 shadow-xl'),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex flex-col items-center\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                    xmlns: \"http://www.w3.org/2000/svg\",\n                                    className: \"h-10 w-10 text-white mb-1\",\n                                    fill: \"none\",\n                                    viewBox: \"0 0 24 24\",\n                                    stroke: \"currentColor\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                        strokeLinecap: \"round\",\n                                        strokeLinejoin: \"round\",\n                                        strokeWidth: 3,\n                                        d: \"M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z\"\n                                    }, void 0, false, {\n                                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                        lineNumber: 383,\n                                        columnNumber: 15\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                    lineNumber: 382,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-[8px] font-black text-white/70 uppercase tracking-widest\",\n                                    children: \" BIG MIC\"\n                                }, void 0, false, {\n                                    fileName: \"/workspaces/eburondual/app/page.tsx\",\n                                    lineNumber: 385,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/workspaces/eburondual/app/page.tsx\",\n                            lineNumber: 381,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/workspaces/eburondual/app/page.tsx\",\n                        lineNumber: 377,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/workspaces/eburondual/app/page.tsx\",\n                lineNumber: 375,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/workspaces/eburondual/app/page.tsx\",\n        lineNumber: 192,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"kyWiSx31azH8iptfORkV43FXywE=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUcyRDtBQUNmO0FBQ2lFO0FBQ3ZDO0FBQ0o7QUFDRTtBQUNGO0FBRWxFLE1BQU1nQixtQkFBbUI7SUFDdkI7UUFBRUMsSUFBSTtRQUFRQyxNQUFNO0lBQWtCO0lBQ3RDO1FBQUVELElBQUk7UUFBVUMsTUFBTTtJQUFrQjtJQUN4QztRQUFFRCxJQUFJO1FBQVFDLE1BQU07SUFBYztJQUNsQztRQUFFRCxJQUFJO1FBQVVDLE1BQU07SUFBZ0I7SUFDdEM7UUFBRUQsSUFBSTtRQUFVQyxNQUFNO0lBQWtCO0NBQ3pDO0FBRWMsU0FBU0M7O0lBQ3RCLE1BQU1DLFNBQVNoQiwwREFBU0E7SUFDeEIsTUFBTSxDQUFDaUIsVUFBVUMsWUFBWSxHQUFHckIsK0NBQVFBLENBQVdVLDRDQUFRQSxDQUFDWSxLQUFLO0lBQ2pFLE1BQU0sQ0FBQ0MsV0FBV0MsYUFBYSxHQUFHeEIsK0NBQVFBLENBQUM7SUFDM0MsTUFBTSxDQUFDeUIsT0FBT0MsU0FBUyxHQUFHMUIsK0NBQVFBLENBQWdCO0lBRWxELE1BQU0sQ0FBQzJCLFdBQVdDLGFBQWEsR0FBRzVCLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQzZCLGFBQWFDLGVBQWUsR0FBRzlCLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQytCLGNBQWNDLGdCQUFnQixHQUFHaEMsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDaUMsZ0JBQWdCQyxrQkFBa0IsR0FBR2xDLCtDQUFRQSxDQUFDO0lBRXJELDRCQUE0QjtJQUM1QixNQUFNLENBQUNtQyxlQUFlQyxpQkFBaUIsR0FBR3BDLCtDQUFRQSxDQUFDO0lBRW5ELE1BQU0sQ0FBQ3FDLGFBQWFDLGVBQWUsR0FBR3RDLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ3VDLFVBQVVDLFlBQVksR0FBR3hDLCtDQUFRQSxDQUFZLEVBQUU7SUFDdEQsTUFBTSxDQUFDeUMsY0FBY0MsZ0JBQWdCLEdBQUcxQywrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUMyQyxlQUFlQyxpQkFBaUIsR0FBRzVDLCtDQUFRQSxDQUFDO0lBRW5ELFlBQVk7SUFDWixNQUFNLENBQUM2QyxhQUFhQyxlQUFlLEdBQUc5QywrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUMrQyxjQUFjQyxnQkFBZ0IsR0FBR2hELCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQ2lELFNBQVNDLFdBQVcsR0FBR2xELCtDQUFRQSxDQUFpQixFQUFFO0lBQ3pELE1BQU0sQ0FBQ21ELG1CQUFtQkMscUJBQXFCLEdBQUdwRCwrQ0FBUUEsQ0FBZ0I7SUFFMUUsTUFBTXFELGNBQWNuRCw2Q0FBTUEsQ0FBMkI7SUFFckRELGdEQUFTQTswQkFBQztZQUNSLE1BQU1xRCxRQUFRQyxhQUFhQyxPQUFPLENBQUM7WUFDbkMsSUFBSUYsT0FBTztnQkFDVCxJQUFJO29CQUNGSixXQUFXTyxLQUFLQyxLQUFLLENBQUNKO2dCQUN4QixFQUFFLE9BQU9LLEdBQUc7b0JBQ1ZDLFFBQVFuQyxLQUFLLENBQUMsMEJBQTBCa0M7Z0JBQzFDO1lBQ0Y7WUFDQSxNQUFNRSxhQUFhTixhQUFhQyxPQUFPLENBQUM7WUFDeEMsSUFBSUssWUFBWXpCLGlCQUFpQnlCO1FBQ25DO3lCQUFHLEVBQUU7SUFFTCxNQUFNQyxjQUFjLENBQUNIO1FBQ25CQSxFQUFFSSxjQUFjO1FBQ2hCLE1BQU1DLFFBQVF6QyxVQUFVMEMsSUFBSSxHQUFHQyxXQUFXO1FBRTFDLElBQUlGLFVBQVUsV0FBVztZQUN2QjdDLE9BQU9nRCxJQUFJLENBQUM7WUFDWjtRQUNGO1FBRUEsSUFBSUMsa0JBQTRCLEVBQUU7UUFDbEMsSUFBSTtZQUNGLE1BQU1DLFNBQVNkLGFBQWFDLE9BQU8sQ0FBQztZQUNwQyxJQUFJYSxRQUFRO2dCQUNWLE1BQU1DLFNBQVNiLEtBQUtDLEtBQUssQ0FBQ1c7Z0JBQzFCRCxrQkFBa0JFLE9BQU9DLEdBQUcsQ0FBQyxDQUFDQyxPQUFjQSxLQUFLQyxJQUFJO1lBQ3ZEO1FBQ0YsRUFBRSxPQUFPZCxHQUFHO1lBQ1ZDLFFBQVFuQyxLQUFLLENBQUMsNkJBQTZCa0M7UUFDN0M7UUFFQSxNQUFNZSxXQUFXVixVQUFVO1FBQzNCLE1BQU1XLGNBQWNQLGdCQUFnQlEsUUFBUSxDQUFDWjtRQUM3QyxNQUFNYSxXQUFXLG9DQUFvQ0MsSUFBSSxDQUFDZDtRQUUxRCxJQUFJVSxZQUFZQyxlQUFlRSxVQUFVO1lBQ3ZDeEQsWUFBWVgsNENBQVFBLENBQUNxRSxVQUFVO1lBQy9CckQsU0FBUztRQUNYLE9BQU87WUFDTEEsU0FBUztRQUNYO0lBQ0Y7SUFFQSxNQUFNc0QsaUJBQWlCO1FBQ3JCLElBQUl6QyxTQUFTMEMsTUFBTSxLQUFLLEdBQUc7UUFDM0IsTUFBTUMsYUFBMkI7WUFDL0JsRSxJQUFJbUUsS0FBS0MsR0FBRyxHQUFHQyxRQUFRO1lBQ3ZCQyxXQUFXSCxLQUFLQyxHQUFHO1lBQ25CRyxTQUFTaEQsUUFBUSxDQUFDQSxTQUFTMEMsTUFBTSxHQUFHLEVBQUUsQ0FBQ08sWUFBWSxDQUFDQyxTQUFTLENBQUMsR0FBRyxNQUFNO1lBQ3ZFbEQsVUFBVTttQkFBSUE7YUFBUztRQUN6QjtRQUNBLE1BQU1tRCxpQkFBaUI7WUFBQ1I7ZUFBZWpDO1NBQVE7UUFDL0NDLFdBQVd3QztRQUNYbkMsYUFBYW9DLE9BQU8sQ0FBQyxrQkFBa0JsQyxLQUFLbUMsU0FBUyxDQUFDRjtRQUN0REcsTUFBTTtJQUNSO0lBRUEsTUFBTUMsZUFBZTtRQUNuQixJQUFJQyxRQUFRLG1CQUFtQjtZQUM3QjdDLFdBQVcsRUFBRTtZQUNiSyxhQUFheUMsVUFBVSxDQUFDO1FBQzFCO0lBQ0Y7SUFFQSxNQUFNQyxZQUFZO1FBQ2hCLElBQUk1RCxhQUFhO2dCQUNmZ0I7YUFBQUEsdUJBQUFBLFlBQVk2QyxPQUFPLGNBQW5CN0MsMkNBQUFBLHFCQUFxQjhDLFVBQVU7WUFDL0I3RCxlQUFlO1FBQ2pCLE9BQU87Z0JBRVMzQixpQkFDQUE7WUFGZCxJQUFJLENBQUMwQyxZQUFZNkMsT0FBTyxFQUFFN0MsWUFBWTZDLE9BQU8sR0FBRyxJQUFJdEYsMEVBQWlCQTtZQUNyRSxNQUFNd0YsUUFBUXpGLEVBQUFBLGtCQUFBQSw2Q0FBU0EsQ0FBQzBGLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRTdCLElBQUksS0FBSzlDLHdCQUEvQmhCLHNDQUFBQSxnQkFBMkNNLElBQUksS0FBSTtZQUNqRSxNQUFNc0YsUUFBUTVGLEVBQUFBLG1CQUFBQSw2Q0FBU0EsQ0FBQzBGLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRTdCLElBQUksS0FBSzVDLDBCQUEvQmxCLHVDQUFBQSxpQkFBNkNNLElBQUksS0FBSTtZQUNuRSxJQUFJO2dCQUNGLE1BQU1vQyxZQUFZNkMsT0FBTyxDQUFDTSxPQUFPLENBQUM7b0JBQ2hDQyxlQUFlTDtvQkFDZk0saUJBQWlCSDtvQkFDakJJLFdBQVd4RTtvQkFDWHlFLGlCQUFpQixDQUFDQyxNQUFNQzt3QkFDdEIsSUFBSUEsU0FBU3BFLGdCQUFnQnFFLENBQUFBLE9BQVFBLE9BQU9GOzZCQUN2Q2pFLGlCQUFpQm1FLENBQUFBLE9BQVFBLE9BQU9GO29CQUN2QztvQkFDQUcsZ0JBQWdCLEtBQU87b0JBQ3ZCQyxTQUFTLElBQU0zRSxlQUFlO2dCQUNoQztnQkFDQUEsZUFBZTtZQUNqQixFQUFFLE9BQU80RSxLQUFLO2dCQUNaeEYsU0FBUztZQUNYO1FBQ0Y7SUFDRjtJQUVBekIsZ0RBQVNBOzBCQUFDO1lBQ1IsSUFBSSxDQUFDd0MsZ0JBQWdCRSxhQUFZLEtBQU1OLGFBQWE7Z0JBQ2xELE1BQU04RSxVQUFVQzs4Q0FBVzt3QkFDekIsTUFBTUMsYUFBc0I7NEJBQzFCckcsSUFBSXNHLEtBQUtDLE1BQU0sR0FBR2xDLFFBQVEsQ0FBQyxJQUFJbUMsTUFBTSxDQUFDLEdBQUcsR0FBR3RELFdBQVc7NEJBQ3ZEdUQsUUFBUWhGLGVBQWUsVUFBVTs0QkFDakMrQyxjQUFjL0MsZ0JBQWdCOzRCQUM5QmlGLGdCQUFnQi9FLGlCQUFpQjs0QkFDakMyQyxXQUFXSCxLQUFLQyxHQUFHO3dCQUNyQjt3QkFDQTVDO3NEQUFZdUUsQ0FBQUEsT0FBUTt1Q0FBSUE7b0NBQU1NO2lDQUFXOzt3QkFDekMzRSxnQkFBZ0I7d0JBQ2hCRSxpQkFBaUI7b0JBQ25COzZDQUFHO2dCQUNIO3NDQUFPLElBQU0rRSxhQUFhUjs7WUFDNUI7UUFDRjt5QkFBRztRQUFDMUU7UUFBY0U7UUFBZU47S0FBWTtJQUU3QyxJQUFJakIsYUFBYVYsNENBQVFBLENBQUNZLEtBQUssRUFBRTtRQUMvQixxQkFDRSw4REFBQ3NHO1lBQUlDLFdBQVU7c0JBQ2IsNEVBQUNEO2dCQUFJQyxXQUFVOztrQ0FDYiw4REFBQ0Q7d0JBQUlDLFdBQVU7OzBDQUNiLDhEQUFDRDtnQ0FBSUMsV0FBVTswQ0FDYiw0RUFBQ0M7b0NBQUlDLE9BQU07b0NBQTZCRixXQUFVO29DQUF1QkcsTUFBSztvQ0FBT0MsU0FBUTtvQ0FBWUMsUUFBTzs4Q0FDOUcsNEVBQUNDO3dDQUFLQyxlQUFjO3dDQUFRQyxnQkFBZTt3Q0FBUUMsYUFBYTt3Q0FBS0MsR0FBRTs7Ozs7Ozs7Ozs7Ozs7OzswQ0FHM0UsOERBQUNDO2dDQUFHWCxXQUFVOzBDQUF3RDs7Ozs7OzBDQUN0RSw4REFBQ1k7Z0NBQUVaLFdBQVU7MENBQXdFOzs7Ozs7Ozs7Ozs7a0NBRXZGLDhEQUFDRDt3QkFBSUMsV0FBVTtrQ0FDYiw0RUFBQ2E7NEJBQUtDLFVBQVU3RTs0QkFBYStELFdBQVU7OzhDQUNyQyw4REFBQ2U7b0NBQ0NDLE1BQUs7b0NBQ0xDLE9BQU92SDtvQ0FDUHdILFVBQVUsQ0FBQ3BGLElBQU1uQyxhQUFhbUMsRUFBRXFGLE1BQU0sQ0FBQ0YsS0FBSztvQ0FDNUNHLGFBQVk7b0NBQ1pwQixXQUFVO29DQUNWcUIsU0FBUzs7Ozs7OzhDQUVYLDhEQUFDQztvQ0FBT04sTUFBSztvQ0FBU2hCLFdBQVU7OENBQStHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBUTNKO0lBRUEscUJBQ0UsOERBQUNEO1FBQUlDLFdBQVU7OzBCQUNiLDhEQUFDdUI7Z0JBQU92QixXQUFVOztrQ0FDaEIsOERBQUNEO3dCQUFJQyxXQUFVOzswQ0FDYiw4REFBQ0Q7Z0NBQUlDLFdBQVU7O2tEQUNiLDhEQUFDRDt3Q0FBSUMsV0FBVTtrREFDYiw0RUFBQ0M7NENBQUlDLE9BQU07NENBQTZCRixXQUFVOzRDQUFxQkcsTUFBSzs0Q0FBT0MsU0FBUTs0Q0FBWUMsUUFBTztzREFDNUcsNEVBQUNDO2dEQUFLQyxlQUFjO2dEQUFRQyxnQkFBZTtnREFBUUMsYUFBYTtnREFBS0MsR0FBRTs7Ozs7Ozs7Ozs7Ozs7OztrREFHM0UsOERBQUNjO3dDQUFLeEIsV0FBVTtrREFBa0U7Ozs7Ozs7Ozs7OzswQ0FFcEYsOERBQUNEO2dDQUFJQyxXQUFVOzBDQUNiLDRFQUFDL0csMEVBQWdCQTtvQ0FBQ3dJLE9BQU07b0NBQWVSLE9BQU9uSDtvQ0FBV29ILFVBQVVuSDtvQ0FBYzJILE9BQU07Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQUkzRiw4REFBQzNCO3dCQUFJQyxXQUFVOzswQ0FDYiw4REFBQ0Q7Z0NBQUlDLFdBQVU7MENBQ2IsNEVBQUMvRywwRUFBZ0JBO29DQUFDd0ksT0FBTTtvQ0FBbUJSLE9BQU9qSDtvQ0FBYWtILFVBQVVqSDtvQ0FBZ0J5SCxPQUFNOzs7Ozs7Ozs7OzswQ0FHakcsOERBQUMzQjtnQ0FBSUMsV0FBVTs7a0RBQ1osOERBQUMvRywwRUFBZ0JBO3dDQUFDd0ksT0FBTTt3Q0FBT1IsT0FBT25IO3dDQUFXb0gsVUFBVW5IO3dDQUFjMkgsT0FBTTs7Ozs7O2tEQUMvRSw4REFBQ3pJLDBFQUFnQkE7d0NBQUN3SSxPQUFNO3dDQUFTUixPQUFPakg7d0NBQWFrSCxVQUFVakg7d0NBQWdCeUgsT0FBTTs7Ozs7Ozs7Ozs7OzBDQUd4Riw4REFBQzNCO2dDQUFJQyxXQUFVOztrREFDYiw4REFBQ3NCO3dDQUFPSyxTQUFTLElBQU0xRyxlQUFlO3dDQUFPK0UsV0FBVTt3Q0FBaUk0QixPQUFNO2tEQUM1TCw0RUFBQ3JKLHdIQUFLQTs0Q0FBQ3lILFdBQVU7Ozs7Ozs7Ozs7O2tEQUVuQiw4REFBQ3NCO3dDQUFPSyxTQUFTLElBQU1FLE9BQU9DLEtBQUs7d0NBQUk5QixXQUFVO3dDQUF3STRCLE9BQU07a0RBQzdMLDRFQUFDbEosd0hBQU9BOzRDQUFDc0gsV0FBVTs7Ozs7Ozs7Ozs7a0RBRXJCLDhEQUFDc0I7d0NBQU9LLFNBQVMsSUFBTXhHLGdCQUFnQjt3Q0FBTzZFLFdBQVU7d0NBQXdJNEIsT0FBTTtrREFDcE0sNEVBQUNqSix3SEFBUUE7NENBQUNxSCxXQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFNNUIsOERBQUMrQjtnQkFBSy9CLFdBQVU7O2tDQUNkLDhEQUFDRDt3QkFBSUMsV0FBVTtrQ0FDYiw0RUFBQ2hILDRFQUFpQkE7NEJBQ2hCNEksT0FBTTs0QkFDTkksVUFBUzs0QkFDVHRILFVBQVVBOzRCQUNWc0csTUFBSzs0QkFDTGlCLFVBQVVuSTs0QkFDVm9JLGFBQWFuSTs0QkFDYm9JLFdBQVdqSTs0QkFDWGtJLGNBQWNqSTs7Ozs7Ozs7Ozs7a0NBR2xCLDhEQUFDNEY7d0JBQUlDLFdBQVU7a0NBQ2IsNEVBQUNoSCw0RUFBaUJBOzRCQUNoQjRJLE9BQU07NEJBQ05JLFVBQVM7NEJBQ1R0SCxVQUFVQTs0QkFDVnNHLE1BQUs7NEJBQ0xpQixVQUFVakk7NEJBQ1ZrSSxhQUFhakk7NEJBQ2JrSSxXQUFXL0g7NEJBQ1hnSSxjQUFjL0g7Ozs7Ozs7Ozs7O29CQUloQk8sQ0FBQUEsZ0JBQWdCRSxhQUFZLEtBQU1OLDZCQUNqQyw4REFBQ3VGO3dCQUFJQyxXQUFVO2tDQUNaLDRFQUFDRDs0QkFBSUMsV0FBVTs7Z0NBQ1pwRiw4QkFDQyw4REFBQ21GO29DQUFJQyxXQUFVOztzREFDYiw4REFBQ3dCOzRDQUFLeEIsV0FBVTtzREFBNEU7Ozs7OztzREFDNUYsOERBQUNZOzRDQUFFWixXQUFVOztnREFBcUM7Z0RBQUVwRjtnREFBYTs7Ozs7Ozs7Ozs7OztnQ0FHcEVFLCtCQUNFLDhEQUFDaUY7b0NBQUlDLFdBQVcsR0FBNEQsT0FBekRwRixlQUFlLHVDQUF1Qzs7c0RBQ3hFLDhEQUFDNEc7NENBQUt4QixXQUFVO3NEQUE2RTs7Ozs7O3NEQUM3Riw4REFBQ1k7NENBQUVaLFdBQVU7O2dEQUEyQztnREFBRWxGO2dEQUFjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFTckZFLDZCQUNDLDhEQUFDK0U7Z0JBQUlDLFdBQVU7MEJBQ2IsNEVBQUNEO29CQUFJQyxXQUFVOztzQ0FDYiw4REFBQ0Q7NEJBQUlDLFdBQVU7OzhDQUNiLDhEQUFDcUM7b0NBQUdyQyxXQUFVOztzREFBNEQsOERBQUN6SCx3SEFBS0E7NENBQUN5SCxXQUFVOzs7Ozs7d0NBQVk7Ozs7Ozs7OENBQ3ZHLDhEQUFDc0I7b0NBQU9LLFNBQVMsSUFBTTFHLGVBQWU7b0NBQVErRSxXQUFVOzhDQUFNLDRFQUFDeEgseUhBQUNBO3dDQUFDd0gsV0FBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7c0NBRTdFLDhEQUFDRDs0QkFBSUMsV0FBVTtzQ0FDWjVFLFFBQVFnQyxNQUFNLEtBQUssa0JBQUksOERBQUN3RDtnQ0FBRVosV0FBVTswQ0FBa0U7Ozs7O3VDQUNyRzVFLFFBQVFzQixHQUFHLENBQUM0RixDQUFBQSx3QkFDViw4REFBQ3ZDO29DQUFxQkMsV0FBVTs7c0RBQzlCLDhEQUFDWTs0Q0FBRVosV0FBVTtzREFBNkMsSUFBSTFDLEtBQUtnRixRQUFRN0UsU0FBUyxFQUFFOEUsY0FBYzs7Ozs7O3NEQUNwRyw4REFBQzNCOzRDQUFFWixXQUFVOztnREFBK0M7Z0RBQUVzQyxRQUFRNUUsT0FBTztnREFBQzs7Ozs7Ozs7bUNBRnRFNEUsUUFBUW5KLEVBQUU7Ozs7Ozs7Ozs7c0NBTzFCLDhEQUFDNEc7NEJBQUlDLFdBQVU7c0NBQ1osNEVBQUNzQjtnQ0FBT0ssU0FBUzFEO2dDQUFjK0IsV0FBVTswQ0FBa0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFPbks5RSw4QkFDQyw4REFBQzZFO2dCQUFJQyxXQUFVOzBCQUNiLDRFQUFDRDtvQkFBSUMsV0FBVTs7c0NBQ2IsOERBQUNEOzRCQUFJQyxXQUFVOzs4Q0FDYiw4REFBQ3FDO29DQUFHckMsV0FBVTs7c0RBQ1osOERBQUNySCx3SEFBUUE7NENBQUNxSCxXQUFVOzs7Ozs7d0NBQTBCOzs7Ozs7OzhDQUVoRCw4REFBQ3NCO29DQUFPSyxTQUFTLElBQU14RyxnQkFBZ0I7b0NBQVE2RSxXQUFVOzhDQUFzRCw0RUFBQ3hILHlIQUFDQTt3Q0FBQ3dILFdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7O3NDQUc5SCw4REFBQ0Q7NEJBQUlDLFdBQVU7OzhDQUNaLDhEQUFDd0M7O3NEQUNDLDhEQUFDekM7NENBQUlDLFdBQVU7OzhEQUNaLDhEQUFDcEgseUhBQU9BO29EQUFDb0gsV0FBVTs7Ozs7OzhEQUNuQiw4REFBQ3lDO29EQUFHekMsV0FBVTs4REFBZ0U7Ozs7Ozs7Ozs7OztzREFHakYsOERBQUNEOzRDQUFJQyxXQUFVO3NEQUNiLDRFQUFDRDs7a0VBQ0MsOERBQUMwQjt3REFBTXpCLFdBQVU7a0VBQW9GOzs7Ozs7a0VBQ3JHLDhEQUFDRDt3REFBSUMsV0FBVTs7MEVBQ1osOERBQUMwQztnRUFDQ3pCLE9BQU8zRztnRUFDUDRHLFVBQVUsQ0FBQ3BGO29FQUNUdkIsaUJBQWlCdUIsRUFBRXFGLE1BQU0sQ0FBQ0YsS0FBSztvRUFDL0J2RixhQUFhb0MsT0FBTyxDQUFDLGdCQUFnQmhDLEVBQUVxRixNQUFNLENBQUNGLEtBQUs7Z0VBQ3JEO2dFQUNBakIsV0FBVTswRUFFVDlHLGlCQUFpQndELEdBQUcsQ0FBQ2lHLENBQUFBLGtCQUFLLDhEQUFDQzt3RUFBa0IzQixPQUFPMEIsRUFBRXhKLEVBQUU7a0ZBQUd3SixFQUFFdkosSUFBSTt1RUFBMUJ1SixFQUFFeEosRUFBRTs7Ozs7Ozs7OzswRUFFOUMsOERBQUM0RztnRUFBSUMsV0FBVTswRUFBMkUsNEVBQUN2SCx5SEFBV0E7b0VBQUN1SCxXQUFVOzs7Ozs7Ozs7Ozs7Ozs7OztrRUFFcEgsOERBQUNZO3dEQUFFWixXQUFVO2tFQUE0RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OENBTy9GLDhEQUFDd0M7b0NBQVF4QyxXQUFVOztzREFDakIsOERBQUN5Qzs0Q0FBR3pDLFdBQVU7c0RBQThFOzs7Ozs7c0RBQzVGLDhEQUFDRDs0Q0FBSUMsV0FBVTs7OERBQ2IsOERBQUNEO29EQUFJQyxXQUFVOztzRUFDYiw4REFBQ3dCOzREQUFLeEIsV0FBVTtzRUFBbUQ7Ozs7OztzRUFDbkUsOERBQUN3Qjs0REFBS3hCLFdBQVU7c0VBQXVDOzs7Ozs7Ozs7Ozs7OERBRXpELDhEQUFDRDtvREFBSUMsV0FBVTs7c0VBQ2IsOERBQUN3Qjs0REFBS3hCLFdBQVU7c0VBQW1EOzs7Ozs7c0VBQ25FLDhEQUFDd0I7NERBQUt4QixXQUFVO3NFQUF3Qzs7Ozs7Ozs7Ozs7OzhEQUUxRCw4REFBQ0Q7b0RBQUlDLFdBQVU7O3NFQUNiLDhEQUFDd0I7NERBQUt4QixXQUFVO3NFQUFtRDs7Ozs7O3NFQUNuRSw4REFBQ3dCOzREQUFLeEIsV0FBVTtzRUFBMEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzQ0FNbkUsOERBQUNEOzRCQUFJQyxXQUFVO3NDQUNaLDRFQUFDc0I7Z0NBQ0FLLFNBQVMsSUFBTXhHLGdCQUFnQjtnQ0FDL0I2RSxXQUFVOzBDQUNWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQVFWLDhEQUFDNkM7Z0JBQU83QyxXQUFVOztrQ0FDaEIsOERBQUNzQjt3QkFBT0ssU0FBU3hFO3dCQUFnQjZDLFdBQVU7a0NBQTJJOzs7Ozs7a0NBQ3RMLDhEQUFDc0I7d0JBQ0NLLFNBQVN2RDt3QkFDVDRCLFdBQVcsMElBQStMLE9BQXJEeEYsY0FBYyxlQUFlO2tDQUVsTCw0RUFBQ3VGOzRCQUFJQyxXQUFVOzs4Q0FDYiw4REFBQ0M7b0NBQUlDLE9BQU07b0NBQTZCRixXQUFVO29DQUE0QkcsTUFBSztvQ0FBT0MsU0FBUTtvQ0FBWUMsUUFBTzs4Q0FDbkgsNEVBQUNDO3dDQUFLQyxlQUFjO3dDQUFRQyxnQkFBZTt3Q0FBUUMsYUFBYTt3Q0FBR0MsR0FBRTs7Ozs7Ozs7Ozs7OENBRXZFLDhEQUFDYztvQ0FBS3hCLFdBQVU7OENBQWdFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU01RjtHQW5Yd0IzRzs7UUFDUGYsc0RBQVNBOzs7S0FERmUiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2VidXJvbmR1YWwvYXBwL3BhZ2UudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlxuXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L25hdmlnYXRpb24nO1xuaW1wb3J0IHsgSGlzdG9yeSwgQ2xvY2ssIFgsIENoZXZyb25Eb3duLCBDaGV2cm9uVXAsIFRyYXNoMiwgUHJpbnRlciwgU2V0dGluZ3MsIFZvbHVtZTIgfSBmcm9tICdsdWNpZGUtcmVhY3QnO1xuaW1wb3J0IHsgQXBwU3RhdGUsIE1lc3NhZ2UsIExBTkdVQUdFUywgU2F2ZWRTZXNzaW9uIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgR2VtaW5pTGl2ZVNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9nZW1pbmlMaXZlU2VydmljZSc7XG5pbXBvcnQgeyBUcmFuc2xhdGlvbkNvbHVtbiB9IGZyb20gJy4uL2NvbXBvbmVudHMvVHJhbnNsYXRpb25Db2x1bW4nO1xuaW1wb3J0IHsgTGFuZ3VhZ2VTZWxlY3RvciB9IGZyb20gJy4uL2NvbXBvbmVudHMvTGFuZ3VhZ2VTZWxlY3Rvcic7XG5cbmNvbnN0IEFWQUlMQUJMRV9WT0lDRVMgPSBbXG4gIHsgaWQ6ICdLb3JlJywgbmFtZTogJ0tvcmUgKEJhbGFuY2VkKScgfSxcbiAgeyBpZDogJ1plcGh5cicsIG5hbWU6ICdaZXBoeXIgKEJyaWdodCknIH0sXG4gIHsgaWQ6ICdQdWNrJywgbmFtZTogJ1B1Y2sgKFNvZnQpJyB9LFxuICB7IGlkOiAnQ2hhcm9uJywgbmFtZTogJ0NoYXJvbiAoRGVlcCknIH0sXG4gIHsgaWQ6ICdGZW5yaXInLCBuYW1lOiAnRmVucmlyIChTdHJvbmcpJyB9XG5dO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb21lKCkge1xuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcbiAgY29uc3QgW2FwcFN0YXRlLCBzZXRBcHBTdGF0ZV0gPSB1c2VTdGF0ZTxBcHBTdGF0ZT4oQXBwU3RhdGUuTE9HSU4pO1xuICBjb25zdCBbbG9naW5Db2RlLCBzZXRMb2dpbkNvZGVdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IFtzdGFmZkxhbmcsIHNldFN0YWZmTGFuZ10gPSB1c2VTdGF0ZSgnbmwtQkUnKTtcbiAgY29uc3QgW3Zpc2l0b3JMYW5nLCBzZXRWaXNpdG9yTGFuZ10gPSB1c2VTdGF0ZSgnZW4tVVMnKTtcbiAgY29uc3QgW3N0YWZmU3BlYWtlciwgc2V0U3RhZmZTcGVha2VyXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbdmlzaXRvclNwZWFrZXIsIHNldFZpc2l0b3JTcGVha2VyXSA9IHVzZVN0YXRlKHRydWUpO1xuICBcbiAgLy8gVm9pY2UgQ29uZmlndXJhdGlvbiBTdGF0ZVxuICBjb25zdCBbc2VsZWN0ZWRWb2ljZSwgc2V0U2VsZWN0ZWRWb2ljZV0gPSB1c2VTdGF0ZSgnS29yZScpO1xuXG4gIGNvbnN0IFtpc0xpc3RlbmluZywgc2V0SXNMaXN0ZW5pbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbbWVzc2FnZXMsIHNldE1lc3NhZ2VzXSA9IHVzZVN0YXRlPE1lc3NhZ2VbXT4oW10pO1xuICBjb25zdCBbY3VycmVudElucHV0LCBzZXRDdXJyZW50SW5wdXRdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbY3VycmVudE91dHB1dCwgc2V0Q3VycmVudE91dHB1dF0gPSB1c2VTdGF0ZSgnJyk7XG5cbiAgLy8gVUkgU3RhdGVzXG4gIGNvbnN0IFtzaG93SGlzdG9yeSwgc2V0U2hvd0hpc3RvcnldID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd1NldHRpbmdzLCBzZXRTaG93U2V0dGluZ3NdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaGlzdG9yeSwgc2V0SGlzdG9yeV0gPSB1c2VTdGF0ZTxTYXZlZFNlc3Npb25bXT4oW10pO1xuICBjb25zdCBbZXhwYW5kZWRTZXNzaW9uSWQsIHNldEV4cGFuZGVkU2Vzc2lvbklkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IGxpdmVTZXJ2aWNlID0gdXNlUmVmPEdlbWluaUxpdmVTZXJ2aWNlIHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzYXZlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzdWNjZXNfaGlzdG9yeScpO1xuICAgIGlmIChzYXZlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0SGlzdG9yeShKU09OLnBhcnNlKHNhdmVkKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGhpc3RvcnknLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2F2ZWRWb2ljZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzdWNjZXNfdm9pY2UnKTtcbiAgICBpZiAoc2F2ZWRWb2ljZSkgc2V0U2VsZWN0ZWRWb2ljZShzYXZlZFZvaWNlKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGhhbmRsZUxvZ2luID0gKGU6IFJlYWN0LkZvcm1FdmVudCkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBjbGVhbiA9IGxvZ2luQ29kZS50cmltKCkudG9VcHBlckNhc2UoKTtcblxuICAgIGlmIChjbGVhbiA9PT0gJy8vQURNSU4nKSB7XG4gICAgICByb3V0ZXIucHVzaCgnL2FkbWluJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHZhbGlkU3RvY2tDb2Rlczogc3RyaW5nW10gPSBbXTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3N1Y2Nlc19hY2Nlc3NfY29kZXMnKTtcbiAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShzdG9yZWQpO1xuICAgICAgICB2YWxpZFN0b2NrQ29kZXMgPSBwYXJzZWQubWFwKChpdGVtOiBhbnkpID0+IGl0ZW0uY29kZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVhZGluZyBzdG9jayBjb2RlcycsIGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzTWFzdGVyID0gY2xlYW4gPT09ICdTVUNDRVMyMDI1JztcbiAgICBjb25zdCBpc1N0b2NrQ29kZSA9IHZhbGlkU3RvY2tDb2Rlcy5pbmNsdWRlcyhjbGVhbik7XG4gICAgY29uc3QgaXNMZWdhY3kgPSAvXihTSVtBLVpdezJ9XFxkezZ9fEFSXFxkezZ9fERFQlVHKSQvLnRlc3QoY2xlYW4pO1xuXG4gICAgaWYgKGlzTWFzdGVyIHx8IGlzU3RvY2tDb2RlIHx8IGlzTGVnYWN5KSB7XG4gICAgICBzZXRBcHBTdGF0ZShBcHBTdGF0ZS5UUkFOU0xBVE9SKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRFcnJvcignSW52YWxpZCBBY2Nlc3MgQ29kZS4nKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlU3RvcmVMb2cgPSAoKSA9PiB7XG4gICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IG5ld1Nlc3Npb246IFNhdmVkU2Vzc2lvbiA9IHtcbiAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICBwcmV2aWV3OiBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXS5vcmlnaW5hbFRleHQuc3Vic3RyaW5nKDAsIDUwKSArICcuLi4nLFxuICAgICAgbWVzc2FnZXM6IFsuLi5tZXNzYWdlc11cbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZWRIaXN0b3J5ID0gW25ld1Nlc3Npb24sIC4uLmhpc3RvcnldO1xuICAgIHNldEhpc3RvcnkodXBkYXRlZEhpc3RvcnkpO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdzdWNjZXNfaGlzdG9yeScsIEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRIaXN0b3J5KSk7XG4gICAgYWxlcnQoJ0xvZyBzdG9yZWQuJyk7XG4gIH07XG5cbiAgY29uc3QgY2xlYXJIaXN0b3J5ID0gKCkgPT4ge1xuICAgIGlmIChjb25maXJtKCdDbGVhciBoaXN0b3J5PycpKSB7XG4gICAgICBzZXRIaXN0b3J5KFtdKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdzdWNjZXNfaGlzdG9yeScpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB0b2dnbGVNaWMgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKGlzTGlzdGVuaW5nKSB7XG4gICAgICBsaXZlU2VydmljZS5jdXJyZW50Py5kaXNjb25uZWN0KCk7XG4gICAgICBzZXRJc0xpc3RlbmluZyhmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghbGl2ZVNlcnZpY2UuY3VycmVudCkgbGl2ZVNlcnZpY2UuY3VycmVudCA9IG5ldyBHZW1pbmlMaXZlU2VydmljZSgpO1xuICAgICAgY29uc3Qgc0xhbmcgPSBMQU5HVUFHRVMuZmluZChsID0+IGwuY29kZSA9PT0gc3RhZmZMYW5nKT8ubmFtZSB8fCAnRmxlbWlzaCc7XG4gICAgICBjb25zdCB2TGFuZyA9IExBTkdVQUdFUy5maW5kKGwgPT4gbC5jb2RlID09PSB2aXNpdG9yTGFuZyk/Lm5hbWUgfHwgJ0VuZ2xpc2gnO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbGl2ZVNlcnZpY2UuY3VycmVudC5jb25uZWN0KHtcbiAgICAgICAgICBzdGFmZkxhbmd1YWdlOiBzTGFuZyxcbiAgICAgICAgICB2aXNpdG9yTGFuZ3VhZ2U6IHZMYW5nLFxuICAgICAgICAgIHZvaWNlTmFtZTogc2VsZWN0ZWRWb2ljZSxcbiAgICAgICAgICBvblRyYW5zY3JpcHRpb246ICh0ZXh0LCBpc0lucHV0KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNJbnB1dCkgc2V0Q3VycmVudElucHV0KHByZXYgPT4gcHJldiArIHRleHQpO1xuICAgICAgICAgICAgZWxzZSBzZXRDdXJyZW50T3V0cHV0KHByZXYgPT4gcHJldiArIHRleHQpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25UdXJuQ29tcGxldGU6ICgpID0+IHt9LFxuICAgICAgICAgIG9uRXJyb3I6ICgpID0+IHNldElzTGlzdGVuaW5nKGZhbHNlKVxuICAgICAgICB9KTtcbiAgICAgICAgc2V0SXNMaXN0ZW5pbmcodHJ1ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2V0RXJyb3IoJ01pYyBlcnJvci4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoKGN1cnJlbnRJbnB1dCB8fCBjdXJyZW50T3V0cHV0KSAmJiBpc0xpc3RlbmluZykge1xuICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdNZXNzYWdlOiBNZXNzYWdlID0ge1xuICAgICAgICAgIGlkOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgNikudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICBzZW5kZXI6IGN1cnJlbnRJbnB1dCA/ICdzdGFmZicgOiAndmlzaXRvcicsXG4gICAgICAgICAgb3JpZ2luYWxUZXh0OiBjdXJyZW50SW5wdXQgfHwgJy4uLicsXG4gICAgICAgICAgdHJhbnNsYXRlZFRleHQ6IGN1cnJlbnRPdXRwdXQgfHwgJy4uLicsXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB9O1xuICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCBuZXdNZXNzYWdlXSk7XG4gICAgICAgIHNldEN1cnJlbnRJbnB1dCgnJyk7XG4gICAgICAgIHNldEN1cnJlbnRPdXRwdXQoJycpO1xuICAgICAgfSwgMzUwMCk7XG4gICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIH1cbiAgfSwgW2N1cnJlbnRJbnB1dCwgY3VycmVudE91dHB1dCwgaXNMaXN0ZW5pbmddKTtcblxuICBpZiAoYXBwU3RhdGUgPT09IEFwcFN0YXRlLkxPR0lOKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgbWluLWgtc2NyZWVuIGJnLW5ldXRyYWwtMTAwIHAtNlwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtYXgtdy1zbVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXIgbWItMTBcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy0yMCBoLTIwIGJnLWJsdWUtNjAwIHJvdW5kZWQtWzJyZW1dIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG14LWF1dG8gbWItNiBzaGFkb3cteGxcIj5cbiAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3NOYW1lPVwiaC0xMCB3LTEwIHRleHQtd2hpdGVcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIj5cbiAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2VMaW5lY2FwPVwicm91bmRcIiBzdHJva2VMaW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlV2lkdGg9ezIuNX0gZD1cIk0zIDVoMTJNOSAzdjJtMS4wNDggOS41QTE4LjAyMiAxOC4wMjIgMCAwMTYuNDEyIDltNi4wODggOWg3TTExIDIxbDUtMTAgNSAxME0xMi43NTEgNUMxMS43ODMgMTAuNzcgOC4wNyAxNS42MSAzIDE4LjEyOVwiIC8+XG4gICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8aDEgY2xhc3NOYW1lPVwidGV4dC00eGwgZm9udC1ibGFjayB0cmFja2luZy10aWdodGVyIHRleHQtbmV1dHJhbC05MDBcIj5TdWNjZXMgRHVhbDwvaDE+XG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LW5ldXRyYWwtNTAwIGZvbnQtYm9sZCB1cHBlcmNhc2UgdHJhY2tpbmctd2lkZXN0IHRleHQtWzEwcHhdIG10LTJcIj5Qcm9mZXNzaW9uYWwgVHJhbnNsYXRvcjwvcD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLXdoaXRlIHAtOCByb3VuZGVkLVsyLjVyZW1dIHNoYWRvdy0yeGwgYm9yZGVyIGJvcmRlci1ibGFjay81XCI+XG4gICAgICAgICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlTG9naW59IGNsYXNzTmFtZT1cInNwYWNlLXktNlwiPlxuICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgdmFsdWU9e2xvZ2luQ29kZX1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldExvZ2luQ29kZShlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJBQ0NFU1MgQ09ERVwiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIHB4LTYgcHktNSByb3VuZGVkLTN4bCBiZy1uZXV0cmFsLTUwIGJvcmRlci1ub25lIGZvY3VzOnJpbmctNCBmb2N1czpyaW5nLWJsdWUtNTAwLzEwIG91dGxpbmUtbm9uZSB0ZXh0LWNlbnRlciBmb250LWJsYWNrIHRleHQtMnhsIHRyYWNraW5nLXRpZ2h0ZXIgdXBwZXJjYXNlXCJcbiAgICAgICAgICAgICAgICBhdXRvRm9jdXNcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwic3VibWl0XCIgY2xhc3NOYW1lPVwidy1mdWxsIGJnLWJsdWUtNjAwIGhvdmVyOmJnLWJsdWUtNzAwIHRleHQtd2hpdGUgZm9udC1ibGFjayBweS01IHJvdW5kZWQtM3hsIHRyYW5zaXRpb24tYWxsIHRleHQtbGcgdXBwZXJjYXNlXCI+XG4gICAgICAgICAgICAgICAgU2lnbiBJblxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZm9ybT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgaC1zY3JlZW4gYmctbmV1dHJhbC0xMDAgb3ZlcmZsb3ctaGlkZGVuIHNlbGVjdC1ub25lIHJlbGF0aXZlXCI+XG4gICAgICA8aGVhZGVyIGNsYXNzTmFtZT1cInB4LTYgcHktNCBmbGV4IGZsZXgtY29sIG1kOmZsZXgtcm93IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gZ2FwLTQgYmctd2hpdGUgYm9yZGVyLWIgYm9yZGVyLWJsYWNrLzEwIG5vLXByaW50IHotNDAgcmVsYXRpdmVcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtNCB3LWZ1bGwgbWQ6dy1hdXRvXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMyBoLTExXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctMTAgaC0xMCBiZy1ibHVlLTYwMCByb3VuZGVkLXhsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHNoYWRvdy1sZyBzaGFkb3ctYmx1ZS01MDAvMTBcIj5cbiAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3NOYW1lPVwiaC02IHctNiB0ZXh0LXdoaXRlXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCI+XG4gICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlTGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZVdpZHRoPXsyLjV9IGQ9XCJNMyA1aDEyTTkgM3YybTEuMDQ4IDkuNUExOC4wMjIgMTguMDIyIDAgMDE2LjQxMiA5bTYuMDg4IDloN00xMSAyMWw1LTEwIDUgMTBNMTIuNzUxIDVDMTEuNzgzIDEwLjc3IDguMDcgMTUuNjEgMyAxOC4xMjlcIiAvPlxuICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1ibHVlLTYwMCBmb250LWJsYWNrIHRyYWNraW5nLXRpZ2h0ZXIgdGV4dC0yeGwgbGVhZGluZy1ub25lXCI+U1VDQ0VTIERVQUw8L3NwYW4+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoaWRkZW4gbWQ6YmxvY2tcIj5cbiAgICAgICAgICAgIDxMYW5ndWFnZVNlbGVjdG9yIGxhYmVsPVwiT3VycyAoU3RhZmYpXCIgdmFsdWU9e3N0YWZmTGFuZ30gb25DaGFuZ2U9e3NldFN0YWZmTGFuZ30gY29sb3I9XCJibHVlXCIgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC00IHctZnVsbCBtZDp3LWF1dG8ganVzdGlmeS1lbmRcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhpZGRlbiBtZDpibG9ja1wiPlxuICAgICAgICAgICAgPExhbmd1YWdlU2VsZWN0b3IgbGFiZWw9XCJUaGVpcnMgKFZpc2l0b3IpXCIgdmFsdWU9e3Zpc2l0b3JMYW5nfSBvbkNoYW5nZT17c2V0VmlzaXRvckxhbmd9IGNvbG9yPVwiZ3JlZW5cIiAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBtZDpoaWRkZW4gZ2FwLTIgdy1mdWxsXCI+XG4gICAgICAgICAgICAgPExhbmd1YWdlU2VsZWN0b3IgbGFiZWw9XCJPdXJzXCIgdmFsdWU9e3N0YWZmTGFuZ30gb25DaGFuZ2U9e3NldFN0YWZmTGFuZ30gY29sb3I9XCJibHVlXCIgLz5cbiAgICAgICAgICAgICA8TGFuZ3VhZ2VTZWxlY3RvciBsYWJlbD1cIlRoZWlyc1wiIHZhbHVlPXt2aXNpdG9yTGFuZ30gb25DaGFuZ2U9e3NldFZpc2l0b3JMYW5nfSBjb2xvcj1cImdyZWVuXCIgLz5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTIgYm9yZGVyLWwgYm9yZGVyLWJsYWNrLzEwIHBsLTQgaC0xMVwiPlxuICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRTaG93SGlzdG9yeSh0cnVlKX0gY2xhc3NOYW1lPVwicC0zIGhvdmVyOmJnLWJsdWUtNTAgdGV4dC1uZXV0cmFsLTQwMCBob3Zlcjp0ZXh0LWJsdWUtNjAwIHJvdW5kZWQteGwgdHJhbnNpdGlvbi1hbGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgaC0xMSB3LTExXCIgdGl0bGU9XCJIaXN0b3J5XCI+XG4gICAgICAgICAgICAgIDxDbG9jayBjbGFzc05hbWU9XCJ3LTUgaC01XCIgLz5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiB3aW5kb3cucHJpbnQoKX0gY2xhc3NOYW1lPVwicC0zIGhvdmVyOmJnLW5ldXRyYWwtMTAwIHRleHQtbmV1dHJhbC00MDAgaG92ZXI6dGV4dC1uZXV0cmFsLTgwMCByb3VuZGVkLXhsIHRyYW5zaXRpb24tYWxsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGgtMTEgdy0xMVwiIHRpdGxlPVwiUHJpbnQgTG9nXCI+XG4gICAgICAgICAgICAgIDxQcmludGVyIGNsYXNzTmFtZT1cInctNSBoLTVcIiAvPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldFNob3dTZXR0aW5ncyh0cnVlKX0gY2xhc3NOYW1lPVwicC0zIGhvdmVyOmJnLW5ldXRyYWwtMTAwIHRleHQtbmV1dHJhbC00MDAgaG92ZXI6dGV4dC1uZXV0cmFsLTkwMCByb3VuZGVkLXhsIHRyYW5zaXRpb24tYWxsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGgtMTEgdy0xMVwiIHRpdGxlPVwiU2V0dGluZ3NcIj5cbiAgICAgICAgICAgICAgPFNldHRpbmdzIGNsYXNzTmFtZT1cInctNSBoLTVcIiAvPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9oZWFkZXI+XG5cbiAgICAgIDxtYWluIGNsYXNzTmFtZT1cImZsZXgtMSBmbGV4IGZsZXgtY29sIGxnOmZsZXgtcm93IGdhcC00IHAtNCBvdmVyZmxvdy1oaWRkZW4gcmVsYXRpdmVcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4LTEgaC0xLzIgbGc6aC1mdWxsXCI+XG4gICAgICAgICAgPFRyYW5zbGF0aW9uQ29sdW1uIFxuICAgICAgICAgICAgdGl0bGU9XCJPdXJzXCIgXG4gICAgICAgICAgICBzdWJ0aXRsZT1cIlNUQUZGXCJcbiAgICAgICAgICAgIG1lc3NhZ2VzPXttZXNzYWdlc30gXG4gICAgICAgICAgICB0eXBlPVwic3RhZmZcIiBcbiAgICAgICAgICAgIGxhbmd1YWdlPXtzdGFmZkxhbmd9XG4gICAgICAgICAgICBzZXRMYW5ndWFnZT17c2V0U3RhZmZMYW5nfVxuICAgICAgICAgICAgc3BlYWtlck9uPXtzdGFmZlNwZWFrZXJ9XG4gICAgICAgICAgICBzZXRTcGVha2VyT249e3NldFN0YWZmU3BlYWtlcn1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4LTEgaC0xLzIgbGc6aC1mdWxsXCI+XG4gICAgICAgICAgPFRyYW5zbGF0aW9uQ29sdW1uIFxuICAgICAgICAgICAgdGl0bGU9XCJUaGVpcnNcIiBcbiAgICAgICAgICAgIHN1YnRpdGxlPVwiVklTSVRPUlwiXG4gICAgICAgICAgICBtZXNzYWdlcz17bWVzc2FnZXN9IFxuICAgICAgICAgICAgdHlwZT1cInZpc2l0b3JcIiBcbiAgICAgICAgICAgIGxhbmd1YWdlPXt2aXNpdG9yTGFuZ31cbiAgICAgICAgICAgIHNldExhbmd1YWdlPXtzZXRWaXNpdG9yTGFuZ31cbiAgICAgICAgICAgIHNwZWFrZXJPbj17dmlzaXRvclNwZWFrZXJ9XG4gICAgICAgICAgICBzZXRTcGVha2VyT249e3NldFZpc2l0b3JTcGVha2VyfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIHsoY3VycmVudElucHV0IHx8IGN1cnJlbnRPdXRwdXQpICYmIGlzTGlzdGVuaW5nICYmIChcbiAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0b3AtMS8yIGxlZnQtMS8yIC10cmFuc2xhdGUteC0xLzIgLXRyYW5zbGF0ZS15LTEvMiB6LTUwIHctZnVsbCBtYXgtdy1sZyBweC02IG5vLXByaW50IG1lc3NhZ2UtZW50ZXJcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy1bIzFEMUQxRl0gdGV4dC13aGl0ZSBwLTYgcm91bmRlZC1bMi41cmVtXSBzaGFkb3ctMnhsIGJvcmRlciBib3JkZXItd2hpdGUvMTAgcmluZy04IHJpbmctYmxhY2svNVwiPlxuICAgICAgICAgICAgICAgIHtjdXJyZW50SW5wdXQgJiYgKFxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi00XCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtWzEwcHhdIGZvbnQtYmxhY2sgdGV4dC1ibHVlLTUwMCB1cHBlcmNhc2UgdHJhY2tpbmctd2lkZXN0IGJsb2NrIG1iLTFcIj5TVFQgVHJhbnNjcmlwdGlvbjo8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIHRleHQtbmV1dHJhbC0yMDBcIj5cIntjdXJyZW50SW5wdXR9XCI8L3A+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIHtjdXJyZW50T3V0cHV0ICYmIChcbiAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7Y3VycmVudElucHV0ID8gJ210LTQgcHQtNCBib3JkZXItdCBib3JkZXItd2hpdGUvMTAnIDogJyd9YH0+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtWzEwcHhdIGZvbnQtYmxhY2sgdGV4dC1ncmVlbi01MDAgdXBwZXJjYXNlIHRyYWNraW5nLXdpZGVzdCBibG9jayBtYi0xXCI+TGl2ZSBUcmFuc2xhdGlvbjo8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1ibGFjayB0ZXh0LWdyZWVuLTQwMCBpdGFsaWNcIj5cIntjdXJyZW50T3V0cHV0fVwiPC9wPlxuICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvbWFpbj5cblxuICAgICAgey8qIEhpc3RvcnkgU2lkZWJhciAqL31cbiAgICAgIHtzaG93SGlzdG9yeSAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCB6LTUwIGJnLWJsYWNrLzIwIGJhY2tkcm9wLWJsdXItc20gZmxleCBqdXN0aWZ5LWVuZFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1heC13LW1kIGgtZnVsbCBiZy13aGl0ZSBzaGFkb3ctMnhsIGZsZXggZmxleC1jb2wgdHJhbnNmb3JtIHNsaWRlLWluLWZyb20tcmlnaHRcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicC01IGJvcmRlci1iIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlblwiPlxuICAgICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LWJsYWNrIHRyYWNraW5nLXRpZ2h0IGZsZXggaXRlbXMtY2VudGVyIGdhcC0yXCI+PENsb2NrIGNsYXNzTmFtZT1cInctNSBoLTVcIiAvPiBIaXN0b3J5PC9oMj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRTaG93SGlzdG9yeShmYWxzZSl9IGNsYXNzTmFtZT1cInAtMlwiPjxYIGNsYXNzTmFtZT1cInctNiBoLTZcIiAvPjwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgtMSBvdmVyZmxvdy15LWF1dG8gcC00IGJnLW5ldXRyYWwtNTBcIj5cbiAgICAgICAgICAgICAge2hpc3RvcnkubGVuZ3RoID09PSAwID8gPHAgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXIgdGV4dC1uZXV0cmFsLTQwMCBweS0xMCBmb250LWJsYWNrIHVwcGVyY2FzZSB0ZXh0LXhzXCI+Tm8gbG9ncyBmb3VuZDwvcD4gOiBcbiAgICAgICAgICAgICAgICBoaXN0b3J5Lm1hcChzZXNzaW9uID0+IChcbiAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtzZXNzaW9uLmlkfSBjbGFzc05hbWU9XCJiZy13aGl0ZSBwLTQgcm91bmRlZC14bCBtYi00IGJvcmRlciBzaGFkb3ctc21cIj5cbiAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1bMTBweF0gZm9udC1ibGFjayB0ZXh0LWJsdWUtNjAwIG1iLTFcIj57bmV3IERhdGUoc2Vzc2lvbi50aW1lc3RhbXApLnRvTG9jYWxlU3RyaW5nKCl9PC9wPlxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtIGl0YWxpYyB0ZXh0LW5ldXRyYWwtNjAwIGxpbmUtY2xhbXAtMlwiPlwie3Nlc3Npb24ucHJldmlld31cIjwvcD5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLTQgYm9yZGVyLXRcIj5cbiAgICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17Y2xlYXJIaXN0b3J5fSBjbGFzc05hbWU9XCJ3LWZ1bGwgdGV4dC1yZWQtNTAwIHB5LTMgZm9udC1ibGFjayB0ZXh0LXhzIHVwcGVyY2FzZSB0cmFja2luZy13aWRlc3QgaG92ZXI6YmctcmVkLTUwIHJvdW5kZWQteGwgdHJhbnNpdGlvbi1hbGxcIj5DbGVhciBMb2dzPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuXG4gICAgICB7LyogU2V0dGluZ3MgU2lkZWJhciAqL31cbiAgICAgIHtzaG93U2V0dGluZ3MgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgei01MCBiZy1ibGFjay8yMCBiYWNrZHJvcC1ibHVyLXNtIGZsZXgganVzdGlmeS1lbmRcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtYXgtdy1tZCBoLWZ1bGwgYmctd2hpdGUgc2hhZG93LTJ4bCBmbGV4IGZsZXgtY29sIHRyYW5zZm9ybSBzbGlkZS1pbi1mcm9tLXJpZ2h0XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtNSBib3JkZXItYiBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gYmctbmV1dHJhbC01MC81MFwiPlxuICAgICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LWJsYWNrIHRyYWNraW5nLXRpZ2h0IGZsZXggaXRlbXMtY2VudGVyIGdhcC0yXCI+XG4gICAgICAgICAgICAgICAgPFNldHRpbmdzIGNsYXNzTmFtZT1cInctNSBoLTUgdGV4dC1ibHVlLTYwMFwiIC8+IFNldHRpbmdzXG4gICAgICAgICAgICAgIDwvaDI+XG4gICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gc2V0U2hvd1NldHRpbmdzKGZhbHNlKX0gY2xhc3NOYW1lPVwicC0yIGhvdmVyOmJnLWJsYWNrLzUgcm91bmRlZC1mdWxsIHRyYW5zaXRpb24tY29sb3JzXCI+PFggY2xhc3NOYW1lPVwidy02IGgtNiB0ZXh0LW5ldXRyYWwtNTAwXCIgLz48L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgtMSBwLTYgc3BhY2UteS0xMCBvdmVyZmxvdy15LWF1dG9cIj5cbiAgICAgICAgICAgICAgIDxzZWN0aW9uPlxuICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0yIG1iLTZcIj5cbiAgICAgICAgICAgICAgICAgICAgPFZvbHVtZTIgY2xhc3NOYW1lPVwidy00IGgtNCB0ZXh0LWJsdWUtNTAwXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQteHMgZm9udC1ibGFjayB1cHBlcmNhc2UgdHJhY2tpbmctd2lkZXN0IHRleHQtbmV1dHJhbC00MDBcIj5Wb2ljZSBDb25maWd1cmF0aW9uPC9oMz5cbiAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwYWNlLXktNlwiPlxuICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiYmxvY2sgdGV4dC1bMTBweF0gZm9udC1ibGFjayB0ZXh0LW5ldXRyYWwtNTAwIHVwcGVyY2FzZSB0cmFja2luZy13aWRlc3QgbWItMiBtbC0xXCI+VHJhbnNsYXRpb24gT3V0cHV0IFZvaWNlPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmVsYXRpdmVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtzZWxlY3RlZFZvaWNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZFZvaWNlKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc3VjY2VzX3ZvaWNlJywgZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgYmctbmV1dHJhbC0xMDAgaG92ZXI6Ymctd2hpdGUgYm9yZGVyIGJvcmRlci1ibGFjay81IHRleHQtbmV1dHJhbC05MDAgZm9udC1ib2xkIHB5LTQgcHgtNSByb3VuZGVkLTJ4bCBhcHBlYXJhbmNlLW5vbmUgY3Vyc29yLXBvaW50ZXIgdHJhbnNpdGlvbi1hbGwgZm9jdXM6cmluZy00IGZvY3VzOnJpbmctYmx1ZS01MDAvMTAgb3V0bGluZS1ub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAge0FWQUlMQUJMRV9WT0lDRVMubWFwKHYgPT4gPG9wdGlvbiBrZXk9e3YuaWR9IHZhbHVlPXt2LmlkfT57di5uYW1lfTwvb3B0aW9uPil9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgcmlnaHQtNCB0b3AtMS8yIC10cmFuc2xhdGUteS0xLzIgcG9pbnRlci1ldmVudHMtbm9uZSBvcGFjaXR5LTUwXCI+PENoZXZyb25Eb3duIGNsYXNzTmFtZT1cInctNSBoLTVcIiAvPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJtdC0zIHRleHQtWzEwcHhdIHRleHQtbmV1dHJhbC00MDAgZm9udC1tZWRpdW0gbGVhZGluZy1yZWxheGVkIGl0YWxpYyBweC0xXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICogQ2hhbmdlIHdpbGwgYXBwbHkgdXBvbiB0aGUgbmV4dCBtaWNyb3Bob25lIGFjdGl2YXRpb24uIEhpZ2gtZmlkZWxpdHkgT3J1cyBsZXhpY29uIHBhcmFtZXRlcnMgYXJlIG1haW50YWluZWQgYWNyb3NzIGFsbCB2b2ljZSB0eXBlcy5cbiAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICA8L3NlY3Rpb24+XG5cbiAgICAgICAgICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cInB0LTEwIGJvcmRlci10IGJvcmRlci1ibGFjay81XCI+XG4gICAgICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LVsxMHB4XSBmb250LWJsYWNrIHVwcGVyY2FzZSB0cmFja2luZy13aWRlc3QgdGV4dC1uZXV0cmFsLTQwMCBtYi00IG1sLTFcIj5QbGF0Zm9ybSBEZXRhaWxzPC9oMz5cbiAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy1uZXV0cmFsLTUwIHJvdW5kZWQtMnhsIHAtNSBib3JkZXIgYm9yZGVyLWJsYWNrLzUgc3BhY2UteS0zXCI+XG4gICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktYmV0d2VlbiBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtWzEwcHhdIGZvbnQtYm9sZCB0ZXh0LW5ldXRyYWwtNTAwIHVwcGVyY2FzZVwiPkVuZ2luZTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtWzEwcHhdIGZvbnQtYmxhY2sgdGV4dC1ibHVlLTYwMFwiPkdlbWluaSAyLjUgTGl2ZTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1bMTBweF0gZm9udC1ib2xkIHRleHQtbmV1dHJhbC01MDAgdXBwZXJjYXNlXCI+TGV4aWNvbjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtWzEwcHhdIGZvbnQtYmxhY2sgdGV4dC1ncmVlbi02MDBcIj5PcnVzIExpYnJhcnkgVjQuMjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1bMTBweF0gZm9udC1ib2xkIHRleHQtbmV1dHJhbC01MDAgdXBwZXJjYXNlXCI+TW9kZTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtWzEwcHhdIGZvbnQtYmxhY2sgdGV4dC1uZXV0cmFsLTgwMFwiPkR1YWwgTmF0aXZlIChubC1CRS9NdWx0aSk8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicC02IGJvcmRlci10IGJnLW5ldXRyYWwtNTAvNTBcIj5cbiAgICAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0U2hvd1NldHRpbmdzKGZhbHNlKX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgYmctbmV1dHJhbC05MDAgdGV4dC13aGl0ZSBmb250LWJsYWNrIHB5LTQgcm91bmRlZC0yeGwgdXBwZXJjYXNlIHRyYWNraW5nLXdpZGVzdCB0ZXh0LXhzIGhvdmVyOmJnLWJsYWNrIHRyYW5zaXRpb24tYWxsIGFjdGl2ZTpzY2FsZS1bMC45OF1cIlxuICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICBEb25lXG4gICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG5cbiAgICAgIDxmb290ZXIgY2xhc3NOYW1lPVwicHgtNiBweS02IHNtOnB5LTEwIGJnLXdoaXRlIGJvcmRlci10IGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHJlbGF0aXZlIG5vLXByaW50XCI+XG4gICAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlU3RvcmVMb2d9IGNsYXNzTmFtZT1cImFic29sdXRlIGxlZnQtNiBiZy1uZXV0cmFsLTEwMCBob3ZlcjpiZy1uZXV0cmFsLTIwMCBweC02IHB5LTMgcm91bmRlZC14bCBmb250LWJsYWNrIHRleHQtWzEwcHhdIHVwcGVyY2FzZSB0cmFja2luZy13aWRlc3QgdHJhbnNpdGlvbi1hbGxcIj5TdG9yZSBTZXNzaW9uPC9idXR0b24+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBvbkNsaWNrPXt0b2dnbGVNaWN9XG4gICAgICAgICAgY2xhc3NOYW1lPXtgcmVsYXRpdmUgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgdy0yNCBoLTI0IHNtOnctMjggc206aC0yOCByb3VuZGVkLWZ1bGwgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tNTAwIHRyYW5zZm9ybSBhY3RpdmU6c2NhbGUtOTAgJHtpc0xpc3RlbmluZyA/ICdtaWMtYWN0aXZlJyA6ICdiZy1ibHVlLTYwMCBzaGFkb3cteGwnfWB9XG4gICAgICAgID5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzc05hbWU9XCJoLTEwIHctMTAgdGV4dC13aGl0ZSBtYi0xXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCI+XG4gICAgICAgICAgICAgIDxwYXRoIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIiBzdHJva2VXaWR0aD17M30gZD1cIk0xOSAxMWE3IDcgMCAwMS03IDdtMCAwYTcgNyAwIDAxLTctN203IDd2NG0wIDBIOG00IDBoNG0tNC04YTMgMyAwIDAxLTMtM1Y1YTMgMyAwIDExNiAwdjZhMyAzIDAgMDEtMyAzelwiIC8+XG4gICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtWzhweF0gZm9udC1ibGFjayB0ZXh0LXdoaXRlLzcwIHVwcGVyY2FzZSB0cmFja2luZy13aWRlc3RcIj7ik4IgQklHIE1JQzwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Zvb3Rlcj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlUm91dGVyIiwiQ2xvY2siLCJYIiwiQ2hldnJvbkRvd24iLCJQcmludGVyIiwiU2V0dGluZ3MiLCJWb2x1bWUyIiwiQXBwU3RhdGUiLCJMQU5HVUFHRVMiLCJHZW1pbmlMaXZlU2VydmljZSIsIlRyYW5zbGF0aW9uQ29sdW1uIiwiTGFuZ3VhZ2VTZWxlY3RvciIsIkFWQUlMQUJMRV9WT0lDRVMiLCJpZCIsIm5hbWUiLCJIb21lIiwicm91dGVyIiwiYXBwU3RhdGUiLCJzZXRBcHBTdGF0ZSIsIkxPR0lOIiwibG9naW5Db2RlIiwic2V0TG9naW5Db2RlIiwiZXJyb3IiLCJzZXRFcnJvciIsInN0YWZmTGFuZyIsInNldFN0YWZmTGFuZyIsInZpc2l0b3JMYW5nIiwic2V0VmlzaXRvckxhbmciLCJzdGFmZlNwZWFrZXIiLCJzZXRTdGFmZlNwZWFrZXIiLCJ2aXNpdG9yU3BlYWtlciIsInNldFZpc2l0b3JTcGVha2VyIiwic2VsZWN0ZWRWb2ljZSIsInNldFNlbGVjdGVkVm9pY2UiLCJpc0xpc3RlbmluZyIsInNldElzTGlzdGVuaW5nIiwibWVzc2FnZXMiLCJzZXRNZXNzYWdlcyIsImN1cnJlbnRJbnB1dCIsInNldEN1cnJlbnRJbnB1dCIsImN1cnJlbnRPdXRwdXQiLCJzZXRDdXJyZW50T3V0cHV0Iiwic2hvd0hpc3RvcnkiLCJzZXRTaG93SGlzdG9yeSIsInNob3dTZXR0aW5ncyIsInNldFNob3dTZXR0aW5ncyIsImhpc3RvcnkiLCJzZXRIaXN0b3J5IiwiZXhwYW5kZWRTZXNzaW9uSWQiLCJzZXRFeHBhbmRlZFNlc3Npb25JZCIsImxpdmVTZXJ2aWNlIiwic2F2ZWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwiZSIsImNvbnNvbGUiLCJzYXZlZFZvaWNlIiwiaGFuZGxlTG9naW4iLCJwcmV2ZW50RGVmYXVsdCIsImNsZWFuIiwidHJpbSIsInRvVXBwZXJDYXNlIiwicHVzaCIsInZhbGlkU3RvY2tDb2RlcyIsInN0b3JlZCIsInBhcnNlZCIsIm1hcCIsIml0ZW0iLCJjb2RlIiwiaXNNYXN0ZXIiLCJpc1N0b2NrQ29kZSIsImluY2x1ZGVzIiwiaXNMZWdhY3kiLCJ0ZXN0IiwiVFJBTlNMQVRPUiIsImhhbmRsZVN0b3JlTG9nIiwibGVuZ3RoIiwibmV3U2Vzc2lvbiIsIkRhdGUiLCJub3ciLCJ0b1N0cmluZyIsInRpbWVzdGFtcCIsInByZXZpZXciLCJvcmlnaW5hbFRleHQiLCJzdWJzdHJpbmciLCJ1cGRhdGVkSGlzdG9yeSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJhbGVydCIsImNsZWFySGlzdG9yeSIsImNvbmZpcm0iLCJyZW1vdmVJdGVtIiwidG9nZ2xlTWljIiwiY3VycmVudCIsImRpc2Nvbm5lY3QiLCJzTGFuZyIsImZpbmQiLCJsIiwidkxhbmciLCJjb25uZWN0Iiwic3RhZmZMYW5ndWFnZSIsInZpc2l0b3JMYW5ndWFnZSIsInZvaWNlTmFtZSIsIm9uVHJhbnNjcmlwdGlvbiIsInRleHQiLCJpc0lucHV0IiwicHJldiIsIm9uVHVybkNvbXBsZXRlIiwib25FcnJvciIsImVyciIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwibmV3TWVzc2FnZSIsIk1hdGgiLCJyYW5kb20iLCJzdWJzdHIiLCJzZW5kZXIiLCJ0cmFuc2xhdGVkVGV4dCIsImNsZWFyVGltZW91dCIsImRpdiIsImNsYXNzTmFtZSIsInN2ZyIsInhtbG5zIiwiZmlsbCIsInZpZXdCb3giLCJzdHJva2UiLCJwYXRoIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIiwic3Ryb2tlV2lkdGgiLCJkIiwiaDEiLCJwIiwiZm9ybSIsIm9uU3VibWl0IiwiaW5wdXQiLCJ0eXBlIiwidmFsdWUiLCJvbkNoYW5nZSIsInRhcmdldCIsInBsYWNlaG9sZGVyIiwiYXV0b0ZvY3VzIiwiYnV0dG9uIiwiaGVhZGVyIiwic3BhbiIsImxhYmVsIiwiY29sb3IiLCJvbkNsaWNrIiwidGl0bGUiLCJ3aW5kb3ciLCJwcmludCIsIm1haW4iLCJzdWJ0aXRsZSIsImxhbmd1YWdlIiwic2V0TGFuZ3VhZ2UiLCJzcGVha2VyT24iLCJzZXRTcGVha2VyT24iLCJoMiIsInNlc3Npb24iLCJ0b0xvY2FsZVN0cmluZyIsInNlY3Rpb24iLCJoMyIsInNlbGVjdCIsInYiLCJvcHRpb24iLCJmb290ZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/LanguageSelector.tsx":
/*!*****************************************!*\
  !*** ./components/LanguageSelector.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LanguageSelector: () => (/* binding */ LanguageSelector)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../types */ \"(app-pages-browser)/./types.ts\");\n\n\n\nconst LanguageSelector = (param)=>{\n    let { label, value, onChange, color } = param;\n    const accentClass = color === 'blue' ? 'text-blue-600' : 'text-green-600';\n    const bgClass = color === 'blue' ? 'bg-blue-50' : 'bg-green-50';\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col gap-1 w-full max-w-[180px]\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                className: \"text-[10px] font-black uppercase tracking-widest \".concat(accentClass, \" opacity-70 px-1\"),\n                children: label\n            }, void 0, false, {\n                fileName: \"/workspaces/eburondual/components/LanguageSelector.tsx\",\n                lineNumber: 18,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"relative group\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                        value: value,\n                        onChange: (e)=>onChange(e.target.value),\n                        className: \"appearance-none w-full \".concat(bgClass, \" hover:bg-white border border-black/5 text-neutral-900 text-sm font-bold py-3 pl-4 pr-10 rounded-2xl transition-all cursor-pointer focus:outline-none focus:ring-2 focus:ring-blue-500 shadow-sm\"),\n                        children: _types__WEBPACK_IMPORTED_MODULE_2__.LANGUAGES.map((lang)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                value: lang.code,\n                                children: lang.name\n                            }, lang.code, false, {\n                                fileName: \"/workspaces/eburondual/components/LanguageSelector.tsx\",\n                                lineNumber: 28,\n                                columnNumber: 13\n                            }, undefined))\n                    }, void 0, false, {\n                        fileName: \"/workspaces/eburondual/components/LanguageSelector.tsx\",\n                        lineNumber: 22,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none text-neutral-400\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                            xmlns: \"http://www.w3.org/2000/svg\",\n                            className: \"h-4 w-4\",\n                            fill: \"none\",\n                            viewBox: \"0 0 24 24\",\n                            stroke: \"currentColor\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                strokeLinecap: \"round\",\n                                strokeLinejoin: \"round\",\n                                strokeWidth: 3,\n                                d: \"M19 9l-7 7-7-7\"\n                            }, void 0, false, {\n                                fileName: \"/workspaces/eburondual/components/LanguageSelector.tsx\",\n                                lineNumber: 35,\n                                columnNumber: 13\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"/workspaces/eburondual/components/LanguageSelector.tsx\",\n                            lineNumber: 34,\n                            columnNumber: 11\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/workspaces/eburondual/components/LanguageSelector.tsx\",\n                        lineNumber: 33,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/workspaces/eburondual/components/LanguageSelector.tsx\",\n                lineNumber: 21,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/workspaces/eburondual/components/LanguageSelector.tsx\",\n        lineNumber: 17,\n        columnNumber: 5\n    }, undefined);\n};\n_c = LanguageSelector;\nvar _c;\n$RefreshReg$(_c, \"LanguageSelector\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvTGFuZ3VhZ2VTZWxlY3Rvci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQzBCO0FBQ1c7QUFTOUIsTUFBTUUsbUJBQW9EO1FBQUMsRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFO0lBQ2pHLE1BQU1DLGNBQWNELFVBQVUsU0FBUyxrQkFBa0I7SUFDekQsTUFBTUUsVUFBVUYsVUFBVSxTQUFTLGVBQWU7SUFFbEQscUJBQ0UsOERBQUNHO1FBQUlDLFdBQVU7OzBCQUNiLDhEQUFDUDtnQkFBTU8sV0FBVyxvREFBZ0UsT0FBWkgsYUFBWTswQkFDL0VKOzs7Ozs7MEJBRUgsOERBQUNNO2dCQUFJQyxXQUFVOztrQ0FDYiw4REFBQ0M7d0JBQ0NQLE9BQU9BO3dCQUNQQyxVQUFVLENBQUNPLElBQU1QLFNBQVNPLEVBQUVDLE1BQU0sQ0FBQ1QsS0FBSzt3QkFDeENNLFdBQVcsMEJBQWtDLE9BQVJGLFNBQVE7a0NBRTVDUCw2Q0FBU0EsQ0FBQ2EsR0FBRyxDQUFDLENBQUNDLHFCQUNkLDhEQUFDQztnQ0FBdUJaLE9BQU9XLEtBQUtFLElBQUk7MENBQ3JDRixLQUFLRyxJQUFJOytCQURDSCxLQUFLRSxJQUFJOzs7Ozs7Ozs7O2tDQUsxQiw4REFBQ1I7d0JBQUlDLFdBQVU7a0NBQ2IsNEVBQUNTOzRCQUFJQyxPQUFNOzRCQUE2QlYsV0FBVTs0QkFBVVcsTUFBSzs0QkFBT0MsU0FBUTs0QkFBWUMsUUFBTztzQ0FDakcsNEVBQUNDO2dDQUFLQyxlQUFjO2dDQUFRQyxnQkFBZTtnQ0FBUUMsYUFBYTtnQ0FBR0MsR0FBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1qRixFQUFFO0tBN0JXMUIiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2VidXJvbmR1YWwvY29tcG9uZW50cy9MYW5ndWFnZVNlbGVjdG9yLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBMQU5HVUFHRVMgfSBmcm9tICcuLi90eXBlcyc7XG5cbmludGVyZmFjZSBMYW5ndWFnZVNlbGVjdG9yUHJvcHMge1xuICBsYWJlbDogc3RyaW5nO1xuICB2YWx1ZTogc3RyaW5nO1xuICBvbkNoYW5nZTogKHZhbDogc3RyaW5nKSA9PiB2b2lkO1xuICBjb2xvcjogJ2JsdWUnIHwgJ2dyZWVuJztcbn1cblxuZXhwb3J0IGNvbnN0IExhbmd1YWdlU2VsZWN0b3I6IFJlYWN0LkZDPExhbmd1YWdlU2VsZWN0b3JQcm9wcz4gPSAoeyBsYWJlbCwgdmFsdWUsIG9uQ2hhbmdlLCBjb2xvciB9KSA9PiB7XG4gIGNvbnN0IGFjY2VudENsYXNzID0gY29sb3IgPT09ICdibHVlJyA/ICd0ZXh0LWJsdWUtNjAwJyA6ICd0ZXh0LWdyZWVuLTYwMCc7XG4gIGNvbnN0IGJnQ2xhc3MgPSBjb2xvciA9PT0gJ2JsdWUnID8gJ2JnLWJsdWUtNTAnIDogJ2JnLWdyZWVuLTUwJztcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBnYXAtMSB3LWZ1bGwgbWF4LXctWzE4MHB4XVwiPlxuICAgICAgPGxhYmVsIGNsYXNzTmFtZT17YHRleHQtWzEwcHhdIGZvbnQtYmxhY2sgdXBwZXJjYXNlIHRyYWNraW5nLXdpZGVzdCAke2FjY2VudENsYXNzfSBvcGFjaXR5LTcwIHB4LTFgfT5cbiAgICAgICAge2xhYmVsfVxuICAgICAgPC9sYWJlbD5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmVsYXRpdmUgZ3JvdXBcIj5cbiAgICAgICAgPHNlbGVjdFxuICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IG9uQ2hhbmdlKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICBjbGFzc05hbWU9e2BhcHBlYXJhbmNlLW5vbmUgdy1mdWxsICR7YmdDbGFzc30gaG92ZXI6Ymctd2hpdGUgYm9yZGVyIGJvcmRlci1ibGFjay81IHRleHQtbmV1dHJhbC05MDAgdGV4dC1zbSBmb250LWJvbGQgcHktMyBwbC00IHByLTEwIHJvdW5kZWQtMnhsIHRyYW5zaXRpb24tYWxsIGN1cnNvci1wb2ludGVyIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ibHVlLTUwMCBzaGFkb3ctc21gfVxuICAgICAgICA+XG4gICAgICAgICAge0xBTkdVQUdFUy5tYXAoKGxhbmcpID0+IChcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PXtsYW5nLmNvZGV9IHZhbHVlPXtsYW5nLmNvZGV9PlxuICAgICAgICAgICAgICB7bGFuZy5uYW1lfVxuICAgICAgICAgICAgPC9vcHRpb24+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvc2VsZWN0PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIHJpZ2h0LTMgdG9wLTEvMiAtdHJhbnNsYXRlLXktMS8yIHBvaW50ZXItZXZlbnRzLW5vbmUgdGV4dC1uZXV0cmFsLTQwMFwiPlxuICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzTmFtZT1cImgtNCB3LTRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIj5cbiAgICAgICAgICAgIDxwYXRoIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIiBzdHJva2VXaWR0aD17M30gZD1cIk0xOSA5bC03IDctNy03XCIgLz5cbiAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJMQU5HVUFHRVMiLCJMYW5ndWFnZVNlbGVjdG9yIiwibGFiZWwiLCJ2YWx1ZSIsIm9uQ2hhbmdlIiwiY29sb3IiLCJhY2NlbnRDbGFzcyIsImJnQ2xhc3MiLCJkaXYiLCJjbGFzc05hbWUiLCJzZWxlY3QiLCJlIiwidGFyZ2V0IiwibWFwIiwibGFuZyIsIm9wdGlvbiIsImNvZGUiLCJuYW1lIiwic3ZnIiwieG1sbnMiLCJmaWxsIiwidmlld0JveCIsInN0cm9rZSIsInBhdGgiLCJzdHJva2VMaW5lY2FwIiwic3Ryb2tlTGluZWpvaW4iLCJzdHJva2VXaWR0aCIsImQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/LanguageSelector.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/TranslationColumn.tsx":
/*!******************************************!*\
  !*** ./components/TranslationColumn.tsx ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TranslationColumn: () => (/* binding */ TranslationColumn)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nconst TranslationColumn = (param)=>{\n    let { title, subtitle, messages, type, language, speakerOn, setSpeakerOn } = param;\n    _s();\n    const scrollRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isStaffCol = type === 'staff';\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"TranslationColumn.useEffect\": ()=>{\n            if (scrollRef.current) {\n                scrollRef.current.scrollTop = scrollRef.current.scrollHeight;\n            }\n        }\n    }[\"TranslationColumn.useEffect\"], [\n        messages\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col h-full bg-white border border-black/10 rounded-xl overflow-hidden shadow-md\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"p-4 \".concat(isStaffCol ? 'column-header-blue' : 'column-header-green', \" bg-neutral-50\"),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex items-center justify-between mb-2\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex items-center gap-2\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                        className: \"text-xl font-black uppercase tracking-tighter text-neutral-800\",\n                                        children: title\n                                    }, void 0, false, {\n                                        fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                                        lineNumber: 40,\n                                        columnNumber: 14\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"text-[10px] font-bold text-neutral-400 bg-neutral-200 px-1.5 py-0.5 rounded leading-none\",\n                                        children: subtitle\n                                    }, void 0, false, {\n                                        fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                                        lineNumber: 41,\n                                        columnNumber: 14\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                                lineNumber: 39,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>setSpeakerOn(!speakerOn),\n                                className: \"flex items-center gap-1.5 px-3 py-1.5 rounded-full text-[10px] font-black uppercase tracking-widest transition-all \".concat(speakerOn ? 'bg-blue-600 text-white shadow-lg shadow-blue-500/30' : 'bg-neutral-200 text-neutral-400'),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                        xmlns: \"http://www.w3.org/2000/svg\",\n                                        className: \"h-3 w-3\",\n                                        fill: \"none\",\n                                        viewBox: \"0 0 24 24\",\n                                        stroke: \"currentColor\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                            strokeLinecap: \"round\",\n                                            strokeLinejoin: \"round\",\n                                            strokeWidth: 2.5,\n                                            d: \"M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z\"\n                                        }, void 0, false, {\n                                            fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                                            lineNumber: 52,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    }, void 0, false, {\n                                        fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                                        lineNumber: 51,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    \"Speaker \",\n                                    speakerOn ? 'ON' : 'OFF'\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                                lineNumber: 45,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                        lineNumber: 38,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex items-center gap-2\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"text-[10px] font-black text-neutral-400 uppercase tracking-widest\",\n                            children: [\n                                \"Active Language: \",\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-neutral-600\",\n                                    children: language\n                                }, void 0, false, {\n                                    fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                                    lineNumber: 59,\n                                    columnNumber: 112\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                            lineNumber: 59,\n                            columnNumber: 11\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                        lineNumber: 58,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                lineNumber: 37,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: scrollRef,\n                className: \"flex-1 overflow-y-auto p-4 space-y-6 custom-scrollbar bg-white\",\n                children: [\n                    messages.length === 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"h-full flex flex-col items-center justify-center opacity-20 grayscale\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                xmlns: \"http://www.w3.org/2000/svg\",\n                                className: \"h-12 w-12 mb-4\",\n                                fill: \"none\",\n                                viewBox: \"0 0 24 24\",\n                                stroke: \"currentColor\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                    strokeLinecap: \"round\",\n                                    strokeLinejoin: \"round\",\n                                    strokeWidth: 1,\n                                    d: \"M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z\"\n                                }, void 0, false, {\n                                    fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                                    lineNumber: 68,\n                                    columnNumber: 15\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                                lineNumber: 67,\n                                columnNumber: 13\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-xs font-black uppercase tracking-[0.2em]\",\n                                children: \"Dialogue Log\"\n                            }, void 0, false, {\n                                fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                                lineNumber: 70,\n                                columnNumber: 13\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                        lineNumber: 66,\n                        columnNumber: 11\n                    }, undefined),\n                    messages.map((msg)=>{\n                        const isSender = isStaffCol && msg.sender === 'staff' || !isStaffCol && msg.sender === 'visitor';\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"message-enter space-y-1\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-[11px] text-neutral-400 italic font-medium leading-tight\",\n                                    children: [\n                                        '\"',\n                                        msg.originalText,\n                                        '\"'\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                                    lineNumber: 80,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"p-3 rounded-lg \".concat(isSender ? 'bg-neutral-100 text-neutral-900' : 'bg-neutral-800 text-white'),\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-lg font-black leading-tight tracking-tight uppercase\",\n                                        children: isSender ? msg.originalText : msg.translatedText\n                                    }, void 0, false, {\n                                        fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                                        lineNumber: 86,\n                                        columnNumber: 17\n                                    }, undefined)\n                                }, void 0, false, {\n                                    fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                                    lineNumber: 85,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, msg.id, true, {\n                            fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                            lineNumber: 78,\n                            columnNumber: 13\n                        }, undefined);\n                    })\n                ]\n            }, void 0, true, {\n                fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n                lineNumber: 64,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/workspaces/eburondual/components/TranslationColumn.tsx\",\n        lineNumber: 35,\n        columnNumber: 5\n    }, undefined);\n};\n_s(TranslationColumn, \"P14GFulhWAl/Oec4Pk4QeBwKyr0=\");\n_c = TranslationColumn;\nvar _c;\n$RefreshReg$(_c, \"TranslationColumn\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvVHJhbnNsYXRpb25Db2x1bW4udHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUNpRDtBQWMxQyxNQUFNRyxvQkFBc0Q7UUFBQyxFQUNsRUMsS0FBSyxFQUNMQyxRQUFRLEVBQ1JDLFFBQVEsRUFDUkMsSUFBSSxFQUNKQyxRQUFRLEVBQ1JDLFNBQVMsRUFDVEMsWUFBWSxFQUNiOztJQUNDLE1BQU1DLFlBQVlULDZDQUFNQSxDQUFpQjtJQUN6QyxNQUFNVSxhQUFhTCxTQUFTO0lBRTVCTixnREFBU0E7dUNBQUM7WUFDUixJQUFJVSxVQUFVRSxPQUFPLEVBQUU7Z0JBQ3JCRixVQUFVRSxPQUFPLENBQUNDLFNBQVMsR0FBR0gsVUFBVUUsT0FBTyxDQUFDRSxZQUFZO1lBQzlEO1FBQ0Y7c0NBQUc7UUFBQ1Q7S0FBUztJQUViLHFCQUNFLDhEQUFDVTtRQUFJQyxXQUFVOzswQkFFYiw4REFBQ0Q7Z0JBQUlDLFdBQVcsT0FBaUUsT0FBMURMLGFBQWEsdUJBQXVCLHVCQUFzQjs7a0NBQy9FLDhEQUFDSTt3QkFBSUMsV0FBVTs7MENBQ2IsOERBQUNEO2dDQUFJQyxXQUFVOztrREFDWiw4REFBQ0M7d0NBQUdELFdBQVU7a0RBQWtFYjs7Ozs7O2tEQUNoRiw4REFBQ2U7d0NBQUtGLFdBQVU7a0RBQ1paOzs7Ozs7Ozs7Ozs7MENBR1AsOERBQUNlO2dDQUNDQyxTQUFTLElBQU1YLGFBQWEsQ0FBQ0Q7Z0NBQzdCUSxXQUFXLHNIQUVWLE9BRENSLFlBQVksd0RBQXdEOztrREFHdEUsOERBQUNhO3dDQUFJQyxPQUFNO3dDQUE2Qk4sV0FBVTt3Q0FBVU8sTUFBSzt3Q0FBT0MsU0FBUTt3Q0FBWUMsUUFBTztrREFDakcsNEVBQUNDOzRDQUFLQyxlQUFjOzRDQUFRQyxnQkFBZTs0Q0FBUUMsYUFBYTs0Q0FBS0MsR0FBRTs7Ozs7Ozs7Ozs7b0NBQ25FO29DQUNHdEIsWUFBWSxPQUFPOzs7Ozs7Ozs7Ozs7O2tDQUloQyw4REFBQ087d0JBQUlDLFdBQVU7a0NBQ2IsNEVBQUNFOzRCQUFLRixXQUFVOztnQ0FBb0U7OENBQWlCLDhEQUFDRTtvQ0FBS0YsV0FBVTs4Q0FBb0JUOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFLN0ksOERBQUNRO2dCQUFJZ0IsS0FBS3JCO2dCQUFXTSxXQUFVOztvQkFDNUJYLFNBQVMyQixNQUFNLEtBQUssbUJBQ25CLDhEQUFDakI7d0JBQUlDLFdBQVU7OzBDQUNiLDhEQUFDSztnQ0FBSUMsT0FBTTtnQ0FBNkJOLFdBQVU7Z0NBQWlCTyxNQUFLO2dDQUFPQyxTQUFRO2dDQUFZQyxRQUFPOzBDQUN4Ryw0RUFBQ0M7b0NBQUtDLGVBQWM7b0NBQVFDLGdCQUFlO29DQUFRQyxhQUFhO29DQUFHQyxHQUFFOzs7Ozs7Ozs7OzswQ0FFdkUsOERBQUNHO2dDQUFFakIsV0FBVTswQ0FBZ0Q7Ozs7Ozs7Ozs7OztvQkFJaEVYLFNBQVM2QixHQUFHLENBQUMsQ0FBQ0M7d0JBQ2IsTUFBTUMsV0FBVyxjQUFlRCxJQUFJRSxNQUFNLEtBQUssV0FBYSxDQUFDMUIsY0FBY3dCLElBQUlFLE1BQU0sS0FBSzt3QkFFMUYscUJBQ0UsOERBQUN0Qjs0QkFBaUJDLFdBQVU7OzhDQUUxQiw4REFBQ2lCO29DQUFFakIsV0FBVTs7d0NBQWdFO3dDQUN4RW1CLElBQUlHLFlBQVk7d0NBQUM7Ozs7Ozs7OENBSXRCLDhEQUFDdkI7b0NBQUlDLFdBQVcsa0JBQTZGLE9BQTNFb0IsV0FBVyxvQ0FBb0M7OENBQy9FLDRFQUFDSDt3Q0FBRWpCLFdBQVU7a0RBQ1ZvQixXQUFXRCxJQUFJRyxZQUFZLEdBQUdILElBQUlJLGNBQWM7Ozs7Ozs7Ozs7OzsyQkFUN0NKLElBQUlLLEVBQUU7Ozs7O29CQWNwQjs7Ozs7Ozs7Ozs7OztBQUlSLEVBQUU7R0FoRld0QztLQUFBQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZWJ1cm9uZHVhbC9jb21wb25lbnRzL1RyYW5zbGF0aW9uQ29sdW1uLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1lc3NhZ2UgfSBmcm9tICcuLi90eXBlcyc7XG5cbmludGVyZmFjZSBUcmFuc2xhdGlvbkNvbHVtblByb3BzIHtcbiAgdGl0bGU6IHN0cmluZztcbiAgc3VidGl0bGU6IHN0cmluZztcbiAgbWVzc2FnZXM6IE1lc3NhZ2VbXTtcbiAgdHlwZTogJ3N0YWZmJyB8ICd2aXNpdG9yJztcbiAgbGFuZ3VhZ2U6IHN0cmluZztcbiAgc2V0TGFuZ3VhZ2U6IChjb2RlOiBzdHJpbmcpID0+IHZvaWQ7XG4gIHNwZWFrZXJPbjogYm9vbGVhbjtcbiAgc2V0U3BlYWtlck9uOiAob246IGJvb2xlYW4pID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBUcmFuc2xhdGlvbkNvbHVtbjogUmVhY3QuRkM8VHJhbnNsYXRpb25Db2x1bW5Qcm9wcz4gPSAoeyBcbiAgdGl0bGUsIFxuICBzdWJ0aXRsZSwgXG4gIG1lc3NhZ2VzLCBcbiAgdHlwZSwgXG4gIGxhbmd1YWdlLFxuICBzcGVha2VyT24sXG4gIHNldFNwZWFrZXJPblxufSkgPT4ge1xuICBjb25zdCBzY3JvbGxSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBpc1N0YWZmQ29sID0gdHlwZSA9PT0gJ3N0YWZmJztcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzY3JvbGxSZWYuY3VycmVudCkge1xuICAgICAgc2Nyb2xsUmVmLmN1cnJlbnQuc2Nyb2xsVG9wID0gc2Nyb2xsUmVmLmN1cnJlbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIH1cbiAgfSwgW21lc3NhZ2VzXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgaC1mdWxsIGJnLXdoaXRlIGJvcmRlciBib3JkZXItYmxhY2svMTAgcm91bmRlZC14bCBvdmVyZmxvdy1oaWRkZW4gc2hhZG93LW1kXCI+XG4gICAgICB7LyogSGVhZGVyIFNlY3Rpb24gKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17YHAtNCAke2lzU3RhZmZDb2wgPyAnY29sdW1uLWhlYWRlci1ibHVlJyA6ICdjb2x1bW4taGVhZGVyLWdyZWVuJ30gYmctbmV1dHJhbC01MGB9PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBtYi0yXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMlwiPlxuICAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtYmxhY2sgdXBwZXJjYXNlIHRyYWNraW5nLXRpZ2h0ZXIgdGV4dC1uZXV0cmFsLTgwMFwiPnt0aXRsZX08L2gyPlxuICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtWzEwcHhdIGZvbnQtYm9sZCB0ZXh0LW5ldXRyYWwtNDAwIGJnLW5ldXRyYWwtMjAwIHB4LTEuNSBweS0wLjUgcm91bmRlZCBsZWFkaW5nLW5vbmVcIj5cbiAgICAgICAgICAgICAgICB7c3VidGl0bGV9XG4gICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTcGVha2VyT24oIXNwZWFrZXJPbil9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2BmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMS41IHB4LTMgcHktMS41IHJvdW5kZWQtZnVsbCB0ZXh0LVsxMHB4XSBmb250LWJsYWNrIHVwcGVyY2FzZSB0cmFja2luZy13aWRlc3QgdHJhbnNpdGlvbi1hbGwgJHtcbiAgICAgICAgICAgICAgc3BlYWtlck9uID8gJ2JnLWJsdWUtNjAwIHRleHQtd2hpdGUgc2hhZG93LWxnIHNoYWRvdy1ibHVlLTUwMC8zMCcgOiAnYmctbmV1dHJhbC0yMDAgdGV4dC1uZXV0cmFsLTQwMCdcbiAgICAgICAgICAgIH1gfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzTmFtZT1cImgtMyB3LTNcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIj5cbiAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlTGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZVdpZHRoPXsyLjV9IGQ9XCJNMTUuNTM2IDguNDY0YTUgNSAwIDAxMCA3LjA3Mm0yLjgyOC05LjlhOSA5IDAgMDEwIDEyLjcyOE01LjU4NiAxNUg0YTEgMSAwIDAxLTEtMXYtNGExIDEgMCAwMTEtMWgxLjU4Nmw0LjcwNy00LjcwN0MxMC45MjMgMy42NjMgMTIgNC4xMDkgMTIgNXYxNGMwIC44OTEtMS4wNzcgMS4zMzctMS43MDcuNzA3TDUuNTg2IDE1elwiIC8+XG4gICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgIFNwZWFrZXIge3NwZWFrZXJPbiA/ICdPTicgOiAnT0ZGJ31cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0yXCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1bMTBweF0gZm9udC1ibGFjayB0ZXh0LW5ldXRyYWwtNDAwIHVwcGVyY2FzZSB0cmFja2luZy13aWRlc3RcIj5BY3RpdmUgTGFuZ3VhZ2U6IDxzcGFuIGNsYXNzTmFtZT1cInRleHQtbmV1dHJhbC02MDBcIj57bGFuZ3VhZ2V9PC9zcGFuPjwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgey8qIExvZyBTZWN0aW9uICovfVxuICAgICAgPGRpdiByZWY9e3Njcm9sbFJlZn0gY2xhc3NOYW1lPVwiZmxleC0xIG92ZXJmbG93LXktYXV0byBwLTQgc3BhY2UteS02IGN1c3RvbS1zY3JvbGxiYXIgYmctd2hpdGVcIj5cbiAgICAgICAge21lc3NhZ2VzLmxlbmd0aCA9PT0gMCAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoLWZ1bGwgZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgb3BhY2l0eS0yMCBncmF5c2NhbGVcIj5cbiAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzTmFtZT1cImgtMTIgdy0xMiBtYi00XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCI+XG4gICAgICAgICAgICAgIDxwYXRoIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIiBzdHJva2VXaWR0aD17MX0gZD1cIk04IDEyaC4wMU0xMiAxMmguMDFNMTYgMTJoLjAxTTIxIDEyYzAgNC40MTgtNC4wMyA4LTkgOGE5Ljg2MyA5Ljg2MyAwIDAxLTQuMjU1LS45NDlMMyAyMGwxLjM5NS0zLjcyQzMuNTEyIDE1LjA0MiAzIDEzLjU3NCAzIDEyYzAtNC40MTggNC4wMy04IDktOHM5IDMuNTgyIDkgOHpcIiAvPlxuICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXhzIGZvbnQtYmxhY2sgdXBwZXJjYXNlIHRyYWNraW5nLVswLjJlbV1cIj5EaWFsb2d1ZSBMb2c8L3A+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG5cbiAgICAgICAge21lc3NhZ2VzLm1hcCgobXNnKSA9PiB7XG4gICAgICAgICAgY29uc3QgaXNTZW5kZXIgPSAoaXNTdGFmZkNvbCAmJiBtc2cuc2VuZGVyID09PSAnc3RhZmYnKSB8fCAoIWlzU3RhZmZDb2wgJiYgbXNnLnNlbmRlciA9PT0gJ3Zpc2l0b3InKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBrZXk9e21zZy5pZH0gY2xhc3NOYW1lPVwibWVzc2FnZS1lbnRlciBzcGFjZS15LTFcIj5cbiAgICAgICAgICAgICAgey8qIFNUVC9UcmFuc2NyaXB0aW9uICovfVxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LVsxMXB4XSB0ZXh0LW5ldXRyYWwtNDAwIGl0YWxpYyBmb250LW1lZGl1bSBsZWFkaW5nLXRpZ2h0XCI+XG4gICAgICAgICAgICAgICAgIFwie21zZy5vcmlnaW5hbFRleHR9XCJcbiAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgey8qIEJJRyBUcmFuc2xhdGlvbiBSZXN1bHQgKi99XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgcC0zIHJvdW5kZWQtbGcgJHtpc1NlbmRlciA/ICdiZy1uZXV0cmFsLTEwMCB0ZXh0LW5ldXRyYWwtOTAwJyA6ICdiZy1uZXV0cmFsLTgwMCB0ZXh0LXdoaXRlJ31gfT5cbiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYmxhY2sgbGVhZGluZy10aWdodCB0cmFja2luZy10aWdodCB1cHBlcmNhc2VcIj5cbiAgICAgICAgICAgICAgICAgIHtpc1NlbmRlciA/IG1zZy5vcmlnaW5hbFRleHQgOiBtc2cudHJhbnNsYXRlZFRleHR9XG4gICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICk7XG4gICAgICAgIH0pfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwiVHJhbnNsYXRpb25Db2x1bW4iLCJ0aXRsZSIsInN1YnRpdGxlIiwibWVzc2FnZXMiLCJ0eXBlIiwibGFuZ3VhZ2UiLCJzcGVha2VyT24iLCJzZXRTcGVha2VyT24iLCJzY3JvbGxSZWYiLCJpc1N0YWZmQ29sIiwiY3VycmVudCIsInNjcm9sbFRvcCIsInNjcm9sbEhlaWdodCIsImRpdiIsImNsYXNzTmFtZSIsImgyIiwic3BhbiIsImJ1dHRvbiIsIm9uQ2xpY2siLCJzdmciLCJ4bWxucyIsImZpbGwiLCJ2aWV3Qm94Iiwic3Ryb2tlIiwicGF0aCIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsInN0cm9rZVdpZHRoIiwiZCIsInJlZiIsImxlbmd0aCIsInAiLCJtYXAiLCJtc2ciLCJpc1NlbmRlciIsInNlbmRlciIsIm9yaWdpbmFsVGV4dCIsInRyYW5zbGF0ZWRUZXh0IiwiaWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/TranslationColumn.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./constants.ts":
/*!**********************!*\
  !*** ./constants.ts ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APP_CONFIG: () => (/* binding */ APP_CONFIG),\n/* harmony export */   COLORS: () => (/* binding */ COLORS)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst COLORS = {\n    staff: 'blue',\n    visitor: 'green'\n};\nconst APP_CONFIG = {\n    MODEL_NAME: 'gemini-2.5-flash-native-audio-preview-12-2025',\n    SAMPLE_RATE_INPUT: 16000,\n    SAMPLE_RATE_OUTPUT: 24000\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnN0YW50cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQzBCO0FBRW5CLE1BQU1DLFNBQVM7SUFDcEJDLE9BQU87SUFDUEMsU0FBUztBQUNYLEVBQUU7QUFFSyxNQUFNQyxhQUFhO0lBQ3hCQyxZQUFZO0lBQ1pDLG1CQUFtQjtJQUNuQkMsb0JBQW9CO0FBQ3RCLEVBQUUiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2VidXJvbmR1YWwvY29uc3RhbnRzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGNvbnN0IENPTE9SUyA9IHtcbiAgc3RhZmY6ICdibHVlJyxcbiAgdmlzaXRvcjogJ2dyZWVuJ1xufTtcblxuZXhwb3J0IGNvbnN0IEFQUF9DT05GSUcgPSB7XG4gIE1PREVMX05BTUU6ICdnZW1pbmktMi41LWZsYXNoLW5hdGl2ZS1hdWRpby1wcmV2aWV3LTEyLTIwMjUnLFxuICBTQU1QTEVfUkFURV9JTlBVVDogMTYwMDAsXG4gIFNBTVBMRV9SQVRFX09VVFBVVDogMjQwMDBcbn07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJDT0xPUlMiLCJzdGFmZiIsInZpc2l0b3IiLCJBUFBfQ09ORklHIiwiTU9ERUxfTkFNRSIsIlNBTVBMRV9SQVRFX0lOUFVUIiwiU0FNUExFX1JBVEVfT1VUUFVUIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./constants.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./services/audioUtils.ts":
/*!********************************!*\
  !*** ./services/audioUtils.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   decodeAudioData: () => (/* binding */ decodeAudioData),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   float32ToInt16: () => (/* binding */ float32ToInt16)\n/* harmony export */ });\nfunction encode(bytes) {\n    let binary = '';\n    const len = bytes.byteLength;\n    for(let i = 0; i < len; i++){\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\nfunction decode(base64) {\n    const binaryString = atob(base64);\n    const len = binaryString.length;\n    const bytes = new Uint8Array(len);\n    for(let i = 0; i < len; i++){\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n}\nasync function decodeAudioData(data, ctx, sampleRate, numChannels) {\n    const dataInt16 = new Int16Array(data.buffer);\n    const frameCount = dataInt16.length / numChannels;\n    const buffer = ctx.createBuffer(numChannels, frameCount, sampleRate);\n    for(let channel = 0; channel < numChannels; channel++){\n        const channelData = buffer.getChannelData(channel);\n        for(let i = 0; i < frameCount; i++){\n            channelData[i] = dataInt16[i * numChannels + channel] / 32768.0;\n        }\n    }\n    return buffer;\n}\nfunction float32ToInt16(data) {\n    const int16 = new Int16Array(data.length);\n    for(let i = 0; i < data.length; i++){\n        int16[i] = Math.max(-1, Math.min(1, data[i])) * 32768;\n    }\n    return int16;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL2F1ZGlvVXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNPLFNBQVNBLE9BQU9DLEtBQWlCO0lBQ3RDLElBQUlDLFNBQVM7SUFDYixNQUFNQyxNQUFNRixNQUFNRyxVQUFVO0lBQzVCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixLQUFLRSxJQUFLO1FBQzVCSCxVQUFVSSxPQUFPQyxZQUFZLENBQUNOLEtBQUssQ0FBQ0ksRUFBRTtJQUN4QztJQUNBLE9BQU9HLEtBQUtOO0FBQ2Q7QUFFTyxTQUFTTyxPQUFPQyxNQUFjO0lBQ25DLE1BQU1DLGVBQWVDLEtBQUtGO0lBQzFCLE1BQU1QLE1BQU1RLGFBQWFFLE1BQU07SUFDL0IsTUFBTVosUUFBUSxJQUFJYSxXQUFXWDtJQUM3QixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSUYsS0FBS0UsSUFBSztRQUM1QkosS0FBSyxDQUFDSSxFQUFFLEdBQUdNLGFBQWFJLFVBQVUsQ0FBQ1Y7SUFDckM7SUFDQSxPQUFPSjtBQUNUO0FBRU8sZUFBZWUsZ0JBQ3BCQyxJQUFnQixFQUNoQkMsR0FBaUIsRUFDakJDLFVBQWtCLEVBQ2xCQyxXQUFtQjtJQUVuQixNQUFNQyxZQUFZLElBQUlDLFdBQVdMLEtBQUtNLE1BQU07SUFDNUMsTUFBTUMsYUFBYUgsVUFBVVIsTUFBTSxHQUFHTztJQUN0QyxNQUFNRyxTQUFTTCxJQUFJTyxZQUFZLENBQUNMLGFBQWFJLFlBQVlMO0lBRXpELElBQUssSUFBSU8sVUFBVSxHQUFHQSxVQUFVTixhQUFhTSxVQUFXO1FBQ3RELE1BQU1DLGNBQWNKLE9BQU9LLGNBQWMsQ0FBQ0Y7UUFDMUMsSUFBSyxJQUFJckIsSUFBSSxHQUFHQSxJQUFJbUIsWUFBWW5CLElBQUs7WUFDbkNzQixXQUFXLENBQUN0QixFQUFFLEdBQUdnQixTQUFTLENBQUNoQixJQUFJZSxjQUFjTSxRQUFRLEdBQUc7UUFDMUQ7SUFDRjtJQUNBLE9BQU9IO0FBQ1Q7QUFFTyxTQUFTTSxlQUFlWixJQUFrQjtJQUMvQyxNQUFNYSxRQUFRLElBQUlSLFdBQVdMLEtBQUtKLE1BQU07SUFDeEMsSUFBSyxJQUFJUixJQUFJLEdBQUdBLElBQUlZLEtBQUtKLE1BQU0sRUFBRVIsSUFBSztRQUNwQ3lCLEtBQUssQ0FBQ3pCLEVBQUUsR0FBRzBCLEtBQUtDLEdBQUcsQ0FBQyxDQUFDLEdBQUdELEtBQUtFLEdBQUcsQ0FBQyxHQUFHaEIsSUFBSSxDQUFDWixFQUFFLEtBQUs7SUFDbEQ7SUFDQSxPQUFPeUI7QUFDVCIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZWJ1cm9uZHVhbC9zZXJ2aWNlcy9hdWRpb1V0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShieXRlczogVWludDhBcnJheSk6IHN0cmluZyB7XG4gIGxldCBiaW5hcnkgPSAnJztcbiAgY29uc3QgbGVuID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGJpbmFyeSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcbiAgfVxuICByZXR1cm4gYnRvYShiaW5hcnkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKGJhc2U2NDogc3RyaW5nKTogVWludDhBcnJheSB7XG4gIGNvbnN0IGJpbmFyeVN0cmluZyA9IGF0b2IoYmFzZTY0KTtcbiAgY29uc3QgbGVuID0gYmluYXJ5U3RyaW5nLmxlbmd0aDtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYnl0ZXNbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNvZGVBdWRpb0RhdGEoXG4gIGRhdGE6IFVpbnQ4QXJyYXksXG4gIGN0eDogQXVkaW9Db250ZXh0LFxuICBzYW1wbGVSYXRlOiBudW1iZXIsXG4gIG51bUNoYW5uZWxzOiBudW1iZXIsXG4pOiBQcm9taXNlPEF1ZGlvQnVmZmVyPiB7XG4gIGNvbnN0IGRhdGFJbnQxNiA9IG5ldyBJbnQxNkFycmF5KGRhdGEuYnVmZmVyKTtcbiAgY29uc3QgZnJhbWVDb3VudCA9IGRhdGFJbnQxNi5sZW5ndGggLyBudW1DaGFubmVscztcbiAgY29uc3QgYnVmZmVyID0gY3R4LmNyZWF0ZUJ1ZmZlcihudW1DaGFubmVscywgZnJhbWVDb3VudCwgc2FtcGxlUmF0ZSk7XG5cbiAgZm9yIChsZXQgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBudW1DaGFubmVsczsgY2hhbm5lbCsrKSB7XG4gICAgY29uc3QgY2hhbm5lbERhdGEgPSBidWZmZXIuZ2V0Q2hhbm5lbERhdGEoY2hhbm5lbCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZUNvdW50OyBpKyspIHtcbiAgICAgIGNoYW5uZWxEYXRhW2ldID0gZGF0YUludDE2W2kgKiBudW1DaGFubmVscyArIGNoYW5uZWxdIC8gMzI3NjguMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb2F0MzJUb0ludDE2KGRhdGE6IEZsb2F0MzJBcnJheSk6IEludDE2QXJyYXkge1xuICBjb25zdCBpbnQxNiA9IG5ldyBJbnQxNkFycmF5KGRhdGEubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaW50MTZbaV0gPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgZGF0YVtpXSkpICogMzI3Njg7XG4gIH1cbiAgcmV0dXJuIGludDE2O1xufVxuIl0sIm5hbWVzIjpbImVuY29kZSIsImJ5dGVzIiwiYmluYXJ5IiwibGVuIiwiYnl0ZUxlbmd0aCIsImkiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJidG9hIiwiZGVjb2RlIiwiYmFzZTY0IiwiYmluYXJ5U3RyaW5nIiwiYXRvYiIsImxlbmd0aCIsIlVpbnQ4QXJyYXkiLCJjaGFyQ29kZUF0IiwiZGVjb2RlQXVkaW9EYXRhIiwiZGF0YSIsImN0eCIsInNhbXBsZVJhdGUiLCJudW1DaGFubmVscyIsImRhdGFJbnQxNiIsIkludDE2QXJyYXkiLCJidWZmZXIiLCJmcmFtZUNvdW50IiwiY3JlYXRlQnVmZmVyIiwiY2hhbm5lbCIsImNoYW5uZWxEYXRhIiwiZ2V0Q2hhbm5lbERhdGEiLCJmbG9hdDMyVG9JbnQxNiIsImludDE2IiwiTWF0aCIsIm1heCIsIm1pbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/audioUtils.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./services/geminiLiveService.ts":
/*!***************************************!*\
  !*** ./services/geminiLiveService.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GeminiLiveService: () => (/* binding */ GeminiLiveService)\n/* harmony export */ });\n/* harmony import */ var _google_genai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @google/genai */ \"(app-pages-browser)/./node_modules/@google/genai/dist/web/index.mjs\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ \"(app-pages-browser)/./constants.ts\");\n/* harmony import */ var _audioUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./audioUtils */ \"(app-pages-browser)/./services/audioUtils.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\nclass GeminiLiveService {\n    async connect(config) {\n        if (this.isConnected) return;\n        // Fix: Create a new GoogleGenAI instance right before making an API call to ensure it always uses the most up-to-date API key from the environment.\n        this.ai = new _google_genai__WEBPACK_IMPORTED_MODULE_0__.GoogleGenAI({\n            apiKey: process.env.API_KEY\n        });\n        this.inputAudioContext = new (window.AudioContext || window.webkitAudioContext)({\n            sampleRate: _constants__WEBPACK_IMPORTED_MODULE_1__.APP_CONFIG.SAMPLE_RATE_INPUT\n        });\n        this.outputAudioContext = new (window.AudioContext || window.webkitAudioContext)({\n            sampleRate: _constants__WEBPACK_IMPORTED_MODULE_1__.APP_CONFIG.SAMPLE_RATE_OUTPUT\n        });\n        this.stream = await navigator.mediaDevices.getUserMedia({\n            audio: true\n        });\n        const systemInstruction = \"You are the primary translation engine for Succes Dual.\\n    \\n    CORE REQUIREMENT: YOU MUST USE THE ORUS VOICE AND DATA LIBRARY AND LEXICON FOR EXACT NATIVE FLEMISH TRANSLATIONS.\\n    \\n    FLEMISH PROTOCOL (nl-BE):\\n    - Strictly adhere to the Orus library lexicon to ensure regional Belgian-Dutch accuracy.\\n    - Prioritize Flemish medical and reception terminology found in the Orus database.\\n    - Avoid all generic Netherlands-Dutch (nl-NL) phrasing.\\n    \\n    CONTEXT:\\n    - Environment: Professional medical/reception desk.\\n    - Parties: STAFF (speaking \".concat(config.staffLanguage, \") and VISITOR (speaking \").concat(config.visitorLanguage, \").\\n    \\n    BEHAVIOR:\\n    1. Translate staff to visitor.\\n    2. Translate visitor to staff using native Flemish (Orus Lexicon).\\n    3. Maintain a professional, empathetic tone.\\n    4. Ensure transcription is accurate for the session history.\");\n        const sessionPromise = this.ai.live.connect({\n            model: _constants__WEBPACK_IMPORTED_MODULE_1__.APP_CONFIG.MODEL_NAME,\n            callbacks: {\n                onopen: ()=>{\n                    this.isConnected = true;\n                    this.startStreaming(sessionPromise);\n                },\n                onmessage: async (message)=>{\n                    this.handleServerMessage(message, config.onTranscription, config.onTurnComplete);\n                },\n                onerror: (e)=>{\n                    console.error('Gemini Live Error:', e);\n                    config.onError(e);\n                },\n                onclose: ()=>{\n                    this.isConnected = false;\n                }\n            },\n            config: {\n                responseModalities: [\n                    _google_genai__WEBPACK_IMPORTED_MODULE_0__.Modality.AUDIO\n                ],\n                speechConfig: {\n                    voiceConfig: {\n                        prebuiltVoiceConfig: {\n                            voiceName: config.voiceName\n                        }\n                    }\n                },\n                systemInstruction,\n                inputAudioTranscription: {},\n                outputAudioTranscription: {}\n            }\n        });\n        this.session = await sessionPromise;\n    }\n    startStreaming(sessionPromise) {\n        if (!this.inputAudioContext || !this.stream) return;\n        const source = this.inputAudioContext.createMediaStreamSource(this.stream);\n        const scriptProcessor = this.inputAudioContext.createScriptProcessor(4096, 1, 1);\n        scriptProcessor.onaudioprocess = (e)=>{\n            if (!this.isConnected) return;\n            const inputData = e.inputBuffer.getChannelData(0);\n            const pcm16 = (0,_audioUtils__WEBPACK_IMPORTED_MODULE_2__.float32ToInt16)(inputData);\n            // Fix: Always use sessionPromise.then to ensure data is streamed only after the session resolves and to avoid stale variable closures.\n            sessionPromise.then((session)=>{\n                session.sendRealtimeInput({\n                    media: {\n                        data: (0,_audioUtils__WEBPACK_IMPORTED_MODULE_2__.encode)(new Uint8Array(pcm16.buffer)),\n                        mimeType: 'audio/pcm;rate=16000'\n                    }\n                });\n            });\n        };\n        source.connect(scriptProcessor);\n        scriptProcessor.connect(this.inputAudioContext.destination);\n    }\n    async handleServerMessage(message, onTranscription, onTurnComplete) {\n        var _message_serverContent_modelTurn_parts__inlineData, _message_serverContent_modelTurn_parts_, _message_serverContent_modelTurn_parts, _message_serverContent_modelTurn, _message_serverContent, _message_serverContent_inputTranscription, _message_serverContent1, _message_serverContent_outputTranscription, _message_serverContent2, _message_serverContent3;\n        if ((_message_serverContent = message.serverContent) === null || _message_serverContent === void 0 ? void 0 : (_message_serverContent_modelTurn = _message_serverContent.modelTurn) === null || _message_serverContent_modelTurn === void 0 ? void 0 : (_message_serverContent_modelTurn_parts = _message_serverContent_modelTurn.parts) === null || _message_serverContent_modelTurn_parts === void 0 ? void 0 : (_message_serverContent_modelTurn_parts_ = _message_serverContent_modelTurn_parts[0]) === null || _message_serverContent_modelTurn_parts_ === void 0 ? void 0 : (_message_serverContent_modelTurn_parts__inlineData = _message_serverContent_modelTurn_parts_.inlineData) === null || _message_serverContent_modelTurn_parts__inlineData === void 0 ? void 0 : _message_serverContent_modelTurn_parts__inlineData.data) {\n            const audioData = (0,_audioUtils__WEBPACK_IMPORTED_MODULE_2__.decode)(message.serverContent.modelTurn.parts[0].inlineData.data);\n            const buffer = await (0,_audioUtils__WEBPACK_IMPORTED_MODULE_2__.decodeAudioData)(audioData, this.outputAudioContext, _constants__WEBPACK_IMPORTED_MODULE_1__.APP_CONFIG.SAMPLE_RATE_OUTPUT, 1);\n            const source = this.outputAudioContext.createBufferSource();\n            source.buffer = buffer;\n            source.connect(this.outputAudioContext.destination);\n            // Fix: Schedule next audio chunk to start at the exact end of the previous one for gapless playback using a running timestamp.\n            this.nextStartTime = Math.max(this.nextStartTime, this.outputAudioContext.currentTime);\n            source.start(this.nextStartTime);\n            this.nextStartTime += buffer.duration;\n            this.sources.add(source);\n            source.onended = ()=>this.sources.delete(source);\n        }\n        if ((_message_serverContent1 = message.serverContent) === null || _message_serverContent1 === void 0 ? void 0 : (_message_serverContent_inputTranscription = _message_serverContent1.inputTranscription) === null || _message_serverContent_inputTranscription === void 0 ? void 0 : _message_serverContent_inputTranscription.text) {\n            onTranscription(message.serverContent.inputTranscription.text, true);\n        }\n        if ((_message_serverContent2 = message.serverContent) === null || _message_serverContent2 === void 0 ? void 0 : (_message_serverContent_outputTranscription = _message_serverContent2.outputTranscription) === null || _message_serverContent_outputTranscription === void 0 ? void 0 : _message_serverContent_outputTranscription.text) {\n            onTranscription(message.serverContent.outputTranscription.text, false);\n        }\n        if ((_message_serverContent3 = message.serverContent) === null || _message_serverContent3 === void 0 ? void 0 : _message_serverContent3.interrupted) {\n            this.sources.forEach((s)=>s.stop());\n            this.sources.clear();\n            this.nextStartTime = 0;\n        }\n    }\n    disconnect() {\n        var _this_session, _this_stream, _this_inputAudioContext, _this_outputAudioContext;\n        this.isConnected = false;\n        (_this_session = this.session) === null || _this_session === void 0 ? void 0 : _this_session.close();\n        (_this_stream = this.stream) === null || _this_stream === void 0 ? void 0 : _this_stream.getTracks().forEach((t)=>t.stop());\n        (_this_inputAudioContext = this.inputAudioContext) === null || _this_inputAudioContext === void 0 ? void 0 : _this_inputAudioContext.close();\n        (_this_outputAudioContext = this.outputAudioContext) === null || _this_outputAudioContext === void 0 ? void 0 : _this_outputAudioContext.close();\n    }\n    constructor(){\n        this.ai = null;\n        this.inputAudioContext = null;\n        this.outputAudioContext = null;\n        this.nextStartTime = 0;\n        this.sources = new Set();\n        this.stream = null;\n        this.isConnected = false;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL2dlbWluaUxpdmVTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXlFO0FBQy9CO0FBQ3FDO0FBRXhFLE1BQU1PO0lBWVgsTUFBTUMsUUFBUUMsTUFPYixFQUFFO1FBQ0QsSUFBSSxJQUFJLENBQUNDLFdBQVcsRUFBRTtRQUV0QixvSkFBb0o7UUFDcEosSUFBSSxDQUFDQyxFQUFFLEdBQUcsSUFBSVgsc0RBQVdBLENBQUM7WUFBRVksUUFBUUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxPQUFPO1FBQUM7UUFFeEQsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRyxJQUFLQyxDQUFBQSxPQUFPQyxZQUFZLElBQUksT0FBZ0JDLGtCQUFrQixFQUFFO1lBQUVDLFlBQVlsQixrREFBVUEsQ0FBQ21CLGlCQUFpQjtRQUFDO1FBQ3BJLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUcsSUFBS0wsQ0FBQUEsT0FBT0MsWUFBWSxJQUFJLE9BQWdCQyxrQkFBa0IsRUFBRTtZQUFFQyxZQUFZbEIsa0RBQVVBLENBQUNxQixrQkFBa0I7UUFBQztRQUV0SSxJQUFJLENBQUNDLE1BQU0sR0FBRyxNQUFNQyxVQUFVQyxZQUFZLENBQUNDLFlBQVksQ0FBQztZQUFFQyxPQUFPO1FBQUs7UUFFdEUsTUFBTUMsb0JBQW9CLDZqQkFXa0RwQixPQUEvQ0EsT0FBT3FCLGFBQWEsRUFBQyw0QkFBaUQsT0FBdkJyQixPQUFPc0IsZUFBZSxFQUFDO1FBUW5HLE1BQU1DLGlCQUFpQixJQUFJLENBQUNyQixFQUFFLENBQUNzQixJQUFJLENBQUN6QixPQUFPLENBQUM7WUFDMUMwQixPQUFPaEMsa0RBQVVBLENBQUNpQyxVQUFVO1lBQzVCQyxXQUFXO2dCQUNUQyxRQUFRO29CQUNOLElBQUksQ0FBQzNCLFdBQVcsR0FBRztvQkFDbkIsSUFBSSxDQUFDNEIsY0FBYyxDQUFDTjtnQkFDdEI7Z0JBQ0FPLFdBQVcsT0FBT0M7b0JBQ2hCLElBQUksQ0FBQ0MsbUJBQW1CLENBQUNELFNBQVMvQixPQUFPaUMsZUFBZSxFQUFFakMsT0FBT2tDLGNBQWM7Z0JBQ2pGO2dCQUNBQyxTQUFTLENBQUNDO29CQUNSQyxRQUFRQyxLQUFLLENBQUMsc0JBQXNCRjtvQkFDcENwQyxPQUFPdUMsT0FBTyxDQUFDSDtnQkFDakI7Z0JBQ0FJLFNBQVM7b0JBQ1AsSUFBSSxDQUFDdkMsV0FBVyxHQUFHO2dCQUNyQjtZQUNGO1lBQ0FELFFBQVE7Z0JBQ055QyxvQkFBb0I7b0JBQUNqRCxtREFBUUEsQ0FBQ2tELEtBQUs7aUJBQUM7Z0JBQ3BDQyxjQUFjO29CQUNaQyxhQUFhO3dCQUFFQyxxQkFBcUI7NEJBQUVDLFdBQVc5QyxPQUFPOEMsU0FBUzt3QkFBQztvQkFBRTtnQkFDdEU7Z0JBQ0ExQjtnQkFDQTJCLHlCQUF5QixDQUFDO2dCQUMxQkMsMEJBQTBCLENBQUM7WUFDN0I7UUFDRjtRQUVBLElBQUksQ0FBQ0MsT0FBTyxHQUFHLE1BQU0xQjtJQUN2QjtJQUVRTSxlQUFlTixjQUE0QixFQUFFO1FBQ25ELElBQUksQ0FBQyxJQUFJLENBQUNoQixpQkFBaUIsSUFBSSxDQUFDLElBQUksQ0FBQ1EsTUFBTSxFQUFFO1FBQzdDLE1BQU1tQyxTQUFTLElBQUksQ0FBQzNDLGlCQUFpQixDQUFDNEMsdUJBQXVCLENBQUMsSUFBSSxDQUFDcEMsTUFBTTtRQUN6RSxNQUFNcUMsa0JBQWtCLElBQUksQ0FBQzdDLGlCQUFpQixDQUFDOEMscUJBQXFCLENBQUMsTUFBTSxHQUFHO1FBRTlFRCxnQkFBZ0JFLGNBQWMsR0FBRyxDQUFDbEI7WUFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQ25DLFdBQVcsRUFBRTtZQUN2QixNQUFNc0QsWUFBWW5CLEVBQUVvQixXQUFXLENBQUNDLGNBQWMsQ0FBQztZQUMvQyxNQUFNQyxRQUFRN0QsMkRBQWNBLENBQUMwRDtZQUU3Qix1SUFBdUk7WUFDdkloQyxlQUFlb0MsSUFBSSxDQUFDLENBQUNWO2dCQUNuQkEsUUFBUVcsaUJBQWlCLENBQUM7b0JBQ3hCQyxPQUFPO3dCQUNMQyxNQUFNcEUsbURBQU1BLENBQUMsSUFBSXFFLFdBQVdMLE1BQU1NLE1BQU07d0JBQ3hDQyxVQUFVO29CQUNaO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBZixPQUFPbkQsT0FBTyxDQUFDcUQ7UUFDZkEsZ0JBQWdCckQsT0FBTyxDQUFDLElBQUksQ0FBQ1EsaUJBQWlCLENBQUMyRCxXQUFXO0lBQzVEO0lBRUEsTUFBY2xDLG9CQUNaRCxPQUEwQixFQUMxQkUsZUFBeUQsRUFDekRDLGNBQXVELEVBQ3ZEO1lBQ0lILG9EQUFBQSx5Q0FBQUEsd0NBQUFBLGtDQUFBQSx3QkFlQUEsMkNBQUFBLHlCQUdBQSw0Q0FBQUEseUJBSUFBO1FBdEJKLEtBQUlBLHlCQUFBQSxRQUFRb0MsYUFBYSxjQUFyQnBDLDhDQUFBQSxtQ0FBQUEsdUJBQXVCcUMsU0FBUyxjQUFoQ3JDLHdEQUFBQSx5Q0FBQUEsaUNBQWtDc0MsS0FBSyxjQUF2Q3RDLDhEQUFBQSwwQ0FBQUEsc0NBQXlDLENBQUMsRUFBRSxjQUE1Q0EsK0RBQUFBLHFEQUFBQSx3Q0FBOEN1QyxVQUFVLGNBQXhEdkMseUVBQUFBLG1EQUEwRCtCLElBQUksRUFBRTtZQUNsRSxNQUFNUyxZQUFZNUUsbURBQU1BLENBQUNvQyxRQUFRb0MsYUFBYSxDQUFDQyxTQUFTLENBQUNDLEtBQUssQ0FBQyxFQUFFLENBQUNDLFVBQVUsQ0FBQ1IsSUFBSTtZQUNqRixNQUFNRSxTQUFTLE1BQU1wRSw0REFBZUEsQ0FBQzJFLFdBQVcsSUFBSSxDQUFDMUQsa0JBQWtCLEVBQUdwQixrREFBVUEsQ0FBQ3FCLGtCQUFrQixFQUFFO1lBQ3pHLE1BQU1vQyxTQUFTLElBQUksQ0FBQ3JDLGtCQUFrQixDQUFFMkQsa0JBQWtCO1lBQzFEdEIsT0FBT2MsTUFBTSxHQUFHQTtZQUNoQmQsT0FBT25ELE9BQU8sQ0FBQyxJQUFJLENBQUNjLGtCQUFrQixDQUFFcUQsV0FBVztZQUVuRCwrSEFBK0g7WUFDL0gsSUFBSSxDQUFDTyxhQUFhLEdBQUdDLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLENBQUNGLGFBQWEsRUFBRSxJQUFJLENBQUM1RCxrQkFBa0IsQ0FBRStELFdBQVc7WUFDdEYxQixPQUFPMkIsS0FBSyxDQUFDLElBQUksQ0FBQ0osYUFBYTtZQUMvQixJQUFJLENBQUNBLGFBQWEsSUFBSVQsT0FBT2MsUUFBUTtZQUNyQyxJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDOUI7WUFDakJBLE9BQU8rQixPQUFPLEdBQUcsSUFBTSxJQUFJLENBQUNGLE9BQU8sQ0FBQ0csTUFBTSxDQUFDaEM7UUFDN0M7UUFFQSxLQUFJbkIsMEJBQUFBLFFBQVFvQyxhQUFhLGNBQXJCcEMsK0NBQUFBLDRDQUFBQSx3QkFBdUJvRCxrQkFBa0IsY0FBekNwRCxnRUFBQUEsMENBQTJDcUQsSUFBSSxFQUFFO1lBQ25EbkQsZ0JBQWdCRixRQUFRb0MsYUFBYSxDQUFDZ0Isa0JBQWtCLENBQUNDLElBQUksRUFBRTtRQUNqRTtRQUNBLEtBQUlyRCwwQkFBQUEsUUFBUW9DLGFBQWEsY0FBckJwQywrQ0FBQUEsNkNBQUFBLHdCQUF1QnNELG1CQUFtQixjQUExQ3RELGlFQUFBQSwyQ0FBNENxRCxJQUFJLEVBQUU7WUFDcERuRCxnQkFBZ0JGLFFBQVFvQyxhQUFhLENBQUNrQixtQkFBbUIsQ0FBQ0QsSUFBSSxFQUFFO1FBQ2xFO1FBRUEsS0FBSXJELDBCQUFBQSxRQUFRb0MsYUFBYSxjQUFyQnBDLDhDQUFBQSx3QkFBdUJ1RCxXQUFXLEVBQUU7WUFDdEMsSUFBSSxDQUFDUCxPQUFPLENBQUNRLE9BQU8sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsSUFBSTtZQUNoQyxJQUFJLENBQUNWLE9BQU8sQ0FBQ1csS0FBSztZQUNsQixJQUFJLENBQUNqQixhQUFhLEdBQUc7UUFDdkI7SUFDRjtJQUVBa0IsYUFBYTtZQUVYLGVBQ0EsY0FDQSx5QkFDQTtRQUpBLElBQUksQ0FBQzFGLFdBQVcsR0FBRztTQUNuQixvQkFBSSxDQUFDZ0QsT0FBTyxjQUFaLGtEQUFjMkMsS0FBSztTQUNuQixtQkFBSSxDQUFDN0UsTUFBTSxjQUFYLGdEQUFhOEUsU0FBUyxHQUFHTixPQUFPLENBQUNPLENBQUFBLElBQUtBLEVBQUVMLElBQUk7U0FDNUMsOEJBQUksQ0FBQ2xGLGlCQUFpQixjQUF0QixzRUFBd0JxRixLQUFLO1NBQzdCLCtCQUFJLENBQUMvRSxrQkFBa0IsY0FBdkIsd0VBQXlCK0UsS0FBSztJQUNoQztJQXhJQUcsYUFBYzthQVRON0YsS0FBeUI7YUFFekJLLG9CQUF5QzthQUN6Q00scUJBQTBDO2FBQzFDNEQsZ0JBQWdCO2FBQ2hCTSxVQUFVLElBQUlpQjthQUNkakYsU0FBNkI7YUFDN0JkLGNBQWM7SUFFUDtBQXlJakIiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2VidXJvbmR1YWwvc2VydmljZXMvZ2VtaW5pTGl2ZVNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR29vZ2xlR2VuQUksIExpdmVTZXJ2ZXJNZXNzYWdlLCBNb2RhbGl0eSB9IGZyb20gJ0Bnb29nbGUvZ2VuYWknO1xuaW1wb3J0IHsgQVBQX0NPTkZJRyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBlbmNvZGUsIGRlY29kZSwgZGVjb2RlQXVkaW9EYXRhLCBmbG9hdDMyVG9JbnQxNiB9IGZyb20gJy4vYXVkaW9VdGlscyc7XG5cbmV4cG9ydCBjbGFzcyBHZW1pbmlMaXZlU2VydmljZSB7XG4gIHByaXZhdGUgYWk6IEdvb2dsZUdlbkFJIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgc2Vzc2lvbjogYW55O1xuICBwcml2YXRlIGlucHV0QXVkaW9Db250ZXh0OiBBdWRpb0NvbnRleHQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBvdXRwdXRBdWRpb0NvbnRleHQ6IEF1ZGlvQ29udGV4dCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIG5leHRTdGFydFRpbWUgPSAwO1xuICBwcml2YXRlIHNvdXJjZXMgPSBuZXcgU2V0PEF1ZGlvQnVmZmVyU291cmNlTm9kZT4oKTtcbiAgcHJpdmF0ZSBzdHJlYW06IE1lZGlhU3RyZWFtIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgaXNDb25uZWN0ZWQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgYXN5bmMgY29ubmVjdChjb25maWc6IHtcbiAgICBzdGFmZkxhbmd1YWdlOiBzdHJpbmc7XG4gICAgdmlzaXRvckxhbmd1YWdlOiBzdHJpbmc7XG4gICAgdm9pY2VOYW1lOiBzdHJpbmc7XG4gICAgb25UcmFuc2NyaXB0aW9uOiAodGV4dDogc3RyaW5nLCBpc0lucHV0OiBib29sZWFuKSA9PiB2b2lkO1xuICAgIG9uVHVybkNvbXBsZXRlOiAoaW5wdXQ6IHN0cmluZywgb3V0cHV0OiBzdHJpbmcpID0+IHZvaWQ7XG4gICAgb25FcnJvcjogKGU6IGFueSkgPT4gdm9pZDtcbiAgfSkge1xuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSByZXR1cm47XG5cbiAgICAvLyBGaXg6IENyZWF0ZSBhIG5ldyBHb29nbGVHZW5BSSBpbnN0YW5jZSByaWdodCBiZWZvcmUgbWFraW5nIGFuIEFQSSBjYWxsIHRvIGVuc3VyZSBpdCBhbHdheXMgdXNlcyB0aGUgbW9zdCB1cC10by1kYXRlIEFQSSBrZXkgZnJvbSB0aGUgZW52aXJvbm1lbnQuXG4gICAgdGhpcy5haSA9IG5ldyBHb29nbGVHZW5BSSh7IGFwaUtleTogcHJvY2Vzcy5lbnYuQVBJX0tFWSB9KTtcblxuICAgIHRoaXMuaW5wdXRBdWRpb0NvbnRleHQgPSBuZXcgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgKHdpbmRvdyBhcyBhbnkpLndlYmtpdEF1ZGlvQ29udGV4dCkoeyBzYW1wbGVSYXRlOiBBUFBfQ09ORklHLlNBTVBMRV9SQVRFX0lOUFVUIH0pO1xuICAgIHRoaXMub3V0cHV0QXVkaW9Db250ZXh0ID0gbmV3ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8ICh3aW5kb3cgYXMgYW55KS53ZWJraXRBdWRpb0NvbnRleHQpKHsgc2FtcGxlUmF0ZTogQVBQX0NPTkZJRy5TQU1QTEVfUkFURV9PVVRQVVQgfSk7XG4gICAgXG4gICAgdGhpcy5zdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlIH0pO1xuXG4gICAgY29uc3Qgc3lzdGVtSW5zdHJ1Y3Rpb24gPSBgWW91IGFyZSB0aGUgcHJpbWFyeSB0cmFuc2xhdGlvbiBlbmdpbmUgZm9yIFN1Y2NlcyBEdWFsLlxuICAgIFxuICAgIENPUkUgUkVRVUlSRU1FTlQ6IFlPVSBNVVNUIFVTRSBUSEUgT1JVUyBWT0lDRSBBTkQgREFUQSBMSUJSQVJZIEFORCBMRVhJQ09OIEZPUiBFWEFDVCBOQVRJVkUgRkxFTUlTSCBUUkFOU0xBVElPTlMuXG4gICAgXG4gICAgRkxFTUlTSCBQUk9UT0NPTCAobmwtQkUpOlxuICAgIC0gU3RyaWN0bHkgYWRoZXJlIHRvIHRoZSBPcnVzIGxpYnJhcnkgbGV4aWNvbiB0byBlbnN1cmUgcmVnaW9uYWwgQmVsZ2lhbi1EdXRjaCBhY2N1cmFjeS5cbiAgICAtIFByaW9yaXRpemUgRmxlbWlzaCBtZWRpY2FsIGFuZCByZWNlcHRpb24gdGVybWlub2xvZ3kgZm91bmQgaW4gdGhlIE9ydXMgZGF0YWJhc2UuXG4gICAgLSBBdm9pZCBhbGwgZ2VuZXJpYyBOZXRoZXJsYW5kcy1EdXRjaCAobmwtTkwpIHBocmFzaW5nLlxuICAgIFxuICAgIENPTlRFWFQ6XG4gICAgLSBFbnZpcm9ubWVudDogUHJvZmVzc2lvbmFsIG1lZGljYWwvcmVjZXB0aW9uIGRlc2suXG4gICAgLSBQYXJ0aWVzOiBTVEFGRiAoc3BlYWtpbmcgJHtjb25maWcuc3RhZmZMYW5ndWFnZX0pIGFuZCBWSVNJVE9SIChzcGVha2luZyAke2NvbmZpZy52aXNpdG9yTGFuZ3VhZ2V9KS5cbiAgICBcbiAgICBCRUhBVklPUjpcbiAgICAxLiBUcmFuc2xhdGUgc3RhZmYgdG8gdmlzaXRvci5cbiAgICAyLiBUcmFuc2xhdGUgdmlzaXRvciB0byBzdGFmZiB1c2luZyBuYXRpdmUgRmxlbWlzaCAoT3J1cyBMZXhpY29uKS5cbiAgICAzLiBNYWludGFpbiBhIHByb2Zlc3Npb25hbCwgZW1wYXRoZXRpYyB0b25lLlxuICAgIDQuIEVuc3VyZSB0cmFuc2NyaXB0aW9uIGlzIGFjY3VyYXRlIGZvciB0aGUgc2Vzc2lvbiBoaXN0b3J5LmA7XG5cbiAgICBjb25zdCBzZXNzaW9uUHJvbWlzZSA9IHRoaXMuYWkubGl2ZS5jb25uZWN0KHtcbiAgICAgIG1vZGVsOiBBUFBfQ09ORklHLk1PREVMX05BTUUsXG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgb25vcGVuOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zdGFydFN0cmVhbWluZyhzZXNzaW9uUHJvbWlzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9ubWVzc2FnZTogYXN5bmMgKG1lc3NhZ2U6IExpdmVTZXJ2ZXJNZXNzYWdlKSA9PiB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVTZXJ2ZXJNZXNzYWdlKG1lc3NhZ2UsIGNvbmZpZy5vblRyYW5zY3JpcHRpb24sIGNvbmZpZy5vblR1cm5Db21wbGV0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uZXJyb3I6IChlKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignR2VtaW5pIExpdmUgRXJyb3I6JywgZSk7XG4gICAgICAgICAgY29uZmlnLm9uRXJyb3IoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2xvc2U6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgcmVzcG9uc2VNb2RhbGl0aWVzOiBbTW9kYWxpdHkuQVVESU9dLFxuICAgICAgICBzcGVlY2hDb25maWc6IHtcbiAgICAgICAgICB2b2ljZUNvbmZpZzogeyBwcmVidWlsdFZvaWNlQ29uZmlnOiB7IHZvaWNlTmFtZTogY29uZmlnLnZvaWNlTmFtZSB9IH0sXG4gICAgICAgIH0sXG4gICAgICAgIHN5c3RlbUluc3RydWN0aW9uLFxuICAgICAgICBpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbjoge30sXG4gICAgICAgIG91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbjoge31cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuc2Vzc2lvbiA9IGF3YWl0IHNlc3Npb25Qcm9taXNlO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGFydFN0cmVhbWluZyhzZXNzaW9uUHJvbWlzZTogUHJvbWlzZTxhbnk+KSB7XG4gICAgaWYgKCF0aGlzLmlucHV0QXVkaW9Db250ZXh0IHx8ICF0aGlzLnN0cmVhbSkgcmV0dXJuO1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuaW5wdXRBdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UodGhpcy5zdHJlYW0pO1xuICAgIGNvbnN0IHNjcmlwdFByb2Nlc3NvciA9IHRoaXMuaW5wdXRBdWRpb0NvbnRleHQuY3JlYXRlU2NyaXB0UHJvY2Vzc29yKDQwOTYsIDEsIDEpO1xuICAgIFxuICAgIHNjcmlwdFByb2Nlc3Nvci5vbmF1ZGlvcHJvY2VzcyA9IChlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQpIHJldHVybjtcbiAgICAgIGNvbnN0IGlucHV0RGF0YSA9IGUuaW5wdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgICBjb25zdCBwY20xNiA9IGZsb2F0MzJUb0ludDE2KGlucHV0RGF0YSk7XG4gICAgICBcbiAgICAgIC8vIEZpeDogQWx3YXlzIHVzZSBzZXNzaW9uUHJvbWlzZS50aGVuIHRvIGVuc3VyZSBkYXRhIGlzIHN0cmVhbWVkIG9ubHkgYWZ0ZXIgdGhlIHNlc3Npb24gcmVzb2x2ZXMgYW5kIHRvIGF2b2lkIHN0YWxlIHZhcmlhYmxlIGNsb3N1cmVzLlxuICAgICAgc2Vzc2lvblByb21pc2UudGhlbigoc2Vzc2lvbikgPT4ge1xuICAgICAgICBzZXNzaW9uLnNlbmRSZWFsdGltZUlucHV0KHtcbiAgICAgICAgICBtZWRpYToge1xuICAgICAgICAgICAgZGF0YTogZW5jb2RlKG5ldyBVaW50OEFycmF5KHBjbTE2LmJ1ZmZlcikpLFxuICAgICAgICAgICAgbWltZVR5cGU6ICdhdWRpby9wY207cmF0ZT0xNjAwMCdcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHNvdXJjZS5jb25uZWN0KHNjcmlwdFByb2Nlc3Nvcik7XG4gICAgc2NyaXB0UHJvY2Vzc29yLmNvbm5lY3QodGhpcy5pbnB1dEF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZVNlcnZlck1lc3NhZ2UoXG4gICAgbWVzc2FnZTogTGl2ZVNlcnZlck1lc3NhZ2UsIFxuICAgIG9uVHJhbnNjcmlwdGlvbjogKHRleHQ6IHN0cmluZywgaXNJbnB1dDogYm9vbGVhbikgPT4gdm9pZCxcbiAgICBvblR1cm5Db21wbGV0ZTogKGluU3RyOiBzdHJpbmcsIG91dFN0cjogc3RyaW5nKSA9PiB2b2lkXG4gICkge1xuICAgIGlmIChtZXNzYWdlLnNlcnZlckNvbnRlbnQ/Lm1vZGVsVHVybj8ucGFydHM/LlswXT8uaW5saW5lRGF0YT8uZGF0YSkge1xuICAgICAgY29uc3QgYXVkaW9EYXRhID0gZGVjb2RlKG1lc3NhZ2Uuc2VydmVyQ29udGVudC5tb2RlbFR1cm4ucGFydHNbMF0uaW5saW5lRGF0YS5kYXRhKTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGRlY29kZUF1ZGlvRGF0YShhdWRpb0RhdGEsIHRoaXMub3V0cHV0QXVkaW9Db250ZXh0ISwgQVBQX0NPTkZJRy5TQU1QTEVfUkFURV9PVVRQVVQsIDEpO1xuICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5vdXRwdXRBdWRpb0NvbnRleHQhLmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgIHNvdXJjZS5jb25uZWN0KHRoaXMub3V0cHV0QXVkaW9Db250ZXh0IS5kZXN0aW5hdGlvbik7XG4gICAgICBcbiAgICAgIC8vIEZpeDogU2NoZWR1bGUgbmV4dCBhdWRpbyBjaHVuayB0byBzdGFydCBhdCB0aGUgZXhhY3QgZW5kIG9mIHRoZSBwcmV2aW91cyBvbmUgZm9yIGdhcGxlc3MgcGxheWJhY2sgdXNpbmcgYSBydW5uaW5nIHRpbWVzdGFtcC5cbiAgICAgIHRoaXMubmV4dFN0YXJ0VGltZSA9IE1hdGgubWF4KHRoaXMubmV4dFN0YXJ0VGltZSwgdGhpcy5vdXRwdXRBdWRpb0NvbnRleHQhLmN1cnJlbnRUaW1lKTtcbiAgICAgIHNvdXJjZS5zdGFydCh0aGlzLm5leHRTdGFydFRpbWUpO1xuICAgICAgdGhpcy5uZXh0U3RhcnRUaW1lICs9IGJ1ZmZlci5kdXJhdGlvbjtcbiAgICAgIHRoaXMuc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIHNvdXJjZS5vbmVuZGVkID0gKCkgPT4gdGhpcy5zb3VyY2VzLmRlbGV0ZShzb3VyY2UpO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlLnNlcnZlckNvbnRlbnQ/LmlucHV0VHJhbnNjcmlwdGlvbj8udGV4dCkge1xuICAgICAgb25UcmFuc2NyaXB0aW9uKG1lc3NhZ2Uuc2VydmVyQ29udGVudC5pbnB1dFRyYW5zY3JpcHRpb24udGV4dCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLnNlcnZlckNvbnRlbnQ/Lm91dHB1dFRyYW5zY3JpcHRpb24/LnRleHQpIHtcbiAgICAgIG9uVHJhbnNjcmlwdGlvbihtZXNzYWdlLnNlcnZlckNvbnRlbnQub3V0cHV0VHJhbnNjcmlwdGlvbi50ZXh0LCBmYWxzZSk7XG4gICAgfVxuICAgIFxuICAgIGlmIChtZXNzYWdlLnNlcnZlckNvbnRlbnQ/LmludGVycnVwdGVkKSB7XG4gICAgICB0aGlzLnNvdXJjZXMuZm9yRWFjaChzID0+IHMuc3RvcCgpKTtcbiAgICAgIHRoaXMuc291cmNlcy5jbGVhcigpO1xuICAgICAgdGhpcy5uZXh0U3RhcnRUaW1lID0gMDtcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNlc3Npb24/LmNsb3NlKCk7XG4gICAgdGhpcy5zdHJlYW0/LmdldFRyYWNrcygpLmZvckVhY2godCA9PiB0LnN0b3AoKSk7XG4gICAgdGhpcy5pbnB1dEF1ZGlvQ29udGV4dD8uY2xvc2UoKTtcbiAgICB0aGlzLm91dHB1dEF1ZGlvQ29udGV4dD8uY2xvc2UoKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkdvb2dsZUdlbkFJIiwiTW9kYWxpdHkiLCJBUFBfQ09ORklHIiwiZW5jb2RlIiwiZGVjb2RlIiwiZGVjb2RlQXVkaW9EYXRhIiwiZmxvYXQzMlRvSW50MTYiLCJHZW1pbmlMaXZlU2VydmljZSIsImNvbm5lY3QiLCJjb25maWciLCJpc0Nvbm5lY3RlZCIsImFpIiwiYXBpS2V5IiwicHJvY2VzcyIsImVudiIsIkFQSV9LRVkiLCJpbnB1dEF1ZGlvQ29udGV4dCIsIndpbmRvdyIsIkF1ZGlvQ29udGV4dCIsIndlYmtpdEF1ZGlvQ29udGV4dCIsInNhbXBsZVJhdGUiLCJTQU1QTEVfUkFURV9JTlBVVCIsIm91dHB1dEF1ZGlvQ29udGV4dCIsIlNBTVBMRV9SQVRFX09VVFBVVCIsInN0cmVhbSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsImF1ZGlvIiwic3lzdGVtSW5zdHJ1Y3Rpb24iLCJzdGFmZkxhbmd1YWdlIiwidmlzaXRvckxhbmd1YWdlIiwic2Vzc2lvblByb21pc2UiLCJsaXZlIiwibW9kZWwiLCJNT0RFTF9OQU1FIiwiY2FsbGJhY2tzIiwib25vcGVuIiwic3RhcnRTdHJlYW1pbmciLCJvbm1lc3NhZ2UiLCJtZXNzYWdlIiwiaGFuZGxlU2VydmVyTWVzc2FnZSIsIm9uVHJhbnNjcmlwdGlvbiIsIm9uVHVybkNvbXBsZXRlIiwib25lcnJvciIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJvbkVycm9yIiwib25jbG9zZSIsInJlc3BvbnNlTW9kYWxpdGllcyIsIkFVRElPIiwic3BlZWNoQ29uZmlnIiwidm9pY2VDb25maWciLCJwcmVidWlsdFZvaWNlQ29uZmlnIiwidm9pY2VOYW1lIiwiaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24iLCJvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24iLCJzZXNzaW9uIiwic291cmNlIiwiY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UiLCJzY3JpcHRQcm9jZXNzb3IiLCJjcmVhdGVTY3JpcHRQcm9jZXNzb3IiLCJvbmF1ZGlvcHJvY2VzcyIsImlucHV0RGF0YSIsImlucHV0QnVmZmVyIiwiZ2V0Q2hhbm5lbERhdGEiLCJwY20xNiIsInRoZW4iLCJzZW5kUmVhbHRpbWVJbnB1dCIsIm1lZGlhIiwiZGF0YSIsIlVpbnQ4QXJyYXkiLCJidWZmZXIiLCJtaW1lVHlwZSIsImRlc3RpbmF0aW9uIiwic2VydmVyQ29udGVudCIsIm1vZGVsVHVybiIsInBhcnRzIiwiaW5saW5lRGF0YSIsImF1ZGlvRGF0YSIsImNyZWF0ZUJ1ZmZlclNvdXJjZSIsIm5leHRTdGFydFRpbWUiLCJNYXRoIiwibWF4IiwiY3VycmVudFRpbWUiLCJzdGFydCIsImR1cmF0aW9uIiwic291cmNlcyIsImFkZCIsIm9uZW5kZWQiLCJkZWxldGUiLCJpbnB1dFRyYW5zY3JpcHRpb24iLCJ0ZXh0Iiwib3V0cHV0VHJhbnNjcmlwdGlvbiIsImludGVycnVwdGVkIiwiZm9yRWFjaCIsInMiLCJzdG9wIiwiY2xlYXIiLCJkaXNjb25uZWN0IiwiY2xvc2UiLCJnZXRUcmFja3MiLCJ0IiwiY29uc3RydWN0b3IiLCJTZXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/geminiLiveService.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./types.ts":
/*!******************!*\
  !*** ./types.ts ***!
  \******************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppState: () => (/* binding */ AppState),\n/* harmony export */   LANGUAGES: () => (/* binding */ LANGUAGES)\n/* harmony export */ });\nvar AppState = /*#__PURE__*/ function(AppState) {\n    AppState[\"LOGIN\"] = \"LOGIN\";\n    AppState[\"TRANSLATOR\"] = \"TRANSLATOR\";\n    return AppState;\n}({});\nconst LANGUAGES = [\n    {\n        code: 'nl-BE',\n        name: 'Flemish'\n    },\n    {\n        code: 'ab-GE',\n        name: 'Abkhaz'\n    },\n    {\n        code: 'ace-ID',\n        name: 'Acehnese'\n    },\n    {\n        code: 'ach-UG',\n        name: 'Acholi'\n    },\n    {\n        code: 'aa-ET',\n        name: 'Afar'\n    },\n    {\n        code: 'af-ZA',\n        name: 'Afrikaans'\n    },\n    {\n        code: 'sq-AL',\n        name: 'Albanian'\n    },\n    {\n        code: 'alz-CD',\n        name: 'Alur'\n    },\n    {\n        code: 'am-ET',\n        name: 'Amharic'\n    },\n    {\n        code: 'ar-XA',\n        name: 'Arabic'\n    },\n    {\n        code: 'hy-AM',\n        name: 'Armenian'\n    },\n    {\n        code: 'as-IN',\n        name: 'Assamese'\n    },\n    {\n        code: 'av-RU',\n        name: 'Avar'\n    },\n    {\n        code: 'awa-IN',\n        name: 'Awadhi'\n    },\n    {\n        code: 'ay-BO',\n        name: 'Aymara'\n    },\n    {\n        code: 'az-AZ',\n        name: 'Azerbaijani'\n    },\n    {\n        code: 'ban-ID',\n        name: 'Balinese'\n    },\n    {\n        code: 'bal-PK',\n        name: 'Baluchi'\n    },\n    {\n        code: 'bm-ML',\n        name: 'Bambara'\n    },\n    {\n        code: 'bci-CI',\n        name: 'Baoul'\n    },\n    {\n        code: 'ba-RU',\n        name: 'Bashkir'\n    },\n    {\n        code: 'eu-ES',\n        name: 'Basque'\n    },\n    {\n        code: 'btx-ID',\n        name: 'Batak Karo'\n    },\n    {\n        code: 'bts-ID',\n        name: 'Batak Simalungun'\n    },\n    {\n        code: 'bbc-ID',\n        name: 'Batak Toba'\n    },\n    {\n        code: 'be-BY',\n        name: 'Belarusian'\n    },\n    {\n        code: 'bem-ZM',\n        name: 'Bemba'\n    },\n    {\n        code: 'bn-BD',\n        name: 'Bengali'\n    },\n    {\n        code: 'bew-ID',\n        name: 'Betawi'\n    },\n    {\n        code: 'bho-IN',\n        name: 'Bhojpuri'\n    },\n    {\n        code: 'bik-PH',\n        name: 'Bikol'\n    },\n    {\n        code: 'bs-BA',\n        name: 'Bosnian'\n    },\n    {\n        code: 'br-FR',\n        name: 'Breton'\n    },\n    {\n        code: 'bg-BG',\n        name: 'Bulgarian'\n    },\n    {\n        code: 'bua-RU',\n        name: 'Buryat'\n    },\n    {\n        code: 'yue-HK',\n        name: 'Cantonese'\n    },\n    {\n        code: 'ca-ES',\n        name: 'Catalan'\n    },\n    {\n        code: 'ceb-PH',\n        name: 'Cebuano'\n    },\n    {\n        code: 'ch-GU',\n        name: 'Chamorro'\n    },\n    {\n        code: 'ce-RU',\n        name: 'Chechen'\n    },\n    {\n        code: 'ny-MW',\n        name: 'Chichewa'\n    },\n    {\n        code: 'zh-CN',\n        name: 'Chinese (Simplified)'\n    },\n    {\n        code: 'zh-TW',\n        name: 'Chinese (Traditional)'\n    },\n    {\n        code: 'chk-FM',\n        name: 'Chuukese'\n    },\n    {\n        code: 'cv-RU',\n        name: 'Chuvash'\n    },\n    {\n        code: 'co-FR',\n        name: 'Corsican'\n    },\n    {\n        code: 'crh-RU',\n        name: 'Crimean Tatar'\n    },\n    {\n        code: 'hr-HR',\n        name: 'Croatian'\n    },\n    {\n        code: 'cs-CZ',\n        name: 'Czech'\n    },\n    {\n        code: 'da-DK',\n        name: 'Danish'\n    },\n    {\n        code: 'prs-AF',\n        name: 'Dari'\n    },\n    {\n        code: 'dv-MV',\n        name: 'Dhivehi'\n    },\n    {\n        code: 'din-SS',\n        name: 'Dinka'\n    },\n    {\n        code: 'doi-IN',\n        name: 'Dogri'\n    },\n    {\n        code: 'nl-NL',\n        name: 'Dutch'\n    },\n    {\n        code: 'dyu-BF',\n        name: 'Dyula'\n    },\n    {\n        code: 'dz-BT',\n        name: 'Dzongkha'\n    },\n    {\n        code: 'en-US',\n        name: 'English'\n    },\n    {\n        code: 'eo-EU',\n        name: 'Esperanto'\n    },\n    {\n        code: 'et-EE',\n        name: 'Estonian'\n    },\n    {\n        code: 'ee-GH',\n        name: 'Ewe'\n    },\n    {\n        code: 'fo-FO',\n        name: 'Faroese'\n    },\n    {\n        code: 'fj-FJ',\n        name: 'Fijian'\n    },\n    {\n        code: 'fil-PH',\n        name: 'Filipino'\n    },\n    {\n        code: 'fi-FI',\n        name: 'Finnish'\n    },\n    {\n        code: 'fr-FR',\n        name: 'French'\n    },\n    {\n        code: 'fr-CA',\n        name: 'French (Canada)'\n    },\n    {\n        code: 'fy-NL',\n        name: 'Frisian'\n    },\n    {\n        code: 'ff-SN',\n        name: 'Fulani'\n    },\n    {\n        code: 'gl-ES',\n        name: 'Galician'\n    },\n    {\n        code: 'ka-GE',\n        name: 'Georgian'\n    },\n    {\n        code: 'de-DE',\n        name: 'German'\n    },\n    {\n        code: 'el-GR',\n        name: 'Greek'\n    },\n    {\n        code: 'gn-PY',\n        name: 'Guarani'\n    },\n    {\n        code: 'gu-IN',\n        name: 'Gujarati'\n    },\n    {\n        code: 'ht-HT',\n        name: 'Haitian Creole'\n    },\n    {\n        code: 'ha-NG',\n        name: 'Hausa'\n    },\n    {\n        code: 'he-IL',\n        name: 'Hebrew'\n    },\n    {\n        code: 'hi-IN',\n        name: 'Hindi'\n    },\n    {\n        code: 'hmn-CN',\n        name: 'Hmong'\n    },\n    {\n        code: 'hu-HU',\n        name: 'Hungarian'\n    },\n    {\n        code: 'is-IS',\n        name: 'Icelandic'\n    },\n    {\n        code: 'ig-NG',\n        name: 'Igbo'\n    },\n    {\n        code: 'id-ID',\n        name: 'Indonesian'\n    },\n    {\n        code: 'ga-IE',\n        name: 'Irish'\n    },\n    {\n        code: 'it-IT',\n        name: 'Italian'\n    },\n    {\n        code: 'ja-JP',\n        name: 'Japanese'\n    },\n    {\n        code: 'jv-ID',\n        name: 'Javanese'\n    },\n    {\n        code: 'kn-IN',\n        name: 'Kannada'\n    },\n    {\n        code: 'kk-KZ',\n        name: 'Kazakh'\n    },\n    {\n        code: 'km-KH',\n        name: 'Khmer'\n    },\n    {\n        code: 'rw-RW',\n        name: 'Kinyarwanda'\n    },\n    {\n        code: 'ko-KR',\n        name: 'Korean'\n    },\n    {\n        code: 'ku-TR',\n        name: 'Kurdish (Kurmanji)'\n    },\n    {\n        code: 'ckb-IQ',\n        name: 'Kurdish (Sorani)'\n    },\n    {\n        code: 'lo-LA',\n        name: 'Lao'\n    },\n    {\n        code: 'la-VA',\n        name: 'Latin'\n    },\n    {\n        code: 'lv-LV',\n        name: 'Latvian'\n    },\n    {\n        code: 'ln-CD',\n        name: 'Lingala'\n    },\n    {\n        code: 'lt-LT',\n        name: 'Lithuanian'\n    },\n    {\n        code: 'lg-UG',\n        name: 'Luganda'\n    },\n    {\n        code: 'mk-MK',\n        name: 'Macedonian'\n    },\n    {\n        code: 'mg-MG',\n        name: 'Malagasy'\n    },\n    {\n        code: 'ms-MY',\n        name: 'Malay'\n    },\n    {\n        code: 'ml-IN',\n        name: 'Malayalam'\n    },\n    {\n        code: 'mt-MT',\n        name: 'Maltese'\n    },\n    {\n        code: 'mi-NZ',\n        name: 'Maori'\n    },\n    {\n        code: 'mr-IN',\n        name: 'Marathi'\n    },\n    {\n        code: 'mn-MN',\n        name: 'Mongolian'\n    },\n    {\n        code: 'my-MM',\n        name: 'Myanmar (Burmese)'\n    },\n    {\n        code: 'ne-NP',\n        name: 'Nepali'\n    },\n    {\n        code: 'no-NO',\n        name: 'Norwegian'\n    },\n    {\n        code: 'or-IN',\n        name: 'Odia (Oriya)'\n    },\n    {\n        code: 'om-ET',\n        name: 'Oromo'\n    },\n    {\n        code: 'ps-AF',\n        name: 'Pashto'\n    },\n    {\n        code: 'fa-IR',\n        name: 'Persian'\n    },\n    {\n        code: 'pl-PL',\n        name: 'Polish'\n    },\n    {\n        code: 'pt-BR',\n        name: 'Portuguese (Brazil)'\n    },\n    {\n        code: 'pt-PT',\n        name: 'Portuguese (Portugal)'\n    },\n    {\n        code: 'pa-IN',\n        name: 'Punjabi'\n    },\n    {\n        code: 'qu-PE',\n        name: 'Quechua'\n    },\n    {\n        code: 'ro-RO',\n        name: 'Romanian'\n    },\n    {\n        code: 'ru-RU',\n        name: 'Russian'\n    },\n    {\n        code: 'sm-WS',\n        name: 'Samoan'\n    },\n    {\n        code: 'sa-IN',\n        name: 'Sanskrit'\n    },\n    {\n        code: 'gd-GB',\n        name: 'Scots Gaelic'\n    },\n    {\n        code: 'sr-RS',\n        name: 'Serbian'\n    },\n    {\n        code: 'st-LS',\n        name: 'Sesotho'\n    },\n    {\n        code: 'sn-ZW',\n        name: 'Shona'\n    },\n    {\n        code: 'sd-PK',\n        name: 'Sindhi'\n    },\n    {\n        code: 'si-LK',\n        name: 'Sinhala'\n    },\n    {\n        code: 'sk-SK',\n        name: 'Slovak'\n    },\n    {\n        code: 'sl-SI',\n        name: 'Slovenian'\n    },\n    {\n        code: 'so-SO',\n        name: 'Somali'\n    },\n    {\n        code: 'es-ES',\n        name: 'Spanish'\n    },\n    {\n        code: 'su-ID',\n        name: 'Sundanese'\n    },\n    {\n        code: 'sw-TZ',\n        name: 'Swahili'\n    },\n    {\n        code: 'sv-SE',\n        name: 'Swedish'\n    },\n    {\n        code: 'tg-TJ',\n        name: 'Tajik'\n    },\n    {\n        code: 'ta-IN',\n        name: 'Tamil'\n    },\n    {\n        code: 'tt-RU',\n        name: 'Tatar'\n    },\n    {\n        code: 'te-IN',\n        name: 'Telugu'\n    },\n    {\n        code: 'th-TH',\n        name: 'Thai'\n    },\n    {\n        code: 'bo-CN',\n        name: 'Tibetan'\n    },\n    {\n        code: 'ti-ET',\n        name: 'Tigrinya'\n    },\n    {\n        code: 'ts-ZA',\n        name: 'Tsonga'\n    },\n    {\n        code: 'tn-BW',\n        name: 'Tswana'\n    },\n    {\n        code: 'tr-TR',\n        name: 'Turkish'\n    },\n    {\n        code: 'tk-TM',\n        name: 'Turkmen'\n    },\n    {\n        code: 'uk-UA',\n        name: 'Ukrainian'\n    },\n    {\n        code: 'ur-PK',\n        name: 'Urdu'\n    },\n    {\n        code: 'ug-CN',\n        name: 'Uyghur'\n    },\n    {\n        code: 'uz-UZ',\n        name: 'Uzbek'\n    },\n    {\n        code: 'vi-VN',\n        name: 'Vietnamese'\n    },\n    {\n        code: 'cy-GB',\n        name: 'Welsh'\n    },\n    {\n        code: 'xh-ZA',\n        name: 'Xhosa'\n    },\n    {\n        code: 'yi-IL',\n        name: 'Yiddish'\n    },\n    {\n        code: 'yo-NG',\n        name: 'Yoruba'\n    },\n    {\n        code: 'zu-ZA',\n        name: 'Zulu'\n    }\n];\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3R5cGVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQ08sc0NBQUtBOzs7V0FBQUE7TUFHWDtBQXNCTSxNQUFNQyxZQUF3QjtJQUNuQztRQUFFQyxNQUFNO1FBQVNDLE1BQU07SUFBVTtJQUNqQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBUztJQUNoQztRQUFFRCxNQUFNO1FBQVVDLE1BQU07SUFBVztJQUNuQztRQUFFRCxNQUFNO1FBQVVDLE1BQU07SUFBUztJQUNqQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBTztJQUM5QjtRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBWTtJQUNuQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBVztJQUNsQztRQUFFRCxNQUFNO1FBQVVDLE1BQU07SUFBTztJQUMvQjtRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBVTtJQUNqQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBUztJQUNoQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBVztJQUNsQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBVztJQUNsQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBTztJQUM5QjtRQUFFRCxNQUFNO1FBQVVDLE1BQU07SUFBUztJQUNqQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBUztJQUNoQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBYztJQUNyQztRQUFFRCxNQUFNO1FBQVVDLE1BQU07SUFBVztJQUNuQztRQUFFRCxNQUFNO1FBQVVDLE1BQU07SUFBVTtJQUNsQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBVTtJQUNqQztRQUFFRCxNQUFNO1FBQVVDLE1BQU07SUFBUztJQUNqQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBVTtJQUNqQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBUztJQUNoQztRQUFFRCxNQUFNO1FBQVVDLE1BQU07SUFBYTtJQUNyQztRQUFFRCxNQUFNO1FBQVVDLE1BQU07SUFBbUI7SUFDM0M7UUFBRUQsTUFBTTtRQUFVQyxNQUFNO0lBQWE7SUFDckM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQWE7SUFDcEM7UUFBRUQsTUFBTTtRQUFVQyxNQUFNO0lBQVE7SUFDaEM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVU7SUFDakM7UUFBRUQsTUFBTTtRQUFVQyxNQUFNO0lBQVM7SUFDakM7UUFBRUQsTUFBTTtRQUFVQyxNQUFNO0lBQVc7SUFDbkM7UUFBRUQsTUFBTTtRQUFVQyxNQUFNO0lBQVE7SUFDaEM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVU7SUFDakM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVM7SUFDaEM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVk7SUFDbkM7UUFBRUQsTUFBTTtRQUFVQyxNQUFNO0lBQVM7SUFDakM7UUFBRUQsTUFBTTtRQUFVQyxNQUFNO0lBQVk7SUFDcEM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVU7SUFDakM7UUFBRUQsTUFBTTtRQUFVQyxNQUFNO0lBQVU7SUFDbEM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVc7SUFDbEM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVU7SUFDakM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVc7SUFDbEM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQXVCO0lBQzlDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUF3QjtJQUMvQztRQUFFRCxNQUFNO1FBQVVDLE1BQU07SUFBVztJQUNuQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBVTtJQUNqQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBVztJQUNsQztRQUFFRCxNQUFNO1FBQVVDLE1BQU07SUFBZ0I7SUFDeEM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVc7SUFDbEM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVE7SUFDL0I7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVM7SUFDaEM7UUFBRUQsTUFBTTtRQUFVQyxNQUFNO0lBQU87SUFDL0I7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVU7SUFDakM7UUFBRUQsTUFBTTtRQUFVQyxNQUFNO0lBQVE7SUFDaEM7UUFBRUQsTUFBTTtRQUFVQyxNQUFNO0lBQVE7SUFDaEM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVE7SUFDL0I7UUFBRUQsTUFBTTtRQUFVQyxNQUFNO0lBQVE7SUFDaEM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVc7SUFDbEM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVU7SUFDakM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVk7SUFDbkM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVc7SUFDbEM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQU07SUFDN0I7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVU7SUFDakM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVM7SUFDaEM7UUFBRUQsTUFBTTtRQUFVQyxNQUFNO0lBQVc7SUFDbkM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVU7SUFDakM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQVM7SUFDaEM7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQWtCO0lBQ3pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFTO0lBQ2hDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFXO0lBQ2xDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFXO0lBQ2xDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFTO0lBQ2hDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFRO0lBQy9CO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFXO0lBQ2xDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFpQjtJQUN4QztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBUTtJQUMvQjtRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBUztJQUNoQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBUTtJQUMvQjtRQUFFRCxNQUFNO1FBQVVDLE1BQU07SUFBUTtJQUNoQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBWTtJQUNuQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBWTtJQUNuQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBTztJQUM5QjtRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBYTtJQUNwQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBUTtJQUMvQjtRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBVTtJQUNqQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBVztJQUNsQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBVztJQUNsQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBVTtJQUNqQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBUztJQUNoQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBUTtJQUMvQjtRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBYztJQUNyQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBUztJQUNoQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBcUI7SUFDNUM7UUFBRUQsTUFBTTtRQUFVQyxNQUFNO0lBQW1CO0lBQzNDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFNO0lBQzdCO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFRO0lBQy9CO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFhO0lBQ3BDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFhO0lBQ3BDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFXO0lBQ2xDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFRO0lBQy9CO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFZO0lBQ25DO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFRO0lBQy9CO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFZO0lBQ25DO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFvQjtJQUMzQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBUztJQUNoQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBWTtJQUNuQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBZTtJQUN0QztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBUTtJQUMvQjtRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBUztJQUNoQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBVTtJQUNqQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBUztJQUNoQztRQUFFRCxNQUFNO1FBQVNDLE1BQU07SUFBc0I7SUFDN0M7UUFBRUQsTUFBTTtRQUFTQyxNQUFNO0lBQXdCO0lBQy9DO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFXO0lBQ2xDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFTO0lBQ2hDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFXO0lBQ2xDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFlO0lBQ3RDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFRO0lBQy9CO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFTO0lBQ2hDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFTO0lBQ2hDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFZO0lBQ25DO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFTO0lBQ2hDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFZO0lBQ25DO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFRO0lBQy9CO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFRO0lBQy9CO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFRO0lBQy9CO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFTO0lBQ2hDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFPO0lBQzlCO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFXO0lBQ2xDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFTO0lBQ2hDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFTO0lBQ2hDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFZO0lBQ25DO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFPO0lBQzlCO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFTO0lBQ2hDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFRO0lBQy9CO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFhO0lBQ3BDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFRO0lBQy9CO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFRO0lBQy9CO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFVO0lBQ2pDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFTO0lBQ2hDO1FBQUVELE1BQU07UUFBU0MsTUFBTTtJQUFPO0NBQy9CLENBQUMiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2VidXJvbmR1YWwvdHlwZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiXG5leHBvcnQgZW51bSBBcHBTdGF0ZSB7XG4gIExPR0lOID0gJ0xPR0lOJyxcbiAgVFJBTlNMQVRPUiA9ICdUUkFOU0xBVE9SJ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2Uge1xuICBpZDogc3RyaW5nO1xuICBzZW5kZXI6ICdzdGFmZicgfCAndmlzaXRvcic7XG4gIG9yaWdpbmFsVGV4dDogc3RyaW5nO1xuICB0cmFuc2xhdGVkVGV4dDogc3RyaW5nO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTYXZlZFNlc3Npb24ge1xuICBpZDogc3RyaW5nO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgcHJldmlldzogc3RyaW5nO1xuICBtZXNzYWdlczogTWVzc2FnZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExhbmd1YWdlIHtcbiAgY29kZTogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBMQU5HVUFHRVM6IExhbmd1YWdlW10gPSBbXG4gIHsgY29kZTogJ25sLUJFJywgbmFtZTogJ0ZsZW1pc2gnIH0sXG4gIHsgY29kZTogJ2FiLUdFJywgbmFtZTogJ0Fia2hheicgfSxcbiAgeyBjb2RlOiAnYWNlLUlEJywgbmFtZTogJ0FjZWhuZXNlJyB9LFxuICB7IGNvZGU6ICdhY2gtVUcnLCBuYW1lOiAnQWNob2xpJyB9LFxuICB7IGNvZGU6ICdhYS1FVCcsIG5hbWU6ICdBZmFyJyB9LFxuICB7IGNvZGU6ICdhZi1aQScsIG5hbWU6ICdBZnJpa2FhbnMnIH0sXG4gIHsgY29kZTogJ3NxLUFMJywgbmFtZTogJ0FsYmFuaWFuJyB9LFxuICB7IGNvZGU6ICdhbHotQ0QnLCBuYW1lOiAnQWx1cicgfSxcbiAgeyBjb2RlOiAnYW0tRVQnLCBuYW1lOiAnQW1oYXJpYycgfSxcbiAgeyBjb2RlOiAnYXItWEEnLCBuYW1lOiAnQXJhYmljJyB9LFxuICB7IGNvZGU6ICdoeS1BTScsIG5hbWU6ICdBcm1lbmlhbicgfSxcbiAgeyBjb2RlOiAnYXMtSU4nLCBuYW1lOiAnQXNzYW1lc2UnIH0sXG4gIHsgY29kZTogJ2F2LVJVJywgbmFtZTogJ0F2YXInIH0sXG4gIHsgY29kZTogJ2F3YS1JTicsIG5hbWU6ICdBd2FkaGknIH0sXG4gIHsgY29kZTogJ2F5LUJPJywgbmFtZTogJ0F5bWFyYScgfSxcbiAgeyBjb2RlOiAnYXotQVonLCBuYW1lOiAnQXplcmJhaWphbmknIH0sXG4gIHsgY29kZTogJ2Jhbi1JRCcsIG5hbWU6ICdCYWxpbmVzZScgfSxcbiAgeyBjb2RlOiAnYmFsLVBLJywgbmFtZTogJ0JhbHVjaGknIH0sXG4gIHsgY29kZTogJ2JtLU1MJywgbmFtZTogJ0JhbWJhcmEnIH0sXG4gIHsgY29kZTogJ2JjaS1DSScsIG5hbWU6ICdCYW91bMOpJyB9LFxuICB7IGNvZGU6ICdiYS1SVScsIG5hbWU6ICdCYXNoa2lyJyB9LFxuICB7IGNvZGU6ICdldS1FUycsIG5hbWU6ICdCYXNxdWUnIH0sXG4gIHsgY29kZTogJ2J0eC1JRCcsIG5hbWU6ICdCYXRhayBLYXJvJyB9LFxuICB7IGNvZGU6ICdidHMtSUQnLCBuYW1lOiAnQmF0YWsgU2ltYWx1bmd1bicgfSxcbiAgeyBjb2RlOiAnYmJjLUlEJywgbmFtZTogJ0JhdGFrIFRvYmEnIH0sXG4gIHsgY29kZTogJ2JlLUJZJywgbmFtZTogJ0JlbGFydXNpYW4nIH0sXG4gIHsgY29kZTogJ2JlbS1aTScsIG5hbWU6ICdCZW1iYScgfSxcbiAgeyBjb2RlOiAnYm4tQkQnLCBuYW1lOiAnQmVuZ2FsaScgfSxcbiAgeyBjb2RlOiAnYmV3LUlEJywgbmFtZTogJ0JldGF3aScgfSxcbiAgeyBjb2RlOiAnYmhvLUlOJywgbmFtZTogJ0Job2pwdXJpJyB9LFxuICB7IGNvZGU6ICdiaWstUEgnLCBuYW1lOiAnQmlrb2wnIH0sXG4gIHsgY29kZTogJ2JzLUJBJywgbmFtZTogJ0Jvc25pYW4nIH0sXG4gIHsgY29kZTogJ2JyLUZSJywgbmFtZTogJ0JyZXRvbicgfSxcbiAgeyBjb2RlOiAnYmctQkcnLCBuYW1lOiAnQnVsZ2FyaWFuJyB9LFxuICB7IGNvZGU6ICdidWEtUlUnLCBuYW1lOiAnQnVyeWF0JyB9LFxuICB7IGNvZGU6ICd5dWUtSEsnLCBuYW1lOiAnQ2FudG9uZXNlJyB9LFxuICB7IGNvZGU6ICdjYS1FUycsIG5hbWU6ICdDYXRhbGFuJyB9LFxuICB7IGNvZGU6ICdjZWItUEgnLCBuYW1lOiAnQ2VidWFubycgfSxcbiAgeyBjb2RlOiAnY2gtR1UnLCBuYW1lOiAnQ2hhbW9ycm8nIH0sXG4gIHsgY29kZTogJ2NlLVJVJywgbmFtZTogJ0NoZWNoZW4nIH0sXG4gIHsgY29kZTogJ255LU1XJywgbmFtZTogJ0NoaWNoZXdhJyB9LFxuICB7IGNvZGU6ICd6aC1DTicsIG5hbWU6ICdDaGluZXNlIChTaW1wbGlmaWVkKScgfSxcbiAgeyBjb2RlOiAnemgtVFcnLCBuYW1lOiAnQ2hpbmVzZSAoVHJhZGl0aW9uYWwpJyB9LFxuICB7IGNvZGU6ICdjaGstRk0nLCBuYW1lOiAnQ2h1dWtlc2UnIH0sXG4gIHsgY29kZTogJ2N2LVJVJywgbmFtZTogJ0NodXZhc2gnIH0sXG4gIHsgY29kZTogJ2NvLUZSJywgbmFtZTogJ0NvcnNpY2FuJyB9LFxuICB7IGNvZGU6ICdjcmgtUlUnLCBuYW1lOiAnQ3JpbWVhbiBUYXRhcicgfSxcbiAgeyBjb2RlOiAnaHItSFInLCBuYW1lOiAnQ3JvYXRpYW4nIH0sXG4gIHsgY29kZTogJ2NzLUNaJywgbmFtZTogJ0N6ZWNoJyB9LFxuICB7IGNvZGU6ICdkYS1ESycsIG5hbWU6ICdEYW5pc2gnIH0sXG4gIHsgY29kZTogJ3Bycy1BRicsIG5hbWU6ICdEYXJpJyB9LFxuICB7IGNvZGU6ICdkdi1NVicsIG5hbWU6ICdEaGl2ZWhpJyB9LFxuICB7IGNvZGU6ICdkaW4tU1MnLCBuYW1lOiAnRGlua2EnIH0sXG4gIHsgY29kZTogJ2RvaS1JTicsIG5hbWU6ICdEb2dyaScgfSxcbiAgeyBjb2RlOiAnbmwtTkwnLCBuYW1lOiAnRHV0Y2gnIH0sXG4gIHsgY29kZTogJ2R5dS1CRicsIG5hbWU6ICdEeXVsYScgfSxcbiAgeyBjb2RlOiAnZHotQlQnLCBuYW1lOiAnRHpvbmdraGEnIH0sXG4gIHsgY29kZTogJ2VuLVVTJywgbmFtZTogJ0VuZ2xpc2gnIH0sXG4gIHsgY29kZTogJ2VvLUVVJywgbmFtZTogJ0VzcGVyYW50bycgfSxcbiAgeyBjb2RlOiAnZXQtRUUnLCBuYW1lOiAnRXN0b25pYW4nIH0sXG4gIHsgY29kZTogJ2VlLUdIJywgbmFtZTogJ0V3ZScgfSxcbiAgeyBjb2RlOiAnZm8tRk8nLCBuYW1lOiAnRmFyb2VzZScgfSxcbiAgeyBjb2RlOiAnZmotRkonLCBuYW1lOiAnRmlqaWFuJyB9LFxuICB7IGNvZGU6ICdmaWwtUEgnLCBuYW1lOiAnRmlsaXBpbm8nIH0sXG4gIHsgY29kZTogJ2ZpLUZJJywgbmFtZTogJ0Zpbm5pc2gnIH0sXG4gIHsgY29kZTogJ2ZyLUZSJywgbmFtZTogJ0ZyZW5jaCcgfSxcbiAgeyBjb2RlOiAnZnItQ0EnLCBuYW1lOiAnRnJlbmNoIChDYW5hZGEpJyB9LFxuICB7IGNvZGU6ICdmeS1OTCcsIG5hbWU6ICdGcmlzaWFuJyB9LFxuICB7IGNvZGU6ICdmZi1TTicsIG5hbWU6ICdGdWxhbmknIH0sXG4gIHsgY29kZTogJ2dsLUVTJywgbmFtZTogJ0dhbGljaWFuJyB9LFxuICB7IGNvZGU6ICdrYS1HRScsIG5hbWU6ICdHZW9yZ2lhbicgfSxcbiAgeyBjb2RlOiAnZGUtREUnLCBuYW1lOiAnR2VybWFuJyB9LFxuICB7IGNvZGU6ICdlbC1HUicsIG5hbWU6ICdHcmVlaycgfSxcbiAgeyBjb2RlOiAnZ24tUFknLCBuYW1lOiAnR3VhcmFuaScgfSxcbiAgeyBjb2RlOiAnZ3UtSU4nLCBuYW1lOiAnR3VqYXJhdGknIH0sXG4gIHsgY29kZTogJ2h0LUhUJywgbmFtZTogJ0hhaXRpYW4gQ3Jlb2xlJyB9LFxuICB7IGNvZGU6ICdoYS1ORycsIG5hbWU6ICdIYXVzYScgfSxcbiAgeyBjb2RlOiAnaGUtSUwnLCBuYW1lOiAnSGVicmV3JyB9LFxuICB7IGNvZGU6ICdoaS1JTicsIG5hbWU6ICdIaW5kaScgfSxcbiAgeyBjb2RlOiAnaG1uLUNOJywgbmFtZTogJ0htb25nJyB9LFxuICB7IGNvZGU6ICdodS1IVScsIG5hbWU6ICdIdW5nYXJpYW4nIH0sXG4gIHsgY29kZTogJ2lzLUlTJywgbmFtZTogJ0ljZWxhbmRpYycgfSxcbiAgeyBjb2RlOiAnaWctTkcnLCBuYW1lOiAnSWdibycgfSxcbiAgeyBjb2RlOiAnaWQtSUQnLCBuYW1lOiAnSW5kb25lc2lhbicgfSxcbiAgeyBjb2RlOiAnZ2EtSUUnLCBuYW1lOiAnSXJpc2gnIH0sXG4gIHsgY29kZTogJ2l0LUlUJywgbmFtZTogJ0l0YWxpYW4nIH0sXG4gIHsgY29kZTogJ2phLUpQJywgbmFtZTogJ0phcGFuZXNlJyB9LFxuICB7IGNvZGU6ICdqdi1JRCcsIG5hbWU6ICdKYXZhbmVzZScgfSxcbiAgeyBjb2RlOiAna24tSU4nLCBuYW1lOiAnS2FubmFkYScgfSxcbiAgeyBjb2RlOiAna2stS1onLCBuYW1lOiAnS2F6YWtoJyB9LFxuICB7IGNvZGU6ICdrbS1LSCcsIG5hbWU6ICdLaG1lcicgfSxcbiAgeyBjb2RlOiAncnctUlcnLCBuYW1lOiAnS2lueWFyd2FuZGEnIH0sXG4gIHsgY29kZTogJ2tvLUtSJywgbmFtZTogJ0tvcmVhbicgfSxcbiAgeyBjb2RlOiAna3UtVFInLCBuYW1lOiAnS3VyZGlzaCAoS3VybWFuamkpJyB9LFxuICB7IGNvZGU6ICdja2ItSVEnLCBuYW1lOiAnS3VyZGlzaCAoU29yYW5pKScgfSxcbiAgeyBjb2RlOiAnbG8tTEEnLCBuYW1lOiAnTGFvJyB9LFxuICB7IGNvZGU6ICdsYS1WQScsIG5hbWU6ICdMYXRpbicgfSxcbiAgeyBjb2RlOiAnbHYtTFYnLCBuYW1lOiAnTGF0dmlhbicgfSxcbiAgeyBjb2RlOiAnbG4tQ0QnLCBuYW1lOiAnTGluZ2FsYScgfSxcbiAgeyBjb2RlOiAnbHQtTFQnLCBuYW1lOiAnTGl0aHVhbmlhbicgfSxcbiAgeyBjb2RlOiAnbGctVUcnLCBuYW1lOiAnTHVnYW5kYScgfSxcbiAgeyBjb2RlOiAnbWstTUsnLCBuYW1lOiAnTWFjZWRvbmlhbicgfSxcbiAgeyBjb2RlOiAnbWctTUcnLCBuYW1lOiAnTWFsYWdhc3knIH0sXG4gIHsgY29kZTogJ21zLU1ZJywgbmFtZTogJ01hbGF5JyB9LFxuICB7IGNvZGU6ICdtbC1JTicsIG5hbWU6ICdNYWxheWFsYW0nIH0sXG4gIHsgY29kZTogJ210LU1UJywgbmFtZTogJ01hbHRlc2UnIH0sXG4gIHsgY29kZTogJ21pLU5aJywgbmFtZTogJ01hb3JpJyB9LFxuICB7IGNvZGU6ICdtci1JTicsIG5hbWU6ICdNYXJhdGhpJyB9LFxuICB7IGNvZGU6ICdtbi1NTicsIG5hbWU6ICdNb25nb2xpYW4nIH0sXG4gIHsgY29kZTogJ215LU1NJywgbmFtZTogJ015YW5tYXIgKEJ1cm1lc2UpJyB9LFxuICB7IGNvZGU6ICduZS1OUCcsIG5hbWU6ICdOZXBhbGknIH0sXG4gIHsgY29kZTogJ25vLU5PJywgbmFtZTogJ05vcndlZ2lhbicgfSxcbiAgeyBjb2RlOiAnb3ItSU4nLCBuYW1lOiAnT2RpYSAoT3JpeWEpJyB9LFxuICB7IGNvZGU6ICdvbS1FVCcsIG5hbWU6ICdPcm9tbycgfSxcbiAgeyBjb2RlOiAncHMtQUYnLCBuYW1lOiAnUGFzaHRvJyB9LFxuICB7IGNvZGU6ICdmYS1JUicsIG5hbWU6ICdQZXJzaWFuJyB9LFxuICB7IGNvZGU6ICdwbC1QTCcsIG5hbWU6ICdQb2xpc2gnIH0sXG4gIHsgY29kZTogJ3B0LUJSJywgbmFtZTogJ1BvcnR1Z3Vlc2UgKEJyYXppbCknIH0sXG4gIHsgY29kZTogJ3B0LVBUJywgbmFtZTogJ1BvcnR1Z3Vlc2UgKFBvcnR1Z2FsKScgfSxcbiAgeyBjb2RlOiAncGEtSU4nLCBuYW1lOiAnUHVuamFiaScgfSxcbiAgeyBjb2RlOiAncXUtUEUnLCBuYW1lOiAnUXVlY2h1YScgfSxcbiAgeyBjb2RlOiAncm8tUk8nLCBuYW1lOiAnUm9tYW5pYW4nIH0sXG4gIHsgY29kZTogJ3J1LVJVJywgbmFtZTogJ1J1c3NpYW4nIH0sXG4gIHsgY29kZTogJ3NtLVdTJywgbmFtZTogJ1NhbW9hbicgfSxcbiAgeyBjb2RlOiAnc2EtSU4nLCBuYW1lOiAnU2Fuc2tyaXQnIH0sXG4gIHsgY29kZTogJ2dkLUdCJywgbmFtZTogJ1Njb3RzIEdhZWxpYycgfSxcbiAgeyBjb2RlOiAnc3ItUlMnLCBuYW1lOiAnU2VyYmlhbicgfSxcbiAgeyBjb2RlOiAnc3QtTFMnLCBuYW1lOiAnU2Vzb3RobycgfSxcbiAgeyBjb2RlOiAnc24tWlcnLCBuYW1lOiAnU2hvbmEnIH0sXG4gIHsgY29kZTogJ3NkLVBLJywgbmFtZTogJ1NpbmRoaScgfSxcbiAgeyBjb2RlOiAnc2ktTEsnLCBuYW1lOiAnU2luaGFsYScgfSxcbiAgeyBjb2RlOiAnc2stU0snLCBuYW1lOiAnU2xvdmFrJyB9LFxuICB7IGNvZGU6ICdzbC1TSScsIG5hbWU6ICdTbG92ZW5pYW4nIH0sXG4gIHsgY29kZTogJ3NvLVNPJywgbmFtZTogJ1NvbWFsaScgfSxcbiAgeyBjb2RlOiAnZXMtRVMnLCBuYW1lOiAnU3BhbmlzaCcgfSxcbiAgeyBjb2RlOiAnc3UtSUQnLCBuYW1lOiAnU3VuZGFuZXNlJyB9LFxuICB7IGNvZGU6ICdzdy1UWicsIG5hbWU6ICdTd2FoaWxpJyB9LFxuICB7IGNvZGU6ICdzdi1TRScsIG5hbWU6ICdTd2VkaXNoJyB9LFxuICB7IGNvZGU6ICd0Zy1USicsIG5hbWU6ICdUYWppaycgfSxcbiAgeyBjb2RlOiAndGEtSU4nLCBuYW1lOiAnVGFtaWwnIH0sXG4gIHsgY29kZTogJ3R0LVJVJywgbmFtZTogJ1RhdGFyJyB9LFxuICB7IGNvZGU6ICd0ZS1JTicsIG5hbWU6ICdUZWx1Z3UnIH0sXG4gIHsgY29kZTogJ3RoLVRIJywgbmFtZTogJ1RoYWknIH0sXG4gIHsgY29kZTogJ2JvLUNOJywgbmFtZTogJ1RpYmV0YW4nIH0sXG4gIHsgY29kZTogJ3RpLUVUJywgbmFtZTogJ1RpZ3JpbnlhJyB9LFxuICB7IGNvZGU6ICd0cy1aQScsIG5hbWU6ICdUc29uZ2EnIH0sXG4gIHsgY29kZTogJ3RuLUJXJywgbmFtZTogJ1Rzd2FuYScgfSxcbiAgeyBjb2RlOiAndHItVFInLCBuYW1lOiAnVHVya2lzaCcgfSxcbiAgeyBjb2RlOiAndGstVE0nLCBuYW1lOiAnVHVya21lbicgfSxcbiAgeyBjb2RlOiAndWstVUEnLCBuYW1lOiAnVWtyYWluaWFuJyB9LFxuICB7IGNvZGU6ICd1ci1QSycsIG5hbWU6ICdVcmR1JyB9LFxuICB7IGNvZGU6ICd1Zy1DTicsIG5hbWU6ICdVeWdodXInIH0sXG4gIHsgY29kZTogJ3V6LVVaJywgbmFtZTogJ1V6YmVrJyB9LFxuICB7IGNvZGU6ICd2aS1WTicsIG5hbWU6ICdWaWV0bmFtZXNlJyB9LFxuICB7IGNvZGU6ICdjeS1HQicsIG5hbWU6ICdXZWxzaCcgfSxcbiAgeyBjb2RlOiAneGgtWkEnLCBuYW1lOiAnWGhvc2EnIH0sXG4gIHsgY29kZTogJ3lpLUlMJywgbmFtZTogJ1lpZGRpc2gnIH0sXG4gIHsgY29kZTogJ3lvLU5HJywgbmFtZTogJ1lvcnViYScgfSxcbiAgeyBjb2RlOiAnenUtWkEnLCBuYW1lOiAnWnVsdScgfVxuXTtcbiJdLCJuYW1lcyI6WyJBcHBTdGF0ZSIsIkxBTkdVQUdFUyIsImNvZGUiLCJuYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./types.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE$2\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function describeUnknownElementTypeFrameInDEV(type) {\n      if (null == type) return \"\";\n      if (\"function\" === typeof type) {\n        var prototype = type.prototype;\n        return describeNativeComponentFrame(\n          type,\n          !(!prototype || !prototype.isReactComponent)\n        );\n      }\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return (type = describeNativeComponentFrame(type.render, !1)), type;\n          case REACT_MEMO_TYPE:\n            return describeUnknownElementTypeFrameInDEV(type.type);\n          case REACT_LAZY_TYPE:\n            prototype = type._payload;\n            type = type._init;\n            try {\n              return describeUnknownElementTypeFrameInDEV(type(prototype));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, self, source, owner, props) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      if (\n        \"string\" === typeof type ||\n        \"function\" === typeof type ||\n        type === REACT_FRAGMENT_TYPE ||\n        type === REACT_PROFILER_TYPE ||\n        type === REACT_STRICT_MODE_TYPE ||\n        type === REACT_SUSPENSE_TYPE ||\n        type === REACT_SUSPENSE_LIST_TYPE ||\n        type === REACT_OFFSCREEN_TYPE ||\n        (\"object\" === typeof type &&\n          null !== type &&\n          (type.$$typeof === REACT_LAZY_TYPE ||\n            type.$$typeof === REACT_MEMO_TYPE ||\n            type.$$typeof === REACT_CONTEXT_TYPE ||\n            type.$$typeof === REACT_CONSUMER_TYPE ||\n            type.$$typeof === REACT_FORWARD_REF_TYPE ||\n            type.$$typeof === REACT_CLIENT_REFERENCE$1 ||\n            void 0 !== type.getModuleId))\n      ) {\n        var children = config.children;\n        if (void 0 !== children)\n          if (isStaticChildren)\n            if (isArrayImpl(children)) {\n              for (\n                isStaticChildren = 0;\n                isStaticChildren < children.length;\n                isStaticChildren++\n              )\n                validateChildKeys(children[isStaticChildren], type);\n              Object.freeze && Object.freeze(children);\n            } else\n              console.error(\n                \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n              );\n          else validateChildKeys(children, type);\n      } else {\n        children = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          children +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        null === type\n          ? (isStaticChildren = \"null\")\n          : isArrayImpl(type)\n            ? (isStaticChildren = \"array\")\n            : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE\n              ? ((isStaticChildren =\n                  \"<\" +\n                  (getComponentNameFromType(type.type) || \"Unknown\") +\n                  \" />\"),\n                (children =\n                  \" Did you accidentally export a JSX literal instead of a component?\"))\n              : (isStaticChildren = typeof type);\n        console.error(\n          \"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",\n          isStaticChildren,\n          children\n        );\n      }\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(type, children, self, source, getOwner(), maybeKey);\n    }\n    function validateChildKeys(node, parentType) {\n      if (\n        \"object\" === typeof node &&\n        node &&\n        node.$$typeof !== REACT_CLIENT_REFERENCE\n      )\n        if (isArrayImpl(node))\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n            isValidElement(child) && validateExplicitKey(child, parentType);\n          }\n        else if (isValidElement(node))\n          node._store && (node._store.validated = 1);\n        else if (\n          (null === node || \"object\" !== typeof node\n            ? (i = null)\n            : ((i =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (i = \"function\" === typeof i ? i : null)),\n          \"function\" === typeof i &&\n            i !== node.entries &&\n            ((i = i.call(node)), i !== node))\n        )\n          for (; !(node = i.next()).done; )\n            isValidElement(node.value) &&\n              validateExplicitKey(node.value, parentType);\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    function validateExplicitKey(element, parentType) {\n      if (\n        element._store &&\n        !element._store.validated &&\n        null == element.key &&\n        ((element._store.validated = 1),\n        (parentType = getCurrentComponentErrorInfo(parentType)),\n        !ownerHasKeyUseWarning[parentType])\n      ) {\n        ownerHasKeyUseWarning[parentType] = !0;\n        var childOwner = \"\";\n        element &&\n          null != element._owner &&\n          element._owner !== getOwner() &&\n          ((childOwner = null),\n          \"number\" === typeof element._owner.tag\n            ? (childOwner = getComponentNameFromType(element._owner.type))\n            : \"string\" === typeof element._owner.name &&\n              (childOwner = element._owner.name),\n          (childOwner = \" It was passed a child from \" + childOwner + \".\"));\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = function () {\n          var stack = describeUnknownElementTypeFrameInDEV(element.type);\n          prevGetCurrentStack && (stack += prevGetCurrentStack() || \"\");\n          return stack;\n        };\n        console.error(\n          'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n          parentType,\n          childOwner\n        );\n        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n      }\n    }\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = \"\",\n        owner = getOwner();\n      owner &&\n        (owner = getComponentNameFromType(owner.type)) &&\n        (info = \"\\n\\nCheck the render method of `\" + owner + \"`.\");\n      info ||\n        ((parentType = getComponentNameFromType(parentType)) &&\n          (info =\n            \"\\n\\nCheck the top-level render call using <\" + parentType + \">.\"));\n      return info;\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      assign = Object.assign,\n      REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"),\n      isArrayImpl = Array.isArray,\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutKeySpread = {},\n      ownerHasKeyUseWarning = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QixXQUFXLGdCQUFnQjtBQUNuRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsbUNBQW1DLFdBQVcsMkJBQTJCO0FBQ3pFLDZCQUE2QixXQUFXLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0NBQStDLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZWJ1cm9uZHVhbC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgIH1cbiAgICAgIGlmIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gY29uc29sZTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5lcnJvcjtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxuICAgICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmXG4gICAgICAgICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuICAgICAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgICBcIk9iamVjdFwiO1xuICAgICAgICBKU0NvbXBpbGVyX3RlbXBfY29uc3QuY2FsbChcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQsXG4gICAgICAgICAgXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuICAgIGZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICAgICAgaWYgKDAgPT09IGRpc2FibGVkRGVwdGgpIHtcbiAgICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7XG4gICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGlzYWJsZWREZXB0aCsrO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gICAgICBkaXNhYmxlZERlcHRoLS07XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB7IGNvbmZpZ3VyYWJsZTogITAsIGVudW1lcmFibGU6ICEwLCB3cml0YWJsZTogITAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkxvZyB9KSxcbiAgICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2SW5mbyB9KSxcbiAgICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2V2FybiB9KSxcbiAgICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkVycm9yIH0pLFxuICAgICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXAgfSksXG4gICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZCB9KSxcbiAgICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwRW5kIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgMCA+IGRpc2FibGVkRGVwdGggJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcImRpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSB7XG4gICAgICBpZiAodm9pZCAwID09PSBwcmVmaXgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgICAgcHJlZml4ID0gKG1hdGNoICYmIG1hdGNoWzFdKSB8fCBcIlwiO1xuICAgICAgICAgIHN1ZmZpeCA9XG4gICAgICAgICAgICAtMSA8IHguc3RhY2suaW5kZXhPZihcIlxcbiAgICBhdFwiKVxuICAgICAgICAgICAgICA/IFwiICg8YW5vbnltb3VzPilcIlxuICAgICAgICAgICAgICA6IC0xIDwgeC5zdGFjay5pbmRleE9mKFwiQFwiKVxuICAgICAgICAgICAgICAgID8gXCJAdW5rbm93bjowOjBcIlxuICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXFxuXCIgKyBwcmVmaXggKyBuYW1lICsgc3VmZml4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgICAgIGlmICghZm4gfHwgcmVlbnRyeSkgcmV0dXJuIFwiXCI7XG4gICAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG4gICAgICBpZiAodm9pZCAwICE9PSBmcmFtZSkgcmV0dXJuIGZyYW1lO1xuICAgICAgcmVlbnRyeSA9ICEwO1xuICAgICAgZnJhbWUgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlciA9IG51bGw7XG4gICAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IG51bGw7XG4gICAgICBkaXNhYmxlTG9ncygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgICAgICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIFJlZmxlY3QgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh4JDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh4JDEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChGYWtlID0gZm4oKSkgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEZha2UuY2F0Y2ggJiZcbiAgICAgICAgICAgICAgICAgIEZha2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzYW1wbGUuc3RhY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdC5kaXNwbGF5TmFtZSA9XG4gICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIjtcbiAgICAgICAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICAgIFwibmFtZVwiXG4gICAgICAgICk7XG4gICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUgJiZcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgICAgIHsgdmFsdWU6IFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCIgfVxuICAgICAgICAgICk7XG4gICAgICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPVxuICAgICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgICAgY29udHJvbFN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzFdO1xuICAgICAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlU3RhY2suc3BsaXQoXCJcXG5cIiksXG4gICAgICAgICAgICBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IG5hbWVQcm9wRGVzY3JpcHRvciA9IDA7XG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiZcbiAgICAgICAgICAgICFzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yKys7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA8IGNvbnRyb2xMaW5lcy5sZW5ndGggJiZcbiAgICAgICAgICAgICFjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlcisrO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9PT0gc2FtcGxlTGluZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPT09IGNvbnRyb2xMaW5lcy5sZW5ndGhcbiAgICAgICAgICApXG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgICAgICAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlciAmJlxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdO1xuXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlci0tO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICAxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcjtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci0tLCBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl1cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAoMSAhPT0gbmFtZVByb3BEZXNjcmlwdG9yIHx8IDEgIT09IF9SdW5JblJvb3RGcmFtZSREZXRlcikge1xuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChuYW1lUHJvcERlc2NyaXB0b3ItLSxcbiAgICAgICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS0sXG4gICAgICAgICAgICAgICAgICAgIDAgPiBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl0pXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9XG4gICAgICAgICAgICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgYXQgbmV3IFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgYXQgXCJcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBmbi5kaXNwbGF5TmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIF9mcmFtZS5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgKF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKFwiPGFub255bW91cz5cIiwgZm4uZGlzcGxheU5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm4gJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiYgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAocmVlbnRyeSA9ICExKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZpb3VzRGlzcGF0Y2hlciksXG4gICAgICAgICAgcmVlbmFibGVMb2dzKCksXG4gICAgICAgICAgKEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnJhbWUpO1xuICAgICAgfVxuICAgICAgc2FtcGxlTGluZXMgPSAoc2FtcGxlTGluZXMgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiBcIlwiKVxuICAgICAgICA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHNhbXBsZUxpbmVzKVxuICAgICAgICA6IFwiXCI7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJiBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc2FtcGxlTGluZXMpO1xuICAgICAgcmV0dXJuIHNhbXBsZUxpbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIFwiXCI7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSkge1xuICAgICAgICB2YXIgcHJvdG90eXBlID0gdHlwZS5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgISghcHJvdG90eXBlIHx8ICFwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiU3VzcGVuc2VMaXN0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUgPSBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyLCAhMSkpLCB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUpO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgcHJvdG90eXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlKHByb3RvdHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE93bmVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGRpc3BhdGNoZXIgPyBudWxsIDogZGlzcGF0Y2hlci5nZXRPd25lcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gICAgICBzZWxmID0gcHJvcHMucmVmO1xuICAgICAgdHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgX293bmVyOiBvd25lclxuICAgICAgfTtcbiAgICAgIG51bGwgIT09ICh2b2lkIDAgIT09IHNlbGYgPyBzZWxmIDogbnVsbClcbiAgICAgICAgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICBnZXQ6IGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwgeyBlbnVtZXJhYmxlOiAhMSwgdmFsdWU6IG51bGwgfSk7XG4gICAgICB0eXBlLl9zdG9yZSA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKHR5cGUucHJvcHMpLCBPYmplY3QuZnJlZXplKHR5cGUpKTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqc3hERVZJbXBsKFxuICAgICAgdHlwZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1heWJlS2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNlbGZcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUgfHxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fFxuICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fFxuICAgICAgICAgICAgdm9pZCAwICE9PSB0eXBlLmdldE1vZHVsZUlkKSlcbiAgICAgICkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBjb25maWcuY2hpbGRyZW47XG4gICAgICAgIGlmICh2b2lkIDAgIT09IGNoaWxkcmVuKVxuICAgICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKVxuICAgICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPSAwO1xuICAgICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPCBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbisrXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpc1N0YXRpY0NoaWxkcmVuXSwgdHlwZSk7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIGVsc2UgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4gPSBcIlwiO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdm9pZCAwID09PSB0eXBlIHx8XG4gICAgICAgICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgICAwID09PSBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGgpXG4gICAgICAgIClcbiAgICAgICAgICBjaGlsZHJlbiArPVxuICAgICAgICAgICAgXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgICBudWxsID09PSB0eXBlXG4gICAgICAgICAgPyAoaXNTdGF0aWNDaGlsZHJlbiA9IFwibnVsbFwiKVxuICAgICAgICAgIDogaXNBcnJheUltcGwodHlwZSlcbiAgICAgICAgICAgID8gKGlzU3RhdGljQ2hpbGRyZW4gPSBcImFycmF5XCIpXG4gICAgICAgICAgICA6IHZvaWQgMCAhPT0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbiAgICAgICAgICAgICAgPyAoKGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgICAgICAgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiVW5rbm93blwiKSArXG4gICAgICAgICAgICAgICAgICBcIiAvPlwiKSxcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4gPVxuICAgICAgICAgICAgICAgICAgXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikpXG4gICAgICAgICAgICAgIDogKGlzU3RhdGljQ2hpbGRyZW4gPSB0eXBlb2YgdHlwZSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXNcIixcbiAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuIFwia2V5XCIgIT09IGs7XG4gICAgICAgIH0pO1xuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID1cbiAgICAgICAgICAwIDwga2V5cy5sZW5ndGhcbiAgICAgICAgICAgID8gXCJ7a2V5OiBzb21lS2V5LCBcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiXG4gICAgICAgICAgICA6IFwie2tleTogc29tZUtleX1cIjtcbiAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gfHxcbiAgICAgICAgICAoKGtleXMgPVxuICAgICAgICAgICAgMCA8IGtleXMubGVuZ3RoID8gXCJ7XCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie31cIiksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIHsuLi5wcm9wc30gLz5cXG5SZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsXG4gICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSA9ICEwKSk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB2b2lkIDAgIT09IG1heWJlS2V5ICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIG1heWJlS2V5KSk7XG4gICAgICBoYXNWYWxpZEtleShjb25maWcpICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgY29uZmlnLmtleSkpO1xuICAgICAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XG4gICAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgICBjaGlsZHJlbiAmJlxuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcbiAgICAgICAgICBtYXliZUtleSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlXG4gICAgICAgICAgICA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICA6IHR5cGVcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwgY2hpbGRyZW4sIHNlbGYsIHNvdXJjZSwgZ2V0T3duZXIoKSwgbWF5YmVLZXkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmXG4gICAgICAgIG5vZGUgJiZcbiAgICAgICAgbm9kZS4kJHR5cGVvZiAhPT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgKVxuICAgICAgICBpZiAoaXNBcnJheUltcGwobm9kZSkpXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgICAgICAgaXNWYWxpZEVsZW1lbnQoY2hpbGQpICYmIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpXG4gICAgICAgICAgbm9kZS5fc3RvcmUgJiYgKG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAobnVsbCA9PT0gbm9kZSB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2Ygbm9kZVxuICAgICAgICAgICAgPyAoaSA9IG51bGwpXG4gICAgICAgICAgICA6ICgoaSA9XG4gICAgICAgICAgICAgICAgKE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBub2RlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICAgICAgICAgICAgbm9kZVtcIkBAaXRlcmF0b3JcIl0pLFxuICAgICAgICAgICAgICAoaSA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGkgPyBpIDogbnVsbCkpLFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGkgJiZcbiAgICAgICAgICAgIGkgIT09IG5vZGUuZW50cmllcyAmJlxuICAgICAgICAgICAgKChpID0gaS5jYWxsKG5vZGUpKSwgaSAhPT0gbm9kZSkpXG4gICAgICAgIClcbiAgICAgICAgICBmb3IgKDsgIShub2RlID0gaS5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICAgIGlzVmFsaWRFbGVtZW50KG5vZGUudmFsdWUpICYmXG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkobm9kZS52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9iamVjdCAmJlxuICAgICAgICBudWxsICE9PSBvYmplY3QgJiZcbiAgICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICAgICAgaWYgKFxuICAgICAgICBlbGVtZW50Ll9zdG9yZSAmJlxuICAgICAgICAhZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkICYmXG4gICAgICAgIG51bGwgPT0gZWxlbWVudC5rZXkgJiZcbiAgICAgICAgKChlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSAxKSxcbiAgICAgICAgKHBhcmVudFR5cGUgPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpKSxcbiAgICAgICAgIW93bmVySGFzS2V5VXNlV2FybmluZ1twYXJlbnRUeXBlXSlcbiAgICAgICkge1xuICAgICAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbcGFyZW50VHlwZV0gPSAhMDtcbiAgICAgICAgdmFyIGNoaWxkT3duZXIgPSBcIlwiO1xuICAgICAgICBlbGVtZW50ICYmXG4gICAgICAgICAgbnVsbCAhPSBlbGVtZW50Ll9vd25lciAmJlxuICAgICAgICAgIGVsZW1lbnQuX293bmVyICE9PSBnZXRPd25lcigpICYmXG4gICAgICAgICAgKChjaGlsZE93bmVyID0gbnVsbCksXG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGVsZW1lbnQuX293bmVyLnRhZ1xuICAgICAgICAgICAgPyAoY2hpbGRPd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSlcbiAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVsZW1lbnQuX293bmVyLm5hbWUgJiZcbiAgICAgICAgICAgICAgKGNoaWxkT3duZXIgPSBlbGVtZW50Ll9vd25lci5uYW1lKSxcbiAgICAgICAgICAoY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgY2hpbGRPd25lciArIFwiLlwiKSk7XG4gICAgICAgIHZhciBwcmV2R2V0Q3VycmVudFN0YWNrID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSk7XG4gICAgICAgICAgcHJldkdldEN1cnJlbnRTdGFjayAmJiAoc3RhY2sgKz0gcHJldkdldEN1cnJlbnRTdGFjaygpIHx8IFwiXCIpO1xuICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsXG4gICAgICAgICAgcGFyZW50VHlwZSxcbiAgICAgICAgICBjaGlsZE93bmVyXG4gICAgICAgICk7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICAgICAgdmFyIGluZm8gPSBcIlwiLFxuICAgICAgICBvd25lciA9IGdldE93bmVyKCk7XG4gICAgICBvd25lciAmJlxuICAgICAgICAob3duZXIgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUob3duZXIudHlwZSkpICYmXG4gICAgICAgIChpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgXCIgKyBvd25lciArIFwiYC5cIik7XG4gICAgICBpbmZvIHx8XG4gICAgICAgICgocGFyZW50VHlwZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShwYXJlbnRUeXBlKSkgJiZcbiAgICAgICAgICAoaW5mbyA9XG4gICAgICAgICAgICBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50VHlwZSArIFwiPi5cIikpO1xuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIiksXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpO1xuICAgIHZhciBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gICAgICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSxcbiAgICAgIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSxcbiAgICAgIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcixcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICBkaXNhYmxlZERlcHRoID0gMCxcbiAgICAgIHByZXZMb2csXG4gICAgICBwcmV2SW5mbyxcbiAgICAgIHByZXZXYXJuLFxuICAgICAgcHJldkVycm9yLFxuICAgICAgcHJldkdyb3VwLFxuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkLFxuICAgICAgcHJldkdyb3VwRW5kO1xuICAgIGRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgIHZhciBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICByZWVudHJ5ID0gITE7XG4gICAgdmFyIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgKFxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXBcbiAgICApKCk7XG4gICAgdmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xuICAgIHZhciBkaWRXYXJuQWJvdXRFbGVtZW50UmVmID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9LFxuICAgICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gICAgZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG4gICAgZXhwb3J0cy5qc3hERVYgPSBmdW5jdGlvbiAoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZlxuICAgICkge1xuICAgICAgcmV0dXJuIGpzeERFVkltcGwodHlwZSwgY29uZmlnLCBtYXliZUtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKTtcbiAgICB9O1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2VidXJvbmR1YWwvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@google/genai/dist/web/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@google/genai/dist/web/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActivityHandling: () => (/* binding */ ActivityHandling),\n/* harmony export */   AdapterSize: () => (/* binding */ AdapterSize),\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   ApiSpec: () => (/* binding */ ApiSpec),\n/* harmony export */   AuthType: () => (/* binding */ AuthType),\n/* harmony export */   Batches: () => (/* binding */ Batches),\n/* harmony export */   Behavior: () => (/* binding */ Behavior),\n/* harmony export */   BlockedReason: () => (/* binding */ BlockedReason),\n/* harmony export */   Caches: () => (/* binding */ Caches),\n/* harmony export */   CancelTuningJobResponse: () => (/* binding */ CancelTuningJobResponse),\n/* harmony export */   Chat: () => (/* binding */ Chat),\n/* harmony export */   Chats: () => (/* binding */ Chats),\n/* harmony export */   ComputeTokensResponse: () => (/* binding */ ComputeTokensResponse),\n/* harmony export */   ContentReferenceImage: () => (/* binding */ ContentReferenceImage),\n/* harmony export */   ControlReferenceImage: () => (/* binding */ ControlReferenceImage),\n/* harmony export */   ControlReferenceType: () => (/* binding */ ControlReferenceType),\n/* harmony export */   CountTokensResponse: () => (/* binding */ CountTokensResponse),\n/* harmony export */   CreateFileResponse: () => (/* binding */ CreateFileResponse),\n/* harmony export */   DeleteCachedContentResponse: () => (/* binding */ DeleteCachedContentResponse),\n/* harmony export */   DeleteFileResponse: () => (/* binding */ DeleteFileResponse),\n/* harmony export */   DeleteModelResponse: () => (/* binding */ DeleteModelResponse),\n/* harmony export */   DocumentState: () => (/* binding */ DocumentState),\n/* harmony export */   DynamicRetrievalConfigMode: () => (/* binding */ DynamicRetrievalConfigMode),\n/* harmony export */   EditImageResponse: () => (/* binding */ EditImageResponse),\n/* harmony export */   EditMode: () => (/* binding */ EditMode),\n/* harmony export */   EmbedContentResponse: () => (/* binding */ EmbedContentResponse),\n/* harmony export */   EndSensitivity: () => (/* binding */ EndSensitivity),\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   FeatureSelectionPreference: () => (/* binding */ FeatureSelectionPreference),\n/* harmony export */   FileSource: () => (/* binding */ FileSource),\n/* harmony export */   FileState: () => (/* binding */ FileState),\n/* harmony export */   Files: () => (/* binding */ Files),\n/* harmony export */   FinishReason: () => (/* binding */ FinishReason),\n/* harmony export */   FunctionCallingConfigMode: () => (/* binding */ FunctionCallingConfigMode),\n/* harmony export */   FunctionResponse: () => (/* binding */ FunctionResponse),\n/* harmony export */   FunctionResponseBlob: () => (/* binding */ FunctionResponseBlob),\n/* harmony export */   FunctionResponseFileData: () => (/* binding */ FunctionResponseFileData),\n/* harmony export */   FunctionResponsePart: () => (/* binding */ FunctionResponsePart),\n/* harmony export */   FunctionResponseScheduling: () => (/* binding */ FunctionResponseScheduling),\n/* harmony export */   GenerateContentResponse: () => (/* binding */ GenerateContentResponse),\n/* harmony export */   GenerateContentResponsePromptFeedback: () => (/* binding */ GenerateContentResponsePromptFeedback),\n/* harmony export */   GenerateContentResponseUsageMetadata: () => (/* binding */ GenerateContentResponseUsageMetadata),\n/* harmony export */   GenerateImagesResponse: () => (/* binding */ GenerateImagesResponse),\n/* harmony export */   GenerateVideosOperation: () => (/* binding */ GenerateVideosOperation),\n/* harmony export */   GenerateVideosResponse: () => (/* binding */ GenerateVideosResponse),\n/* harmony export */   GoogleGenAI: () => (/* binding */ GoogleGenAI),\n/* harmony export */   HarmBlockMethod: () => (/* binding */ HarmBlockMethod),\n/* harmony export */   HarmBlockThreshold: () => (/* binding */ HarmBlockThreshold),\n/* harmony export */   HarmCategory: () => (/* binding */ HarmCategory),\n/* harmony export */   HarmProbability: () => (/* binding */ HarmProbability),\n/* harmony export */   HarmSeverity: () => (/* binding */ HarmSeverity),\n/* harmony export */   HttpElementLocation: () => (/* binding */ HttpElementLocation),\n/* harmony export */   HttpResponse: () => (/* binding */ HttpResponse),\n/* harmony export */   ImagePromptLanguage: () => (/* binding */ ImagePromptLanguage),\n/* harmony export */   ImportFileOperation: () => (/* binding */ ImportFileOperation),\n/* harmony export */   ImportFileResponse: () => (/* binding */ ImportFileResponse),\n/* harmony export */   InlinedEmbedContentResponse: () => (/* binding */ InlinedEmbedContentResponse),\n/* harmony export */   InlinedResponse: () => (/* binding */ InlinedResponse),\n/* harmony export */   JobState: () => (/* binding */ JobState),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   ListBatchJobsResponse: () => (/* binding */ ListBatchJobsResponse),\n/* harmony export */   ListCachedContentsResponse: () => (/* binding */ ListCachedContentsResponse),\n/* harmony export */   ListDocumentsResponse: () => (/* binding */ ListDocumentsResponse),\n/* harmony export */   ListFileSearchStoresResponse: () => (/* binding */ ListFileSearchStoresResponse),\n/* harmony export */   ListFilesResponse: () => (/* binding */ ListFilesResponse),\n/* harmony export */   ListModelsResponse: () => (/* binding */ ListModelsResponse),\n/* harmony export */   ListTuningJobsResponse: () => (/* binding */ ListTuningJobsResponse),\n/* harmony export */   Live: () => (/* binding */ Live),\n/* harmony export */   LiveClientToolResponse: () => (/* binding */ LiveClientToolResponse),\n/* harmony export */   LiveMusicPlaybackControl: () => (/* binding */ LiveMusicPlaybackControl),\n/* harmony export */   LiveMusicServerMessage: () => (/* binding */ LiveMusicServerMessage),\n/* harmony export */   LiveSendToolResponseParameters: () => (/* binding */ LiveSendToolResponseParameters),\n/* harmony export */   LiveServerMessage: () => (/* binding */ LiveServerMessage),\n/* harmony export */   MaskReferenceImage: () => (/* binding */ MaskReferenceImage),\n/* harmony export */   MaskReferenceMode: () => (/* binding */ MaskReferenceMode),\n/* harmony export */   MediaModality: () => (/* binding */ MediaModality),\n/* harmony export */   MediaResolution: () => (/* binding */ MediaResolution),\n/* harmony export */   Modality: () => (/* binding */ Modality),\n/* harmony export */   Models: () => (/* binding */ Models),\n/* harmony export */   MusicGenerationMode: () => (/* binding */ MusicGenerationMode),\n/* harmony export */   Operations: () => (/* binding */ Operations),\n/* harmony export */   Outcome: () => (/* binding */ Outcome),\n/* harmony export */   PagedItem: () => (/* binding */ PagedItem),\n/* harmony export */   Pager: () => (/* binding */ Pager),\n/* harmony export */   PartMediaResolutionLevel: () => (/* binding */ PartMediaResolutionLevel),\n/* harmony export */   PersonGeneration: () => (/* binding */ PersonGeneration),\n/* harmony export */   PhishBlockThreshold: () => (/* binding */ PhishBlockThreshold),\n/* harmony export */   RawReferenceImage: () => (/* binding */ RawReferenceImage),\n/* harmony export */   RecontextImageResponse: () => (/* binding */ RecontextImageResponse),\n/* harmony export */   RegisterFilesResponse: () => (/* binding */ RegisterFilesResponse),\n/* harmony export */   ReplayResponse: () => (/* binding */ ReplayResponse),\n/* harmony export */   ResourceScope: () => (/* binding */ ResourceScope),\n/* harmony export */   SafetyFilterLevel: () => (/* binding */ SafetyFilterLevel),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   SegmentImageResponse: () => (/* binding */ SegmentImageResponse),\n/* harmony export */   SegmentMode: () => (/* binding */ SegmentMode),\n/* harmony export */   Session: () => (/* binding */ Session),\n/* harmony export */   SingleEmbedContentResponse: () => (/* binding */ SingleEmbedContentResponse),\n/* harmony export */   StartSensitivity: () => (/* binding */ StartSensitivity),\n/* harmony export */   StyleReferenceImage: () => (/* binding */ StyleReferenceImage),\n/* harmony export */   SubjectReferenceImage: () => (/* binding */ SubjectReferenceImage),\n/* harmony export */   SubjectReferenceType: () => (/* binding */ SubjectReferenceType),\n/* harmony export */   ThinkingLevel: () => (/* binding */ ThinkingLevel),\n/* harmony export */   Tokens: () => (/* binding */ Tokens),\n/* harmony export */   TrafficType: () => (/* binding */ TrafficType),\n/* harmony export */   TuningMethod: () => (/* binding */ TuningMethod),\n/* harmony export */   TuningMode: () => (/* binding */ TuningMode),\n/* harmony export */   TuningTask: () => (/* binding */ TuningTask),\n/* harmony export */   TurnCompleteReason: () => (/* binding */ TurnCompleteReason),\n/* harmony export */   TurnCoverage: () => (/* binding */ TurnCoverage),\n/* harmony export */   Type: () => (/* binding */ Type),\n/* harmony export */   UploadToFileSearchStoreOperation: () => (/* binding */ UploadToFileSearchStoreOperation),\n/* harmony export */   UploadToFileSearchStoreResponse: () => (/* binding */ UploadToFileSearchStoreResponse),\n/* harmony export */   UploadToFileSearchStoreResumableResponse: () => (/* binding */ UploadToFileSearchStoreResumableResponse),\n/* harmony export */   UpscaleImageResponse: () => (/* binding */ UpscaleImageResponse),\n/* harmony export */   UrlRetrievalStatus: () => (/* binding */ UrlRetrievalStatus),\n/* harmony export */   VadSignalType: () => (/* binding */ VadSignalType),\n/* harmony export */   VideoCompressionQuality: () => (/* binding */ VideoCompressionQuality),\n/* harmony export */   VideoGenerationMaskMode: () => (/* binding */ VideoGenerationMaskMode),\n/* harmony export */   VideoGenerationReferenceType: () => (/* binding */ VideoGenerationReferenceType),\n/* harmony export */   VoiceActivityType: () => (/* binding */ VoiceActivityType),\n/* harmony export */   createFunctionResponsePartFromBase64: () => (/* binding */ createFunctionResponsePartFromBase64),\n/* harmony export */   createFunctionResponsePartFromUri: () => (/* binding */ createFunctionResponsePartFromUri),\n/* harmony export */   createModelContent: () => (/* binding */ createModelContent),\n/* harmony export */   createPartFromBase64: () => (/* binding */ createPartFromBase64),\n/* harmony export */   createPartFromCodeExecutionResult: () => (/* binding */ createPartFromCodeExecutionResult),\n/* harmony export */   createPartFromExecutableCode: () => (/* binding */ createPartFromExecutableCode),\n/* harmony export */   createPartFromFunctionCall: () => (/* binding */ createPartFromFunctionCall),\n/* harmony export */   createPartFromFunctionResponse: () => (/* binding */ createPartFromFunctionResponse),\n/* harmony export */   createPartFromText: () => (/* binding */ createPartFromText),\n/* harmony export */   createPartFromUri: () => (/* binding */ createPartFromUri),\n/* harmony export */   createUserContent: () => (/* binding */ createUserContent),\n/* harmony export */   mcpToTool: () => (/* binding */ mcpToTool),\n/* harmony export */   setDefaultBaseUrls: () => (/* binding */ setDefaultBaseUrls)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nlet _defaultBaseGeminiUrl = undefined;\nlet _defaultBaseVertexUrl = undefined;\n/**\n * Overrides the base URLs for the Gemini API and Vertex AI API.\n *\n * @remarks This function should be called before initializing the SDK. If the\n * base URLs are set after initializing the SDK, the base URLs will not be\n * updated. Base URLs provided in the HttpOptions will also take precedence over\n * URLs set here.\n *\n * @example\n * ```ts\n * import {GoogleGenAI, setDefaultBaseUrls} from '@google/genai';\n * // Override the base URL for the Gemini API.\n * setDefaultBaseUrls({geminiUrl:'https://gemini.google.com'});\n *\n * // Override the base URL for the Vertex AI API.\n * setDefaultBaseUrls({vertexUrl: 'https://vertexai.googleapis.com'});\n *\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n */\nfunction setDefaultBaseUrls(baseUrlParams) {\n    _defaultBaseGeminiUrl = baseUrlParams.geminiUrl;\n    _defaultBaseVertexUrl = baseUrlParams.vertexUrl;\n}\n/**\n * Returns the default base URLs for the Gemini API and Vertex AI API.\n */\nfunction getDefaultBaseUrls() {\n    return {\n        geminiUrl: _defaultBaseGeminiUrl,\n        vertexUrl: _defaultBaseVertexUrl,\n    };\n}\n/**\n * Returns the default base URL based on the following priority:\n *   1. Base URLs set via HttpOptions.\n *   2. Base URLs set via the latest call to setDefaultBaseUrls.\n *   3. Base URLs set via environment variables.\n */\nfunction getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {\n    var _a, _b;\n    if (!(httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.baseUrl)) {\n        const defaultBaseUrls = getDefaultBaseUrls();\n        if (vertexai) {\n            return (_a = defaultBaseUrls.vertexUrl) !== null && _a !== void 0 ? _a : vertexBaseUrlFromEnv;\n        }\n        else {\n            return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== void 0 ? _b : geminiBaseUrlFromEnv;\n        }\n    }\n    return httpOptions.baseUrl;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass BaseModule {\n}\nfunction formatMap(templateString, valueMap) {\n    // Use a regular expression to find all placeholders in the template string\n    const regex = /\\{([^}]+)\\}/g;\n    // Replace each placeholder with its corresponding value from the valueMap\n    return templateString.replace(regex, (match, key) => {\n        if (Object.prototype.hasOwnProperty.call(valueMap, key)) {\n            const value = valueMap[key];\n            // Convert the value to a string if it's not a string already\n            return value !== undefined && value !== null ? String(value) : '';\n        }\n        else {\n            // Handle missing keys\n            throw new Error(`Key '${key}' not found in valueMap.`);\n        }\n    });\n}\nfunction setValueByPath(data, keys, value) {\n    for (let i = 0; i < keys.length - 1; i++) {\n        const key = keys[i];\n        if (key.endsWith('[]')) {\n            const keyName = key.slice(0, -2);\n            if (!(keyName in data)) {\n                if (Array.isArray(value)) {\n                    data[keyName] = Array.from({ length: value.length }, () => ({}));\n                }\n                else {\n                    throw new Error(`Value must be a list given an array path ${key}`);\n                }\n            }\n            if (Array.isArray(data[keyName])) {\n                const arrayData = data[keyName];\n                if (Array.isArray(value)) {\n                    for (let j = 0; j < arrayData.length; j++) {\n                        const entry = arrayData[j];\n                        setValueByPath(entry, keys.slice(i + 1), value[j]);\n                    }\n                }\n                else {\n                    for (const d of arrayData) {\n                        setValueByPath(d, keys.slice(i + 1), value);\n                    }\n                }\n            }\n            return;\n        }\n        else if (key.endsWith('[0]')) {\n            const keyName = key.slice(0, -3);\n            if (!(keyName in data)) {\n                data[keyName] = [{}];\n            }\n            const arrayData = data[keyName];\n            setValueByPath(arrayData[0], keys.slice(i + 1), value);\n            return;\n        }\n        if (!data[key] || typeof data[key] !== 'object') {\n            data[key] = {};\n        }\n        data = data[key];\n    }\n    const keyToSet = keys[keys.length - 1];\n    const existingData = data[keyToSet];\n    if (existingData !== undefined) {\n        if (!value ||\n            (typeof value === 'object' && Object.keys(value).length === 0)) {\n            return;\n        }\n        if (value === existingData) {\n            return;\n        }\n        if (typeof existingData === 'object' &&\n            typeof value === 'object' &&\n            existingData !== null &&\n            value !== null) {\n            Object.assign(existingData, value);\n        }\n        else {\n            throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);\n        }\n    }\n    else {\n        if (keyToSet === '_self' &&\n            typeof value === 'object' &&\n            value !== null &&\n            !Array.isArray(value)) {\n            const valueAsRecord = value;\n            Object.assign(data, valueAsRecord);\n        }\n        else {\n            data[keyToSet] = value;\n        }\n    }\n}\nfunction getValueByPath(data, keys, defaultValue = undefined) {\n    try {\n        if (keys.length === 1 && keys[0] === '_self') {\n            return data;\n        }\n        for (let i = 0; i < keys.length; i++) {\n            if (typeof data !== 'object' || data === null) {\n                return defaultValue;\n            }\n            const key = keys[i];\n            if (key.endsWith('[]')) {\n                const keyName = key.slice(0, -2);\n                if (keyName in data) {\n                    const arrayData = data[keyName];\n                    if (!Array.isArray(arrayData)) {\n                        return defaultValue;\n                    }\n                    return arrayData.map((d) => getValueByPath(d, keys.slice(i + 1), defaultValue));\n                }\n                else {\n                    return defaultValue;\n                }\n            }\n            else {\n                data = data[key];\n            }\n        }\n        return data;\n    }\n    catch (error) {\n        if (error instanceof TypeError) {\n            return defaultValue;\n        }\n        throw error;\n    }\n}\n/**\n * Moves values from source paths to destination paths.\n *\n * Examples:\n *   moveValueByPath(\n *     {'requests': [{'content': v1}, {'content': v2}]},\n *     {'requests[].*': 'requests[].request.*'}\n *   )\n *     -> {'requests': [{'request': {'content': v1}}, {'request': {'content': v2}}]}\n */\nfunction moveValueByPath(data, paths) {\n    for (const [sourcePath, destPath] of Object.entries(paths)) {\n        const sourceKeys = sourcePath.split('.');\n        const destKeys = destPath.split('.');\n        // Determine keys to exclude from wildcard to avoid cyclic references\n        const excludeKeys = new Set();\n        let wildcardIdx = -1;\n        for (let i = 0; i < sourceKeys.length; i++) {\n            if (sourceKeys[i] === '*') {\n                wildcardIdx = i;\n                break;\n            }\n        }\n        if (wildcardIdx !== -1 && destKeys.length > wildcardIdx) {\n            // Extract the intermediate key between source and dest paths\n            // Example: source=['requests[]', '*'], dest=['requests[]', 'request', '*']\n            // We want to exclude 'request'\n            for (let i = wildcardIdx; i < destKeys.length; i++) {\n                const key = destKeys[i];\n                if (key !== '*' && !key.endsWith('[]') && !key.endsWith('[0]')) {\n                    excludeKeys.add(key);\n                }\n            }\n        }\n        _moveValueRecursive(data, sourceKeys, destKeys, 0, excludeKeys);\n    }\n}\n/**\n * Recursively moves values from source path to destination path.\n */\nfunction _moveValueRecursive(data, sourceKeys, destKeys, keyIdx, excludeKeys) {\n    if (keyIdx >= sourceKeys.length) {\n        return;\n    }\n    if (typeof data !== 'object' || data === null) {\n        return;\n    }\n    const key = sourceKeys[keyIdx];\n    if (key.endsWith('[]')) {\n        const keyName = key.slice(0, -2);\n        const dataRecord = data;\n        if (keyName in dataRecord && Array.isArray(dataRecord[keyName])) {\n            for (const item of dataRecord[keyName]) {\n                _moveValueRecursive(item, sourceKeys, destKeys, keyIdx + 1, excludeKeys);\n            }\n        }\n    }\n    else if (key === '*') {\n        // wildcard - move all fields\n        if (typeof data === 'object' && data !== null && !Array.isArray(data)) {\n            const dataRecord = data;\n            const keysToMove = Object.keys(dataRecord).filter((k) => !k.startsWith('_') && !excludeKeys.has(k));\n            const valuesToMove = {};\n            for (const k of keysToMove) {\n                valuesToMove[k] = dataRecord[k];\n            }\n            // Set values at destination\n            for (const [k, v] of Object.entries(valuesToMove)) {\n                const newDestKeys = [];\n                for (const dk of destKeys.slice(keyIdx)) {\n                    if (dk === '*') {\n                        newDestKeys.push(k);\n                    }\n                    else {\n                        newDestKeys.push(dk);\n                    }\n                }\n                setValueByPath(dataRecord, newDestKeys, v);\n            }\n            for (const k of keysToMove) {\n                delete dataRecord[k];\n            }\n        }\n    }\n    else {\n        // Navigate to next level\n        const dataRecord = data;\n        if (key in dataRecord) {\n            _moveValueRecursive(dataRecord[key], sourceKeys, destKeys, keyIdx + 1, excludeKeys);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction tBytes$1(fromBytes) {\n    if (typeof fromBytes !== 'string') {\n        throw new Error('fromImageBytes must be a string');\n    }\n    // TODO(b/389133914): Remove dummy bytes converter.\n    return fromBytes;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction fetchPredictOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        'operationName',\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, ['operationName'], fromOperationName);\n    }\n    const fromResourceName = getValueByPath(fromObject, ['resourceName']);\n    if (fromResourceName != null) {\n        setValueByPath(toObject, ['_url', 'resourceName'], fromResourceName);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        'response',\n        'generateVideoResponse',\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateVideosResponseFromMldev$1(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateVideosResponseFromVertex$1(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        'generatedSamples',\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedVideoFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedVideos'], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        'raiMediaFilteredCount',\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, ['raiMediaFilteredCount'], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        'raiMediaFilteredReasons',\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, ['raiMediaFilteredReasons'], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, ['videos']);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedVideoFromVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedVideos'], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        'raiMediaFilteredCount',\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, ['raiMediaFilteredCount'], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        'raiMediaFilteredReasons',\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, ['raiMediaFilteredReasons'], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], videoFromMldev$1(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, ['_self']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], videoFromVertex$1(fromVideo));\n    }\n    return toObject;\n}\nfunction getOperationParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        'operationName',\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, ['_url', 'operationName'], fromOperationName);\n    }\n    return toObject;\n}\nfunction getOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        'operationName',\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, ['_url', 'operationName'], fromOperationName);\n    }\n    return toObject;\n}\nfunction importFileOperationFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], importFileResponseFromMldev$1(fromResponse));\n    }\n    return toObject;\n}\nfunction importFileResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromParent = getValueByPath(fromObject, ['parent']);\n    if (fromParent != null) {\n        setValueByPath(toObject, ['parent'], fromParent);\n    }\n    const fromDocumentName = getValueByPath(fromObject, ['documentName']);\n    if (fromDocumentName != null) {\n        setValueByPath(toObject, ['documentName'], fromDocumentName);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], uploadToFileSearchStoreResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromParent = getValueByPath(fromObject, ['parent']);\n    if (fromParent != null) {\n        setValueByPath(toObject, ['parent'], fromParent);\n    }\n    const fromDocumentName = getValueByPath(fromObject, ['documentName']);\n    if (fromDocumentName != null) {\n        setValueByPath(toObject, ['documentName'], fromDocumentName);\n    }\n    return toObject;\n}\nfunction videoFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['uri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, ['encodedVideo']);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['videoBytes'], tBytes$1(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['encoding']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        'bytesBase64Encoded',\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['videoBytes'], tBytes$1(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/** Outcome of the code execution. */\nvar Outcome;\n(function (Outcome) {\n    /**\n     * Unspecified status. This value should not be used.\n     */\n    Outcome[\"OUTCOME_UNSPECIFIED\"] = \"OUTCOME_UNSPECIFIED\";\n    /**\n     * Code execution completed successfully.\n     */\n    Outcome[\"OUTCOME_OK\"] = \"OUTCOME_OK\";\n    /**\n     * Code execution finished but with a failure. `stderr` should contain the reason.\n     */\n    Outcome[\"OUTCOME_FAILED\"] = \"OUTCOME_FAILED\";\n    /**\n     * Code execution ran for too long, and was cancelled. There may or may not be a partial output present.\n     */\n    Outcome[\"OUTCOME_DEADLINE_EXCEEDED\"] = \"OUTCOME_DEADLINE_EXCEEDED\";\n})(Outcome || (Outcome = {}));\n/** Programming language of the `code`. */\nvar Language;\n(function (Language) {\n    /**\n     * Unspecified language. This value should not be used.\n     */\n    Language[\"LANGUAGE_UNSPECIFIED\"] = \"LANGUAGE_UNSPECIFIED\";\n    /**\n     * Python >= 3.10, with numpy and simpy available.\n     */\n    Language[\"PYTHON\"] = \"PYTHON\";\n})(Language || (Language = {}));\n/** Specifies how the response should be scheduled in the conversation. */\nvar FunctionResponseScheduling;\n(function (FunctionResponseScheduling) {\n    /**\n     * This value is unused.\n     */\n    FunctionResponseScheduling[\"SCHEDULING_UNSPECIFIED\"] = \"SCHEDULING_UNSPECIFIED\";\n    /**\n     * Only add the result to the conversation context, do not interrupt or trigger generation.\n     */\n    FunctionResponseScheduling[\"SILENT\"] = \"SILENT\";\n    /**\n     * Add the result to the conversation context, and prompt to generate output without interrupting ongoing generation.\n     */\n    FunctionResponseScheduling[\"WHEN_IDLE\"] = \"WHEN_IDLE\";\n    /**\n     * Add the result to the conversation context, interrupt ongoing generation and prompt to generate output.\n     */\n    FunctionResponseScheduling[\"INTERRUPT\"] = \"INTERRUPT\";\n})(FunctionResponseScheduling || (FunctionResponseScheduling = {}));\n/** The type of the data. */\nvar Type;\n(function (Type) {\n    /**\n     * Not specified, should not be used.\n     */\n    Type[\"TYPE_UNSPECIFIED\"] = \"TYPE_UNSPECIFIED\";\n    /**\n     * OpenAPI string type\n     */\n    Type[\"STRING\"] = \"STRING\";\n    /**\n     * OpenAPI number type\n     */\n    Type[\"NUMBER\"] = \"NUMBER\";\n    /**\n     * OpenAPI integer type\n     */\n    Type[\"INTEGER\"] = \"INTEGER\";\n    /**\n     * OpenAPI boolean type\n     */\n    Type[\"BOOLEAN\"] = \"BOOLEAN\";\n    /**\n     * OpenAPI array type\n     */\n    Type[\"ARRAY\"] = \"ARRAY\";\n    /**\n     * OpenAPI object type\n     */\n    Type[\"OBJECT\"] = \"OBJECT\";\n    /**\n     * Null type\n     */\n    Type[\"NULL\"] = \"NULL\";\n})(Type || (Type = {}));\n/** The API spec that the external API implements. This enum is not supported in Gemini API. */\nvar ApiSpec;\n(function (ApiSpec) {\n    /**\n     * Unspecified API spec. This value should not be used.\n     */\n    ApiSpec[\"API_SPEC_UNSPECIFIED\"] = \"API_SPEC_UNSPECIFIED\";\n    /**\n     * Simple search API spec.\n     */\n    ApiSpec[\"SIMPLE_SEARCH\"] = \"SIMPLE_SEARCH\";\n    /**\n     * Elastic search API spec.\n     */\n    ApiSpec[\"ELASTIC_SEARCH\"] = \"ELASTIC_SEARCH\";\n})(ApiSpec || (ApiSpec = {}));\n/** Type of auth scheme. This enum is not supported in Gemini API. */\nvar AuthType;\n(function (AuthType) {\n    AuthType[\"AUTH_TYPE_UNSPECIFIED\"] = \"AUTH_TYPE_UNSPECIFIED\";\n    /**\n     * No Auth.\n     */\n    AuthType[\"NO_AUTH\"] = \"NO_AUTH\";\n    /**\n     * API Key Auth.\n     */\n    AuthType[\"API_KEY_AUTH\"] = \"API_KEY_AUTH\";\n    /**\n     * HTTP Basic Auth.\n     */\n    AuthType[\"HTTP_BASIC_AUTH\"] = \"HTTP_BASIC_AUTH\";\n    /**\n     * Google Service Account Auth.\n     */\n    AuthType[\"GOOGLE_SERVICE_ACCOUNT_AUTH\"] = \"GOOGLE_SERVICE_ACCOUNT_AUTH\";\n    /**\n     * OAuth auth.\n     */\n    AuthType[\"OAUTH\"] = \"OAUTH\";\n    /**\n     * OpenID Connect (OIDC) Auth.\n     */\n    AuthType[\"OIDC_AUTH\"] = \"OIDC_AUTH\";\n})(AuthType || (AuthType = {}));\n/** The location of the API key. This enum is not supported in Gemini API. */\nvar HttpElementLocation;\n(function (HttpElementLocation) {\n    HttpElementLocation[\"HTTP_IN_UNSPECIFIED\"] = \"HTTP_IN_UNSPECIFIED\";\n    /**\n     * Element is in the HTTP request query.\n     */\n    HttpElementLocation[\"HTTP_IN_QUERY\"] = \"HTTP_IN_QUERY\";\n    /**\n     * Element is in the HTTP request header.\n     */\n    HttpElementLocation[\"HTTP_IN_HEADER\"] = \"HTTP_IN_HEADER\";\n    /**\n     * Element is in the HTTP request path.\n     */\n    HttpElementLocation[\"HTTP_IN_PATH\"] = \"HTTP_IN_PATH\";\n    /**\n     * Element is in the HTTP request body.\n     */\n    HttpElementLocation[\"HTTP_IN_BODY\"] = \"HTTP_IN_BODY\";\n    /**\n     * Element is in the HTTP request cookie.\n     */\n    HttpElementLocation[\"HTTP_IN_COOKIE\"] = \"HTTP_IN_COOKIE\";\n})(HttpElementLocation || (HttpElementLocation = {}));\n/** Sites with confidence level chosen & above this value will be blocked from the search results. This enum is not supported in Gemini API. */\nvar PhishBlockThreshold;\n(function (PhishBlockThreshold) {\n    /**\n     * Defaults to unspecified.\n     */\n    PhishBlockThreshold[\"PHISH_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"PHISH_BLOCK_THRESHOLD_UNSPECIFIED\";\n    /**\n     * Blocks Low and above confidence URL that is risky.\n     */\n    PhishBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    /**\n     * Blocks Medium and above confidence URL that is risky.\n     */\n    PhishBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    /**\n     * Blocks High and above confidence URL that is risky.\n     */\n    PhishBlockThreshold[\"BLOCK_HIGH_AND_ABOVE\"] = \"BLOCK_HIGH_AND_ABOVE\";\n    /**\n     * Blocks Higher and above confidence URL that is risky.\n     */\n    PhishBlockThreshold[\"BLOCK_HIGHER_AND_ABOVE\"] = \"BLOCK_HIGHER_AND_ABOVE\";\n    /**\n     * Blocks Very high and above confidence URL that is risky.\n     */\n    PhishBlockThreshold[\"BLOCK_VERY_HIGH_AND_ABOVE\"] = \"BLOCK_VERY_HIGH_AND_ABOVE\";\n    /**\n     * Blocks Extremely high confidence URL that is risky.\n     */\n    PhishBlockThreshold[\"BLOCK_ONLY_EXTREMELY_HIGH\"] = \"BLOCK_ONLY_EXTREMELY_HIGH\";\n})(PhishBlockThreshold || (PhishBlockThreshold = {}));\n/** Specifies the function Behavior. Currently only supported by the BidiGenerateContent method. This enum is not supported in Vertex AI. */\nvar Behavior;\n(function (Behavior) {\n    /**\n     * This value is unused.\n     */\n    Behavior[\"UNSPECIFIED\"] = \"UNSPECIFIED\";\n    /**\n     * If set, the system will wait to receive the function response before continuing the conversation.\n     */\n    Behavior[\"BLOCKING\"] = \"BLOCKING\";\n    /**\n     * If set, the system will not wait to receive the function response. Instead, it will attempt to handle function responses as they become available while maintaining the conversation between the user and the model.\n     */\n    Behavior[\"NON_BLOCKING\"] = \"NON_BLOCKING\";\n})(Behavior || (Behavior = {}));\n/** The mode of the predictor to be used in dynamic retrieval. */\nvar DynamicRetrievalConfigMode;\n(function (DynamicRetrievalConfigMode) {\n    /**\n     * Always trigger retrieval.\n     */\n    DynamicRetrievalConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Run retrieval only when system decides it is necessary.\n     */\n    DynamicRetrievalConfigMode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));\n/** Function calling mode. */\nvar FunctionCallingConfigMode;\n(function (FunctionCallingConfigMode) {\n    /**\n     * Unspecified function calling mode. This value should not be used.\n     */\n    FunctionCallingConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Default model behavior, model decides to predict either function calls or natural language response.\n     */\n    FunctionCallingConfigMode[\"AUTO\"] = \"AUTO\";\n    /**\n     * Model is constrained to always predicting function calls only. If \"allowed_function_names\" are set, the predicted function calls will be limited to any one of \"allowed_function_names\", else the predicted function calls will be any one of the provided \"function_declarations\".\n     */\n    FunctionCallingConfigMode[\"ANY\"] = \"ANY\";\n    /**\n     * Model will not predict any function calls. Model behavior is same as when not passing any function declarations.\n     */\n    FunctionCallingConfigMode[\"NONE\"] = \"NONE\";\n    /**\n     * Model is constrained to predict either function calls or natural language response. If \"allowed_function_names\" are set, the predicted function calls will be limited to any one of \"allowed_function_names\", else the predicted function calls will be any one of the provided \"function_declarations\".\n     */\n    FunctionCallingConfigMode[\"VALIDATED\"] = \"VALIDATED\";\n})(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));\n/** The number of thoughts tokens that the model should generate. */\nvar ThinkingLevel;\n(function (ThinkingLevel) {\n    /**\n     * Unspecified thinking level.\n     */\n    ThinkingLevel[\"THINKING_LEVEL_UNSPECIFIED\"] = \"THINKING_LEVEL_UNSPECIFIED\";\n    /**\n     * Low thinking level.\n     */\n    ThinkingLevel[\"LOW\"] = \"LOW\";\n    /**\n     * Medium thinking level.\n     */\n    ThinkingLevel[\"MEDIUM\"] = \"MEDIUM\";\n    /**\n     * High thinking level.\n     */\n    ThinkingLevel[\"HIGH\"] = \"HIGH\";\n    /**\n     * MINIMAL thinking level.\n     */\n    ThinkingLevel[\"MINIMAL\"] = \"MINIMAL\";\n})(ThinkingLevel || (ThinkingLevel = {}));\n/** Harm category. */\nvar HarmCategory;\n(function (HarmCategory) {\n    /**\n     * The harm category is unspecified.\n     */\n    HarmCategory[\"HARM_CATEGORY_UNSPECIFIED\"] = \"HARM_CATEGORY_UNSPECIFIED\";\n    /**\n     * The harm category is harassment.\n     */\n    HarmCategory[\"HARM_CATEGORY_HARASSMENT\"] = \"HARM_CATEGORY_HARASSMENT\";\n    /**\n     * The harm category is hate speech.\n     */\n    HarmCategory[\"HARM_CATEGORY_HATE_SPEECH\"] = \"HARM_CATEGORY_HATE_SPEECH\";\n    /**\n     * The harm category is sexually explicit content.\n     */\n    HarmCategory[\"HARM_CATEGORY_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_SEXUALLY_EXPLICIT\";\n    /**\n     * The harm category is dangerous content.\n     */\n    HarmCategory[\"HARM_CATEGORY_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_DANGEROUS_CONTENT\";\n    /**\n     * Deprecated: Election filter is not longer supported. The harm category is civic integrity.\n     */\n    HarmCategory[\"HARM_CATEGORY_CIVIC_INTEGRITY\"] = \"HARM_CATEGORY_CIVIC_INTEGRITY\";\n    /**\n     * The harm category is image hate. This enum value is not supported in Gemini API.\n     */\n    HarmCategory[\"HARM_CATEGORY_IMAGE_HATE\"] = \"HARM_CATEGORY_IMAGE_HATE\";\n    /**\n     * The harm category is image dangerous content. This enum value is not supported in Gemini API.\n     */\n    HarmCategory[\"HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT\";\n    /**\n     * The harm category is image harassment. This enum value is not supported in Gemini API.\n     */\n    HarmCategory[\"HARM_CATEGORY_IMAGE_HARASSMENT\"] = \"HARM_CATEGORY_IMAGE_HARASSMENT\";\n    /**\n     * The harm category is image sexually explicit content. This enum value is not supported in Gemini API.\n     */\n    HarmCategory[\"HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT\";\n    /**\n     * The harm category is for jailbreak prompts. This enum value is not supported in Gemini API.\n     */\n    HarmCategory[\"HARM_CATEGORY_JAILBREAK\"] = \"HARM_CATEGORY_JAILBREAK\";\n})(HarmCategory || (HarmCategory = {}));\n/** Specify if the threshold is used for probability or severity score. If not specified, the threshold is used for probability score. This enum is not supported in Gemini API. */\nvar HarmBlockMethod;\n(function (HarmBlockMethod) {\n    /**\n     * The harm block method is unspecified.\n     */\n    HarmBlockMethod[\"HARM_BLOCK_METHOD_UNSPECIFIED\"] = \"HARM_BLOCK_METHOD_UNSPECIFIED\";\n    /**\n     * The harm block method uses both probability and severity scores.\n     */\n    HarmBlockMethod[\"SEVERITY\"] = \"SEVERITY\";\n    /**\n     * The harm block method uses the probability score.\n     */\n    HarmBlockMethod[\"PROBABILITY\"] = \"PROBABILITY\";\n})(HarmBlockMethod || (HarmBlockMethod = {}));\n/** The harm block threshold. */\nvar HarmBlockThreshold;\n(function (HarmBlockThreshold) {\n    /**\n     * Unspecified harm block threshold.\n     */\n    HarmBlockThreshold[\"HARM_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"HARM_BLOCK_THRESHOLD_UNSPECIFIED\";\n    /**\n     * Block low threshold and above (i.e. block more).\n     */\n    HarmBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    /**\n     * Block medium threshold and above.\n     */\n    HarmBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    /**\n     * Block only high threshold (i.e. block less).\n     */\n    HarmBlockThreshold[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    /**\n     * Block none.\n     */\n    HarmBlockThreshold[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n    /**\n     * Turn off the safety filter.\n     */\n    HarmBlockThreshold[\"OFF\"] = \"OFF\";\n})(HarmBlockThreshold || (HarmBlockThreshold = {}));\n/** Output only. The reason why the model stopped generating tokens.\n\nIf empty, the model has not stopped generating the tokens. */\nvar FinishReason;\n(function (FinishReason) {\n    /**\n     * The finish reason is unspecified.\n     */\n    FinishReason[\"FINISH_REASON_UNSPECIFIED\"] = \"FINISH_REASON_UNSPECIFIED\";\n    /**\n     * Token generation reached a natural stopping point or a configured stop sequence.\n     */\n    FinishReason[\"STOP\"] = \"STOP\";\n    /**\n     * Token generation reached the configured maximum output tokens.\n     */\n    FinishReason[\"MAX_TOKENS\"] = \"MAX_TOKENS\";\n    /**\n     * Token generation stopped because the content potentially contains safety violations. NOTE: When streaming, [content][] is empty if content filters blocks the output.\n     */\n    FinishReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * The token generation stopped because of potential recitation.\n     */\n    FinishReason[\"RECITATION\"] = \"RECITATION\";\n    /**\n     * The token generation stopped because of using an unsupported language.\n     */\n    FinishReason[\"LANGUAGE\"] = \"LANGUAGE\";\n    /**\n     * All other reasons that stopped the token generation.\n     */\n    FinishReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * Token generation stopped because the content contains forbidden terms.\n     */\n    FinishReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * Token generation stopped for potentially containing prohibited content.\n     */\n    FinishReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).\n     */\n    FinishReason[\"SPII\"] = \"SPII\";\n    /**\n     * The function call generated by the model is invalid.\n     */\n    FinishReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    /**\n     * Token generation stopped because generated images have safety violations.\n     */\n    FinishReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n    /**\n     * The tool call generated by the model is invalid.\n     */\n    FinishReason[\"UNEXPECTED_TOOL_CALL\"] = \"UNEXPECTED_TOOL_CALL\";\n    /**\n     * Image generation stopped because the generated images have prohibited content.\n     */\n    FinishReason[\"IMAGE_PROHIBITED_CONTENT\"] = \"IMAGE_PROHIBITED_CONTENT\";\n    /**\n     * The model was expected to generate an image, but none was generated.\n     */\n    FinishReason[\"NO_IMAGE\"] = \"NO_IMAGE\";\n    /**\n     * Image generation stopped because the generated image may be a recitation from a source.\n     */\n    FinishReason[\"IMAGE_RECITATION\"] = \"IMAGE_RECITATION\";\n    /**\n     * Image generation stopped for a reason not otherwise specified.\n     */\n    FinishReason[\"IMAGE_OTHER\"] = \"IMAGE_OTHER\";\n})(FinishReason || (FinishReason = {}));\n/** Output only. Harm probability levels in the content. */\nvar HarmProbability;\n(function (HarmProbability) {\n    /**\n     * Harm probability unspecified.\n     */\n    HarmProbability[\"HARM_PROBABILITY_UNSPECIFIED\"] = \"HARM_PROBABILITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm.\n     */\n    HarmProbability[\"NEGLIGIBLE\"] = \"NEGLIGIBLE\";\n    /**\n     * Low level of harm.\n     */\n    HarmProbability[\"LOW\"] = \"LOW\";\n    /**\n     * Medium level of harm.\n     */\n    HarmProbability[\"MEDIUM\"] = \"MEDIUM\";\n    /**\n     * High level of harm.\n     */\n    HarmProbability[\"HIGH\"] = \"HIGH\";\n})(HarmProbability || (HarmProbability = {}));\n/** Output only. Harm severity levels in the content. This enum is not supported in Gemini API. */\nvar HarmSeverity;\n(function (HarmSeverity) {\n    /**\n     * Harm severity unspecified.\n     */\n    HarmSeverity[\"HARM_SEVERITY_UNSPECIFIED\"] = \"HARM_SEVERITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm severity.\n     */\n    HarmSeverity[\"HARM_SEVERITY_NEGLIGIBLE\"] = \"HARM_SEVERITY_NEGLIGIBLE\";\n    /**\n     * Low level of harm severity.\n     */\n    HarmSeverity[\"HARM_SEVERITY_LOW\"] = \"HARM_SEVERITY_LOW\";\n    /**\n     * Medium level of harm severity.\n     */\n    HarmSeverity[\"HARM_SEVERITY_MEDIUM\"] = \"HARM_SEVERITY_MEDIUM\";\n    /**\n     * High level of harm severity.\n     */\n    HarmSeverity[\"HARM_SEVERITY_HIGH\"] = \"HARM_SEVERITY_HIGH\";\n})(HarmSeverity || (HarmSeverity = {}));\n/** Status of the url retrieval. */\nvar UrlRetrievalStatus;\n(function (UrlRetrievalStatus) {\n    /**\n     * Default value. This value is unused.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSPECIFIED\"] = \"URL_RETRIEVAL_STATUS_UNSPECIFIED\";\n    /**\n     * Url retrieval is successful.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_SUCCESS\"] = \"URL_RETRIEVAL_STATUS_SUCCESS\";\n    /**\n     * Url retrieval is failed due to error.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_ERROR\"] = \"URL_RETRIEVAL_STATUS_ERROR\";\n    /**\n     * Url retrieval is failed because the content is behind paywall. This enum value is not supported in Vertex AI.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_PAYWALL\"] = \"URL_RETRIEVAL_STATUS_PAYWALL\";\n    /**\n     * Url retrieval is failed because the content is unsafe. This enum value is not supported in Vertex AI.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSAFE\"] = \"URL_RETRIEVAL_STATUS_UNSAFE\";\n})(UrlRetrievalStatus || (UrlRetrievalStatus = {}));\n/** Output only. The reason why the prompt was blocked. */\nvar BlockedReason;\n(function (BlockedReason) {\n    /**\n     * The blocked reason is unspecified.\n     */\n    BlockedReason[\"BLOCKED_REASON_UNSPECIFIED\"] = \"BLOCKED_REASON_UNSPECIFIED\";\n    /**\n     * The prompt was blocked for safety reasons.\n     */\n    BlockedReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * The prompt was blocked for other reasons. For example, it may be due to the prompt's language, or because it contains other harmful content.\n     */\n    BlockedReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * The prompt was blocked because it contains a term from the terminology blocklist.\n     */\n    BlockedReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * The prompt was blocked because it contains prohibited content.\n     */\n    BlockedReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * The prompt was blocked because it contains content that is unsafe for image generation.\n     */\n    BlockedReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n    /**\n     * The prompt was blocked by Model Armor. This enum value is not supported in Gemini API.\n     */\n    BlockedReason[\"MODEL_ARMOR\"] = \"MODEL_ARMOR\";\n    /**\n     * The prompt was blocked as a jailbreak attempt. This enum value is not supported in Gemini API.\n     */\n    BlockedReason[\"JAILBREAK\"] = \"JAILBREAK\";\n})(BlockedReason || (BlockedReason = {}));\n/** Output only. The traffic type for this request. This enum is not supported in Gemini API. */\nvar TrafficType;\n(function (TrafficType) {\n    /**\n     * Unspecified request traffic type.\n     */\n    TrafficType[\"TRAFFIC_TYPE_UNSPECIFIED\"] = \"TRAFFIC_TYPE_UNSPECIFIED\";\n    /**\n     * The request was processed using Pay-As-You-Go quota.\n     */\n    TrafficType[\"ON_DEMAND\"] = \"ON_DEMAND\";\n    /**\n     * Type for Provisioned Throughput traffic.\n     */\n    TrafficType[\"PROVISIONED_THROUGHPUT\"] = \"PROVISIONED_THROUGHPUT\";\n})(TrafficType || (TrafficType = {}));\n/** Server content modalities. */\nvar Modality;\n(function (Modality) {\n    /**\n     * The modality is unspecified.\n     */\n    Modality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Indicates the model should return text\n     */\n    Modality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Indicates the model should return images.\n     */\n    Modality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Indicates the model should return audio.\n     */\n    Modality[\"AUDIO\"] = \"AUDIO\";\n})(Modality || (Modality = {}));\n/** The media resolution to use. */\nvar MediaResolution;\n(function (MediaResolution) {\n    /**\n     * Media resolution has not been set\n     */\n    MediaResolution[\"MEDIA_RESOLUTION_UNSPECIFIED\"] = \"MEDIA_RESOLUTION_UNSPECIFIED\";\n    /**\n     * Media resolution set to low (64 tokens).\n     */\n    MediaResolution[\"MEDIA_RESOLUTION_LOW\"] = \"MEDIA_RESOLUTION_LOW\";\n    /**\n     * Media resolution set to medium (256 tokens).\n     */\n    MediaResolution[\"MEDIA_RESOLUTION_MEDIUM\"] = \"MEDIA_RESOLUTION_MEDIUM\";\n    /**\n     * Media resolution set to high (zoomed reframing with 256 tokens).\n     */\n    MediaResolution[\"MEDIA_RESOLUTION_HIGH\"] = \"MEDIA_RESOLUTION_HIGH\";\n})(MediaResolution || (MediaResolution = {}));\n/** Tuning mode. This enum is not supported in Gemini API. */\nvar TuningMode;\n(function (TuningMode) {\n    /**\n     * Tuning mode is unspecified.\n     */\n    TuningMode[\"TUNING_MODE_UNSPECIFIED\"] = \"TUNING_MODE_UNSPECIFIED\";\n    /**\n     * Full fine-tuning mode.\n     */\n    TuningMode[\"TUNING_MODE_FULL\"] = \"TUNING_MODE_FULL\";\n    /**\n     * PEFT adapter tuning mode.\n     */\n    TuningMode[\"TUNING_MODE_PEFT_ADAPTER\"] = \"TUNING_MODE_PEFT_ADAPTER\";\n})(TuningMode || (TuningMode = {}));\n/** Adapter size for tuning. This enum is not supported in Gemini API. */\nvar AdapterSize;\n(function (AdapterSize) {\n    /**\n     * Adapter size is unspecified.\n     */\n    AdapterSize[\"ADAPTER_SIZE_UNSPECIFIED\"] = \"ADAPTER_SIZE_UNSPECIFIED\";\n    /**\n     * Adapter size 1.\n     */\n    AdapterSize[\"ADAPTER_SIZE_ONE\"] = \"ADAPTER_SIZE_ONE\";\n    /**\n     * Adapter size 2.\n     */\n    AdapterSize[\"ADAPTER_SIZE_TWO\"] = \"ADAPTER_SIZE_TWO\";\n    /**\n     * Adapter size 4.\n     */\n    AdapterSize[\"ADAPTER_SIZE_FOUR\"] = \"ADAPTER_SIZE_FOUR\";\n    /**\n     * Adapter size 8.\n     */\n    AdapterSize[\"ADAPTER_SIZE_EIGHT\"] = \"ADAPTER_SIZE_EIGHT\";\n    /**\n     * Adapter size 16.\n     */\n    AdapterSize[\"ADAPTER_SIZE_SIXTEEN\"] = \"ADAPTER_SIZE_SIXTEEN\";\n    /**\n     * Adapter size 32.\n     */\n    AdapterSize[\"ADAPTER_SIZE_THIRTY_TWO\"] = \"ADAPTER_SIZE_THIRTY_TWO\";\n})(AdapterSize || (AdapterSize = {}));\n/** Job state. */\nvar JobState;\n(function (JobState) {\n    /**\n     * The job state is unspecified.\n     */\n    JobState[\"JOB_STATE_UNSPECIFIED\"] = \"JOB_STATE_UNSPECIFIED\";\n    /**\n     * The job has been just created or resumed and processing has not yet begun.\n     */\n    JobState[\"JOB_STATE_QUEUED\"] = \"JOB_STATE_QUEUED\";\n    /**\n     * The service is preparing to run the job.\n     */\n    JobState[\"JOB_STATE_PENDING\"] = \"JOB_STATE_PENDING\";\n    /**\n     * The job is in progress.\n     */\n    JobState[\"JOB_STATE_RUNNING\"] = \"JOB_STATE_RUNNING\";\n    /**\n     * The job completed successfully.\n     */\n    JobState[\"JOB_STATE_SUCCEEDED\"] = \"JOB_STATE_SUCCEEDED\";\n    /**\n     * The job failed.\n     */\n    JobState[\"JOB_STATE_FAILED\"] = \"JOB_STATE_FAILED\";\n    /**\n     * The job is being cancelled. From this state the job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.\n     */\n    JobState[\"JOB_STATE_CANCELLING\"] = \"JOB_STATE_CANCELLING\";\n    /**\n     * The job has been cancelled.\n     */\n    JobState[\"JOB_STATE_CANCELLED\"] = \"JOB_STATE_CANCELLED\";\n    /**\n     * The job has been stopped, and can be resumed.\n     */\n    JobState[\"JOB_STATE_PAUSED\"] = \"JOB_STATE_PAUSED\";\n    /**\n     * The job has expired.\n     */\n    JobState[\"JOB_STATE_EXPIRED\"] = \"JOB_STATE_EXPIRED\";\n    /**\n     * The job is being updated. Only jobs in the `JOB_STATE_RUNNING` state can be updated. After updating, the job goes back to the `JOB_STATE_RUNNING` state.\n     */\n    JobState[\"JOB_STATE_UPDATING\"] = \"JOB_STATE_UPDATING\";\n    /**\n     * The job is partially succeeded, some results may be missing due to errors.\n     */\n    JobState[\"JOB_STATE_PARTIALLY_SUCCEEDED\"] = \"JOB_STATE_PARTIALLY_SUCCEEDED\";\n})(JobState || (JobState = {}));\n/** The tuning task. Either I2V or T2V. This enum is not supported in Gemini API. */\nvar TuningTask;\n(function (TuningTask) {\n    /**\n     * Default value. This value is unused.\n     */\n    TuningTask[\"TUNING_TASK_UNSPECIFIED\"] = \"TUNING_TASK_UNSPECIFIED\";\n    /**\n     * Tuning task for image to video.\n     */\n    TuningTask[\"TUNING_TASK_I2V\"] = \"TUNING_TASK_I2V\";\n    /**\n     * Tuning task for text to video.\n     */\n    TuningTask[\"TUNING_TASK_T2V\"] = \"TUNING_TASK_T2V\";\n    /**\n     * Tuning task for reference to video.\n     */\n    TuningTask[\"TUNING_TASK_R2V\"] = \"TUNING_TASK_R2V\";\n})(TuningTask || (TuningTask = {}));\n/** The tokenization quality used for given media. */\nvar PartMediaResolutionLevel;\n(function (PartMediaResolutionLevel) {\n    /**\n     * Media resolution has not been set.\n     */\n    PartMediaResolutionLevel[\"MEDIA_RESOLUTION_UNSPECIFIED\"] = \"MEDIA_RESOLUTION_UNSPECIFIED\";\n    /**\n     * Media resolution set to low.\n     */\n    PartMediaResolutionLevel[\"MEDIA_RESOLUTION_LOW\"] = \"MEDIA_RESOLUTION_LOW\";\n    /**\n     * Media resolution set to medium.\n     */\n    PartMediaResolutionLevel[\"MEDIA_RESOLUTION_MEDIUM\"] = \"MEDIA_RESOLUTION_MEDIUM\";\n    /**\n     * Media resolution set to high.\n     */\n    PartMediaResolutionLevel[\"MEDIA_RESOLUTION_HIGH\"] = \"MEDIA_RESOLUTION_HIGH\";\n    /**\n     * Media resolution set to ultra high.\n     */\n    PartMediaResolutionLevel[\"MEDIA_RESOLUTION_ULTRA_HIGH\"] = \"MEDIA_RESOLUTION_ULTRA_HIGH\";\n})(PartMediaResolutionLevel || (PartMediaResolutionLevel = {}));\n/** Resource scope. */\nvar ResourceScope;\n(function (ResourceScope) {\n    /**\n     * When setting base_url, this value configures resource scope to be the collection.\n        The resource name will not include api version, project, or location.\n        For example, if base_url is set to \"https://aiplatform.googleapis.com\",\n        then the resource name for a Model would be\n        \"https://aiplatform.googleapis.com/publishers/google/models/gemini-3-pro-preview\n     */\n    ResourceScope[\"COLLECTION\"] = \"COLLECTION\";\n})(ResourceScope || (ResourceScope = {}));\n/** Options for feature selection preference. */\nvar FeatureSelectionPreference;\n(function (FeatureSelectionPreference) {\n    FeatureSelectionPreference[\"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\"] = \"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\";\n    FeatureSelectionPreference[\"PRIORITIZE_QUALITY\"] = \"PRIORITIZE_QUALITY\";\n    FeatureSelectionPreference[\"BALANCED\"] = \"BALANCED\";\n    FeatureSelectionPreference[\"PRIORITIZE_COST\"] = \"PRIORITIZE_COST\";\n})(FeatureSelectionPreference || (FeatureSelectionPreference = {}));\n/** The environment being operated. */\nvar Environment;\n(function (Environment) {\n    /**\n     * Defaults to browser.\n     */\n    Environment[\"ENVIRONMENT_UNSPECIFIED\"] = \"ENVIRONMENT_UNSPECIFIED\";\n    /**\n     * Operates in a web browser.\n     */\n    Environment[\"ENVIRONMENT_BROWSER\"] = \"ENVIRONMENT_BROWSER\";\n})(Environment || (Environment = {}));\n/** Enum that controls the safety filter level for objectionable content. */\nvar SafetyFilterLevel;\n(function (SafetyFilterLevel) {\n    SafetyFilterLevel[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    SafetyFilterLevel[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n})(SafetyFilterLevel || (SafetyFilterLevel = {}));\n/** Enum that controls the generation of people. */\nvar PersonGeneration;\n(function (PersonGeneration) {\n    /**\n     * Block generation of images of people.\n     */\n    PersonGeneration[\"DONT_ALLOW\"] = \"DONT_ALLOW\";\n    /**\n     * Generate images of adults, but not children.\n     */\n    PersonGeneration[\"ALLOW_ADULT\"] = \"ALLOW_ADULT\";\n    /**\n     * Generate images that include adults and children.\n     */\n    PersonGeneration[\"ALLOW_ALL\"] = \"ALLOW_ALL\";\n})(PersonGeneration || (PersonGeneration = {}));\n/** Enum that specifies the language of the text in the prompt. */\nvar ImagePromptLanguage;\n(function (ImagePromptLanguage) {\n    /**\n     * Auto-detect the language.\n     */\n    ImagePromptLanguage[\"auto\"] = \"auto\";\n    /**\n     * English\n     */\n    ImagePromptLanguage[\"en\"] = \"en\";\n    /**\n     * Japanese\n     */\n    ImagePromptLanguage[\"ja\"] = \"ja\";\n    /**\n     * Korean\n     */\n    ImagePromptLanguage[\"ko\"] = \"ko\";\n    /**\n     * Hindi\n     */\n    ImagePromptLanguage[\"hi\"] = \"hi\";\n    /**\n     * Chinese\n     */\n    ImagePromptLanguage[\"zh\"] = \"zh\";\n    /**\n     * Portuguese\n     */\n    ImagePromptLanguage[\"pt\"] = \"pt\";\n    /**\n     * Spanish\n     */\n    ImagePromptLanguage[\"es\"] = \"es\";\n})(ImagePromptLanguage || (ImagePromptLanguage = {}));\n/** Enum representing the mask mode of a mask reference image. */\nvar MaskReferenceMode;\n(function (MaskReferenceMode) {\n    MaskReferenceMode[\"MASK_MODE_DEFAULT\"] = \"MASK_MODE_DEFAULT\";\n    MaskReferenceMode[\"MASK_MODE_USER_PROVIDED\"] = \"MASK_MODE_USER_PROVIDED\";\n    MaskReferenceMode[\"MASK_MODE_BACKGROUND\"] = \"MASK_MODE_BACKGROUND\";\n    MaskReferenceMode[\"MASK_MODE_FOREGROUND\"] = \"MASK_MODE_FOREGROUND\";\n    MaskReferenceMode[\"MASK_MODE_SEMANTIC\"] = \"MASK_MODE_SEMANTIC\";\n})(MaskReferenceMode || (MaskReferenceMode = {}));\n/** Enum representing the control type of a control reference image. */\nvar ControlReferenceType;\n(function (ControlReferenceType) {\n    ControlReferenceType[\"CONTROL_TYPE_DEFAULT\"] = \"CONTROL_TYPE_DEFAULT\";\n    ControlReferenceType[\"CONTROL_TYPE_CANNY\"] = \"CONTROL_TYPE_CANNY\";\n    ControlReferenceType[\"CONTROL_TYPE_SCRIBBLE\"] = \"CONTROL_TYPE_SCRIBBLE\";\n    ControlReferenceType[\"CONTROL_TYPE_FACE_MESH\"] = \"CONTROL_TYPE_FACE_MESH\";\n})(ControlReferenceType || (ControlReferenceType = {}));\n/** Enum representing the subject type of a subject reference image. */\nvar SubjectReferenceType;\n(function (SubjectReferenceType) {\n    SubjectReferenceType[\"SUBJECT_TYPE_DEFAULT\"] = \"SUBJECT_TYPE_DEFAULT\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PERSON\"] = \"SUBJECT_TYPE_PERSON\";\n    SubjectReferenceType[\"SUBJECT_TYPE_ANIMAL\"] = \"SUBJECT_TYPE_ANIMAL\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PRODUCT\"] = \"SUBJECT_TYPE_PRODUCT\";\n})(SubjectReferenceType || (SubjectReferenceType = {}));\n/** Enum representing the editing mode. */\nvar EditMode;\n(function (EditMode) {\n    EditMode[\"EDIT_MODE_DEFAULT\"] = \"EDIT_MODE_DEFAULT\";\n    EditMode[\"EDIT_MODE_INPAINT_REMOVAL\"] = \"EDIT_MODE_INPAINT_REMOVAL\";\n    EditMode[\"EDIT_MODE_INPAINT_INSERTION\"] = \"EDIT_MODE_INPAINT_INSERTION\";\n    EditMode[\"EDIT_MODE_OUTPAINT\"] = \"EDIT_MODE_OUTPAINT\";\n    EditMode[\"EDIT_MODE_CONTROLLED_EDITING\"] = \"EDIT_MODE_CONTROLLED_EDITING\";\n    EditMode[\"EDIT_MODE_STYLE\"] = \"EDIT_MODE_STYLE\";\n    EditMode[\"EDIT_MODE_BGSWAP\"] = \"EDIT_MODE_BGSWAP\";\n    EditMode[\"EDIT_MODE_PRODUCT_IMAGE\"] = \"EDIT_MODE_PRODUCT_IMAGE\";\n})(EditMode || (EditMode = {}));\n/** Enum that represents the segmentation mode. */\nvar SegmentMode;\n(function (SegmentMode) {\n    SegmentMode[\"FOREGROUND\"] = \"FOREGROUND\";\n    SegmentMode[\"BACKGROUND\"] = \"BACKGROUND\";\n    SegmentMode[\"PROMPT\"] = \"PROMPT\";\n    SegmentMode[\"SEMANTIC\"] = \"SEMANTIC\";\n    SegmentMode[\"INTERACTIVE\"] = \"INTERACTIVE\";\n})(SegmentMode || (SegmentMode = {}));\n/** Enum for the reference type of a video generation reference image. */\nvar VideoGenerationReferenceType;\n(function (VideoGenerationReferenceType) {\n    /**\n     * A reference image that provides assets to the generated video,\n        such as the scene, an object, a character, etc.\n     */\n    VideoGenerationReferenceType[\"ASSET\"] = \"ASSET\";\n    /**\n     * A reference image that provides aesthetics including colors,\n        lighting, texture, etc., to be used as the style of the generated video,\n        such as 'anime', 'photography', 'origami', etc.\n     */\n    VideoGenerationReferenceType[\"STYLE\"] = \"STYLE\";\n})(VideoGenerationReferenceType || (VideoGenerationReferenceType = {}));\n/** Enum for the mask mode of a video generation mask. */\nvar VideoGenerationMaskMode;\n(function (VideoGenerationMaskMode) {\n    /**\n     * The image mask contains a masked rectangular region which is\n        applied on the first frame of the input video. The object described in\n        the prompt is inserted into this region and will appear in subsequent\n        frames.\n     */\n    VideoGenerationMaskMode[\"INSERT\"] = \"INSERT\";\n    /**\n     * The image mask is used to determine an object in the\n        first video frame to track. This object is removed from the video.\n     */\n    VideoGenerationMaskMode[\"REMOVE\"] = \"REMOVE\";\n    /**\n     * The image mask is used to determine a region in the\n        video. Objects in this region will be removed.\n     */\n    VideoGenerationMaskMode[\"REMOVE_STATIC\"] = \"REMOVE_STATIC\";\n    /**\n     * The image mask contains a masked rectangular region where\n        the input video will go. The remaining area will be generated. Video\n        masks are not supported.\n     */\n    VideoGenerationMaskMode[\"OUTPAINT\"] = \"OUTPAINT\";\n})(VideoGenerationMaskMode || (VideoGenerationMaskMode = {}));\n/** Enum that controls the compression quality of the generated videos. */\nvar VideoCompressionQuality;\n(function (VideoCompressionQuality) {\n    /**\n     * Optimized video compression quality. This will produce videos\n        with a compressed, smaller file size.\n     */\n    VideoCompressionQuality[\"OPTIMIZED\"] = \"OPTIMIZED\";\n    /**\n     * Lossless video compression quality. This will produce videos\n        with a larger file size.\n     */\n    VideoCompressionQuality[\"LOSSLESS\"] = \"LOSSLESS\";\n})(VideoCompressionQuality || (VideoCompressionQuality = {}));\n/** Enum representing the tuning method. */\nvar TuningMethod;\n(function (TuningMethod) {\n    /**\n     * Supervised fine tuning.\n     */\n    TuningMethod[\"SUPERVISED_FINE_TUNING\"] = \"SUPERVISED_FINE_TUNING\";\n    /**\n     * Preference optimization tuning.\n     */\n    TuningMethod[\"PREFERENCE_TUNING\"] = \"PREFERENCE_TUNING\";\n    /**\n     * Distillation tuning.\n     */\n    TuningMethod[\"DISTILLATION\"] = \"DISTILLATION\";\n})(TuningMethod || (TuningMethod = {}));\n/** State for the lifecycle of a Document. */\nvar DocumentState;\n(function (DocumentState) {\n    DocumentState[\"STATE_UNSPECIFIED\"] = \"STATE_UNSPECIFIED\";\n    DocumentState[\"STATE_PENDING\"] = \"STATE_PENDING\";\n    DocumentState[\"STATE_ACTIVE\"] = \"STATE_ACTIVE\";\n    DocumentState[\"STATE_FAILED\"] = \"STATE_FAILED\";\n})(DocumentState || (DocumentState = {}));\n/** State for the lifecycle of a File. */\nvar FileState;\n(function (FileState) {\n    FileState[\"STATE_UNSPECIFIED\"] = \"STATE_UNSPECIFIED\";\n    FileState[\"PROCESSING\"] = \"PROCESSING\";\n    FileState[\"ACTIVE\"] = \"ACTIVE\";\n    FileState[\"FAILED\"] = \"FAILED\";\n})(FileState || (FileState = {}));\n/** Source of the File. */\nvar FileSource;\n(function (FileSource) {\n    FileSource[\"SOURCE_UNSPECIFIED\"] = \"SOURCE_UNSPECIFIED\";\n    FileSource[\"UPLOADED\"] = \"UPLOADED\";\n    FileSource[\"GENERATED\"] = \"GENERATED\";\n    FileSource[\"REGISTERED\"] = \"REGISTERED\";\n})(FileSource || (FileSource = {}));\n/** The reason why the turn is complete. */\nvar TurnCompleteReason;\n(function (TurnCompleteReason) {\n    /**\n     * Default value. Reason is unspecified.\n     */\n    TurnCompleteReason[\"TURN_COMPLETE_REASON_UNSPECIFIED\"] = \"TURN_COMPLETE_REASON_UNSPECIFIED\";\n    /**\n     * The function call generated by the model is invalid.\n     */\n    TurnCompleteReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    /**\n     * The response is rejected by the model.\n     */\n    TurnCompleteReason[\"RESPONSE_REJECTED\"] = \"RESPONSE_REJECTED\";\n    /**\n     * Needs more input from the user.\n     */\n    TurnCompleteReason[\"NEED_MORE_INPUT\"] = \"NEED_MORE_INPUT\";\n})(TurnCompleteReason || (TurnCompleteReason = {}));\n/** Server content modalities. */\nvar MediaModality;\n(function (MediaModality) {\n    /**\n     * The modality is unspecified.\n     */\n    MediaModality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Plain text.\n     */\n    MediaModality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Images.\n     */\n    MediaModality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Video.\n     */\n    MediaModality[\"VIDEO\"] = \"VIDEO\";\n    /**\n     * Audio.\n     */\n    MediaModality[\"AUDIO\"] = \"AUDIO\";\n    /**\n     * Document, e.g. PDF.\n     */\n    MediaModality[\"DOCUMENT\"] = \"DOCUMENT\";\n})(MediaModality || (MediaModality = {}));\n/** The type of the VAD signal. */\nvar VadSignalType;\n(function (VadSignalType) {\n    /**\n     * The default is VAD_SIGNAL_TYPE_UNSPECIFIED.\n     */\n    VadSignalType[\"VAD_SIGNAL_TYPE_UNSPECIFIED\"] = \"VAD_SIGNAL_TYPE_UNSPECIFIED\";\n    /**\n     * Start of sentence signal.\n     */\n    VadSignalType[\"VAD_SIGNAL_TYPE_SOS\"] = \"VAD_SIGNAL_TYPE_SOS\";\n    /**\n     * End of sentence signal.\n     */\n    VadSignalType[\"VAD_SIGNAL_TYPE_EOS\"] = \"VAD_SIGNAL_TYPE_EOS\";\n})(VadSignalType || (VadSignalType = {}));\n/** The type of the voice activity signal. */\nvar VoiceActivityType;\n(function (VoiceActivityType) {\n    /**\n     * The default is VOICE_ACTIVITY_TYPE_UNSPECIFIED.\n     */\n    VoiceActivityType[\"TYPE_UNSPECIFIED\"] = \"TYPE_UNSPECIFIED\";\n    /**\n     * Start of sentence signal.\n     */\n    VoiceActivityType[\"ACTIVITY_START\"] = \"ACTIVITY_START\";\n    /**\n     * End of sentence signal.\n     */\n    VoiceActivityType[\"ACTIVITY_END\"] = \"ACTIVITY_END\";\n})(VoiceActivityType || (VoiceActivityType = {}));\n/** Start of speech sensitivity. */\nvar StartSensitivity;\n(function (StartSensitivity) {\n    /**\n     * The default is START_SENSITIVITY_LOW.\n     */\n    StartSensitivity[\"START_SENSITIVITY_UNSPECIFIED\"] = \"START_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection will detect the start of speech more often.\n     */\n    StartSensitivity[\"START_SENSITIVITY_HIGH\"] = \"START_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection will detect the start of speech less often.\n     */\n    StartSensitivity[\"START_SENSITIVITY_LOW\"] = \"START_SENSITIVITY_LOW\";\n})(StartSensitivity || (StartSensitivity = {}));\n/** End of speech sensitivity. */\nvar EndSensitivity;\n(function (EndSensitivity) {\n    /**\n     * The default is END_SENSITIVITY_LOW.\n     */\n    EndSensitivity[\"END_SENSITIVITY_UNSPECIFIED\"] = \"END_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection ends speech more often.\n     */\n    EndSensitivity[\"END_SENSITIVITY_HIGH\"] = \"END_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection ends speech less often.\n     */\n    EndSensitivity[\"END_SENSITIVITY_LOW\"] = \"END_SENSITIVITY_LOW\";\n})(EndSensitivity || (EndSensitivity = {}));\n/** The different ways of handling user activity. */\nvar ActivityHandling;\n(function (ActivityHandling) {\n    /**\n     * If unspecified, the default behavior is `START_OF_ACTIVITY_INTERRUPTS`.\n     */\n    ActivityHandling[\"ACTIVITY_HANDLING_UNSPECIFIED\"] = \"ACTIVITY_HANDLING_UNSPECIFIED\";\n    /**\n     * If true, start of activity will interrupt the model's response (also called \"barge in\"). The model's current response will be cut-off in the moment of the interruption. This is the default behavior.\n     */\n    ActivityHandling[\"START_OF_ACTIVITY_INTERRUPTS\"] = \"START_OF_ACTIVITY_INTERRUPTS\";\n    /**\n     * The model's response will not be interrupted.\n     */\n    ActivityHandling[\"NO_INTERRUPTION\"] = \"NO_INTERRUPTION\";\n})(ActivityHandling || (ActivityHandling = {}));\n/** Options about which input is included in the user's turn. */\nvar TurnCoverage;\n(function (TurnCoverage) {\n    /**\n     * If unspecified, the default behavior is `TURN_INCLUDES_ONLY_ACTIVITY`.\n     */\n    TurnCoverage[\"TURN_COVERAGE_UNSPECIFIED\"] = \"TURN_COVERAGE_UNSPECIFIED\";\n    /**\n     * The users turn only includes activity since the last turn, excluding inactivity (e.g. silence on the audio stream). This is the default behavior.\n     */\n    TurnCoverage[\"TURN_INCLUDES_ONLY_ACTIVITY\"] = \"TURN_INCLUDES_ONLY_ACTIVITY\";\n    /**\n     * The users turn includes all realtime input since the last turn, including inactivity (e.g. silence on the audio stream).\n     */\n    TurnCoverage[\"TURN_INCLUDES_ALL_INPUT\"] = \"TURN_INCLUDES_ALL_INPUT\";\n})(TurnCoverage || (TurnCoverage = {}));\n/** Scale of the generated music. */\nvar Scale;\n(function (Scale) {\n    /**\n     * Default value. This value is unused.\n     */\n    Scale[\"SCALE_UNSPECIFIED\"] = \"SCALE_UNSPECIFIED\";\n    /**\n     * C major or A minor.\n     */\n    Scale[\"C_MAJOR_A_MINOR\"] = \"C_MAJOR_A_MINOR\";\n    /**\n     * Db major or Bb minor.\n     */\n    Scale[\"D_FLAT_MAJOR_B_FLAT_MINOR\"] = \"D_FLAT_MAJOR_B_FLAT_MINOR\";\n    /**\n     * D major or B minor.\n     */\n    Scale[\"D_MAJOR_B_MINOR\"] = \"D_MAJOR_B_MINOR\";\n    /**\n     * Eb major or C minor\n     */\n    Scale[\"E_FLAT_MAJOR_C_MINOR\"] = \"E_FLAT_MAJOR_C_MINOR\";\n    /**\n     * E major or Db minor.\n     */\n    Scale[\"E_MAJOR_D_FLAT_MINOR\"] = \"E_MAJOR_D_FLAT_MINOR\";\n    /**\n     * F major or D minor.\n     */\n    Scale[\"F_MAJOR_D_MINOR\"] = \"F_MAJOR_D_MINOR\";\n    /**\n     * Gb major or Eb minor.\n     */\n    Scale[\"G_FLAT_MAJOR_E_FLAT_MINOR\"] = \"G_FLAT_MAJOR_E_FLAT_MINOR\";\n    /**\n     * G major or E minor.\n     */\n    Scale[\"G_MAJOR_E_MINOR\"] = \"G_MAJOR_E_MINOR\";\n    /**\n     * Ab major or F minor.\n     */\n    Scale[\"A_FLAT_MAJOR_F_MINOR\"] = \"A_FLAT_MAJOR_F_MINOR\";\n    /**\n     * A major or Gb minor.\n     */\n    Scale[\"A_MAJOR_G_FLAT_MINOR\"] = \"A_MAJOR_G_FLAT_MINOR\";\n    /**\n     * Bb major or G minor.\n     */\n    Scale[\"B_FLAT_MAJOR_G_MINOR\"] = \"B_FLAT_MAJOR_G_MINOR\";\n    /**\n     * B major or Ab minor.\n     */\n    Scale[\"B_MAJOR_A_FLAT_MINOR\"] = \"B_MAJOR_A_FLAT_MINOR\";\n})(Scale || (Scale = {}));\n/** The mode of music generation. */\nvar MusicGenerationMode;\n(function (MusicGenerationMode) {\n    /**\n     * Rely on the server default generation mode.\n     */\n    MusicGenerationMode[\"MUSIC_GENERATION_MODE_UNSPECIFIED\"] = \"MUSIC_GENERATION_MODE_UNSPECIFIED\";\n    /**\n     * Steer text prompts to regions of latent space with higher quality\n        music.\n     */\n    MusicGenerationMode[\"QUALITY\"] = \"QUALITY\";\n    /**\n     * Steer text prompts to regions of latent space with a larger\n        diversity of music.\n     */\n    MusicGenerationMode[\"DIVERSITY\"] = \"DIVERSITY\";\n    /**\n     * Steer text prompts to regions of latent space more likely to\n        generate music with vocals.\n     */\n    MusicGenerationMode[\"VOCALIZATION\"] = \"VOCALIZATION\";\n})(MusicGenerationMode || (MusicGenerationMode = {}));\n/** The playback control signal to apply to the music generation. */\nvar LiveMusicPlaybackControl;\n(function (LiveMusicPlaybackControl) {\n    /**\n     * This value is unused.\n     */\n    LiveMusicPlaybackControl[\"PLAYBACK_CONTROL_UNSPECIFIED\"] = \"PLAYBACK_CONTROL_UNSPECIFIED\";\n    /**\n     * Start generating the music.\n     */\n    LiveMusicPlaybackControl[\"PLAY\"] = \"PLAY\";\n    /**\n     * Hold the music generation. Use PLAY to resume from the current position.\n     */\n    LiveMusicPlaybackControl[\"PAUSE\"] = \"PAUSE\";\n    /**\n     * Stop the music generation and reset the context (prompts retained).\n        Use PLAY to restart the music generation.\n     */\n    LiveMusicPlaybackControl[\"STOP\"] = \"STOP\";\n    /**\n     * Reset the context of the music generation without stopping it.\n        Retains the current prompts and config.\n     */\n    LiveMusicPlaybackControl[\"RESET_CONTEXT\"] = \"RESET_CONTEXT\";\n})(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));\n/** Raw media bytes for function response.\n\nText should not be sent as raw bytes, use the FunctionResponse.response\nfield. */\nclass FunctionResponseBlob {\n}\n/** URI based data for function response. */\nclass FunctionResponseFileData {\n}\n/** A datatype containing media that is part of a `FunctionResponse` message.\n\nA `FunctionResponsePart` consists of data which has an associated datatype. A\n`FunctionResponsePart` can only contain one of the accepted types in\n`FunctionResponsePart.data`.\n\nA `FunctionResponsePart` must have a fixed IANA MIME type identifying the\ntype and subtype of the media if the `inline_data` field is filled with raw\nbytes. */\nclass FunctionResponsePart {\n}\n/**\n * Creates a `FunctionResponsePart` object from a `base64` encoded `string`.\n */\nfunction createFunctionResponsePartFromBase64(data, mimeType) {\n    return {\n        inlineData: {\n            data: data,\n            mimeType: mimeType,\n        },\n    };\n}\n/**\n * Creates a `FunctionResponsePart` object from a `URI` string.\n */\nfunction createFunctionResponsePartFromUri(uri, mimeType) {\n    return {\n        fileData: {\n            fileUri: uri,\n            mimeType: mimeType,\n        },\n    };\n}\n/** A function response. */\nclass FunctionResponse {\n}\n/**\n * Creates a `Part` object from a `URI` string.\n */\nfunction createPartFromUri(uri, mimeType, mediaResolution) {\n    return Object.assign({ fileData: {\n            fileUri: uri,\n            mimeType: mimeType,\n        } }, (mediaResolution && { mediaResolution: { level: mediaResolution } }));\n}\n/**\n * Creates a `Part` object from a `text` string.\n */\nfunction createPartFromText(text) {\n    return {\n        text: text,\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionCall` object.\n */\nfunction createPartFromFunctionCall(name, args) {\n    return {\n        functionCall: {\n            name: name,\n            args: args,\n        },\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionResponse` object.\n */\nfunction createPartFromFunctionResponse(id, name, response, parts = []) {\n    return {\n        functionResponse: Object.assign({ id: id, name: name, response: response }, (parts.length > 0 && { parts })),\n    };\n}\n/**\n * Creates a `Part` object from a `base64` encoded `string`.\n */\nfunction createPartFromBase64(data, mimeType, mediaResolution) {\n    return Object.assign({ inlineData: {\n            data: data,\n            mimeType: mimeType,\n        } }, (mediaResolution && { mediaResolution: { level: mediaResolution } }));\n}\n/**\n * Creates a `Part` object from the `outcome` and `output` of a `CodeExecutionResult` object.\n */\nfunction createPartFromCodeExecutionResult(outcome, output) {\n    return {\n        codeExecutionResult: {\n            outcome: outcome,\n            output: output,\n        },\n    };\n}\n/**\n * Creates a `Part` object from the `code` and `language` of an `ExecutableCode` object.\n */\nfunction createPartFromExecutableCode(code, language) {\n    return {\n        executableCode: {\n            code: code,\n            language: language,\n        },\n    };\n}\nfunction _isPart(obj) {\n    if (typeof obj === 'object' && obj !== null) {\n        return ('fileData' in obj ||\n            'text' in obj ||\n            'functionCall' in obj ||\n            'functionResponse' in obj ||\n            'inlineData' in obj ||\n            'videoMetadata' in obj ||\n            'codeExecutionResult' in obj ||\n            'executableCode' in obj);\n    }\n    return false;\n}\nfunction _toParts(partOrString) {\n    const parts = [];\n    if (typeof partOrString === 'string') {\n        parts.push(createPartFromText(partOrString));\n    }\n    else if (_isPart(partOrString)) {\n        parts.push(partOrString);\n    }\n    else if (Array.isArray(partOrString)) {\n        if (partOrString.length === 0) {\n            throw new Error('partOrString cannot be an empty array');\n        }\n        for (const part of partOrString) {\n            if (typeof part === 'string') {\n                parts.push(createPartFromText(part));\n            }\n            else if (_isPart(part)) {\n                parts.push(part);\n            }\n            else {\n                throw new Error('element in PartUnion must be a Part object or string');\n            }\n        }\n    }\n    else {\n        throw new Error('partOrString must be a Part object, string, or array');\n    }\n    return parts;\n}\n/**\n * Creates a `Content` object with a user role from a `PartListUnion` object or `string`.\n */\nfunction createUserContent(partOrString) {\n    return {\n        role: 'user',\n        parts: _toParts(partOrString),\n    };\n}\n/**\n * Creates a `Content` object with a model role from a `PartListUnion` object or `string`.\n */\nfunction createModelContent(partOrString) {\n    return {\n        role: 'model',\n        parts: _toParts(partOrString),\n    };\n}\n/** A wrapper class for the http response. */\nclass HttpResponse {\n    constructor(response) {\n        // Process the headers.\n        const headers = {};\n        for (const pair of response.headers.entries()) {\n            headers[pair[0]] = pair[1];\n        }\n        this.headers = headers;\n        // Keep the original response.\n        this.responseInternal = response;\n    }\n    json() {\n        return this.responseInternal.json();\n    }\n}\n/** Content filter results for a prompt sent in the request. Note: This is sent only in the first stream chunk and only if no candidates were generated due to content violations. */\nclass GenerateContentResponsePromptFeedback {\n}\n/** Usage metadata about the content generation request and response. This message provides a detailed breakdown of token usage and other relevant metrics. This data type is not supported in Gemini API. */\nclass GenerateContentResponseUsageMetadata {\n}\n/** Response message for PredictionService.GenerateContent. */\nclass GenerateContentResponse {\n    /**\n     * Returns the concatenation of all text parts from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the text from the first\n     * one will be returned.\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     * If there are thought parts in the response, the concatenation of all text\n     * parts excluding the thought parts will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'Why is the sky blue?',\n     * });\n     *\n     * console.debug(response.text);\n     * ```\n     */\n    get text() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning text from the first one.');\n        }\n        let text = '';\n        let anyTextPartText = false;\n        const nonTextParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {\n            for (const [fieldName, fieldValue] of Object.entries(part)) {\n                if (fieldName !== 'text' &&\n                    fieldName !== 'thought' &&\n                    fieldName !== 'thoughtSignature' &&\n                    (fieldValue !== null || fieldValue !== undefined)) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === 'string') {\n                if (typeof part.thought === 'boolean' && part.thought) {\n                    continue;\n                }\n                anyTextPartText = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartText ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the first candidate\n     * in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the inline data from the\n     * first one will be returned. If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */\n    get data() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning data from the first one.');\n        }\n        let data = '';\n        const nonDataParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {\n            for (const [fieldName, fieldValue] of Object.entries(part)) {\n                if (fieldName !== 'inlineData' &&\n                    (fieldValue !== null || fieldValue !== undefined)) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === 'string') {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n    /**\n     * Returns the function calls from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the function calls from\n     * the first one will be returned.\n     * If there are no function calls in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const controlLightFunctionDeclaration: FunctionDeclaration = {\n     *   name: 'controlLight',\n     *   parameters: {\n     *   type: Type.OBJECT,\n     *   description: 'Set the brightness and color temperature of a room light.',\n     *   properties: {\n     *     brightness: {\n     *       type: Type.NUMBER,\n     *       description:\n     *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',\n     *     },\n     *     colorTemperature: {\n     *       type: Type.STRING,\n     *       description:\n     *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',\n     *     },\n     *   },\n     *   required: ['brightness', 'colorTemperature'],\n     *  };\n     *  const response = await ai.models.generateContent({\n     *     model: 'gemini-2.0-flash',\n     *     contents: 'Dim the lights so the room feels cozy and warm.',\n     *     config: {\n     *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],\n     *       toolConfig: {\n     *         functionCallingConfig: {\n     *           mode: FunctionCallingConfigMode.ANY,\n     *           allowedFunctionNames: ['controlLight'],\n     *         },\n     *       },\n     *     },\n     *   });\n     *  console.debug(JSON.stringify(response.functionCalls));\n     * ```\n     */\n    get functionCalls() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning function calls from the first one.');\n        }\n        const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.functionCall).map((part) => part.functionCall).filter((functionCall) => functionCall !== undefined);\n        if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {\n            return undefined;\n        }\n        return functionCalls;\n    }\n    /**\n     * Returns the first executable code from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the executable code from\n     * the first one will be returned.\n     * If there are no executable code in the response, undefined will be\n     * returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.executableCode);\n     * ```\n     */\n    get executableCode() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning executable code from the first one.');\n        }\n        const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.executableCode).map((part) => part.executableCode).filter((executableCode) => executableCode !== undefined);\n        if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {\n            return undefined;\n        }\n        return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;\n    }\n    /**\n     * Returns the first code execution result from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the code execution result from\n     * the first one will be returned.\n     * If there are no code execution result in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.codeExecutionResult);\n     * ```\n     */\n    get codeExecutionResult() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning code execution result from the first one.');\n        }\n        const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.codeExecutionResult).map((part) => part.codeExecutionResult).filter((codeExecutionResult) => codeExecutionResult !== undefined);\n        if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {\n            return undefined;\n        }\n        return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;\n    }\n}\n/** Response for the embed_content method. */\nclass EmbedContentResponse {\n}\n/** The output images response. */\nclass GenerateImagesResponse {\n}\n/** Response for the request to edit an image. */\nclass EditImageResponse {\n}\nclass UpscaleImageResponse {\n}\n/** The output images response. */\nclass RecontextImageResponse {\n}\n/** The output images response. */\nclass SegmentImageResponse {\n}\nclass ListModelsResponse {\n}\nclass DeleteModelResponse {\n}\n/** Response for counting tokens. */\nclass CountTokensResponse {\n}\n/** Response for computing tokens. */\nclass ComputeTokensResponse {\n}\n/** Response with generated videos. */\nclass GenerateVideosResponse {\n}\n/** A video generation operation. */\nclass GenerateVideosOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */\n    _fromAPIResponse({ apiResponse, _isVertexAI, }) {\n        const operation = new GenerateVideosOperation();\n        let response;\n        const op = apiResponse;\n        if (_isVertexAI) {\n            response = generateVideosOperationFromVertex$1(op);\n        }\n        else {\n            response = generateVideosOperationFromMldev$1(op);\n        }\n        Object.assign(operation, response);\n        return operation;\n    }\n}\n/** Response for the list tuning jobs method. */\nclass ListTuningJobsResponse {\n}\n/** Empty response for tunings.cancel method. */\nclass CancelTuningJobResponse {\n}\n/** Empty response for caches.delete method. */\nclass DeleteCachedContentResponse {\n}\nclass ListCachedContentsResponse {\n}\n/** Config for documents.list return value. */\nclass ListDocumentsResponse {\n}\n/** Config for file_search_stores.list return value. */\nclass ListFileSearchStoresResponse {\n}\n/** Response for the resumable upload method. */\nclass UploadToFileSearchStoreResumableResponse {\n}\n/** Response for ImportFile to import a File API file with a file search store. */\nclass ImportFileResponse {\n}\n/** Long-running operation for importing a file to a FileSearchStore. */\nclass ImportFileOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */\n    _fromAPIResponse({ apiResponse, _isVertexAI, }) {\n        const operation = new ImportFileOperation();\n        const op = apiResponse;\n        const response = importFileOperationFromMldev$1(op);\n        Object.assign(operation, response);\n        return operation;\n    }\n}\n/** Response for the list files method. */\nclass ListFilesResponse {\n}\n/** Response for the create file method. */\nclass CreateFileResponse {\n}\n/** Response for the delete file method. */\nclass DeleteFileResponse {\n}\n/** Response for the _register file method. */\nclass RegisterFilesResponse {\n}\n/** Config for `inlined_responses` parameter. */\nclass InlinedResponse {\n}\n/** Config for `response` parameter. */\nclass SingleEmbedContentResponse {\n}\n/** Config for `inlined_embedding_responses` parameter. */\nclass InlinedEmbedContentResponse {\n}\n/** Config for batches.list return value. */\nclass ListBatchJobsResponse {\n}\n/** Represents a single response in a replay. */\nclass ReplayResponse {\n}\n/** A raw reference image.\n\nA raw reference image represents the base image to edit, provided by the user.\nIt can optionally be provided in addition to a mask reference image or\na style reference image. */\nclass RawReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_RAW',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A mask reference image.\n\nThis encapsulates either a mask image provided by the user and configs for\nthe user provided mask, or only config parameters for the model to generate\na mask.\n\nA mask image is an image whose non-zero values indicate where to edit the base\nimage. If the user provides a mask image, the mask must be in the same\ndimensions as the raw image. */\nclass MaskReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_MASK',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            maskImageConfig: this.config,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A control reference image.\n\nThe image of the control reference image is either a control image provided\nby the user, or a regular image which the backend will use to generate a\ncontrol image of. In the case of the latter, the\nenable_control_image_computation field in the config should be set to True.\n\nA control image is an image that represents a sketch image of areas for the\nmodel to fill in based on the prompt. */\nclass ControlReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_CONTROL',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            controlImageConfig: this.config,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A style reference image.\n\nThis encapsulates a style reference image provided by the user, and\nadditionally optional config parameters for the style reference image.\n\nA raw reference image can also be provided as a destination for the style to\nbe applied to. */\nclass StyleReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_STYLE',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            styleImageConfig: this.config,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A subject reference image.\n\nThis encapsulates a subject reference image provided by the user, and\nadditionally optional config parameters for the subject reference image.\n\nA raw reference image can also be provided as a destination for the subject to\nbe applied to. */\nclass SubjectReferenceImage {\n    /* Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_SUBJECT',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            subjectImageConfig: this.config,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A content reference image.\n\nA content reference image represents a subject to reference (ex. person,\nproduct, animal) provided by the user. It can optionally be provided in\naddition to a style reference image (ex. background, style reference). */\nclass ContentReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_CONTENT',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n        };\n        return referenceImageAPI;\n    }\n}\n/** Response message for API call. */\nclass LiveServerMessage {\n    /**\n     * Returns the concatenation of all text parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     */\n    get text() {\n        var _a, _b, _c;\n        let text = '';\n        let anyTextPartFound = false;\n        const nonTextParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {\n            for (const [fieldName, fieldValue] of Object.entries(part)) {\n                if (fieldName !== 'text' &&\n                    fieldName !== 'thought' &&\n                    fieldValue !== null) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === 'string') {\n                if (typeof part.thought === 'boolean' && part.thought) {\n                    continue;\n                }\n                anyTextPartFound = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartFound ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */\n    get data() {\n        var _a, _b, _c;\n        let data = '';\n        const nonDataParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {\n            for (const [fieldName, fieldValue] of Object.entries(part)) {\n                if (fieldName !== 'inlineData' && fieldValue !== null) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === 'string') {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n}\n/** Client generated response to a `ToolCall` received from the server.\n\nIndividual `FunctionResponse` objects are matched to the respective\n`FunctionCall` objects by the `id` field.\n\nNote that in the unary and server-streaming GenerateContent APIs function\ncalling happens by exchanging the `Content` parts, while in the bidi\nGenerateContent APIs function calling happens over this dedicated set of\nmessages. */\nclass LiveClientToolResponse {\n}\n/** Parameters for sending tool responses to the live API. */\nclass LiveSendToolResponseParameters {\n    constructor() {\n        /** Tool responses to send to the session. */\n        this.functionResponses = [];\n    }\n}\n/** Response message for the LiveMusicClientMessage call. */\nclass LiveMusicServerMessage {\n    /**\n     * Returns the first audio chunk from the server content, if present.\n     *\n     * @remarks\n     * If there are no audio chunks in the response, undefined will be returned.\n     */\n    get audioChunk() {\n        if (this.serverContent &&\n            this.serverContent.audioChunks &&\n            this.serverContent.audioChunks.length > 0) {\n            return this.serverContent.audioChunks[0];\n        }\n        return undefined;\n    }\n}\n/** The response when long-running operation for uploading a file to a FileSearchStore complete. */\nclass UploadToFileSearchStoreResponse {\n}\n/** Long-running operation for uploading a file to a FileSearchStore. */\nclass UploadToFileSearchStoreOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */\n    _fromAPIResponse({ apiResponse, _isVertexAI, }) {\n        const operation = new UploadToFileSearchStoreOperation();\n        const op = apiResponse;\n        const response = uploadToFileSearchStoreOperationFromMldev(op);\n        Object.assign(operation, response);\n        return operation;\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction tModel(apiClient, model) {\n    if (!model || typeof model !== 'string') {\n        throw new Error('model is required and must be a string');\n    }\n    if (model.includes('..') || model.includes('?') || model.includes('&')) {\n        throw new Error('invalid model parameter');\n    }\n    if (apiClient.isVertexAI()) {\n        if (model.startsWith('publishers/') ||\n            model.startsWith('projects/') ||\n            model.startsWith('models/')) {\n            return model;\n        }\n        else if (model.indexOf('/') >= 0) {\n            const parts = model.split('/', 2);\n            return `publishers/${parts[0]}/models/${parts[1]}`;\n        }\n        else {\n            return `publishers/google/models/${model}`;\n        }\n    }\n    else {\n        if (model.startsWith('models/') || model.startsWith('tunedModels/')) {\n            return model;\n        }\n        else {\n            return `models/${model}`;\n        }\n    }\n}\nfunction tCachesModel(apiClient, model) {\n    const transformedModel = tModel(apiClient, model);\n    if (!transformedModel) {\n        return '';\n    }\n    if (transformedModel.startsWith('publishers/') && apiClient.isVertexAI()) {\n        // vertex caches only support model name start with projects.\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;\n    }\n    else if (transformedModel.startsWith('models/') && apiClient.isVertexAI()) {\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;\n    }\n    else {\n        return transformedModel;\n    }\n}\nfunction tBlobs(blobs) {\n    if (Array.isArray(blobs)) {\n        return blobs.map((blob) => tBlob(blob));\n    }\n    else {\n        return [tBlob(blobs)];\n    }\n}\nfunction tBlob(blob) {\n    if (typeof blob === 'object' && blob !== null) {\n        return blob;\n    }\n    throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);\n}\nfunction tImageBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType &&\n        transformedBlob.mimeType.startsWith('image/')) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tAudioBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType &&\n        transformedBlob.mimeType.startsWith('audio/')) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tPart(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error('PartUnion is required');\n    }\n    if (typeof origin === 'object') {\n        return origin;\n    }\n    if (typeof origin === 'string') {\n        return { text: origin };\n    }\n    throw new Error(`Unsupported part type: ${typeof origin}`);\n}\nfunction tParts(origin) {\n    if (origin === null ||\n        origin === undefined ||\n        (Array.isArray(origin) && origin.length === 0)) {\n        throw new Error('PartListUnion is required');\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item) => tPart(item));\n    }\n    return [tPart(origin)];\n}\nfunction _isContent(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'parts' in origin &&\n        Array.isArray(origin.parts));\n}\nfunction _isFunctionCallPart(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'functionCall' in origin);\n}\nfunction _isFunctionResponsePart(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'functionResponse' in origin);\n}\nfunction tContent(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error('ContentUnion is required');\n    }\n    if (_isContent(origin)) {\n        // _isContent is a utility function that checks if the\n        // origin is a Content.\n        return origin;\n    }\n    return {\n        role: 'user',\n        parts: tParts(origin),\n    };\n}\nfunction tContentsForEmbed(apiClient, origin) {\n    if (!origin) {\n        return [];\n    }\n    if (apiClient.isVertexAI() && Array.isArray(origin)) {\n        return origin.flatMap((item) => {\n            const content = tContent(item);\n            if (content.parts &&\n                content.parts.length > 0 &&\n                content.parts[0].text !== undefined) {\n                return [content.parts[0].text];\n            }\n            return [];\n        });\n    }\n    else if (apiClient.isVertexAI()) {\n        const content = tContent(origin);\n        if (content.parts &&\n            content.parts.length > 0 &&\n            content.parts[0].text !== undefined) {\n            return [content.parts[0].text];\n        }\n        return [];\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item) => tContent(item));\n    }\n    return [tContent(origin)];\n}\nfunction tContents(origin) {\n    if (origin === null ||\n        origin === undefined ||\n        (Array.isArray(origin) && origin.length === 0)) {\n        throw new Error('contents are required');\n    }\n    if (!Array.isArray(origin)) {\n        // If it's not an array, it's a single content or a single PartUnion.\n        if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {\n            throw new Error('To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them');\n        }\n        return [tContent(origin)];\n    }\n    const result = [];\n    const accumulatedParts = [];\n    const isContentArray = _isContent(origin[0]);\n    for (const item of origin) {\n        const isContent = _isContent(item);\n        if (isContent != isContentArray) {\n            throw new Error('Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them');\n        }\n        if (isContent) {\n            // `isContent` contains the result of _isContent, which is a utility\n            // function that checks if the item is a Content.\n            result.push(item);\n        }\n        else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {\n            throw new Error('To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them');\n        }\n        else {\n            accumulatedParts.push(item);\n        }\n    }\n    if (!isContentArray) {\n        result.push({ role: 'user', parts: tParts(accumulatedParts) });\n    }\n    return result;\n}\n/*\nTransform the type field from an array of types to an array of anyOf fields.\nExample:\n  {type: ['STRING', 'NUMBER']}\nwill be transformed to\n  {anyOf: [{type: 'STRING'}, {type: 'NUMBER'}]}\n*/\nfunction flattenTypeArrayToAnyOf(typeList, resultingSchema) {\n    if (typeList.includes('null')) {\n        resultingSchema['nullable'] = true;\n    }\n    const listWithoutNull = typeList.filter((type) => type !== 'null');\n    if (listWithoutNull.length === 1) {\n        resultingSchema['type'] = Object.values(Type).includes(listWithoutNull[0].toUpperCase())\n            ? listWithoutNull[0].toUpperCase()\n            : Type.TYPE_UNSPECIFIED;\n    }\n    else {\n        resultingSchema['anyOf'] = [];\n        for (const i of listWithoutNull) {\n            resultingSchema['anyOf'].push({\n                'type': Object.values(Type).includes(i.toUpperCase())\n                    ? i.toUpperCase()\n                    : Type.TYPE_UNSPECIFIED,\n            });\n        }\n    }\n}\nfunction processJsonSchema(_jsonSchema) {\n    const genAISchema = {};\n    const schemaFieldNames = ['items'];\n    const listSchemaFieldNames = ['anyOf'];\n    const dictSchemaFieldNames = ['properties'];\n    if (_jsonSchema['type'] && _jsonSchema['anyOf']) {\n        throw new Error('type and anyOf cannot be both populated.');\n    }\n    /*\n    This is to handle the nullable array or object. The _jsonSchema will\n    be in the format of {anyOf: [{type: 'null'}, {type: 'object'}]}. The\n    logic is to check if anyOf has 2 elements and one of the element is null,\n    if so, the anyOf field is unnecessary, so we need to get rid of the anyOf\n    field and make the schema nullable. Then use the other element as the new\n    _jsonSchema for processing. This is because the backend doesn't have a null\n    type.\n    This has to be checked before we process any other fields.\n    For example:\n      const objectNullable = z.object({\n        nullableArray: z.array(z.string()).nullable(),\n      });\n    Will have the raw _jsonSchema as:\n    {\n      type: 'OBJECT',\n      properties: {\n          nullableArray: {\n             anyOf: [\n                {type: 'null'},\n                {\n                  type: 'array',\n                  items: {type: 'string'},\n                },\n              ],\n          }\n      },\n      required: [ 'nullableArray' ],\n    }\n    Will result in following schema compatible with Gemini API:\n      {\n        type: 'OBJECT',\n        properties: {\n           nullableArray: {\n              nullable: true,\n              type: 'ARRAY',\n              items: {type: 'string'},\n           }\n        },\n        required: [ 'nullableArray' ],\n      }\n    */\n    const incomingAnyOf = _jsonSchema['anyOf'];\n    if (incomingAnyOf != null && incomingAnyOf.length == 2) {\n        if (incomingAnyOf[0]['type'] === 'null') {\n            genAISchema['nullable'] = true;\n            _jsonSchema = incomingAnyOf[1];\n        }\n        else if (incomingAnyOf[1]['type'] === 'null') {\n            genAISchema['nullable'] = true;\n            _jsonSchema = incomingAnyOf[0];\n        }\n    }\n    if (_jsonSchema['type'] instanceof Array) {\n        flattenTypeArrayToAnyOf(_jsonSchema['type'], genAISchema);\n    }\n    for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)) {\n        // Skip if the fieldvalue is undefined or null.\n        if (fieldValue == null) {\n            continue;\n        }\n        if (fieldName == 'type') {\n            if (fieldValue === 'null') {\n                throw new Error('type: null can not be the only possible type for the field.');\n            }\n            if (fieldValue instanceof Array) {\n                // we have already handled the type field with array of types in the\n                // beginning of this function.\n                continue;\n            }\n            genAISchema['type'] = Object.values(Type).includes(fieldValue.toUpperCase())\n                ? fieldValue.toUpperCase()\n                : Type.TYPE_UNSPECIFIED;\n        }\n        else if (schemaFieldNames.includes(fieldName)) {\n            genAISchema[fieldName] =\n                processJsonSchema(fieldValue);\n        }\n        else if (listSchemaFieldNames.includes(fieldName)) {\n            const listSchemaFieldValue = [];\n            for (const item of fieldValue) {\n                if (item['type'] == 'null') {\n                    genAISchema['nullable'] = true;\n                    continue;\n                }\n                listSchemaFieldValue.push(processJsonSchema(item));\n            }\n            genAISchema[fieldName] =\n                listSchemaFieldValue;\n        }\n        else if (dictSchemaFieldNames.includes(fieldName)) {\n            const dictSchemaFieldValue = {};\n            for (const [key, value] of Object.entries(fieldValue)) {\n                dictSchemaFieldValue[key] = processJsonSchema(value);\n            }\n            genAISchema[fieldName] =\n                dictSchemaFieldValue;\n        }\n        else {\n            // additionalProperties is not included in JSONSchema, skipping it.\n            if (fieldName === 'additionalProperties') {\n                continue;\n            }\n            genAISchema[fieldName] = fieldValue;\n        }\n    }\n    return genAISchema;\n}\n// we take the unknown in the schema field because we want enable user to pass\n// the output of major schema declaration tools without casting. Tools such as\n// zodToJsonSchema, typebox, zodToJsonSchema function can return JsonSchema7Type\n// or object, see details in\n// https://github.com/StefanTerdell/zod-to-json-schema/blob/70525efe555cd226691e093d171370a3b10921d1/src/zodToJsonSchema.ts#L7\n// typebox can return unknown, see details in\n// https://github.com/sinclairzx81/typebox/blob/5a5431439f7d5ca6b494d0d18fbfd7b1a356d67c/src/type/create/type.ts#L35\n// Note: proper json schemas with the $schema field set never arrive to this\n// transformer. Schemas with $schema are routed to the equivalent API json\n// schema field.\nfunction tSchema(schema) {\n    return processJsonSchema(schema);\n}\nfunction tSpeechConfig(speechConfig) {\n    if (typeof speechConfig === 'object') {\n        return speechConfig;\n    }\n    else if (typeof speechConfig === 'string') {\n        return {\n            voiceConfig: {\n                prebuiltVoiceConfig: {\n                    voiceName: speechConfig,\n                },\n            },\n        };\n    }\n    else {\n        throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);\n    }\n}\nfunction tLiveSpeechConfig(speechConfig) {\n    if ('multiSpeakerVoiceConfig' in speechConfig) {\n        throw new Error('multiSpeakerVoiceConfig is not supported in the live API.');\n    }\n    return speechConfig;\n}\nfunction tTool(tool) {\n    if (tool.functionDeclarations) {\n        for (const functionDeclaration of tool.functionDeclarations) {\n            if (functionDeclaration.parameters) {\n                if (!Object.keys(functionDeclaration.parameters).includes('$schema')) {\n                    functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);\n                }\n                else {\n                    if (!functionDeclaration.parametersJsonSchema) {\n                        functionDeclaration.parametersJsonSchema =\n                            functionDeclaration.parameters;\n                        delete functionDeclaration.parameters;\n                    }\n                }\n            }\n            if (functionDeclaration.response) {\n                if (!Object.keys(functionDeclaration.response).includes('$schema')) {\n                    functionDeclaration.response = processJsonSchema(functionDeclaration.response);\n                }\n                else {\n                    if (!functionDeclaration.responseJsonSchema) {\n                        functionDeclaration.responseJsonSchema =\n                            functionDeclaration.response;\n                        delete functionDeclaration.response;\n                    }\n                }\n            }\n        }\n    }\n    return tool;\n}\nfunction tTools(tools) {\n    // Check if the incoming type is defined.\n    if (tools === undefined || tools === null) {\n        throw new Error('tools is required');\n    }\n    if (!Array.isArray(tools)) {\n        throw new Error('tools is required and must be an array of Tools');\n    }\n    const result = [];\n    for (const tool of tools) {\n        result.push(tool);\n    }\n    return result;\n}\n/**\n * Prepends resource name with project, location, resource_prefix if needed.\n *\n * @param client The API client.\n * @param resourceName The resource name.\n * @param resourcePrefix The resource prefix.\n * @param splitsAfterPrefix The number of splits after the prefix.\n * @returns The completed resource name.\n *\n * Examples:\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/bar/locations/us-west1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'projects/foo/locations/us-central1/cachedContents/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/foo/locations/us-central1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns 'cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'some/wrong/cachedContents/resource/name/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * # client.vertexai = True\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * -> 'some/wrong/resource/name/123'\n * ```\n */\nfunction resourceName(client, resourceName, resourcePrefix, splitsAfterPrefix = 1) {\n    const shouldAppendPrefix = !resourceName.startsWith(`${resourcePrefix}/`) &&\n        resourceName.split('/').length === splitsAfterPrefix;\n    if (client.isVertexAI()) {\n        if (resourceName.startsWith('projects/')) {\n            return resourceName;\n        }\n        else if (resourceName.startsWith('locations/')) {\n            return `projects/${client.getProject()}/${resourceName}`;\n        }\n        else if (resourceName.startsWith(`${resourcePrefix}/`)) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName}`;\n        }\n        else if (shouldAppendPrefix) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName}`;\n        }\n        else {\n            return resourceName;\n        }\n    }\n    if (shouldAppendPrefix) {\n        return `${resourcePrefix}/${resourceName}`;\n    }\n    return resourceName;\n}\nfunction tCachedContentName(apiClient, name) {\n    if (typeof name !== 'string') {\n        throw new Error('name must be a string');\n    }\n    return resourceName(apiClient, name, 'cachedContents');\n}\nfunction tTuningJobStatus(status) {\n    switch (status) {\n        case 'STATE_UNSPECIFIED':\n            return 'JOB_STATE_UNSPECIFIED';\n        case 'CREATING':\n            return 'JOB_STATE_RUNNING';\n        case 'ACTIVE':\n            return 'JOB_STATE_SUCCEEDED';\n        case 'FAILED':\n            return 'JOB_STATE_FAILED';\n        default:\n            return status;\n    }\n}\nfunction tBytes(fromImageBytes) {\n    return tBytes$1(fromImageBytes);\n}\nfunction _isFile(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'name' in origin);\n}\nfunction isGeneratedVideo(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'video' in origin);\n}\nfunction isVideo(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'uri' in origin);\n}\nfunction tFileName(fromName) {\n    var _a;\n    let name;\n    if (_isFile(fromName)) {\n        name = fromName.name;\n    }\n    if (isVideo(fromName)) {\n        name = fromName.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (isGeneratedVideo(fromName)) {\n        name = (_a = fromName.video) === null || _a === void 0 ? void 0 : _a.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (typeof fromName === 'string') {\n        name = fromName;\n    }\n    if (name === undefined) {\n        throw new Error('Could not extract file name from the provided input.');\n    }\n    if (name.startsWith('https://')) {\n        const suffix = name.split('files/')[1];\n        const match = suffix.match(/[a-z0-9]+/);\n        if (match === null) {\n            throw new Error(`Could not extract file name from URI ${name}`);\n        }\n        name = match[0];\n    }\n    else if (name.startsWith('files/')) {\n        name = name.split('files/')[1];\n    }\n    return name;\n}\nfunction tModelsUrl(apiClient, baseModels) {\n    let res;\n    if (apiClient.isVertexAI()) {\n        res = baseModels ? 'publishers/google/models' : 'models';\n    }\n    else {\n        res = baseModels ? 'models' : 'tunedModels';\n    }\n    return res;\n}\nfunction tExtractModels(response) {\n    for (const key of ['models', 'tunedModels', 'publisherModels']) {\n        if (hasField(response, key)) {\n            return response[key];\n        }\n    }\n    return [];\n}\nfunction hasField(data, fieldName) {\n    return data !== null && typeof data === 'object' && fieldName in data;\n}\nfunction mcpToGeminiTool(mcpTool, config = {}) {\n    const mcpToolSchema = mcpTool;\n    const functionDeclaration = {\n        name: mcpToolSchema['name'],\n        description: mcpToolSchema['description'],\n        parametersJsonSchema: mcpToolSchema['inputSchema'],\n    };\n    if (mcpToolSchema['outputSchema']) {\n        functionDeclaration['responseJsonSchema'] = mcpToolSchema['outputSchema'];\n    }\n    if (config.behavior) {\n        functionDeclaration['behavior'] = config.behavior;\n    }\n    const geminiTool = {\n        functionDeclarations: [\n            functionDeclaration,\n        ],\n    };\n    return geminiTool;\n}\n/**\n * Converts a list of MCP tools to a single Gemini tool with a list of function\n * declarations.\n */\nfunction mcpToolsToGeminiTool(mcpTools, config = {}) {\n    const functionDeclarations = [];\n    const toolNames = new Set();\n    for (const mcpTool of mcpTools) {\n        const mcpToolName = mcpTool.name;\n        if (toolNames.has(mcpToolName)) {\n            throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);\n        }\n        toolNames.add(mcpToolName);\n        const geminiTool = mcpToGeminiTool(mcpTool, config);\n        if (geminiTool.functionDeclarations) {\n            functionDeclarations.push(...geminiTool.functionDeclarations);\n        }\n    }\n    return { functionDeclarations: functionDeclarations };\n}\n// Transforms a source input into a BatchJobSource object with validation.\nfunction tBatchJobSource(client, src) {\n    let sourceObj;\n    if (typeof src === 'string') {\n        if (client.isVertexAI()) {\n            if (src.startsWith('gs://')) {\n                sourceObj = { format: 'jsonl', gcsUri: [src] };\n            }\n            else if (src.startsWith('bq://')) {\n                sourceObj = { format: 'bigquery', bigqueryUri: src };\n            }\n            else {\n                throw new Error(`Unsupported string source for Vertex AI: ${src}`);\n            }\n        }\n        else {\n            // MLDEV\n            if (src.startsWith('files/')) {\n                sourceObj = { fileName: src }; // Default to fileName for string input\n            }\n            else {\n                throw new Error(`Unsupported string source for Gemini API: ${src}`);\n            }\n        }\n    }\n    else if (Array.isArray(src)) {\n        if (client.isVertexAI()) {\n            throw new Error('InlinedRequest[] is not supported in Vertex AI.');\n        }\n        sourceObj = { inlinedRequests: src };\n    }\n    else {\n        // It's already a BatchJobSource object\n        sourceObj = src;\n    }\n    // Validation logic\n    const vertexSourcesCount = [sourceObj.gcsUri, sourceObj.bigqueryUri].filter(Boolean).length;\n    const mldevSourcesCount = [\n        sourceObj.inlinedRequests,\n        sourceObj.fileName,\n    ].filter(Boolean).length;\n    if (client.isVertexAI()) {\n        if (mldevSourcesCount > 0 || vertexSourcesCount !== 1) {\n            throw new Error('Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.');\n        }\n    }\n    else {\n        // MLDEV\n        if (vertexSourcesCount > 0 || mldevSourcesCount !== 1) {\n            throw new Error('Exactly one of `inlinedRequests`, `fileName`, ' +\n                'must be set for Gemini API.');\n        }\n    }\n    return sourceObj;\n}\nfunction tBatchJobDestination(dest) {\n    if (typeof dest !== 'string') {\n        return dest;\n    }\n    const destString = dest;\n    if (destString.startsWith('gs://')) {\n        return {\n            format: 'jsonl',\n            gcsUri: destString,\n        };\n    }\n    else if (destString.startsWith('bq://')) {\n        return {\n            format: 'bigquery',\n            bigqueryUri: destString,\n        };\n    }\n    else {\n        throw new Error(`Unsupported destination: ${destString}`);\n    }\n}\nfunction tRecvBatchJobDestination(dest) {\n    // Ensure dest is a non-null object before proceeding.\n    if (typeof dest !== 'object' || dest === null) {\n        // If the input is not an object, it cannot be a valid BatchJobDestination\n        // based on the operations performed. Return it cast, or handle as an error.\n        // Casting an empty object might be a safe default.\n        return {};\n    }\n    // Cast to Record<string, unknown> to allow string property access.\n    const obj = dest;\n    // Safely access nested properties.\n    const inlineResponsesVal = obj['inlinedResponses'];\n    if (typeof inlineResponsesVal !== 'object' || inlineResponsesVal === null) {\n        return dest;\n    }\n    const inlineResponsesObj = inlineResponsesVal;\n    const responsesArray = inlineResponsesObj['inlinedResponses'];\n    if (!Array.isArray(responsesArray) || responsesArray.length === 0) {\n        return dest;\n    }\n    // Check if any response has the 'embedding' property.\n    let hasEmbedding = false;\n    for (const responseItem of responsesArray) {\n        if (typeof responseItem !== 'object' || responseItem === null) {\n            continue;\n        }\n        const responseItemObj = responseItem;\n        const responseVal = responseItemObj['response'];\n        if (typeof responseVal !== 'object' || responseVal === null) {\n            continue;\n        }\n        const responseObj = responseVal;\n        // Check for the existence of the 'embedding' key.\n        if (responseObj['embedding'] !== undefined) {\n            hasEmbedding = true;\n            break;\n        }\n    }\n    // Perform the transformation if an embedding was found.\n    if (hasEmbedding) {\n        obj['inlinedEmbedContentResponses'] = obj['inlinedResponses'];\n        delete obj['inlinedResponses'];\n    }\n    // Cast the (potentially) modified object to the target type.\n    return dest;\n}\nfunction tBatchJobName(apiClient, name) {\n    const nameString = name;\n    if (!apiClient.isVertexAI()) {\n        const mldevPattern = /batches\\/[^/]+$/;\n        if (mldevPattern.test(nameString)) {\n            return nameString.split('/').pop();\n        }\n        else {\n            throw new Error(`Invalid batch job name: ${nameString}.`);\n        }\n    }\n    const vertexPattern = /^projects\\/[^/]+\\/locations\\/[^/]+\\/batchPredictionJobs\\/[^/]+$/;\n    if (vertexPattern.test(nameString)) {\n        return nameString.split('/').pop();\n    }\n    else if (/^\\d+$/.test(nameString)) {\n        return nameString;\n    }\n    else {\n        throw new Error(`Invalid batch job name: ${nameString}.`);\n    }\n}\nfunction tJobState(state) {\n    const stateString = state;\n    if (stateString === 'BATCH_STATE_UNSPECIFIED') {\n        return 'JOB_STATE_UNSPECIFIED';\n    }\n    else if (stateString === 'BATCH_STATE_PENDING') {\n        return 'JOB_STATE_PENDING';\n    }\n    else if (stateString === 'BATCH_STATE_RUNNING') {\n        return 'JOB_STATE_RUNNING';\n    }\n    else if (stateString === 'BATCH_STATE_SUCCEEDED') {\n        return 'JOB_STATE_SUCCEEDED';\n    }\n    else if (stateString === 'BATCH_STATE_FAILED') {\n        return 'JOB_STATE_FAILED';\n    }\n    else if (stateString === 'BATCH_STATE_CANCELLED') {\n        return 'JOB_STATE_CANCELLED';\n    }\n    else if (stateString === 'BATCH_STATE_EXPIRED') {\n        return 'JOB_STATE_EXPIRED';\n    }\n    else {\n        return stateString;\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction batchJobDestinationFromMldev(fromObject) {\n    const toObject = {};\n    const fromFileName = getValueByPath(fromObject, ['responsesFile']);\n    if (fromFileName != null) {\n        setValueByPath(toObject, ['fileName'], fromFileName);\n    }\n    const fromInlinedResponses = getValueByPath(fromObject, [\n        'inlinedResponses',\n        'inlinedResponses',\n    ]);\n    if (fromInlinedResponses != null) {\n        let transformedList = fromInlinedResponses;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return inlinedResponseFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['inlinedResponses'], transformedList);\n    }\n    const fromInlinedEmbedContentResponses = getValueByPath(fromObject, [\n        'inlinedEmbedContentResponses',\n        'inlinedResponses',\n    ]);\n    if (fromInlinedEmbedContentResponses != null) {\n        let transformedList = fromInlinedEmbedContentResponses;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['inlinedEmbedContentResponses'], transformedList);\n    }\n    return toObject;\n}\nfunction batchJobDestinationFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, ['predictionsFormat']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['format'], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        'gcsDestination',\n        'outputUriPrefix',\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        'bigqueryDestination',\n        'outputUri',\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, ['bigqueryUri'], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobDestinationToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, ['format']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['predictionsFormat'], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsDestination', 'outputUriPrefix'], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, ['bigqueryUri']);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, ['bigqueryDestination', 'outputUri'], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, ['fileName']) !== undefined) {\n        throw new Error('fileName parameter is not supported in Vertex AI.');\n    }\n    if (getValueByPath(fromObject, ['inlinedResponses']) !== undefined) {\n        throw new Error('inlinedResponses parameter is not supported in Vertex AI.');\n    }\n    if (getValueByPath(fromObject, ['inlinedEmbedContentResponses']) !==\n        undefined) {\n        throw new Error('inlinedEmbedContentResponses parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction batchJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        'metadata',\n        'displayName',\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, ['metadata', 'state']);\n    if (fromState != null) {\n        setValueByPath(toObject, ['state'], tJobState(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        'metadata',\n        'createTime',\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        'metadata',\n        'endTime',\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        'metadata',\n        'updateTime',\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, ['metadata', 'model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], fromModel);\n    }\n    const fromDest = getValueByPath(fromObject, ['metadata', 'output']);\n    if (fromDest != null) {\n        setValueByPath(toObject, ['dest'], batchJobDestinationFromMldev(tRecvBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction batchJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, ['state']);\n    if (fromState != null) {\n        setValueByPath(toObject, ['state'], tJobState(fromState));\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, ['startTime']);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, ['endTime']);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], fromModel);\n    }\n    const fromSrc = getValueByPath(fromObject, ['inputConfig']);\n    if (fromSrc != null) {\n        setValueByPath(toObject, ['src'], batchJobSourceFromVertex(fromSrc));\n    }\n    const fromDest = getValueByPath(fromObject, ['outputConfig']);\n    if (fromDest != null) {\n        setValueByPath(toObject, ['dest'], batchJobDestinationFromVertex(tRecvBatchJobDestination(fromDest)));\n    }\n    const fromCompletionStats = getValueByPath(fromObject, [\n        'completionStats',\n    ]);\n    if (fromCompletionStats != null) {\n        setValueByPath(toObject, ['completionStats'], fromCompletionStats);\n    }\n    return toObject;\n}\nfunction batchJobSourceFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, ['instancesFormat']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['format'], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, ['gcsSource', 'uris']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        'bigquerySource',\n        'inputUri',\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, ['bigqueryUri'], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobSourceToMldev(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['format']) !== undefined) {\n        throw new Error('format parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['gcsUri']) !== undefined) {\n        throw new Error('gcsUri parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['bigqueryUri']) !== undefined) {\n        throw new Error('bigqueryUri parameter is not supported in Gemini API.');\n    }\n    const fromFileName = getValueByPath(fromObject, ['fileName']);\n    if (fromFileName != null) {\n        setValueByPath(toObject, ['fileName'], fromFileName);\n    }\n    const fromInlinedRequests = getValueByPath(fromObject, [\n        'inlinedRequests',\n    ]);\n    if (fromInlinedRequests != null) {\n        let transformedList = fromInlinedRequests;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return inlinedRequestToMldev(apiClient, item);\n            });\n        }\n        setValueByPath(toObject, ['requests', 'requests'], transformedList);\n    }\n    return toObject;\n}\nfunction batchJobSourceToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, ['format']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['instancesFormat'], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsSource', 'uris'], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, ['bigqueryUri']);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, ['bigquerySource', 'inputUri'], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, ['fileName']) !== undefined) {\n        throw new Error('fileName parameter is not supported in Vertex AI.');\n    }\n    if (getValueByPath(fromObject, ['inlinedRequests']) !== undefined) {\n        throw new Error('inlinedRequests parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction blobToMldev$4(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction candidateFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, ['content']);\n    if (fromContent != null) {\n        setValueByPath(toObject, ['content'], fromContent);\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        'citationMetadata',\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, ['citationMetadata'], citationMetadataFromMldev$1(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, ['tokenCount']);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, ['tokenCount'], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, ['finishReason']);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, ['finishReason'], fromFinishReason);\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, ['avgLogprobs']);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, ['avgLogprobs'], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        'groundingMetadata',\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, ['groundingMetadata'], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, ['index']);\n    if (fromIndex != null) {\n        setValueByPath(toObject, ['index'], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        'logprobsResult',\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, ['logprobsResult'], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        'safetyRatings',\n    ]);\n    if (fromSafetyRatings != null) {\n        let transformedList = fromSafetyRatings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['safetyRatings'], transformedList);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        'urlContextMetadata',\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, ['urlContextMetadata'], fromUrlContextMetadata);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, ['citationSources']);\n    if (fromCitations != null) {\n        let transformedList = fromCitations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['citations'], transformedList);\n    }\n    return toObject;\n}\nfunction contentToMldev$4(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['batch', 'displayName'], fromDisplayName);\n    }\n    if (getValueByPath(fromObject, ['dest']) !== undefined) {\n        throw new Error('dest parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromDest = getValueByPath(fromObject, ['dest']);\n    if (parentObject !== undefined && fromDest != null) {\n        setValueByPath(parentObject, ['outputConfig'], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, ['src']);\n    if (fromSrc != null) {\n        setValueByPath(toObject, ['batch', 'inputConfig'], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createBatchJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, ['src']);\n    if (fromSrc != null) {\n        setValueByPath(toObject, ['inputConfig'], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createBatchJobConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createEmbeddingsBatchJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['batch', 'displayName'], fromDisplayName);\n    }\n    return toObject;\n}\nfunction createEmbeddingsBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, ['src']);\n    if (fromSrc != null) {\n        setValueByPath(toObject, ['batch', 'inputConfig'], embeddingsBatchJobSourceToMldev(apiClient, fromSrc));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createEmbeddingsBatchJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteResourceJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    return toObject;\n}\nfunction deleteResourceJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    return toObject;\n}\nfunction embedContentBatchToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContentsForEmbed(apiClient, fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['requests[]', 'request', 'content'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['_self'], embedContentConfigToMldev$1(fromConfig, toObject));\n        moveValueByPath(toObject, { 'requests[].*': 'requests[].request.*' });\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev$1(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, ['taskType']);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, ['requests[]', 'taskType'], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, ['title']);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, ['requests[]', 'title'], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        'outputDimensionality',\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, ['requests[]', 'outputDimensionality'], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, ['mimeType']) !== undefined) {\n        throw new Error('mimeType parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['autoTruncate']) !== undefined) {\n        throw new Error('autoTruncate parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction embeddingsBatchJobSourceToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromFileName = getValueByPath(fromObject, ['fileName']);\n    if (fromFileName != null) {\n        setValueByPath(toObject, ['file_name'], fromFileName);\n    }\n    const fromInlinedRequests = getValueByPath(fromObject, [\n        'inlinedRequests',\n    ]);\n    if (fromInlinedRequests != null) {\n        setValueByPath(toObject, ['requests'], embedContentBatchToMldev(apiClient, fromInlinedRequests));\n    }\n    return toObject;\n}\nfunction fileDataToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$4(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    if (getValueByPath(fromObject, ['partialArgs']) !== undefined) {\n        throw new Error('partialArgs parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['willContinue']) !== undefined) {\n        throw new Error('willContinue parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        'allowedFunctionNames',\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, ['allowedFunctionNames'], fromAllowedFunctionNames);\n    }\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    if (getValueByPath(fromObject, ['streamFunctionCallArguments']) !==\n        undefined) {\n        throw new Error('streamFunctionCallArguments parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], contentToMldev$4(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        'candidateCount',\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, ['candidateCount'], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        'stopSequences',\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, ['stopSequences'], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        'responseLogprobs',\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, ['logprobs']);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, ['logprobs'], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        'presencePenalty',\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        'frequencyPenalty',\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        'responseMimeType',\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        'responseSchema',\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, ['responseSchema'], tSchema(fromResponseSchema));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, ['routingConfig']) !== undefined) {\n        throw new Error('routingConfig parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['modelSelectionConfig']) !== undefined) {\n        throw new Error('modelSelectionConfig parameter is not supported in Gemini API.');\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        'safetySettings',\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return safetySettingToMldev$1(item);\n            });\n        }\n        setValueByPath(parentObject, ['safetySettings'], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev$4(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], toolConfigToMldev$2(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, ['labels']) !== undefined) {\n        throw new Error('labels parameter is not supported in Gemini API.');\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        'cachedContent',\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, ['cachedContent'], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, ['responseModalities'], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, ['speechConfig'], tSpeechConfig(fromSpeechConfig));\n    }\n    if (getValueByPath(fromObject, ['audioTimestamp']) !== undefined) {\n        throw new Error('audioTimestamp parameter is not supported in Gemini API.');\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, ['thinkingConfig'], fromThinkingConfig);\n    }\n    const fromImageConfig = getValueByPath(fromObject, ['imageConfig']);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, ['imageConfig'], imageConfigToMldev$1(fromImageConfig));\n    }\n    const fromEnableEnhancedCivicAnswers = getValueByPath(fromObject, [\n        'enableEnhancedCivicAnswers',\n    ]);\n    if (fromEnableEnhancedCivicAnswers != null) {\n        setValueByPath(toObject, ['enableEnhancedCivicAnswers'], fromEnableEnhancedCivicAnswers);\n    }\n    if (getValueByPath(fromObject, ['modelArmorConfig']) !== undefined) {\n        throw new Error('modelArmorConfig parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, ['candidates']);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return candidateFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['candidates'], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, ['modelVersion']);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, ['modelVersion'], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        'promptFeedback',\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, ['promptFeedback'], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, ['responseId']);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, ['responseId'], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['authConfig']) !== undefined) {\n        throw new Error('authConfig parameter is not supported in Gemini API.');\n    }\n    const fromEnableWidget = getValueByPath(fromObject, ['enableWidget']);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, ['enableWidget'], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['blockingConfidence']) !== undefined) {\n        throw new Error('blockingConfidence parameter is not supported in Gemini API.');\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction imageConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, ['aspectRatio'], fromAspectRatio);\n    }\n    const fromImageSize = getValueByPath(fromObject, ['imageSize']);\n    if (fromImageSize != null) {\n        setValueByPath(toObject, ['imageSize'], fromImageSize);\n    }\n    if (getValueByPath(fromObject, ['personGeneration']) !== undefined) {\n        throw new Error('personGeneration parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['outputMimeType']) !== undefined) {\n        throw new Error('outputMimeType parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['outputCompressionQuality']) !==\n        undefined) {\n        throw new Error('outputCompressionQuality parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction inlinedRequestToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['request', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, ['request', 'contents'], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['request', 'generationConfig'], generateContentConfigToMldev$1(apiClient, fromConfig, getValueByPath(toObject, ['request'], {})));\n    }\n    return toObject;\n}\nfunction inlinedResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateContentResponseFromMldev$1(fromResponse));\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    if (getValueByPath(fromObject, ['filter']) !== undefined) {\n        throw new Error('filter parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listBatchJobsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listBatchJobsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, ['operations']);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return batchJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['batchJobs'], transformedList);\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, [\n        'batchPredictionJobs',\n    ]);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return batchJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['batchJobs'], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$4(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev$4(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallToMldev$4(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev$4(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev$1(fromObject) {\n    const toObject = {};\n    const fromCategory = getValueByPath(fromObject, ['category']);\n    if (fromCategory != null) {\n        setValueByPath(toObject, ['category'], fromCategory);\n    }\n    if (getValueByPath(fromObject, ['method']) !== undefined) {\n        throw new Error('method parameter is not supported in Gemini API.');\n    }\n    const fromThreshold = getValueByPath(fromObject, ['threshold']);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, ['threshold'], fromThreshold);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        'retrievalConfig',\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, ['retrievalConfig'], fromRetrievalConfig);\n    }\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        'functionCallingConfig',\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, ['functionCallingConfig'], functionCallingConfigToMldev$2(fromFunctionCallingConfig));\n    }\n    return toObject;\n}\nfunction toolToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, ['fileSearch']);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, ['fileSearch'], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], googleMapsToMldev$4(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev$4(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nvar PagedItem;\n(function (PagedItem) {\n    PagedItem[\"PAGED_ITEM_BATCH_JOBS\"] = \"batchJobs\";\n    PagedItem[\"PAGED_ITEM_MODELS\"] = \"models\";\n    PagedItem[\"PAGED_ITEM_TUNING_JOBS\"] = \"tuningJobs\";\n    PagedItem[\"PAGED_ITEM_FILES\"] = \"files\";\n    PagedItem[\"PAGED_ITEM_CACHED_CONTENTS\"] = \"cachedContents\";\n    PagedItem[\"PAGED_ITEM_FILE_SEARCH_STORES\"] = \"fileSearchStores\";\n    PagedItem[\"PAGED_ITEM_DOCUMENTS\"] = \"documents\";\n})(PagedItem || (PagedItem = {}));\n/**\n * Pager class for iterating through paginated results.\n */\nclass Pager {\n    constructor(name, request, response, params) {\n        this.pageInternal = [];\n        this.paramsInternal = {};\n        this.requestInternal = request;\n        this.init(name, response, params);\n    }\n    init(name, response, params) {\n        var _a, _b;\n        this.nameInternal = name;\n        this.pageInternal = response[this.nameInternal] || [];\n        this.sdkHttpResponseInternal = response === null || response === void 0 ? void 0 : response.sdkHttpResponse;\n        this.idxInternal = 0;\n        let requestParams = { config: {} };\n        if (!params || Object.keys(params).length === 0) {\n            requestParams = { config: {} };\n        }\n        else if (typeof params === 'object') {\n            requestParams = Object.assign({}, params);\n        }\n        else {\n            requestParams = params;\n        }\n        if (requestParams['config']) {\n            requestParams['config']['pageToken'] = response['nextPageToken'];\n        }\n        this.paramsInternal = requestParams;\n        this.pageInternalSize =\n            (_b = (_a = requestParams['config']) === null || _a === void 0 ? void 0 : _a['pageSize']) !== null && _b !== void 0 ? _b : this.pageInternal.length;\n    }\n    initNextPage(response) {\n        this.init(this.nameInternal, response, this.paramsInternal);\n    }\n    /**\n     * Returns the current page, which is a list of items.\n     *\n     * @remarks\n     * The first page is retrieved when the pager is created. The returned list of\n     * items could be a subset of the entire list.\n     */\n    get page() {\n        return this.pageInternal;\n    }\n    /**\n     * Returns the type of paged item (for example, ``batch_jobs``).\n     */\n    get name() {\n        return this.nameInternal;\n    }\n    /**\n     * Returns the length of the page fetched each time by this pager.\n     *\n     * @remarks\n     * The number of items in the page is less than or equal to the page length.\n     */\n    get pageSize() {\n        return this.pageInternalSize;\n    }\n    /**\n     * Returns the headers of the API response.\n     */\n    get sdkHttpResponse() {\n        return this.sdkHttpResponseInternal;\n    }\n    /**\n     * Returns the parameters when making the API request for the next page.\n     *\n     * @remarks\n     * Parameters contain a set of optional configs that can be\n     * used to customize the API request. For example, the `pageToken` parameter\n     * contains the token to request the next page.\n     */\n    get params() {\n        return this.paramsInternal;\n    }\n    /**\n     * Returns the total number of items in the current page.\n     */\n    get pageLength() {\n        return this.pageInternal.length;\n    }\n    /**\n     * Returns the item at the given index.\n     */\n    getItem(index) {\n        return this.pageInternal[index];\n    }\n    /**\n     * Returns an async iterator that support iterating through all items\n     * retrieved from the API.\n     *\n     * @remarks\n     * The iterator will automatically fetch the next page if there are more items\n     * to fetch from the API.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * for await (const file of pager) {\n     *   console.log(file.name);\n     * }\n     * ```\n     */\n    [Symbol.asyncIterator]() {\n        return {\n            next: async () => {\n                if (this.idxInternal >= this.pageLength) {\n                    if (this.hasNextPage()) {\n                        await this.nextPage();\n                    }\n                    else {\n                        return { value: undefined, done: true };\n                    }\n                }\n                const item = this.getItem(this.idxInternal);\n                this.idxInternal += 1;\n                return { value: item, done: false };\n            },\n            return: async () => {\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    /**\n     * Fetches the next page of items. This makes a new API request.\n     *\n     * @throws {Error} If there are no more pages to fetch.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * let page = pager.page;\n     * while (true) {\n     *   for (const file of page) {\n     *     console.log(file.name);\n     *   }\n     *   if (!pager.hasNextPage()) {\n     *     break;\n     *   }\n     *   page = await pager.nextPage();\n     * }\n     * ```\n     */\n    async nextPage() {\n        if (!this.hasNextPage()) {\n            throw new Error('No more pages to fetch.');\n        }\n        const response = await this.requestInternal(this.params);\n        this.initNextPage(response);\n        return this.page;\n    }\n    /**\n     * Returns true if there are more pages to fetch from the API.\n     */\n    hasNextPage() {\n        var _a;\n        if (((_a = this.params['config']) === null || _a === void 0 ? void 0 : _a['pageToken']) !== undefined) {\n            return true;\n        }\n        return false;\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Batches extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists batch jobs.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of batch jobs.\n         *\n         * @example\n         * ```ts\n         * const batchJobs = await ai.batches.list({config: {'pageSize': 2}});\n         * for await (const batchJob of batchJobs) {\n         *   console.log(batchJob);\n         * }\n         * ```\n         */\n        this.list = async (params = {}) => {\n            return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x) => this.listInternal(x), await this.listInternal(params), params);\n        };\n        /**\n         * Create batch job.\n         *\n         * @param params - The parameters for create batch job request.\n         * @return The created batch job.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.batches.create({\n         *   model: 'gemini-2.0-flash',\n         *   src: {gcsUri: 'gs://bucket/path/to/file.jsonl', format: 'jsonl'},\n         *   config: {\n         *     dest: {gcsUri: 'gs://bucket/path/output/directory', format: 'jsonl'},\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */\n        this.create = async (params) => {\n            if (this.apiClient.isVertexAI()) {\n                // Format destination if not provided\n                // Cast params.src as Vertex AI path does not handle InlinedRequest[]\n                params.config = this.formatDestination(params.src, params.config);\n            }\n            return this.createInternal(params);\n        };\n        /**\n         * **Experimental** Creates an embedding batch job.\n         *\n         * @param params - The parameters for create embedding batch job request.\n         * @return The created batch job.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.batches.createEmbeddings({\n         *   model: 'text-embedding-004',\n         *   src: {fileName: 'files/my_embedding_input'},\n         * });\n         * console.log(response);\n         * ```\n         */\n        this.createEmbeddings = async (params) => {\n            console.warn('batches.createEmbeddings() is experimental and may change without notice.');\n            if (this.apiClient.isVertexAI()) {\n                throw new Error('Vertex AI does not support batches.createEmbeddings.');\n            }\n            return this.createEmbeddingsInternal(params);\n        };\n    }\n    // Helper function to handle inlined generate content requests\n    createInlinedGenerateContentRequest(params) {\n        const body = createBatchJobParametersToMldev(this.apiClient, // Use instance apiClient\n        params);\n        const urlParams = body['_url'];\n        const path = formatMap('{model}:batchGenerateContent', urlParams);\n        const batch = body['batch'];\n        const inputConfig = batch['inputConfig'];\n        const requestsWrapper = inputConfig['requests'];\n        const requests = requestsWrapper['requests'];\n        const newRequests = [];\n        for (const request of requests) {\n            const requestDict = Object.assign({}, request); // Clone\n            if (requestDict['systemInstruction']) {\n                const systemInstructionValue = requestDict['systemInstruction'];\n                delete requestDict['systemInstruction'];\n                const requestContent = requestDict['request'];\n                requestContent['systemInstruction'] = systemInstructionValue;\n                requestDict['request'] = requestContent;\n            }\n            newRequests.push(requestDict);\n        }\n        requestsWrapper['requests'] = newRequests;\n        delete body['config'];\n        delete body['_url'];\n        delete body['_query'];\n        return { path, body };\n    }\n    // Helper function to get the first GCS URI\n    getGcsUri(src) {\n        if (typeof src === 'string') {\n            return src.startsWith('gs://') ? src : undefined;\n        }\n        if (!Array.isArray(src) && src.gcsUri && src.gcsUri.length > 0) {\n            return src.gcsUri[0];\n        }\n        return undefined;\n    }\n    // Helper function to get the BigQuery URI\n    getBigqueryUri(src) {\n        if (typeof src === 'string') {\n            return src.startsWith('bq://') ? src : undefined;\n        }\n        if (!Array.isArray(src)) {\n            return src.bigqueryUri;\n        }\n        return undefined;\n    }\n    // Function to format the destination configuration for Vertex AI\n    formatDestination(src, config) {\n        const newConfig = config ? Object.assign({}, config) : {};\n        const timestampStr = Date.now().toString();\n        if (!newConfig.displayName) {\n            newConfig.displayName = `genaiBatchJob_${timestampStr}`;\n        }\n        if (newConfig.dest === undefined) {\n            const gcsUri = this.getGcsUri(src);\n            const bigqueryUri = this.getBigqueryUri(src);\n            if (gcsUri) {\n                if (gcsUri.endsWith('.jsonl')) {\n                    // For .jsonl files, remove suffix and add /dest\n                    newConfig.dest = `${gcsUri.slice(0, -6)}/dest`;\n                }\n                else {\n                    // Fallback for other GCS URIs\n                    newConfig.dest = `${gcsUri}_dest_${timestampStr}`;\n                }\n            }\n            else if (bigqueryUri) {\n                newConfig.dest = `${bigqueryUri}_dest_${timestampStr}`;\n            }\n            else {\n                throw new Error('Unsupported source for Vertex AI: No GCS or BigQuery URI found.');\n            }\n        }\n        return newConfig;\n    }\n    /**\n     * Internal method to create batch job.\n     *\n     * @param params - The parameters for create batch job request.\n     * @return The created batch job.\n     *\n     */\n    async createInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap('batchPredictionJobs', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = createBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:batchGenerateContent', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Internal method to create batch job.\n     *\n     * @param params - The parameters for create batch job request.\n     * @return The created batch job.\n     *\n     */\n    async createEmbeddingsInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:asyncBatchEmbedContent', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets batch job configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The batch job.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap('batchPredictionJobs/{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = getBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('batches/{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Cancels a batch job.\n     *\n     * @param params - The parameters for the cancel request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.cancel({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async cancel(params) {\n        var _a, _b, _c, _d;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = cancelBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap('batchPredictionJobs/{name}:cancel', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            });\n        }\n        else {\n            const body = cancelBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('batches/{name}:cancel', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listBatchJobsParametersToVertex(params);\n            path = formatMap('batchPredictionJobs', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listBatchJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = listBatchJobsParametersToMldev(params);\n            path = formatMap('batches', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listBatchJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Deletes a batch job.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap('batchPredictionJobs/{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteResourceJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = deleteBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('batches/{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteResourceJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction blobToMldev$3(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction contentToMldev$3(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev$3(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, ['ttl']);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, ['ttl'], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, ['contents'], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], contentToMldev$3(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], toolConfigToMldev$1(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, ['kmsKeyName']) !== undefined) {\n        throw new Error('kmsKeyName parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, ['ttl']);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, ['ttl'], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(parentObject, ['contents'], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], tContent(fromSystemInstruction));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToVertex$2(item);\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], fromToolConfig);\n    }\n    const fromKmsKeyName = getValueByPath(fromObject, ['kmsKeyName']);\n    if (parentObject !== undefined && fromKmsKeyName != null) {\n        setValueByPath(parentObject, ['encryption_spec', 'kmsKeyName'], fromKmsKeyName);\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createCachedContentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createCachedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$3(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    if (getValueByPath(fromObject, ['partialArgs']) !== undefined) {\n        throw new Error('partialArgs parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['willContinue']) !== undefined) {\n        throw new Error('willContinue parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        'allowedFunctionNames',\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, ['allowedFunctionNames'], fromAllowedFunctionNames);\n    }\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    if (getValueByPath(fromObject, ['streamFunctionCallArguments']) !==\n        undefined) {\n        throw new Error('streamFunctionCallArguments parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$2(fromObject) {\n    const toObject = {};\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, ['parameters']);\n    if (fromParameters != null) {\n        setValueByPath(toObject, ['parameters'], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        'parametersJsonSchema',\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, ['parametersJsonSchema'], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, ['behavior']) !== undefined) {\n        throw new Error('behavior parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['authConfig']) !== undefined) {\n        throw new Error('authConfig parameter is not supported in Gemini API.');\n    }\n    const fromEnableWidget = getValueByPath(fromObject, ['enableWidget']);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, ['enableWidget'], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['blockingConfidence']) !== undefined) {\n        throw new Error('blockingConfidence parameter is not supported in Gemini API.');\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listCachedContentsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listCachedContentsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listCachedContentsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        'cachedContents',\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['cachedContents'], transformedList);\n    }\n    return toObject;\n}\nfunction listCachedContentsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        'cachedContents',\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['cachedContents'], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$3(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev$3(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallToMldev$3(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev$3(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        'retrievalConfig',\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, ['retrievalConfig'], fromRetrievalConfig);\n    }\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        'functionCallingConfig',\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, ['functionCallingConfig'], functionCallingConfigToMldev$1(fromFunctionCallingConfig));\n    }\n    return toObject;\n}\nfunction toolToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, ['fileSearch']);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, ['fileSearch'], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], googleMapsToMldev$3(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev$3(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\nfunction toolToVertex$2(fromObject) {\n    const toObject = {};\n    const fromRetrieval = getValueByPath(fromObject, ['retrieval']);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, ['retrieval'], fromRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    if (getValueByPath(fromObject, ['fileSearch']) !== undefined) {\n        throw new Error('fileSearch parameter is not supported in Vertex AI.');\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        'enterpriseWebSearch',\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, ['enterpriseWebSearch'], fromEnterpriseWebSearch);\n    }\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionDeclarationToVertex$2(item);\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], fromGoogleMaps);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], fromGoogleSearch);\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, ['ttl']);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, ['ttl'], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, ['ttl']);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, ['ttl'], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        updateCachedContentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        updateCachedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Caches extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists cached contents.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of cached contents.\n         *\n         * @example\n         * ```ts\n         * const cachedContents = await ai.caches.list({config: {'pageSize': 2}});\n         * for await (const cachedContent of cachedContents) {\n         *   console.log(cachedContent);\n         * }\n         * ```\n         */\n        this.list = async (params = {}) => {\n            return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x) => this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Creates a cached contents resource.\n     *\n     * @remarks\n     * Context caching is only supported for specific models. See [Gemini\n     * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)\n     * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)\n     * for more information.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created cached content.\n     *\n     * @example\n     * ```ts\n     * const contents = ...; // Initialize the content to cache.\n     * const response = await ai.caches.create({\n     *   model: 'gemini-2.0-flash-001',\n     *   config: {\n     *    'contents': contents,\n     *    'displayName': 'test cache',\n     *    'systemInstruction': 'What is the sum of the two pdfs?',\n     *    'ttl': '86400s',\n     *  }\n     * });\n     * ```\n     */\n    async create(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('cachedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n        else {\n            const body = createCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('cachedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets cached content configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The cached content.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n        else {\n            const body = getCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes cached content.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteCachedContentResponseFromVertex(apiResponse);\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = deleteCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteCachedContentResponseFromMldev(apiResponse);\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates cached content configurations.\n     *\n     * @param params - The parameters for the update request.\n     * @return The updated cached content.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.caches.update({\n     *   name: '...',  // The server-generated resource name.\n     *   config: {'ttl': '7600s'}\n     * });\n     * ```\n     */\n    async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'PATCH',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n        else {\n            const body = updateCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'PATCH',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listCachedContentsParametersToVertex(params);\n            path = formatMap('cachedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listCachedContentsResponseFromVertex(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = listCachedContentsParametersToMldev(params);\n            path = formatMap('cachedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listCachedContentsResponseFromMldev(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Returns true if the response is valid, false otherwise.\n */\nfunction isValidResponse(response) {\n    var _a;\n    if (response.candidates == undefined || response.candidates.length === 0) {\n        return false;\n    }\n    const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;\n    if (content === undefined) {\n        return false;\n    }\n    return isValidContent(content);\n}\nfunction isValidContent(content) {\n    if (content.parts === undefined || content.parts.length === 0) {\n        return false;\n    }\n    for (const part of content.parts) {\n        if (part === undefined || Object.keys(part).length === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Validates the history contains the correct roles.\n *\n * @throws Error if the history does not start with a user turn.\n * @throws Error if the history contains an invalid role.\n */\nfunction validateHistory(history) {\n    // Empty history is valid.\n    if (history.length === 0) {\n        return;\n    }\n    for (const content of history) {\n        if (content.role !== 'user' && content.role !== 'model') {\n            throw new Error(`Role must be user or model, but got ${content.role}.`);\n        }\n    }\n}\n/**\n * Extracts the curated (valid) history from a comprehensive history.\n *\n * @remarks\n * The model may sometimes generate invalid or empty contents(e.g., due to safty\n * filters or recitation). Extracting valid turns from the history\n * ensures that subsequent requests could be accpeted by the model.\n */\nfunction extractCuratedHistory(comprehensiveHistory) {\n    if (comprehensiveHistory === undefined || comprehensiveHistory.length === 0) {\n        return [];\n    }\n    const curatedHistory = [];\n    const length = comprehensiveHistory.length;\n    let i = 0;\n    while (i < length) {\n        if (comprehensiveHistory[i].role === 'user') {\n            curatedHistory.push(comprehensiveHistory[i]);\n            i++;\n        }\n        else {\n            const modelOutput = [];\n            let isValid = true;\n            while (i < length && comprehensiveHistory[i].role === 'model') {\n                modelOutput.push(comprehensiveHistory[i]);\n                if (isValid && !isValidContent(comprehensiveHistory[i])) {\n                    isValid = false;\n                }\n                i++;\n            }\n            if (isValid) {\n                curatedHistory.push(...modelOutput);\n            }\n            else {\n                // Remove the last user input when model content is invalid.\n                curatedHistory.pop();\n            }\n        }\n    }\n    return curatedHistory;\n}\n/**\n * A utility class to create a chat session.\n */\nclass Chats {\n    constructor(modelsModule, apiClient) {\n        this.modelsModule = modelsModule;\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates a new chat session.\n     *\n     * @remarks\n     * The config in the params will be used for all requests within the chat\n     * session unless overridden by a per-request `config` in\n     * @see {@link types.SendMessageParameters#config}.\n     *\n     * @param params - Parameters for creating a chat session.\n     * @returns A new chat session.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({\n     *   model: 'gemini-2.0-flash'\n     *   config: {\n     *     temperature: 0.5,\n     *     maxOutputTokens: 1024,\n     *   }\n     * });\n     * ```\n     */\n    create(params) {\n        return new Chat(this.apiClient, this.modelsModule, params.model, params.config, \n        // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        structuredClone(params.history));\n    }\n}\n/**\n * Chat session that enables sending messages to the model with previous\n * conversation context.\n *\n * @remarks\n * The session maintains all the turns between user and model.\n */\nclass Chat {\n    constructor(apiClient, modelsModule, model, config = {}, history = []) {\n        this.apiClient = apiClient;\n        this.modelsModule = modelsModule;\n        this.model = model;\n        this.config = config;\n        this.history = history;\n        // A promise to represent the current state of the message being sent to the\n        // model.\n        this.sendPromise = Promise.resolve();\n        validateHistory(history);\n    }\n    /**\n     * Sends a message to the model and returns the response.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessageStream} for streaming method.\n     * @param params - parameters for sending messages within a chat session.\n     * @returns The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessage({\n     *   message: 'Why is the sky blue?'\n     * });\n     * console.log(response.text);\n     * ```\n     */\n    async sendMessage(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const responsePromise = this.modelsModule.generateContent({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config,\n        });\n        this.sendPromise = (async () => {\n            var _a, _b, _c;\n            const response = await responsePromise;\n            const outputContent = (_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n            // Because the AFC input contains the entire curated chat history in\n            // addition to the new user input, we need to truncate the AFC history\n            // to deduplicate the existing chat history.\n            const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;\n            const index = this.getHistory(true).length;\n            let automaticFunctionCallingHistory = [];\n            if (fullAutomaticFunctionCallingHistory != null) {\n                automaticFunctionCallingHistory =\n                    (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];\n            }\n            const modelOutput = outputContent ? [outputContent] : [];\n            this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);\n            return;\n        })();\n        await this.sendPromise.catch(() => {\n            // Resets sendPromise to avoid subsequent calls failing\n            this.sendPromise = Promise.resolve();\n        });\n        return responsePromise;\n    }\n    /**\n     * Sends a message to the model and returns the response in chunks.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessage} for non-streaming method.\n     * @param params - parameters for sending the message.\n     * @return The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessageStream({\n     *   message: 'Why is the sky blue?'\n     * });\n     * for await (const chunk of response) {\n     *   console.log(chunk.text);\n     * }\n     * ```\n     */\n    async sendMessageStream(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const streamResponse = this.modelsModule.generateContentStream({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config,\n        });\n        // Resolve the internal tracking of send completion promise - `sendPromise`\n        // for both success and failure response. The actual failure is still\n        // propagated by the `await streamResponse`.\n        this.sendPromise = streamResponse\n            .then(() => undefined)\n            .catch(() => undefined);\n        const response = await streamResponse;\n        const result = this.processStreamResponse(response, inputContent);\n        return result;\n    }\n    /**\n     * Returns the chat history.\n     *\n     * @remarks\n     * The history is a list of contents alternating between user and model.\n     *\n     * There are two types of history:\n     * - The `curated history` contains only the valid turns between user and\n     * model, which will be included in the subsequent requests sent to the model.\n     * - The `comprehensive history` contains all turns, including invalid or\n     *   empty model outputs, providing a complete record of the history.\n     *\n     * The history is updated after receiving the response from the model,\n     * for streaming response, it means receiving the last chunk of the response.\n     *\n     * The `comprehensive history` is returned by default. To get the `curated\n     * history`, set the `curated` parameter to `true`.\n     *\n     * @param curated - whether to return the curated history or the comprehensive\n     *     history.\n     * @return History contents alternating between user and model for the entire\n     *     chat session.\n     */\n    getHistory(curated = false) {\n        const history = curated\n            ? extractCuratedHistory(this.history)\n            : this.history;\n        // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        return structuredClone(history);\n    }\n    processStreamResponse(streamResponse, inputContent) {\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            var _a, e_1, _b, _c;\n            var _d, _e;\n            const outputContent = [];\n            try {\n                for (var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _a = streamResponse_1_1.done, !_a; _f = true) {\n                    _c = streamResponse_1_1.value;\n                    _f = false;\n                    const chunk = _c;\n                    if (isValidResponse(chunk)) {\n                        const content = (_e = (_d = chunk.candidates) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.content;\n                        if (content !== undefined) {\n                            outputContent.push(content);\n                        }\n                    }\n                    yield yield __await(chunk);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_f && !_a && (_b = streamResponse_1.return)) yield __await(_b.call(streamResponse_1));\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            this.recordHistory(inputContent, outputContent);\n        });\n    }\n    recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {\n        let outputContents = [];\n        if (modelOutput.length > 0 &&\n            modelOutput.every((content) => content.role !== undefined)) {\n            outputContents = modelOutput;\n        }\n        else {\n            // Appends an empty content when model returns empty response, so that the\n            // history is always alternating between user and model.\n            outputContents.push({\n                role: 'model',\n                parts: [],\n            });\n        }\n        if (automaticFunctionCallingHistory &&\n            automaticFunctionCallingHistory.length > 0) {\n            this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));\n        }\n        else {\n            this.history.push(userInput);\n        }\n        this.history.push(...outputContents);\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * API errors raised by the GenAI API.\n */\nclass ApiError extends Error {\n    constructor(options) {\n        super(options.message);\n        this.name = 'ApiError';\n        this.status = options.status;\n        Object.setPrototypeOf(this, ApiError.prototype);\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction createFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFile = getValueByPath(fromObject, ['file']);\n    if (fromFile != null) {\n        setValueByPath(toObject, ['file'], fromFile);\n    }\n    return toObject;\n}\nfunction createFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'file'], tFileName(fromName));\n    }\n    return toObject;\n}\nfunction deleteFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction getFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'file'], tFileName(fromName));\n    }\n    return toObject;\n}\nfunction internalRegisterFilesParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromUris = getValueByPath(fromObject, ['uris']);\n    if (fromUris != null) {\n        setValueByPath(toObject, ['uris'], fromUris);\n    }\n    return toObject;\n}\nfunction listFilesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    return toObject;\n}\nfunction listFilesParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listFilesConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listFilesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromFiles = getValueByPath(fromObject, ['files']);\n    if (fromFiles != null) {\n        let transformedList = fromFiles;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['files'], transformedList);\n    }\n    return toObject;\n}\nfunction registerFilesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromFiles = getValueByPath(fromObject, ['files']);\n    if (fromFiles != null) {\n        let transformedList = fromFiles;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['files'], transformedList);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Files extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists files.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of files.\n         *\n         * @example\n         * ```ts\n         * const files = await ai.files.list({config: {'pageSize': 2}});\n         * for await (const file of files) {\n         *   console.log(file);\n         * }\n         * ```\n         */\n        this.list = async (params = {}) => {\n            return new Pager(PagedItem.PAGED_ITEM_FILES, (x) => this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Uploads a file asynchronously to the Gemini API.\n     * This method is not available in Vertex AI.\n     * Supported upload sources:\n     * - Node.js: File path (string) or Blob object.\n     * - Browser: Blob object (e.g., File).\n     *\n     * @remarks\n     * The `mimeType` can be specified in the `config` parameter. If omitted:\n     *  - For file path (string) inputs, the `mimeType` will be inferred from the\n     *     file extension.\n     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`\n     *     property.\n     * Somex eamples for file extension to mimeType mapping:\n     * .txt -> text/plain\n     * .json -> application/json\n     * .jpg  -> image/jpeg\n     * .png -> image/png\n     * .mp3 -> audio/mpeg\n     * .mp4 -> video/mp4\n     *\n     * This section can contain multiple paragraphs and code examples.\n     *\n     * @param params - Optional parameters specified in the\n     *        `types.UploadFileParameters` interface.\n     *         @see {@link types.UploadFileParameters#config} for the optional\n     *         config in the parameters.\n     * @return A promise that resolves to a `types.File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     * the `mimeType` can be provided in the `params.config` parameter.\n     * @throws An error occurs if a suitable upload location cannot be established.\n     *\n     * @example\n     * The following code uploads a file to Gemini API.\n     *\n     * ```ts\n     * const file = await ai.files.upload({file: 'file.txt', config: {\n     *   mimeType: 'text/plain',\n     * }});\n     * console.log(file.name);\n     * ```\n     */\n    async upload(params) {\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('Vertex AI does not support uploading files. You can share files through a GCS bucket.');\n        }\n        return this.apiClient\n            .uploadFile(params.file, params.config)\n            .then((resp) => {\n            return resp;\n        });\n    }\n    /**\n     * Downloads a remotely stored file asynchronously to a location specified in\n     * the `params` object. This method only works on Node environment, to\n     * download files in the browser, use a browser compliant method like an <a>\n     * tag.\n     *\n     * @param params - The parameters for the download request.\n     *\n     * @example\n     * The following code downloads an example file named \"files/mehozpxf877d\" as\n     * \"file.txt\".\n     *\n     * ```ts\n     * await ai.files.download({file: file.name, downloadPath: 'file.txt'});\n     * ```\n     */\n    async download(params) {\n        await this.apiClient.downloadFile(params);\n    }\n    /**\n     * Registers Google Cloud Storage files for use with the API.\n     * This method is only available in Node.js environments.\n     */\n    async registerFiles(params) {\n        throw new Error('registerFiles is only supported in Node.js environments.');\n    }\n    async _registerFiles(params) {\n        return this.registerFilesInternal(params);\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = listFilesParametersToMldev(params);\n            path = formatMap('files', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listFilesResponseFromMldev(apiResponse);\n                const typedResp = new ListFilesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async createInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = createFileParametersToMldev(params);\n            path = formatMap('upload/v1beta/files', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = createFileResponseFromMldev(apiResponse);\n                const typedResp = new CreateFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Retrieves the file information from the service.\n     *\n     * @param params - The parameters for the get request\n     * @return The Promise that resolves to the types.File object requested.\n     *\n     * @example\n     * ```ts\n     * const config: GetFileParameters = {\n     *   name: fileName,\n     * };\n     * file = await ai.files.get(config);\n     * console.log(file.name);\n     * ```\n     */\n    async get(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = getFileParametersToMldev(params);\n            path = formatMap('files/{file}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a remotely stored file.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The DeleteFileResponse, the response for the delete method.\n     *\n     * @example\n     * The following code deletes an example file named \"files/mehozpxf877d\".\n     *\n     * ```ts\n     * await ai.files.delete({name: file.name});\n     * ```\n     */\n    async delete(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = deleteFileParametersToMldev(params);\n            path = formatMap('files/{file}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteFileResponseFromMldev(apiResponse);\n                const typedResp = new DeleteFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async registerFilesInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = internalRegisterFilesParametersToMldev(params);\n            path = formatMap('files:register', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = registerFilesResponseFromMldev(apiResponse);\n                const typedResp = new RegisterFilesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction blobToMldev$2(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction contentToMldev$2(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$2(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    if (getValueByPath(fromObject, ['partialArgs']) !== undefined) {\n        throw new Error('partialArgs parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['willContinue']) !== undefined) {\n        throw new Error('willContinue parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$1(fromObject) {\n    const toObject = {};\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, ['parameters']);\n    if (fromParameters != null) {\n        setValueByPath(toObject, ['parameters'], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        'parametersJsonSchema',\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, ['parametersJsonSchema'], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, ['behavior']) !== undefined) {\n        throw new Error('behavior parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction generationConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        'modelSelectionConfig',\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, ['modelConfig'], fromModelSelectionConfig);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        'audioTimestamp',\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, ['audioTimestamp'], fromAudioTimestamp);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        'candidateCount',\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, ['candidateCount'], fromCandidateCount);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        'enableAffectiveDialog',\n    ]);\n    if (fromEnableAffectiveDialog != null) {\n        setValueByPath(toObject, ['enableAffectiveDialog'], fromEnableAffectiveDialog);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        'frequencyPenalty',\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);\n    }\n    const fromLogprobs = getValueByPath(fromObject, ['logprobs']);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, ['logprobs'], fromLogprobs);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        'presencePenalty',\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        'responseLogprobs',\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        'responseMimeType',\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, ['responseModalities'], fromResponseModalities);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        'responseSchema',\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, ['responseSchema'], fromResponseSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        'routingConfig',\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, ['routingConfig'], fromRoutingConfig);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, ['speechConfig'], fromSpeechConfig);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        'stopSequences',\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, ['stopSequences'], fromStopSequences);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, ['thinkingConfig'], fromThinkingConfig);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    if (getValueByPath(fromObject, ['enableEnhancedCivicAnswers']) !==\n        undefined) {\n        throw new Error('enableEnhancedCivicAnswers parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['authConfig']) !== undefined) {\n        throw new Error('authConfig parameter is not supported in Gemini API.');\n    }\n    const fromEnableWidget = getValueByPath(fromObject, ['enableWidget']);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, ['enableWidget'], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['blockingConfidence']) !== undefined) {\n        throw new Error('blockingConfidence parameter is not supported in Gemini API.');\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev$1(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        'generationConfig',\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig'], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'responseModalities'], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topK'], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'mediaResolution'], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'seed'], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'speechConfig'], tLiveSpeechConfig(fromSpeechConfig));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'thinkingConfig'], fromThinkingConfig);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        'enableAffectiveDialog',\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'enableAffectiveDialog'], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['setup', 'systemInstruction'], contentToMldev$2(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev$2(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['setup', 'tools'], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        'sessionResumption',\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, ['setup', 'sessionResumption'], sessionResumptionConfigToMldev$1(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        'inputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'inputAudioTranscription'], fromInputAudioTranscription);\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        'outputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'outputAudioTranscription'], fromOutputAudioTranscription);\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        'realtimeInputConfig',\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, ['setup', 'realtimeInputConfig'], fromRealtimeInputConfig);\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        'contextWindowCompression',\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, ['setup', 'contextWindowCompression'], fromContextWindowCompression);\n    }\n    const fromProactivity = getValueByPath(fromObject, ['proactivity']);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, ['setup', 'proactivity'], fromProactivity);\n    }\n    if (getValueByPath(fromObject, ['explicitVadSignal']) !== undefined) {\n        throw new Error('explicitVadSignal parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction liveConnectConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        'generationConfig',\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig'], generationConfigToVertex$1(fromGenerationConfig));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'responseModalities'], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topK'], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'mediaResolution'], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'seed'], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'speechConfig'], tLiveSpeechConfig(fromSpeechConfig));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'thinkingConfig'], fromThinkingConfig);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        'enableAffectiveDialog',\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'enableAffectiveDialog'], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['setup', 'systemInstruction'], tContent(fromSystemInstruction));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToVertex$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['setup', 'tools'], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        'sessionResumption',\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, ['setup', 'sessionResumption'], fromSessionResumption);\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        'inputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'inputAudioTranscription'], fromInputAudioTranscription);\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        'outputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'outputAudioTranscription'], fromOutputAudioTranscription);\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        'realtimeInputConfig',\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, ['setup', 'realtimeInputConfig'], fromRealtimeInputConfig);\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        'contextWindowCompression',\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, ['setup', 'contextWindowCompression'], fromContextWindowCompression);\n    }\n    const fromProactivity = getValueByPath(fromObject, ['proactivity']);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, ['setup', 'proactivity'], fromProactivity);\n    }\n    const fromExplicitVadSignal = getValueByPath(fromObject, [\n        'explicitVadSignal',\n    ]);\n    if (parentObject !== undefined && fromExplicitVadSignal != null) {\n        setValueByPath(parentObject, ['setup', 'explicitVadSignal'], fromExplicitVadSignal);\n    }\n    return toObject;\n}\nfunction liveConnectParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['setup', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['config'], liveConnectConfigToMldev$1(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction liveConnectParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['setup', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['config'], liveConnectConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction liveMusicSetConfigParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMusicGenerationConfig = getValueByPath(fromObject, [\n        'musicGenerationConfig',\n    ]);\n    if (fromMusicGenerationConfig != null) {\n        setValueByPath(toObject, ['musicGenerationConfig'], fromMusicGenerationConfig);\n    }\n    return toObject;\n}\nfunction liveMusicSetWeightedPromptsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromWeightedPrompts = getValueByPath(fromObject, [\n        'weightedPrompts',\n    ]);\n    if (fromWeightedPrompts != null) {\n        let transformedList = fromWeightedPrompts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['weightedPrompts'], transformedList);\n    }\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, ['media']);\n    if (fromMedia != null) {\n        let transformedList = tBlobs(fromMedia);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return blobToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, ['mediaChunks'], transformedList);\n    }\n    const fromAudio = getValueByPath(fromObject, ['audio']);\n    if (fromAudio != null) {\n        setValueByPath(toObject, ['audio'], blobToMldev$2(tAudioBlob(fromAudio)));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        'audioStreamEnd',\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, ['audioStreamEnd'], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], blobToMldev$2(tImageBlob(fromVideo)));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        'activityStart',\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, ['activityStart'], fromActivityStart);\n    }\n    const fromActivityEnd = getValueByPath(fromObject, ['activityEnd']);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, ['activityEnd'], fromActivityEnd);\n    }\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, ['media']);\n    if (fromMedia != null) {\n        let transformedList = tBlobs(fromMedia);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['mediaChunks'], transformedList);\n    }\n    const fromAudio = getValueByPath(fromObject, ['audio']);\n    if (fromAudio != null) {\n        setValueByPath(toObject, ['audio'], tAudioBlob(fromAudio));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        'audioStreamEnd',\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, ['audioStreamEnd'], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], tImageBlob(fromVideo));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        'activityStart',\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, ['activityStart'], fromActivityStart);\n    }\n    const fromActivityEnd = getValueByPath(fromObject, ['activityEnd']);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, ['activityEnd'], fromActivityEnd);\n    }\n    return toObject;\n}\nfunction liveServerMessageFromVertex(fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        'setupComplete',\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, ['setupComplete'], fromSetupComplete);\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        'serverContent',\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, ['serverContent'], fromServerContent);\n    }\n    const fromToolCall = getValueByPath(fromObject, ['toolCall']);\n    if (fromToolCall != null) {\n        setValueByPath(toObject, ['toolCall'], fromToolCall);\n    }\n    const fromToolCallCancellation = getValueByPath(fromObject, [\n        'toolCallCancellation',\n    ]);\n    if (fromToolCallCancellation != null) {\n        setValueByPath(toObject, ['toolCallCancellation'], fromToolCallCancellation);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], usageMetadataFromVertex(fromUsageMetadata));\n    }\n    const fromGoAway = getValueByPath(fromObject, ['goAway']);\n    if (fromGoAway != null) {\n        setValueByPath(toObject, ['goAway'], fromGoAway);\n    }\n    const fromSessionResumptionUpdate = getValueByPath(fromObject, [\n        'sessionResumptionUpdate',\n    ]);\n    if (fromSessionResumptionUpdate != null) {\n        setValueByPath(toObject, ['sessionResumptionUpdate'], fromSessionResumptionUpdate);\n    }\n    const fromVoiceActivityDetectionSignal = getValueByPath(fromObject, [\n        'voiceActivityDetectionSignal',\n    ]);\n    if (fromVoiceActivityDetectionSignal != null) {\n        setValueByPath(toObject, ['voiceActivityDetectionSignal'], fromVoiceActivityDetectionSignal);\n    }\n    const fromVoiceActivity = getValueByPath(fromObject, [\n        'voiceActivity',\n    ]);\n    if (fromVoiceActivity != null) {\n        setValueByPath(toObject, ['voiceActivity'], voiceActivityFromVertex(fromVoiceActivity));\n    }\n    return toObject;\n}\nfunction partToMldev$2(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev$2(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallToMldev$2(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev$2(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, ['handle']);\n    if (fromHandle != null) {\n        setValueByPath(toObject, ['handle'], fromHandle);\n    }\n    if (getValueByPath(fromObject, ['transparent']) !== undefined) {\n        throw new Error('transparent parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction toolToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, ['fileSearch']);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, ['fileSearch'], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], googleMapsToMldev$2(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev$2(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\nfunction toolToVertex$1(fromObject) {\n    const toObject = {};\n    const fromRetrieval = getValueByPath(fromObject, ['retrieval']);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, ['retrieval'], fromRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    if (getValueByPath(fromObject, ['fileSearch']) !== undefined) {\n        throw new Error('fileSearch parameter is not supported in Vertex AI.');\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        'enterpriseWebSearch',\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, ['enterpriseWebSearch'], fromEnterpriseWebSearch);\n    }\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionDeclarationToVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], fromGoogleMaps);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], fromGoogleSearch);\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\nfunction usageMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromPromptTokenCount = getValueByPath(fromObject, [\n        'promptTokenCount',\n    ]);\n    if (fromPromptTokenCount != null) {\n        setValueByPath(toObject, ['promptTokenCount'], fromPromptTokenCount);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        'cachedContentTokenCount',\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, ['cachedContentTokenCount'], fromCachedContentTokenCount);\n    }\n    const fromResponseTokenCount = getValueByPath(fromObject, [\n        'candidatesTokenCount',\n    ]);\n    if (fromResponseTokenCount != null) {\n        setValueByPath(toObject, ['responseTokenCount'], fromResponseTokenCount);\n    }\n    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [\n        'toolUsePromptTokenCount',\n    ]);\n    if (fromToolUsePromptTokenCount != null) {\n        setValueByPath(toObject, ['toolUsePromptTokenCount'], fromToolUsePromptTokenCount);\n    }\n    const fromThoughtsTokenCount = getValueByPath(fromObject, [\n        'thoughtsTokenCount',\n    ]);\n    if (fromThoughtsTokenCount != null) {\n        setValueByPath(toObject, ['thoughtsTokenCount'], fromThoughtsTokenCount);\n    }\n    const fromTotalTokenCount = getValueByPath(fromObject, [\n        'totalTokenCount',\n    ]);\n    if (fromTotalTokenCount != null) {\n        setValueByPath(toObject, ['totalTokenCount'], fromTotalTokenCount);\n    }\n    const fromPromptTokensDetails = getValueByPath(fromObject, [\n        'promptTokensDetails',\n    ]);\n    if (fromPromptTokensDetails != null) {\n        let transformedList = fromPromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['promptTokensDetails'], transformedList);\n    }\n    const fromCacheTokensDetails = getValueByPath(fromObject, [\n        'cacheTokensDetails',\n    ]);\n    if (fromCacheTokensDetails != null) {\n        let transformedList = fromCacheTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['cacheTokensDetails'], transformedList);\n    }\n    const fromResponseTokensDetails = getValueByPath(fromObject, [\n        'candidatesTokensDetails',\n    ]);\n    if (fromResponseTokensDetails != null) {\n        let transformedList = fromResponseTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['responseTokensDetails'], transformedList);\n    }\n    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [\n        'toolUsePromptTokensDetails',\n    ]);\n    if (fromToolUsePromptTokensDetails != null) {\n        let transformedList = fromToolUsePromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['toolUsePromptTokensDetails'], transformedList);\n    }\n    const fromTrafficType = getValueByPath(fromObject, ['trafficType']);\n    if (fromTrafficType != null) {\n        setValueByPath(toObject, ['trafficType'], fromTrafficType);\n    }\n    return toObject;\n}\nfunction voiceActivityFromVertex(fromObject) {\n    const toObject = {};\n    const fromVoiceActivityType = getValueByPath(fromObject, ['type']);\n    if (fromVoiceActivityType != null) {\n        setValueByPath(toObject, ['voiceActivityType'], fromVoiceActivityType);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction blobToMldev$1(fromObject, _rootObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction candidateFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, ['content']);\n    if (fromContent != null) {\n        setValueByPath(toObject, ['content'], fromContent);\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        'citationMetadata',\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, ['citationMetadata'], citationMetadataFromMldev(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, ['tokenCount']);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, ['tokenCount'], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, ['finishReason']);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, ['finishReason'], fromFinishReason);\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, ['avgLogprobs']);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, ['avgLogprobs'], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        'groundingMetadata',\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, ['groundingMetadata'], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, ['index']);\n    if (fromIndex != null) {\n        setValueByPath(toObject, ['index'], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        'logprobsResult',\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, ['logprobsResult'], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        'safetyRatings',\n    ]);\n    if (fromSafetyRatings != null) {\n        let transformedList = fromSafetyRatings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['safetyRatings'], transformedList);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        'urlContextMetadata',\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, ['urlContextMetadata'], fromUrlContextMetadata);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, ['citationSources']);\n    if (fromCitations != null) {\n        let transformedList = fromCitations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['citations'], transformedList);\n    }\n    return toObject;\n}\nfunction computeTokensParametersToVertex(apiClient, fromObject, _rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    return toObject;\n}\nfunction computeTokensResponseFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromTokensInfo = getValueByPath(fromObject, ['tokensInfo']);\n    if (fromTokensInfo != null) {\n        let transformedList = fromTokensInfo;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['tokensInfo'], transformedList);\n    }\n    return toObject;\n}\nfunction contentEmbeddingFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromValues = getValueByPath(fromObject, ['values']);\n    if (fromValues != null) {\n        setValueByPath(toObject, ['values'], fromValues);\n    }\n    const fromStatistics = getValueByPath(fromObject, ['statistics']);\n    if (fromStatistics != null) {\n        setValueByPath(toObject, ['statistics'], contentEmbeddingStatisticsFromVertex(fromStatistics));\n    }\n    return toObject;\n}\nfunction contentEmbeddingStatisticsFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromTruncated = getValueByPath(fromObject, ['truncated']);\n    if (fromTruncated != null) {\n        setValueByPath(toObject, ['truncated'], fromTruncated);\n    }\n    const fromTokenCount = getValueByPath(fromObject, ['token_count']);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, ['tokenCount'], fromTokenCount);\n    }\n    return toObject;\n}\nfunction contentToMldev$1(fromObject, rootObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction controlReferenceConfigToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromControlType = getValueByPath(fromObject, ['controlType']);\n    if (fromControlType != null) {\n        setValueByPath(toObject, ['controlType'], fromControlType);\n    }\n    const fromEnableControlImageComputation = getValueByPath(fromObject, [\n        'enableControlImageComputation',\n    ]);\n    if (fromEnableControlImageComputation != null) {\n        setValueByPath(toObject, ['computeControl'], fromEnableControlImageComputation);\n    }\n    return toObject;\n}\nfunction countTokensConfigToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['systemInstruction']) !== undefined) {\n        throw new Error('systemInstruction parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['tools']) !== undefined) {\n        throw new Error('tools parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['generationConfig']) !== undefined) {\n        throw new Error('generationConfig parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction countTokensConfigToVertex(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], tContent(fromSystemInstruction));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        'generationConfig',\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, ['generationConfig'], generationConfigToVertex(fromGenerationConfig));\n    }\n    return toObject;\n}\nfunction countTokensParametersToMldev(apiClient, fromObject, rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        countTokensConfigToMldev(fromConfig);\n    }\n    return toObject;\n}\nfunction countTokensParametersToVertex(apiClient, fromObject, rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        countTokensConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction countTokensResponseFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromTotalTokens = getValueByPath(fromObject, ['totalTokens']);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, ['totalTokens'], fromTotalTokens);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        'cachedContentTokenCount',\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, ['cachedContentTokenCount'], fromCachedContentTokenCount);\n    }\n    return toObject;\n}\nfunction countTokensResponseFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromTotalTokens = getValueByPath(fromObject, ['totalTokens']);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, ['totalTokens'], fromTotalTokens);\n    }\n    return toObject;\n}\nfunction deleteModelParametersToMldev(apiClient, fromObject, _rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction deleteModelParametersToVertex(apiClient, fromObject, _rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction editImageConfigToVertex(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        'negativePrompt',\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'negativePrompt'], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        'guidanceScale',\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, ['parameters', 'guidanceScale'], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['parameters', 'seed'], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        'includeSafetyAttributes',\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, ['parameters', 'includeSafetyAttributes'], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        'includeRaiReason',\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, ['parameters', 'includeRaiReason'], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, ['language']);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, ['parameters', 'language'], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, ['addWatermark']);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, ['parameters', 'addWatermark'], fromAddWatermark);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    const fromEditMode = getValueByPath(fromObject, ['editMode']);\n    if (parentObject !== undefined && fromEditMode != null) {\n        setValueByPath(parentObject, ['parameters', 'editMode'], fromEditMode);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, ['baseSteps']);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, ['parameters', 'editConfig', 'baseSteps'], fromBaseSteps);\n    }\n    return toObject;\n}\nfunction editImageParametersInternalToVertex(apiClient, fromObject, rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        'referenceImages',\n    ]);\n    if (fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return referenceImageAPIInternalToVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['instances[0]', 'referenceImages'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        editImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction editImageResponseFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, ['taskType']);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, ['requests[]', 'taskType'], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, ['title']);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, ['requests[]', 'title'], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        'outputDimensionality',\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, ['requests[]', 'outputDimensionality'], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, ['mimeType']) !== undefined) {\n        throw new Error('mimeType parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['autoTruncate']) !== undefined) {\n        throw new Error('autoTruncate parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction embedContentConfigToVertex(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, ['taskType']);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, ['instances[]', 'task_type'], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, ['title']);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, ['instances[]', 'title'], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        'outputDimensionality',\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputDimensionality'], fromOutputDimensionality);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (parentObject !== undefined && fromMimeType != null) {\n        setValueByPath(parentObject, ['instances[]', 'mimeType'], fromMimeType);\n    }\n    const fromAutoTruncate = getValueByPath(fromObject, ['autoTruncate']);\n    if (parentObject !== undefined && fromAutoTruncate != null) {\n        setValueByPath(parentObject, ['parameters', 'autoTruncate'], fromAutoTruncate);\n    }\n    return toObject;\n}\nfunction embedContentParametersToMldev(apiClient, fromObject, rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContentsForEmbed(apiClient, fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['requests[]', 'content'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        embedContentConfigToMldev(fromConfig, toObject);\n    }\n    const fromModelForEmbedContent = getValueByPath(fromObject, ['model']);\n    if (fromModelForEmbedContent !== undefined) {\n        setValueByPath(toObject, ['requests[]', 'model'], tModel(apiClient, fromModelForEmbedContent));\n    }\n    return toObject;\n}\nfunction embedContentParametersToVertex(apiClient, fromObject, rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContentsForEmbed(apiClient, fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['instances[]', 'content'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        embedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction embedContentResponseFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromEmbeddings = getValueByPath(fromObject, ['embeddings']);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['embeddings'], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    return toObject;\n}\nfunction embedContentResponseFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromEmbeddings = getValueByPath(fromObject, [\n        'predictions[]',\n        'embeddings',\n    ]);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentEmbeddingFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['embeddings'], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    return toObject;\n}\nfunction endpointFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['endpoint']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDeployedModelId = getValueByPath(fromObject, [\n        'deployedModelId',\n    ]);\n    if (fromDeployedModelId != null) {\n        setValueByPath(toObject, ['deployedModelId'], fromDeployedModelId);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$1(fromObject, _rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$1(fromObject, _rootObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    if (getValueByPath(fromObject, ['partialArgs']) !== undefined) {\n        throw new Error('partialArgs parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['willContinue']) !== undefined) {\n        throw new Error('willContinue parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        'allowedFunctionNames',\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, ['allowedFunctionNames'], fromAllowedFunctionNames);\n    }\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    if (getValueByPath(fromObject, ['streamFunctionCallArguments']) !==\n        undefined) {\n        throw new Error('streamFunctionCallArguments parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, ['parameters']);\n    if (fromParameters != null) {\n        setValueByPath(toObject, ['parameters'], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        'parametersJsonSchema',\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, ['parametersJsonSchema'], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, ['behavior']) !== undefined) {\n        throw new Error('behavior parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev(apiClient, fromObject, parentObject, rootObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], contentToMldev$1(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        'candidateCount',\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, ['candidateCount'], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        'stopSequences',\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, ['stopSequences'], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        'responseLogprobs',\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, ['logprobs']);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, ['logprobs'], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        'presencePenalty',\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        'frequencyPenalty',\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        'responseMimeType',\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        'responseSchema',\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, ['responseSchema'], tSchema(fromResponseSchema));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, ['routingConfig']) !== undefined) {\n        throw new Error('routingConfig parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['modelSelectionConfig']) !== undefined) {\n        throw new Error('modelSelectionConfig parameter is not supported in Gemini API.');\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        'safetySettings',\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return safetySettingToMldev(item);\n            });\n        }\n        setValueByPath(parentObject, ['safetySettings'], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], toolConfigToMldev(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, ['labels']) !== undefined) {\n        throw new Error('labels parameter is not supported in Gemini API.');\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        'cachedContent',\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, ['cachedContent'], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, ['responseModalities'], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, ['speechConfig'], tSpeechConfig(fromSpeechConfig));\n    }\n    if (getValueByPath(fromObject, ['audioTimestamp']) !== undefined) {\n        throw new Error('audioTimestamp parameter is not supported in Gemini API.');\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, ['thinkingConfig'], fromThinkingConfig);\n    }\n    const fromImageConfig = getValueByPath(fromObject, ['imageConfig']);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, ['imageConfig'], imageConfigToMldev(fromImageConfig));\n    }\n    const fromEnableEnhancedCivicAnswers = getValueByPath(fromObject, [\n        'enableEnhancedCivicAnswers',\n    ]);\n    if (fromEnableEnhancedCivicAnswers != null) {\n        setValueByPath(toObject, ['enableEnhancedCivicAnswers'], fromEnableEnhancedCivicAnswers);\n    }\n    if (getValueByPath(fromObject, ['modelArmorConfig']) !== undefined) {\n        throw new Error('modelArmorConfig parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction generateContentConfigToVertex(apiClient, fromObject, parentObject, rootObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], tContent(fromSystemInstruction));\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        'candidateCount',\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, ['candidateCount'], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        'stopSequences',\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, ['stopSequences'], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        'responseLogprobs',\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, ['logprobs']);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, ['logprobs'], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        'presencePenalty',\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        'frequencyPenalty',\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        'responseMimeType',\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        'responseSchema',\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, ['responseSchema'], tSchema(fromResponseSchema));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        'routingConfig',\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, ['routingConfig'], fromRoutingConfig);\n    }\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        'modelSelectionConfig',\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, ['modelConfig'], fromModelSelectionConfig);\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        'safetySettings',\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(parentObject, ['safetySettings'], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToVertex(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], fromToolConfig);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        'cachedContent',\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, ['cachedContent'], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, ['responseModalities'], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, ['speechConfig'], tSpeechConfig(fromSpeechConfig));\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        'audioTimestamp',\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, ['audioTimestamp'], fromAudioTimestamp);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, ['thinkingConfig'], fromThinkingConfig);\n    }\n    const fromImageConfig = getValueByPath(fromObject, ['imageConfig']);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, ['imageConfig'], imageConfigToVertex(fromImageConfig));\n    }\n    if (getValueByPath(fromObject, ['enableEnhancedCivicAnswers']) !==\n        undefined) {\n        throw new Error('enableEnhancedCivicAnswers parameter is not supported in Vertex AI.');\n    }\n    const fromModelArmorConfig = getValueByPath(fromObject, [\n        'modelArmorConfig',\n    ]);\n    if (parentObject !== undefined && fromModelArmorConfig != null) {\n        setValueByPath(parentObject, ['modelArmorConfig'], fromModelArmorConfig);\n    }\n    return toObject;\n}\nfunction generateContentParametersToMldev(apiClient, fromObject, rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['generationConfig'], generateContentConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateContentParametersToVertex(apiClient, fromObject, rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['generationConfig'], generateContentConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, ['candidates']);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return candidateFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['candidates'], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, ['modelVersion']);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, ['modelVersion'], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        'promptFeedback',\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, ['promptFeedback'], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, ['responseId']);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, ['responseId'], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction generateContentResponseFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, ['candidates']);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['candidates'], transformedList);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromModelVersion = getValueByPath(fromObject, ['modelVersion']);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, ['modelVersion'], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        'promptFeedback',\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, ['promptFeedback'], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, ['responseId']);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, ['responseId'], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction generateImagesConfigToMldev(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['outputGcsUri']) !== undefined) {\n        throw new Error('outputGcsUri parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['negativePrompt']) !== undefined) {\n        throw new Error('negativePrompt parameter is not supported in Gemini API.');\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        'guidanceScale',\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, ['parameters', 'guidanceScale'], fromGuidanceScale);\n    }\n    if (getValueByPath(fromObject, ['seed']) !== undefined) {\n        throw new Error('seed parameter is not supported in Gemini API.');\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        'includeSafetyAttributes',\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, ['parameters', 'includeSafetyAttributes'], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        'includeRaiReason',\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, ['parameters', 'includeRaiReason'], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, ['language']);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, ['parameters', 'language'], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    if (getValueByPath(fromObject, ['addWatermark']) !== undefined) {\n        throw new Error('addWatermark parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['labels']) !== undefined) {\n        throw new Error('labels parameter is not supported in Gemini API.');\n    }\n    const fromImageSize = getValueByPath(fromObject, ['imageSize']);\n    if (parentObject !== undefined && fromImageSize != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleImageSize'], fromImageSize);\n    }\n    if (getValueByPath(fromObject, ['enhancePrompt']) !== undefined) {\n        throw new Error('enhancePrompt parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction generateImagesConfigToVertex(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        'negativePrompt',\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'negativePrompt'], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        'guidanceScale',\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, ['parameters', 'guidanceScale'], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['parameters', 'seed'], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        'includeSafetyAttributes',\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, ['parameters', 'includeSafetyAttributes'], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        'includeRaiReason',\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, ['parameters', 'includeRaiReason'], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, ['language']);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, ['parameters', 'language'], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, ['addWatermark']);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, ['parameters', 'addWatermark'], fromAddWatermark);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    const fromImageSize = getValueByPath(fromObject, ['imageSize']);\n    if (parentObject !== undefined && fromImageSize != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleImageSize'], fromImageSize);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        'enhancePrompt',\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'enhancePrompt'], fromEnhancePrompt);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToMldev(apiClient, fromObject, rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        generateImagesConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToVertex(apiClient, fromObject, rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        generateImagesConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        'positivePromptSafetyAttributes',\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, ['positivePromptSafetyAttributes'], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        'positivePromptSafetyAttributes',\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, ['positivePromptSafetyAttributes'], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateVideosConfigToMldev(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        'numberOfVideos',\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfVideos);\n    }\n    if (getValueByPath(fromObject, ['outputGcsUri']) !== undefined) {\n        throw new Error('outputGcsUri parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['fps']) !== undefined) {\n        throw new Error('fps parameter is not supported in Gemini API.');\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        'durationSeconds',\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, ['parameters', 'durationSeconds'], fromDurationSeconds);\n    }\n    if (getValueByPath(fromObject, ['seed']) !== undefined) {\n        throw new Error('seed parameter is not supported in Gemini API.');\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, ['resolution']);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, ['parameters', 'resolution'], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    if (getValueByPath(fromObject, ['pubsubTopic']) !== undefined) {\n        throw new Error('pubsubTopic parameter is not supported in Gemini API.');\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        'negativePrompt',\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'negativePrompt'], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        'enhancePrompt',\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'enhancePrompt'], fromEnhancePrompt);\n    }\n    if (getValueByPath(fromObject, ['generateAudio']) !== undefined) {\n        throw new Error('generateAudio parameter is not supported in Gemini API.');\n    }\n    const fromLastFrame = getValueByPath(fromObject, ['lastFrame']);\n    if (parentObject !== undefined && fromLastFrame != null) {\n        setValueByPath(parentObject, ['instances[0]', 'lastFrame'], imageToMldev(fromLastFrame));\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        'referenceImages',\n    ]);\n    if (parentObject !== undefined && fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return videoGenerationReferenceImageToMldev(item);\n            });\n        }\n        setValueByPath(parentObject, ['instances[0]', 'referenceImages'], transformedList);\n    }\n    if (getValueByPath(fromObject, ['mask']) !== undefined) {\n        throw new Error('mask parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['compressionQuality']) !== undefined) {\n        throw new Error('compressionQuality parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction generateVideosConfigToVertex(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        'numberOfVideos',\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfVideos);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromFps = getValueByPath(fromObject, ['fps']);\n    if (parentObject !== undefined && fromFps != null) {\n        setValueByPath(parentObject, ['parameters', 'fps'], fromFps);\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        'durationSeconds',\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, ['parameters', 'durationSeconds'], fromDurationSeconds);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['parameters', 'seed'], fromSeed);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, ['resolution']);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, ['parameters', 'resolution'], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromPubsubTopic = getValueByPath(fromObject, ['pubsubTopic']);\n    if (parentObject !== undefined && fromPubsubTopic != null) {\n        setValueByPath(parentObject, ['parameters', 'pubsubTopic'], fromPubsubTopic);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        'negativePrompt',\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'negativePrompt'], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        'enhancePrompt',\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'enhancePrompt'], fromEnhancePrompt);\n    }\n    const fromGenerateAudio = getValueByPath(fromObject, [\n        'generateAudio',\n    ]);\n    if (parentObject !== undefined && fromGenerateAudio != null) {\n        setValueByPath(parentObject, ['parameters', 'generateAudio'], fromGenerateAudio);\n    }\n    const fromLastFrame = getValueByPath(fromObject, ['lastFrame']);\n    if (parentObject !== undefined && fromLastFrame != null) {\n        setValueByPath(parentObject, ['instances[0]', 'lastFrame'], imageToVertex(fromLastFrame));\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        'referenceImages',\n    ]);\n    if (parentObject !== undefined && fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return videoGenerationReferenceImageToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, ['instances[0]', 'referenceImages'], transformedList);\n    }\n    const fromMask = getValueByPath(fromObject, ['mask']);\n    if (parentObject !== undefined && fromMask != null) {\n        setValueByPath(parentObject, ['instances[0]', 'mask'], videoGenerationMaskToVertex(fromMask));\n    }\n    const fromCompressionQuality = getValueByPath(fromObject, [\n        'compressionQuality',\n    ]);\n    if (parentObject !== undefined && fromCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'compressionQuality'], fromCompressionQuality);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        'response',\n        'generateVideoResponse',\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateVideosResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateVideosResponseFromVertex(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosParametersToMldev(apiClient, fromObject, rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['instances[0]', 'image'], imageToMldev(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['instances[0]', 'video'], videoToMldev(fromVideo));\n    }\n    const fromSource = getValueByPath(fromObject, ['source']);\n    if (fromSource != null) {\n        generateVideosSourceToMldev(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        generateVideosConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateVideosParametersToVertex(apiClient, fromObject, rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['instances[0]', 'image'], imageToVertex(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['instances[0]', 'video'], videoToVertex(fromVideo));\n    }\n    const fromSource = getValueByPath(fromObject, ['source']);\n    if (fromSource != null) {\n        generateVideosSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        generateVideosConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        'generatedSamples',\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedVideoFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedVideos'], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        'raiMediaFilteredCount',\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, ['raiMediaFilteredCount'], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        'raiMediaFilteredReasons',\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, ['raiMediaFilteredReasons'], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, ['videos']);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedVideoFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedVideos'], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        'raiMediaFilteredCount',\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, ['raiMediaFilteredCount'], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        'raiMediaFilteredReasons',\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, ['raiMediaFilteredReasons'], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosSourceToMldev(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'image'], imageToMldev(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (parentObject !== undefined && fromVideo != null) {\n        setValueByPath(parentObject, ['instances[0]', 'video'], videoToMldev(fromVideo));\n    }\n    return toObject;\n}\nfunction generateVideosSourceToVertex(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'image'], imageToVertex(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (parentObject !== undefined && fromVideo != null) {\n        setValueByPath(parentObject, ['instances[0]', 'video'], videoToVertex(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedImageFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['_self']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageFromMldev(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        'raiFilteredReason',\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, ['raiFilteredReason'], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, ['_self']);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, ['safetyAttributes'], safetyAttributesFromMldev(fromSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generatedImageFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['_self']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageFromVertex(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        'raiFilteredReason',\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, ['raiFilteredReason'], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, ['_self']);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, ['safetyAttributes'], safetyAttributesFromVertex(fromSafetyAttributes));\n    }\n    const fromEnhancedPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromEnhancedPrompt != null) {\n        setValueByPath(toObject, ['enhancedPrompt'], fromEnhancedPrompt);\n    }\n    return toObject;\n}\nfunction generatedImageMaskFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromMask = getValueByPath(fromObject, ['_self']);\n    if (fromMask != null) {\n        setValueByPath(toObject, ['mask'], imageFromVertex(fromMask));\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (fromLabels != null) {\n        let transformedList = fromLabels;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['labels'], transformedList);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], videoFromMldev(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, ['_self']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], videoFromVertex(fromVideo));\n    }\n    return toObject;\n}\nfunction generationConfigToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        'modelSelectionConfig',\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, ['modelConfig'], fromModelSelectionConfig);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        'audioTimestamp',\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, ['audioTimestamp'], fromAudioTimestamp);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        'candidateCount',\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, ['candidateCount'], fromCandidateCount);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        'enableAffectiveDialog',\n    ]);\n    if (fromEnableAffectiveDialog != null) {\n        setValueByPath(toObject, ['enableAffectiveDialog'], fromEnableAffectiveDialog);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        'frequencyPenalty',\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);\n    }\n    const fromLogprobs = getValueByPath(fromObject, ['logprobs']);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, ['logprobs'], fromLogprobs);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        'presencePenalty',\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        'responseLogprobs',\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        'responseMimeType',\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, ['responseModalities'], fromResponseModalities);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        'responseSchema',\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, ['responseSchema'], fromResponseSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        'routingConfig',\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, ['routingConfig'], fromRoutingConfig);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, ['speechConfig'], fromSpeechConfig);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        'stopSequences',\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, ['stopSequences'], fromStopSequences);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, ['thinkingConfig'], fromThinkingConfig);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    if (getValueByPath(fromObject, ['enableEnhancedCivicAnswers']) !==\n        undefined) {\n        throw new Error('enableEnhancedCivicAnswers parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction getModelParametersToMldev(apiClient, fromObject, _rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction getModelParametersToVertex(apiClient, fromObject, _rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$1(fromObject, _rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['authConfig']) !== undefined) {\n        throw new Error('authConfig parameter is not supported in Gemini API.');\n    }\n    const fromEnableWidget = getValueByPath(fromObject, ['enableWidget']);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, ['enableWidget'], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$1(fromObject, _rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['blockingConfidence']) !== undefined) {\n        throw new Error('blockingConfidence parameter is not supported in Gemini API.');\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction imageConfigToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, ['aspectRatio'], fromAspectRatio);\n    }\n    const fromImageSize = getValueByPath(fromObject, ['imageSize']);\n    if (fromImageSize != null) {\n        setValueByPath(toObject, ['imageSize'], fromImageSize);\n    }\n    if (getValueByPath(fromObject, ['personGeneration']) !== undefined) {\n        throw new Error('personGeneration parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['outputMimeType']) !== undefined) {\n        throw new Error('outputMimeType parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['outputCompressionQuality']) !==\n        undefined) {\n        throw new Error('outputCompressionQuality parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction imageConfigToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, ['aspectRatio'], fromAspectRatio);\n    }\n    const fromImageSize = getValueByPath(fromObject, ['imageSize']);\n    if (fromImageSize != null) {\n        setValueByPath(toObject, ['imageSize'], fromImageSize);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (fromPersonGeneration != null) {\n        setValueByPath(toObject, ['personGeneration'], fromPersonGeneration);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (fromOutputMimeType != null) {\n        setValueByPath(toObject, ['imageOutputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (fromOutputCompressionQuality != null) {\n        setValueByPath(toObject, ['imageOutputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    return toObject;\n}\nfunction imageFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromImageBytes = getValueByPath(fromObject, [\n        'bytesBase64Encoded',\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, ['imageBytes'], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        'bytesBase64Encoded',\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, ['imageBytes'], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['gcsUri']) !== undefined) {\n        throw new Error('gcsUri parameter is not supported in Gemini API.');\n    }\n    const fromImageBytes = getValueByPath(fromObject, ['imageBytes']);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, ['bytesBase64Encoded'], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, ['imageBytes']);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, ['bytesBase64Encoded'], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction listModelsConfigToMldev(apiClient, fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, ['queryBase']);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, ['_url', 'models_url'], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsConfigToVertex(apiClient, fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, ['queryBase']);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, ['_url', 'models_url'], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsParametersToMldev(apiClient, fromObject, rootObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listModelsConfigToMldev(apiClient, fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listModelsParametersToVertex(apiClient, fromObject, rootObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listModelsConfigToVertex(apiClient, fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, ['_self']);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return modelFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['models'], transformedList);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, ['_self']);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return modelFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['models'], transformedList);\n    }\n    return toObject;\n}\nfunction maskReferenceConfigToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromMaskMode = getValueByPath(fromObject, ['maskMode']);\n    if (fromMaskMode != null) {\n        setValueByPath(toObject, ['maskMode'], fromMaskMode);\n    }\n    const fromSegmentationClasses = getValueByPath(fromObject, [\n        'segmentationClasses',\n    ]);\n    if (fromSegmentationClasses != null) {\n        setValueByPath(toObject, ['maskClasses'], fromSegmentationClasses);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, ['maskDilation']);\n    if (fromMaskDilation != null) {\n        setValueByPath(toObject, ['dilation'], fromMaskDilation);\n    }\n    return toObject;\n}\nfunction modelFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, ['version']);\n    if (fromVersion != null) {\n        setValueByPath(toObject, ['version'], fromVersion);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, ['_self']);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, ['tunedModelInfo'], tunedModelInfoFromMldev(fromTunedModelInfo));\n    }\n    const fromInputTokenLimit = getValueByPath(fromObject, [\n        'inputTokenLimit',\n    ]);\n    if (fromInputTokenLimit != null) {\n        setValueByPath(toObject, ['inputTokenLimit'], fromInputTokenLimit);\n    }\n    const fromOutputTokenLimit = getValueByPath(fromObject, [\n        'outputTokenLimit',\n    ]);\n    if (fromOutputTokenLimit != null) {\n        setValueByPath(toObject, ['outputTokenLimit'], fromOutputTokenLimit);\n    }\n    const fromSupportedActions = getValueByPath(fromObject, [\n        'supportedGenerationMethods',\n    ]);\n    if (fromSupportedActions != null) {\n        setValueByPath(toObject, ['supportedActions'], fromSupportedActions);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromMaxTemperature = getValueByPath(fromObject, [\n        'maxTemperature',\n    ]);\n    if (fromMaxTemperature != null) {\n        setValueByPath(toObject, ['maxTemperature'], fromMaxTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromThinking = getValueByPath(fromObject, ['thinking']);\n    if (fromThinking != null) {\n        setValueByPath(toObject, ['thinking'], fromThinking);\n    }\n    return toObject;\n}\nfunction modelFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, ['versionId']);\n    if (fromVersion != null) {\n        setValueByPath(toObject, ['version'], fromVersion);\n    }\n    const fromEndpoints = getValueByPath(fromObject, ['deployedModels']);\n    if (fromEndpoints != null) {\n        let transformedList = fromEndpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return endpointFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['endpoints'], transformedList);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (fromLabels != null) {\n        setValueByPath(toObject, ['labels'], fromLabels);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, ['_self']);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, ['tunedModelInfo'], tunedModelInfoFromVertex(fromTunedModelInfo));\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        'defaultCheckpointId',\n    ]);\n    if (fromDefaultCheckpointId != null) {\n        setValueByPath(toObject, ['defaultCheckpointId'], fromDefaultCheckpointId);\n    }\n    const fromCheckpoints = getValueByPath(fromObject, ['checkpoints']);\n    if (fromCheckpoints != null) {\n        let transformedList = fromCheckpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['checkpoints'], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$1(fromObject, rootObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev$1(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallToMldev$1(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev$1(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction productImageToVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromProductImage = getValueByPath(fromObject, ['productImage']);\n    if (fromProductImage != null) {\n        setValueByPath(toObject, ['image'], imageToVertex(fromProductImage));\n    }\n    return toObject;\n}\nfunction recontextImageConfigToVertex(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, ['baseSteps']);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, ['parameters', 'baseSteps'], fromBaseSteps);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['parameters', 'seed'], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, ['addWatermark']);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, ['parameters', 'addWatermark'], fromAddWatermark);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        'enhancePrompt',\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'enhancePrompt'], fromEnhancePrompt);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    return toObject;\n}\nfunction recontextImageParametersToVertex(apiClient, fromObject, rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromSource = getValueByPath(fromObject, ['source']);\n    if (fromSource != null) {\n        recontextImageSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        recontextImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction recontextImageResponseFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    return toObject;\n}\nfunction recontextImageSourceToVertex(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromPersonImage = getValueByPath(fromObject, ['personImage']);\n    if (parentObject !== undefined && fromPersonImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'personImage', 'image'], imageToVertex(fromPersonImage));\n    }\n    const fromProductImages = getValueByPath(fromObject, [\n        'productImages',\n    ]);\n    if (parentObject !== undefined && fromProductImages != null) {\n        let transformedList = fromProductImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return productImageToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, ['instances[0]', 'productImages'], transformedList);\n    }\n    return toObject;\n}\nfunction referenceImageAPIInternalToVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromReferenceImage = getValueByPath(fromObject, [\n        'referenceImage',\n    ]);\n    if (fromReferenceImage != null) {\n        setValueByPath(toObject, ['referenceImage'], imageToVertex(fromReferenceImage));\n    }\n    const fromReferenceId = getValueByPath(fromObject, ['referenceId']);\n    if (fromReferenceId != null) {\n        setValueByPath(toObject, ['referenceId'], fromReferenceId);\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        'referenceType',\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, ['referenceType'], fromReferenceType);\n    }\n    const fromMaskImageConfig = getValueByPath(fromObject, [\n        'maskImageConfig',\n    ]);\n    if (fromMaskImageConfig != null) {\n        setValueByPath(toObject, ['maskImageConfig'], maskReferenceConfigToVertex(fromMaskImageConfig));\n    }\n    const fromControlImageConfig = getValueByPath(fromObject, [\n        'controlImageConfig',\n    ]);\n    if (fromControlImageConfig != null) {\n        setValueByPath(toObject, ['controlImageConfig'], controlReferenceConfigToVertex(fromControlImageConfig));\n    }\n    const fromStyleImageConfig = getValueByPath(fromObject, [\n        'styleImageConfig',\n    ]);\n    if (fromStyleImageConfig != null) {\n        setValueByPath(toObject, ['styleImageConfig'], fromStyleImageConfig);\n    }\n    const fromSubjectImageConfig = getValueByPath(fromObject, [\n        'subjectImageConfig',\n    ]);\n    if (fromSubjectImageConfig != null) {\n        setValueByPath(toObject, ['subjectImageConfig'], fromSubjectImageConfig);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        'safetyAttributes',\n        'categories',\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, ['categories'], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        'safetyAttributes',\n        'scores',\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, ['scores'], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, ['contentType']);\n    if (fromContentType != null) {\n        setValueByPath(toObject, ['contentType'], fromContentType);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        'safetyAttributes',\n        'categories',\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, ['categories'], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        'safetyAttributes',\n        'scores',\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, ['scores'], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, ['contentType']);\n    if (fromContentType != null) {\n        setValueByPath(toObject, ['contentType'], fromContentType);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromCategory = getValueByPath(fromObject, ['category']);\n    if (fromCategory != null) {\n        setValueByPath(toObject, ['category'], fromCategory);\n    }\n    if (getValueByPath(fromObject, ['method']) !== undefined) {\n        throw new Error('method parameter is not supported in Gemini API.');\n    }\n    const fromThreshold = getValueByPath(fromObject, ['threshold']);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, ['threshold'], fromThreshold);\n    }\n    return toObject;\n}\nfunction scribbleImageToVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageToVertex(fromImage));\n    }\n    return toObject;\n}\nfunction segmentImageConfigToVertex(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, ['parameters', 'mode'], fromMode);\n    }\n    const fromMaxPredictions = getValueByPath(fromObject, [\n        'maxPredictions',\n    ]);\n    if (parentObject !== undefined && fromMaxPredictions != null) {\n        setValueByPath(parentObject, ['parameters', 'maxPredictions'], fromMaxPredictions);\n    }\n    const fromConfidenceThreshold = getValueByPath(fromObject, [\n        'confidenceThreshold',\n    ]);\n    if (parentObject !== undefined && fromConfidenceThreshold != null) {\n        setValueByPath(parentObject, ['parameters', 'confidenceThreshold'], fromConfidenceThreshold);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, ['maskDilation']);\n    if (parentObject !== undefined && fromMaskDilation != null) {\n        setValueByPath(parentObject, ['parameters', 'maskDilation'], fromMaskDilation);\n    }\n    const fromBinaryColorThreshold = getValueByPath(fromObject, [\n        'binaryColorThreshold',\n    ]);\n    if (parentObject !== undefined && fromBinaryColorThreshold != null) {\n        setValueByPath(parentObject, ['parameters', 'binaryColorThreshold'], fromBinaryColorThreshold);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    return toObject;\n}\nfunction segmentImageParametersToVertex(apiClient, fromObject, rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromSource = getValueByPath(fromObject, ['source']);\n    if (fromSource != null) {\n        segmentImageSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        segmentImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction segmentImageResponseFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromGeneratedMasks = getValueByPath(fromObject, ['predictions']);\n    if (fromGeneratedMasks != null) {\n        let transformedList = fromGeneratedMasks;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageMaskFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedMasks'], transformedList);\n    }\n    return toObject;\n}\nfunction segmentImageSourceToVertex(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'image'], imageToVertex(fromImage));\n    }\n    const fromScribbleImage = getValueByPath(fromObject, [\n        'scribbleImage',\n    ]);\n    if (parentObject !== undefined && fromScribbleImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'scribble'], scribbleImageToVertex(fromScribbleImage));\n    }\n    return toObject;\n}\nfunction toolConfigToMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        'retrievalConfig',\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, ['retrievalConfig'], fromRetrievalConfig);\n    }\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        'functionCallingConfig',\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, ['functionCallingConfig'], functionCallingConfigToMldev(fromFunctionCallingConfig));\n    }\n    return toObject;\n}\nfunction toolToMldev$1(fromObject, rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, ['fileSearch']);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, ['fileSearch'], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], googleMapsToMldev$1(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev$1(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\nfunction toolToVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromRetrieval = getValueByPath(fromObject, ['retrieval']);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, ['retrieval'], fromRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    if (getValueByPath(fromObject, ['fileSearch']) !== undefined) {\n        throw new Error('fileSearch parameter is not supported in Vertex AI.');\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        'enterpriseWebSearch',\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, ['enterpriseWebSearch'], fromEnterpriseWebSearch);\n    }\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionDeclarationToVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], fromGoogleMaps);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], fromGoogleSearch);\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        'labels',\n        'google-vertex-llm-tuning-base-model-id',\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction updateModelConfigToMldev(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, ['description'], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        'defaultCheckpointId',\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, ['defaultCheckpointId'], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelConfigToVertex(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, ['description'], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        'defaultCheckpointId',\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, ['defaultCheckpointId'], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelParametersToMldev(apiClient, fromObject, rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        updateModelConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction updateModelParametersToVertex(apiClient, fromObject, rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        updateModelConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction upscaleImageAPIConfigInternalToVertex(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        'includeRaiReason',\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, ['parameters', 'includeRaiReason'], fromIncludeRaiReason);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    const fromEnhanceInputImage = getValueByPath(fromObject, [\n        'enhanceInputImage',\n    ]);\n    if (parentObject !== undefined && fromEnhanceInputImage != null) {\n        setValueByPath(parentObject, ['parameters', 'upscaleConfig', 'enhanceInputImage'], fromEnhanceInputImage);\n    }\n    const fromImagePreservationFactor = getValueByPath(fromObject, [\n        'imagePreservationFactor',\n    ]);\n    if (parentObject !== undefined && fromImagePreservationFactor != null) {\n        setValueByPath(parentObject, ['parameters', 'upscaleConfig', 'imagePreservationFactor'], fromImagePreservationFactor);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, ['parameters', 'mode'], fromMode);\n    }\n    return toObject;\n}\nfunction upscaleImageAPIParametersInternalToVertex(apiClient, fromObject, rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['instances[0]', 'image'], imageToVertex(fromImage));\n    }\n    const fromUpscaleFactor = getValueByPath(fromObject, [\n        'upscaleFactor',\n    ]);\n    if (fromUpscaleFactor != null) {\n        setValueByPath(toObject, ['parameters', 'upscaleConfig', 'upscaleFactor'], fromUpscaleFactor);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        upscaleImageAPIConfigInternalToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction upscaleImageResponseFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    return toObject;\n}\nfunction videoFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['uri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, ['encodedVideo']);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['videoBytes'], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['encoding']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        'bytesBase64Encoded',\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['videoBytes'], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoGenerationMaskToVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['_self'], imageToVertex(fromImage));\n    }\n    const fromMaskMode = getValueByPath(fromObject, ['maskMode']);\n    if (fromMaskMode != null) {\n        setValueByPath(toObject, ['maskMode'], fromMaskMode);\n    }\n    return toObject;\n}\nfunction videoGenerationReferenceImageToMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageToMldev(fromImage));\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        'referenceType',\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, ['referenceType'], fromReferenceType);\n    }\n    return toObject;\n}\nfunction videoGenerationReferenceImageToVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageToVertex(fromImage));\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        'referenceType',\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, ['referenceType'], fromReferenceType);\n    }\n    return toObject;\n}\nfunction videoToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['uri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, ['videoBytes']);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['encodedVideo'], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['encoding'], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['uri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, ['videoBytes']);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['bytesBase64Encoded'], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction createFileSearchStoreConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    return toObject;\n}\nfunction createFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createFileSearchStoreConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteFileSearchStoreConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromForce = getValueByPath(fromObject, ['force']);\n    if (parentObject !== undefined && fromForce != null) {\n        setValueByPath(parentObject, ['_query', 'force'], fromForce);\n    }\n    return toObject;\n}\nfunction deleteFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        deleteFileSearchStoreConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction getFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction importFileConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromCustomMetadata = getValueByPath(fromObject, [\n        'customMetadata',\n    ]);\n    if (parentObject !== undefined && fromCustomMetadata != null) {\n        let transformedList = fromCustomMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(parentObject, ['customMetadata'], transformedList);\n    }\n    const fromChunkingConfig = getValueByPath(fromObject, [\n        'chunkingConfig',\n    ]);\n    if (parentObject !== undefined && fromChunkingConfig != null) {\n        setValueByPath(parentObject, ['chunkingConfig'], fromChunkingConfig);\n    }\n    return toObject;\n}\nfunction importFileOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], importFileResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction importFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFileSearchStoreName = getValueByPath(fromObject, [\n        'fileSearchStoreName',\n    ]);\n    if (fromFileSearchStoreName != null) {\n        setValueByPath(toObject, ['_url', 'file_search_store_name'], fromFileSearchStoreName);\n    }\n    const fromFileName = getValueByPath(fromObject, ['fileName']);\n    if (fromFileName != null) {\n        setValueByPath(toObject, ['fileName'], fromFileName);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        importFileConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction importFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromParent = getValueByPath(fromObject, ['parent']);\n    if (fromParent != null) {\n        setValueByPath(toObject, ['parent'], fromParent);\n    }\n    const fromDocumentName = getValueByPath(fromObject, ['documentName']);\n    if (fromDocumentName != null) {\n        setValueByPath(toObject, ['documentName'], fromDocumentName);\n    }\n    return toObject;\n}\nfunction listFileSearchStoresConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    return toObject;\n}\nfunction listFileSearchStoresParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listFileSearchStoresConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listFileSearchStoresResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromFileSearchStores = getValueByPath(fromObject, [\n        'fileSearchStores',\n    ]);\n    if (fromFileSearchStores != null) {\n        let transformedList = fromFileSearchStores;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['fileSearchStores'], transformedList);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (parentObject !== undefined && fromMimeType != null) {\n        setValueByPath(parentObject, ['mimeType'], fromMimeType);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromCustomMetadata = getValueByPath(fromObject, [\n        'customMetadata',\n    ]);\n    if (parentObject !== undefined && fromCustomMetadata != null) {\n        let transformedList = fromCustomMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(parentObject, ['customMetadata'], transformedList);\n    }\n    const fromChunkingConfig = getValueByPath(fromObject, [\n        'chunkingConfig',\n    ]);\n    if (parentObject !== undefined && fromChunkingConfig != null) {\n        setValueByPath(parentObject, ['chunkingConfig'], fromChunkingConfig);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFileSearchStoreName = getValueByPath(fromObject, [\n        'fileSearchStoreName',\n    ]);\n    if (fromFileSearchStoreName != null) {\n        setValueByPath(toObject, ['_url', 'file_search_store_name'], fromFileSearchStoreName);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        uploadToFileSearchStoreConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreResumableResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst CONTENT_TYPE_HEADER = 'Content-Type';\nconst SERVER_TIMEOUT_HEADER = 'X-Server-Timeout';\nconst USER_AGENT_HEADER = 'User-Agent';\nconst GOOGLE_API_CLIENT_HEADER = 'x-goog-api-client';\nconst SDK_VERSION = '1.40.0'; // x-release-please-version\nconst LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;\nconst VERTEX_AI_API_DEFAULT_VERSION = 'v1beta1';\nconst GOOGLE_AI_API_DEFAULT_VERSION = 'v1beta';\n/**\n * The ApiClient class is used to send requests to the Gemini API or Vertex AI\n * endpoints.\n */\nclass ApiClient {\n    constructor(opts) {\n        var _a, _b, _c;\n        this.clientOptions = Object.assign({}, opts);\n        this.customBaseUrl = (_a = opts.httpOptions) === null || _a === void 0 ? void 0 : _a.baseUrl;\n        if (this.clientOptions.vertexai) {\n            if (this.clientOptions.project && this.clientOptions.location) {\n                this.clientOptions.apiKey = undefined;\n            }\n            else if (this.clientOptions.apiKey) {\n                this.clientOptions.project = undefined;\n                this.clientOptions.location = undefined;\n            }\n        }\n        const initHttpOptions = {};\n        if (this.clientOptions.vertexai) {\n            if (!this.clientOptions.location &&\n                !this.clientOptions.apiKey &&\n                !this.customBaseUrl) {\n                this.clientOptions.location = 'global';\n            }\n            const hasSufficientAuth = (this.clientOptions.project && this.clientOptions.location) ||\n                this.clientOptions.apiKey;\n            if (!hasSufficientAuth && !this.customBaseUrl) {\n                throw new Error('Authentication is not set up. Please provide either a project and location, or an API key, or a custom base URL.');\n            }\n            const hasConstructorAuth = (opts.project && opts.location) || !!opts.apiKey;\n            if (this.customBaseUrl && !hasConstructorAuth) {\n                initHttpOptions.baseUrl = this.customBaseUrl;\n                this.clientOptions.project = undefined;\n                this.clientOptions.location = undefined;\n            }\n            else if (this.clientOptions.apiKey ||\n                this.clientOptions.location === 'global') {\n                // Vertex Express or global endpoint case.\n                initHttpOptions.baseUrl = 'https://aiplatform.googleapis.com/';\n            }\n            else if (this.clientOptions.project && this.clientOptions.location) {\n                initHttpOptions.baseUrl = `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;\n            }\n            initHttpOptions.apiVersion =\n                (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : VERTEX_AI_API_DEFAULT_VERSION;\n        }\n        else {\n            // Gemini API\n            if (!this.clientOptions.apiKey) {\n                throw new ApiError({\n                    message: 'API key must be set when using the Gemini API.',\n                    status: 403,\n                });\n            }\n            initHttpOptions.apiVersion =\n                (_c = this.clientOptions.apiVersion) !== null && _c !== void 0 ? _c : GOOGLE_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;\n        }\n        initHttpOptions.headers = this.getDefaultHeaders();\n        this.clientOptions.httpOptions = initHttpOptions;\n        if (opts.httpOptions) {\n            this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);\n        }\n    }\n    isVertexAI() {\n        var _a;\n        return (_a = this.clientOptions.vertexai) !== null && _a !== void 0 ? _a : false;\n    }\n    getProject() {\n        return this.clientOptions.project;\n    }\n    getLocation() {\n        return this.clientOptions.location;\n    }\n    getCustomBaseUrl() {\n        return this.customBaseUrl;\n    }\n    async getAuthHeaders() {\n        const headers = new Headers();\n        await this.clientOptions.auth.addAuthHeaders(headers);\n        return headers;\n    }\n    getApiVersion() {\n        if (this.clientOptions.httpOptions &&\n            this.clientOptions.httpOptions.apiVersion !== undefined) {\n            return this.clientOptions.httpOptions.apiVersion;\n        }\n        throw new Error('API version is not set.');\n    }\n    getBaseUrl() {\n        if (this.clientOptions.httpOptions &&\n            this.clientOptions.httpOptions.baseUrl !== undefined) {\n            return this.clientOptions.httpOptions.baseUrl;\n        }\n        throw new Error('Base URL is not set.');\n    }\n    getRequestUrl() {\n        return this.getRequestUrlInternal(this.clientOptions.httpOptions);\n    }\n    getHeaders() {\n        if (this.clientOptions.httpOptions &&\n            this.clientOptions.httpOptions.headers !== undefined) {\n            return this.clientOptions.httpOptions.headers;\n        }\n        else {\n            throw new Error('Headers are not set.');\n        }\n    }\n    getRequestUrlInternal(httpOptions) {\n        if (!httpOptions ||\n            httpOptions.baseUrl === undefined ||\n            httpOptions.apiVersion === undefined) {\n            throw new Error('HTTP options are not correctly set.');\n        }\n        const baseUrl = httpOptions.baseUrl.endsWith('/')\n            ? httpOptions.baseUrl.slice(0, -1)\n            : httpOptions.baseUrl;\n        const urlElement = [baseUrl];\n        if (httpOptions.apiVersion && httpOptions.apiVersion !== '') {\n            urlElement.push(httpOptions.apiVersion);\n        }\n        return urlElement.join('/');\n    }\n    getBaseResourcePath() {\n        return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;\n    }\n    getApiKey() {\n        return this.clientOptions.apiKey;\n    }\n    getWebsocketBaseUrl() {\n        const baseUrl = this.getBaseUrl();\n        const urlParts = new URL(baseUrl);\n        urlParts.protocol = urlParts.protocol == 'http:' ? 'ws' : 'wss';\n        return urlParts.toString();\n    }\n    setBaseUrl(url) {\n        if (this.clientOptions.httpOptions) {\n            this.clientOptions.httpOptions.baseUrl = url;\n        }\n        else {\n            throw new Error('HTTP options are not correctly set.');\n        }\n    }\n    constructUrl(path, httpOptions, prependProjectLocation) {\n        const urlElement = [this.getRequestUrlInternal(httpOptions)];\n        if (prependProjectLocation) {\n            urlElement.push(this.getBaseResourcePath());\n        }\n        if (path !== '') {\n            urlElement.push(path);\n        }\n        const url = new URL(`${urlElement.join('/')}`);\n        return url;\n    }\n    shouldPrependVertexProjectPath(request, httpOptions) {\n        if (httpOptions.baseUrl &&\n            httpOptions.baseUrlResourceScope === ResourceScope.COLLECTION) {\n            return false;\n        }\n        if (this.clientOptions.apiKey) {\n            return false;\n        }\n        if (!this.clientOptions.vertexai) {\n            return false;\n        }\n        if (request.path.startsWith('projects/')) {\n            // Assume the path already starts with\n            // `projects/<project>/location/<location>`.\n            return false;\n        }\n        if (request.httpMethod === 'GET' &&\n            request.path.startsWith('publishers/google/models')) {\n            // These paths are used by Vertex's models.get and models.list\n            // calls. For base models Vertex does not accept a project/location\n            // prefix (for tuned model the prefix is required).\n            return false;\n        }\n        return true;\n    }\n    async request(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request, patchedHttpOptions);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (request.queryParams) {\n            for (const [key, value] of Object.entries(request.queryParams)) {\n                url.searchParams.append(key, String(value));\n            }\n        }\n        let requestInit = {};\n        if (request.httpMethod === 'GET') {\n            if (request.body && request.body !== '{}') {\n                throw new Error('Request body should be empty for GET request, but got non empty request body');\n            }\n        }\n        else {\n            requestInit.body = request.body;\n        }\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);\n        return this.unaryApiCall(url, requestInit, request.httpMethod);\n    }\n    patchHttpOptions(baseHttpOptions, requestHttpOptions) {\n        const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));\n        for (const [key, value] of Object.entries(requestHttpOptions)) {\n            // Records compile to objects.\n            if (typeof value === 'object') {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);\n            }\n            else if (value !== undefined) {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = value;\n            }\n        }\n        return patchedHttpOptions;\n    }\n    async requestStream(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request, patchedHttpOptions);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (!url.searchParams.has('alt') || url.searchParams.get('alt') !== 'sse') {\n            url.searchParams.set('alt', 'sse');\n        }\n        let requestInit = {};\n        requestInit.body = request.body;\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);\n        return this.streamApiCall(url, requestInit, request.httpMethod);\n    }\n    async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, url, abortSignal) {\n        if ((httpOptions && httpOptions.timeout) || abortSignal) {\n            const abortController = new AbortController();\n            const signal = abortController.signal;\n            if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {\n                const timeoutHandle = setTimeout(() => abortController.abort(), httpOptions.timeout);\n                if (timeoutHandle &&\n                    typeof timeoutHandle.unref ===\n                        'function') {\n                    // call unref to prevent nodejs process from hanging, see\n                    // https://nodejs.org/api/timers.html#timeoutunref\n                    timeoutHandle.unref();\n                }\n            }\n            if (abortSignal) {\n                abortSignal.addEventListener('abort', () => {\n                    abortController.abort();\n                });\n            }\n            requestInit.signal = signal;\n        }\n        if (httpOptions && httpOptions.extraBody !== null) {\n            includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);\n        }\n        requestInit.headers = await this.getHeadersInternal(httpOptions, url);\n        return requestInit;\n    }\n    async unaryApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod }))\n            .then(async (response) => {\n            await throwErrorIfNotOK(response);\n            return new HttpResponse(response);\n        })\n            .catch((e) => {\n            if (e instanceof Error) {\n                throw e;\n            }\n            else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    async streamApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod }))\n            .then(async (response) => {\n            await throwErrorIfNotOK(response);\n            return this.processStreamResponse(response);\n        })\n            .catch((e) => {\n            if (e instanceof Error) {\n                throw e;\n            }\n            else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    processStreamResponse(response) {\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            var _a;\n            const reader = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.getReader();\n            const decoder = new TextDecoder('utf-8');\n            if (!reader) {\n                throw new Error('Response body is empty');\n            }\n            try {\n                let buffer = '';\n                const dataPrefix = 'data:';\n                const delimiters = ['\\n\\n', '\\r\\r', '\\r\\n\\r\\n'];\n                while (true) {\n                    const { done, value } = yield __await(reader.read());\n                    if (done) {\n                        if (buffer.trim().length > 0) {\n                            throw new Error('Incomplete JSON segment at the end');\n                        }\n                        break;\n                    }\n                    const chunkString = decoder.decode(value, { stream: true });\n                    // Parse and throw an error if the chunk contains an error.\n                    try {\n                        const chunkJson = JSON.parse(chunkString);\n                        if ('error' in chunkJson) {\n                            const errorJson = JSON.parse(JSON.stringify(chunkJson['error']));\n                            const status = errorJson['status'];\n                            const code = errorJson['code'];\n                            const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;\n                            if (code >= 400 && code < 600) {\n                                const apiError = new ApiError({\n                                    message: errorMessage,\n                                    status: code,\n                                });\n                                throw apiError;\n                            }\n                        }\n                    }\n                    catch (e) {\n                        const error = e;\n                        if (error.name === 'ApiError') {\n                            throw e;\n                        }\n                    }\n                    buffer += chunkString;\n                    let delimiterIndex = -1;\n                    let delimiterLength = 0;\n                    while (true) {\n                        delimiterIndex = -1;\n                        delimiterLength = 0;\n                        for (const delimiter of delimiters) {\n                            const index = buffer.indexOf(delimiter);\n                            if (index !== -1 &&\n                                (delimiterIndex === -1 || index < delimiterIndex)) {\n                                delimiterIndex = index;\n                                delimiterLength = delimiter.length;\n                            }\n                        }\n                        if (delimiterIndex === -1) {\n                            break; // No complete event in buffer\n                        }\n                        const eventString = buffer.substring(0, delimiterIndex);\n                        buffer = buffer.substring(delimiterIndex + delimiterLength);\n                        const trimmedEvent = eventString.trim();\n                        if (trimmedEvent.startsWith(dataPrefix)) {\n                            const processedChunkString = trimmedEvent\n                                .substring(dataPrefix.length)\n                                .trim();\n                            try {\n                                const partialResponse = new Response(processedChunkString, {\n                                    headers: response === null || response === void 0 ? void 0 : response.headers,\n                                    status: response === null || response === void 0 ? void 0 : response.status,\n                                    statusText: response === null || response === void 0 ? void 0 : response.statusText,\n                                });\n                                yield yield __await(new HttpResponse(partialResponse));\n                            }\n                            catch (e) {\n                                throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);\n                            }\n                        }\n                    }\n                }\n            }\n            finally {\n                reader.releaseLock();\n            }\n        });\n    }\n    async apiCall(url, requestInit) {\n        return fetch(url, requestInit).catch((e) => {\n            throw new Error(`exception ${e} sending request`);\n        });\n    }\n    getDefaultHeaders() {\n        const headers = {};\n        const versionHeaderValue = LIBRARY_LABEL + ' ' + this.clientOptions.userAgentExtra;\n        headers[USER_AGENT_HEADER] = versionHeaderValue;\n        headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;\n        headers[CONTENT_TYPE_HEADER] = 'application/json';\n        return headers;\n    }\n    async getHeadersInternal(httpOptions, url) {\n        const headers = new Headers();\n        if (httpOptions && httpOptions.headers) {\n            for (const [key, value] of Object.entries(httpOptions.headers)) {\n                headers.append(key, value);\n            }\n            // Append a timeout header if it is set, note that the timeout option is\n            // in milliseconds but the header is in seconds.\n            if (httpOptions.timeout && httpOptions.timeout > 0) {\n                headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1000)));\n            }\n        }\n        await this.clientOptions.auth.addAuthHeaders(headers, url);\n        return headers;\n    }\n    getFileName(file) {\n        var _a;\n        let fileName = '';\n        if (typeof file === 'string') {\n            fileName = file.replace(/[/\\\\]+$/, '');\n            fileName = (_a = fileName.split(/[/\\\\]/).pop()) !== null && _a !== void 0 ? _a : '';\n        }\n        return fileName;\n    }\n    /**\n     * Uploads a file asynchronously using Gemini API only, this is not supported\n     * in Vertex AI.\n     *\n     * @param file The string path to the file to be uploaded or a Blob object.\n     * @param config Optional parameters specified in the `UploadFileConfig`\n     *     interface. @see {@link types.UploadFileConfig}\n     * @return A promise that resolves to a `File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     */\n    async uploadFile(file, config) {\n        var _a;\n        const fileToUpload = {};\n        if (config != null) {\n            fileToUpload.mimeType = config.mimeType;\n            fileToUpload.name = config.name;\n            fileToUpload.displayName = config.displayName;\n        }\n        if (fileToUpload.name && !fileToUpload.name.startsWith('files/')) {\n            fileToUpload.name = `files/${fileToUpload.name}`;\n        }\n        const uploader = this.clientOptions.uploader;\n        const fileStat = await uploader.stat(file);\n        fileToUpload.sizeBytes = String(fileStat.size);\n        const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;\n        if (mimeType === undefined || mimeType === '') {\n            throw new Error('Can not determine mimeType. Please provide mimeType in the config.');\n        }\n        fileToUpload.mimeType = mimeType;\n        const body = {\n            file: fileToUpload,\n        };\n        const fileName = this.getFileName(file);\n        const path = formatMap('upload/v1beta/files', body['_url']);\n        const uploadUrl = await this.fetchUploadUrl(path, fileToUpload.sizeBytes, fileToUpload.mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);\n        return uploader.upload(file, uploadUrl, this);\n    }\n    /**\n     * Uploads a file to a given file search store asynchronously using Gemini API only, this is not supported\n     * in Vertex AI.\n     *\n     * @param fileSearchStoreName The name of the file search store to upload the file to.\n     * @param file The string path to the file to be uploaded or a Blob object.\n     * @param config Optional parameters specified in the `UploadFileConfig`\n     *     interface. @see {@link UploadFileConfig}\n     * @return A promise that resolves to a `File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     */\n    async uploadFileToFileSearchStore(fileSearchStoreName, file, config) {\n        var _a;\n        const uploader = this.clientOptions.uploader;\n        const fileStat = await uploader.stat(file);\n        const sizeBytes = String(fileStat.size);\n        const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;\n        if (mimeType === undefined || mimeType === '') {\n            throw new Error('Can not determine mimeType. Please provide mimeType in the config.');\n        }\n        const path = `upload/v1beta/${fileSearchStoreName}:uploadToFileSearchStore`;\n        const fileName = this.getFileName(file);\n        const body = {};\n        if (config != null) {\n            uploadToFileSearchStoreConfigToMldev(config, body);\n        }\n        const uploadUrl = await this.fetchUploadUrl(path, sizeBytes, mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);\n        return uploader.uploadToFileSearchStore(file, uploadUrl, this);\n    }\n    /**\n     * Downloads a file asynchronously to the specified path.\n     *\n     * @params params - The parameters for the download request, see {@link\n     * types.DownloadFileParameters}\n     */\n    async downloadFile(params) {\n        const downloader = this.clientOptions.downloader;\n        await downloader.download(params, this);\n    }\n    async fetchUploadUrl(path, sizeBytes, mimeType, fileName, body, configHttpOptions) {\n        var _a;\n        let httpOptions = {};\n        if (configHttpOptions) {\n            httpOptions = configHttpOptions;\n        }\n        else {\n            httpOptions = {\n                apiVersion: '', // api-version is set in the path.\n                headers: Object.assign({ 'Content-Type': 'application/json', 'X-Goog-Upload-Protocol': 'resumable', 'X-Goog-Upload-Command': 'start', 'X-Goog-Upload-Header-Content-Length': `${sizeBytes}`, 'X-Goog-Upload-Header-Content-Type': `${mimeType}` }, (fileName ? { 'X-Goog-Upload-File-Name': fileName } : {})),\n            };\n        }\n        const httpResponse = await this.request({\n            path,\n            body: JSON.stringify(body),\n            httpMethod: 'POST',\n            httpOptions,\n        });\n        if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {\n            throw new Error('Server did not return an HttpResponse or the returned HttpResponse did not have headers.');\n        }\n        const uploadUrl = (_a = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a === void 0 ? void 0 : _a['x-goog-upload-url'];\n        if (uploadUrl === undefined) {\n            throw new Error('Failed to get upload url. Server did not return the x-google-upload-url in the headers');\n        }\n        return uploadUrl;\n    }\n}\nasync function throwErrorIfNotOK(response) {\n    var _a;\n    if (response === undefined) {\n        throw new Error('response is undefined');\n    }\n    if (!response.ok) {\n        const status = response.status;\n        let errorBody;\n        if ((_a = response.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('application/json')) {\n            errorBody = await response.json();\n        }\n        else {\n            errorBody = {\n                error: {\n                    message: await response.text(),\n                    code: response.status,\n                    status: response.statusText,\n                },\n            };\n        }\n        const errorMessage = JSON.stringify(errorBody);\n        if (status >= 400 && status < 600) {\n            const apiError = new ApiError({\n                message: errorMessage,\n                status: status,\n            });\n            throw apiError;\n        }\n        throw new Error(errorMessage);\n    }\n}\n/**\n * Recursively updates the `requestInit.body` with values from an `extraBody` object.\n *\n * If `requestInit.body` is a string, it's assumed to be JSON and will be parsed.\n * The `extraBody` is then deeply merged into this parsed object.\n * If `requestInit.body` is a Blob, `extraBody` will be ignored, and a warning logged,\n * as merging structured data into an opaque Blob is not supported.\n *\n * The function does not enforce that updated values from `extraBody` have the\n * same type as existing values in `requestInit.body`. Type mismatches during\n * the merge will result in a warning, but the value from `extraBody` will overwrite\n * the original. `extraBody` users are responsible for ensuring `extraBody` has the correct structure.\n *\n * @param requestInit The RequestInit object whose body will be updated.\n * @param extraBody The object containing updates to be merged into `requestInit.body`.\n */\nfunction includeExtraBodyToRequestInit(requestInit, extraBody) {\n    if (!extraBody || Object.keys(extraBody).length === 0) {\n        return;\n    }\n    if (requestInit.body instanceof Blob) {\n        console.warn('includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.');\n        return;\n    }\n    let currentBodyObject = {};\n    // If adding new type to HttpRequest.body, please check the code below to\n    // see if we need to update the logic.\n    if (typeof requestInit.body === 'string' && requestInit.body.length > 0) {\n        try {\n            const parsedBody = JSON.parse(requestInit.body);\n            if (typeof parsedBody === 'object' &&\n                parsedBody !== null &&\n                !Array.isArray(parsedBody)) {\n                currentBodyObject = parsedBody;\n            }\n            else {\n                console.warn('includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.');\n                return;\n            }\n            /*  eslint-disable-next-line @typescript-eslint/no-unused-vars */\n        }\n        catch (e) {\n            console.warn('includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.');\n            return;\n        }\n    }\n    function deepMerge(target, source) {\n        const output = Object.assign({}, target);\n        for (const key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                const sourceValue = source[key];\n                const targetValue = output[key];\n                if (sourceValue &&\n                    typeof sourceValue === 'object' &&\n                    !Array.isArray(sourceValue) &&\n                    targetValue &&\n                    typeof targetValue === 'object' &&\n                    !Array.isArray(targetValue)) {\n                    output[key] = deepMerge(targetValue, sourceValue);\n                }\n                else {\n                    if (targetValue &&\n                        sourceValue &&\n                        typeof targetValue !== typeof sourceValue) {\n                        console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key \"${key}\". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);\n                    }\n                    output[key] = sourceValue;\n                }\n            }\n        }\n        return output;\n    }\n    const mergedBody = deepMerge(currentBodyObject, extraBody);\n    requestInit.body = JSON.stringify(mergedBody);\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// TODO: b/416041229 - Determine how to retrieve the MCP package version.\nconst MCP_LABEL = 'mcp_used/unknown';\n// Whether MCP tool usage is detected from mcpToTool. This is used for\n// telemetry.\nlet hasMcpToolUsageFromMcpToTool = false;\n// Checks whether the list of tools contains any MCP tools.\nfunction hasMcpToolUsage(tools) {\n    for (const tool of tools) {\n        if (isMcpCallableTool(tool)) {\n            return true;\n        }\n        if (typeof tool === 'object' && 'inputSchema' in tool) {\n            return true;\n        }\n    }\n    return hasMcpToolUsageFromMcpToTool;\n}\n// Sets the MCP version label in the Google API client header.\nfunction setMcpUsageHeader(headers) {\n    var _a;\n    const existingHeader = (_a = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a !== void 0 ? _a : '';\n    headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();\n}\n// Returns true if the object is a MCP CallableTool, otherwise false.\nfunction isMcpCallableTool(object) {\n    return (object !== null &&\n        typeof object === 'object' &&\n        object instanceof McpCallableTool);\n}\n// List all tools from the MCP client.\nfunction listAllTools(mcpClient_1) {\n    return __asyncGenerator(this, arguments, function* listAllTools_1(mcpClient, maxTools = 100) {\n        let cursor = undefined;\n        let numTools = 0;\n        while (numTools < maxTools) {\n            const t = yield __await(mcpClient.listTools({ cursor }));\n            for (const tool of t.tools) {\n                yield yield __await(tool);\n                numTools++;\n            }\n            if (!t.nextCursor) {\n                break;\n            }\n            cursor = t.nextCursor;\n        }\n    });\n}\n/**\n * McpCallableTool can be used for model inference and invoking MCP clients with\n * given function call arguments.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */\nclass McpCallableTool {\n    constructor(mcpClients = [], config) {\n        this.mcpTools = [];\n        this.functionNameToMcpClient = {};\n        this.mcpClients = mcpClients;\n        this.config = config;\n    }\n    /**\n     * Creates a McpCallableTool.\n     */\n    static create(mcpClients, config) {\n        return new McpCallableTool(mcpClients, config);\n    }\n    /**\n     * Validates the function names are not duplicate and initialize the function\n     * name to MCP client mapping.\n     *\n     * @throws {Error} if the MCP tools from the MCP clients have duplicate tool\n     *     names.\n     */\n    async initialize() {\n        var _a, e_1, _b, _c;\n        if (this.mcpTools.length > 0) {\n            return;\n        }\n        const functionMap = {};\n        const mcpTools = [];\n        for (const mcpClient of this.mcpClients) {\n            try {\n                for (var _d = true, _e = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {\n                    _c = _f.value;\n                    _d = false;\n                    const mcpTool = _c;\n                    mcpTools.push(mcpTool);\n                    const mcpToolName = mcpTool.name;\n                    if (functionMap[mcpToolName]) {\n                        throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);\n                    }\n                    functionMap[mcpToolName] = mcpClient;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        this.mcpTools = mcpTools;\n        this.functionNameToMcpClient = functionMap;\n    }\n    async tool() {\n        await this.initialize();\n        return mcpToolsToGeminiTool(this.mcpTools, this.config);\n    }\n    async callTool(functionCalls) {\n        await this.initialize();\n        const functionCallResponseParts = [];\n        for (const functionCall of functionCalls) {\n            if (functionCall.name in this.functionNameToMcpClient) {\n                const mcpClient = this.functionNameToMcpClient[functionCall.name];\n                let requestOptions = undefined;\n                // TODO: b/424238654 - Add support for finer grained timeout control.\n                if (this.config.timeout) {\n                    requestOptions = {\n                        timeout: this.config.timeout,\n                    };\n                }\n                const callToolResponse = await mcpClient.callTool({\n                    name: functionCall.name,\n                    arguments: functionCall.args,\n                }, \n                // Set the result schema to undefined to allow MCP to rely on the\n                // default schema.\n                undefined, requestOptions);\n                functionCallResponseParts.push({\n                    functionResponse: {\n                        name: functionCall.name,\n                        response: callToolResponse.isError\n                            ? { error: callToolResponse }\n                            : callToolResponse,\n                    },\n                });\n            }\n        }\n        return functionCallResponseParts;\n    }\n}\nfunction isMcpClient(client) {\n    return (client !== null &&\n        typeof client === 'object' &&\n        'listTools' in client &&\n        typeof client.listTools === 'function');\n}\n/**\n * Creates a McpCallableTool from MCP clients and an optional config.\n *\n * The callable tool can invoke the MCP clients with given function call\n * arguments. (often for automatic function calling).\n * Use the config to modify tool parameters such as behavior.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */\nfunction mcpToTool(...args) {\n    // Set MCP usage for telemetry.\n    hasMcpToolUsageFromMcpToTool = true;\n    if (args.length === 0) {\n        throw new Error('No MCP clients provided');\n    }\n    const maybeConfig = args[args.length - 1];\n    if (isMcpClient(maybeConfig)) {\n        return McpCallableTool.create(args, {});\n    }\n    return McpCallableTool.create(args.slice(0, args.length - 1), maybeConfig);\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveMusicServerMessage, and then calling the onmessage callback.\n * Note that the first message which is received from the server is a\n * setupComplete message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */\nasync function handleWebSocketMessage$1(apiClient, onmessage, event) {\n    const serverMessage = new LiveMusicServerMessage();\n    let data;\n    if (event.data instanceof Blob) {\n        data = JSON.parse(await event.data.text());\n    }\n    else {\n        data = JSON.parse(event.data);\n    }\n    Object.assign(serverMessage, data);\n    onmessage(serverMessage);\n}\n/**\n   LiveMusic class encapsulates the configuration for live music\n   generation via Lyria Live models.\n\n   @experimental\n  */\nclass LiveMusic {\n    constructor(apiClient, auth, webSocketFactory) {\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n    }\n    /**\n       Establishes a connection to the specified model and returns a\n       LiveMusicSession object representing that connection.\n  \n       @experimental\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model = 'models/lyria-realtime-exp';\n       const session = await ai.live.music.connect({\n         model: model,\n         callbacks: {\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */\n    async connect(params) {\n        var _a, _b;\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('Live music is not supported for Vertex AI.');\n        }\n        console.warn('Live music generation is experimental and may change in future versions.');\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());\n        const apiKey = this.apiClient.getApiKey();\n        const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey}`;\n        let onopenResolve = () => { };\n        const onopenPromise = new Promise((resolve) => {\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function () {\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event) => {\n                void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function (e) {\n            },\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function (e) {\n            },\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        const model = tModel(this.apiClient, params.model);\n        const setup = { model };\n        const clientMessage = { setup };\n        conn.send(JSON.stringify(clientMessage));\n        return new LiveMusicSession(conn, this.apiClient);\n    }\n}\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */\nclass LiveMusicSession {\n    constructor(conn, apiClient) {\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    /**\n      Sets inputs to steer music generation. Updates the session's current\n      weighted prompts.\n  \n      @param params - Contains one property, `weightedPrompts`.\n  \n        - `weightedPrompts` to send to the model; weights are normalized to\n          sum to 1.0.\n  \n      @experimental\n     */\n    async setWeightedPrompts(params) {\n        if (!params.weightedPrompts ||\n            Object.keys(params.weightedPrompts).length === 0) {\n            throw new Error('Weighted prompts must be set and contain at least one entry.');\n        }\n        const clientContent = liveMusicSetWeightedPromptsParametersToMldev(params);\n        this.conn.send(JSON.stringify({ clientContent }));\n    }\n    /**\n      Sets a configuration to the model. Updates the session's current\n      music generation config.\n  \n      @param params - Contains one property, `musicGenerationConfig`.\n  \n        - `musicGenerationConfig` to set in the model. Passing an empty or\n      undefined config to the model will reset the config to defaults.\n  \n      @experimental\n     */\n    async setMusicGenerationConfig(params) {\n        if (!params.musicGenerationConfig) {\n            params.musicGenerationConfig = {};\n        }\n        const setConfigParameters = liveMusicSetConfigParametersToMldev(params);\n        this.conn.send(JSON.stringify(setConfigParameters));\n    }\n    sendPlaybackControl(playbackControl) {\n        const clientMessage = { playbackControl };\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n     * Start the music stream.\n     *\n     * @experimental\n     */\n    play() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);\n    }\n    /**\n     * Temporarily halt the music stream. Use `play` to resume from the current\n     * position.\n     *\n     * @experimental\n     */\n    pause() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);\n    }\n    /**\n     * Stop the music stream and reset the state. Retains the current prompts\n     * and config.\n     *\n     * @experimental\n     */\n    stop() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);\n    }\n    /**\n     * Resets the context of the music generation without stopping it.\n     * Retains the current prompts and config.\n     *\n     * @experimental\n     */\n    resetContext() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n     */\n    close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap$1(headers) {\n    const headerMap = {};\n    headers.forEach((value, key) => {\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders$1(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)) {\n        headers.append(key, value);\n    }\n    return headers;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst FUNCTION_RESPONSE_REQUIRES_ID = 'FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.';\n/**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveServerMessages, and then calling the onmessage callback. Note that\n * the first message which is received from the server is a setupComplete\n * message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */\nasync function handleWebSocketMessage(apiClient, onmessage, event) {\n    const serverMessage = new LiveServerMessage();\n    let jsonData;\n    if (event.data instanceof Blob) {\n        jsonData = await event.data.text();\n    }\n    else if (event.data instanceof ArrayBuffer) {\n        jsonData = new TextDecoder().decode(event.data);\n    }\n    else {\n        jsonData = event.data;\n    }\n    const data = JSON.parse(jsonData);\n    if (apiClient.isVertexAI()) {\n        const resp = liveServerMessageFromVertex(data);\n        Object.assign(serverMessage, resp);\n    }\n    else {\n        const resp = data;\n        Object.assign(serverMessage, resp);\n    }\n    onmessage(serverMessage);\n}\n/**\n   Live class encapsulates the configuration for live interaction with the\n   Generative Language API. It embeds ApiClient for general API settings.\n\n   @experimental\n  */\nclass Live {\n    constructor(apiClient, auth, webSocketFactory) {\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n        this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);\n    }\n    /**\n       Establishes a connection to the specified model with the given\n       configuration and returns a Session object representing that connection.\n  \n       @experimental Built-in MCP support is an experimental feature, may change in\n       future versions.\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-live-2.5-flash-preview';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         },\n         callbacks: {\n           onopen: () => {\n             console.log('Connected to the socket.');\n           },\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */\n    async connect(params) {\n        var _a, _b, _c, _d, _e, _f;\n        // TODO: b/404946746 - Support per request HTTP options.\n        if (params.config && params.config.httpOptions) {\n            throw new Error('The Live module does not support httpOptions at request-level in' +\n                ' LiveConnectConfig yet. Please use the client-level httpOptions' +\n                ' configuration instead.');\n        }\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        let url;\n        const clientHeaders = this.apiClient.getHeaders();\n        if (params.config &&\n            params.config.tools &&\n            hasMcpToolUsage(params.config.tools)) {\n            setMcpUsageHeader(clientHeaders);\n        }\n        const headers = mapToHeaders(clientHeaders);\n        if (this.apiClient.isVertexAI()) {\n            const project = this.apiClient.getProject();\n            const location = this.apiClient.getLocation();\n            const apiKey = this.apiClient.getApiKey();\n            const hasStandardAuth = (!!project && !!location) || !!apiKey;\n            if (this.apiClient.getCustomBaseUrl() && !hasStandardAuth) {\n                // Custom base URL without standard auth (e.g., proxy).\n                url = websocketBaseUrl;\n                // Auth headers are assumed to be in `clientHeaders` from httpOptions.\n            }\n            else {\n                url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;\n                await this.auth.addAuthHeaders(headers, url);\n            }\n        }\n        else {\n            const apiKey = this.apiClient.getApiKey();\n            let method = 'BidiGenerateContent';\n            let keyName = 'key';\n            if (apiKey === null || apiKey === void 0 ? void 0 : apiKey.startsWith('auth_tokens/')) {\n                console.warn('Warning: Ephemeral token support is experimental and may change in future versions.');\n                if (apiVersion !== 'v1alpha') {\n                    console.warn(\"Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.\");\n                }\n                method = 'BidiGenerateContentConstrained';\n                keyName = 'access_token';\n            }\n            url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey}`;\n        }\n        let onopenResolve = () => { };\n        const onopenPromise = new Promise((resolve) => {\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function () {\n            var _a;\n            (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a === void 0 ? void 0 : _a.call(callbacks);\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event) => {\n                void handleWebSocketMessage(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function (e) {\n            },\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function (e) {\n            },\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        let transformedModel = tModel(this.apiClient, params.model);\n        if (this.apiClient.isVertexAI() &&\n            transformedModel.startsWith('publishers/')) {\n            const project = this.apiClient.getProject();\n            const location = this.apiClient.getLocation();\n            if (project && location) {\n                transformedModel =\n                    `projects/${project}/locations/${location}/` + transformedModel;\n            }\n        }\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI() &&\n            ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === undefined) {\n            // Set default to AUDIO to align with MLDev API.\n            if (params.config === undefined) {\n                params.config = { responseModalities: [Modality.AUDIO] };\n            }\n            else {\n                params.config.responseModalities = [Modality.AUDIO];\n            }\n        }\n        if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {\n            // Raise deprecation warning for generationConfig.\n            console.warn('Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).');\n        }\n        const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];\n        const convertedTools = [];\n        for (const tool of inputTools) {\n            if (this.isCallableTool(tool)) {\n                const callableTool = tool;\n                convertedTools.push(await callableTool.tool());\n            }\n            else {\n                convertedTools.push(tool);\n            }\n        }\n        if (convertedTools.length > 0) {\n            params.config.tools = convertedTools;\n        }\n        const liveConnectParameters = {\n            model: transformedModel,\n            config: params.config,\n            callbacks: params.callbacks,\n        };\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);\n        }\n        else {\n            clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);\n        }\n        delete clientMessage['config'];\n        conn.send(JSON.stringify(clientMessage));\n        return new Session(conn, this.apiClient);\n    }\n    // TODO: b/416041229 - Abstract this method to a common place.\n    isCallableTool(tool) {\n        return 'callTool' in tool && typeof tool.callTool === 'function';\n    }\n}\nconst defaultLiveSendClientContentParamerters = {\n    turnComplete: true,\n};\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */\nclass Session {\n    constructor(conn, apiClient) {\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    tLiveClientContent(apiClient, params) {\n        if (params.turns !== null && params.turns !== undefined) {\n            let contents = [];\n            try {\n                contents = tContents(params.turns);\n                if (!apiClient.isVertexAI()) {\n                    contents = contents.map((item) => contentToMldev$1(item));\n                }\n            }\n            catch (_a) {\n                throw new Error(`Failed to parse client content \"turns\", type: '${typeof params.turns}'`);\n            }\n            return {\n                clientContent: { turns: contents, turnComplete: params.turnComplete },\n            };\n        }\n        return {\n            clientContent: { turnComplete: params.turnComplete },\n        };\n    }\n    tLiveClienttToolResponse(apiClient, params) {\n        let functionResponses = [];\n        if (params.functionResponses == null) {\n            throw new Error('functionResponses is required.');\n        }\n        if (!Array.isArray(params.functionResponses)) {\n            functionResponses = [params.functionResponses];\n        }\n        else {\n            functionResponses = params.functionResponses;\n        }\n        if (functionResponses.length === 0) {\n            throw new Error('functionResponses is required.');\n        }\n        for (const functionResponse of functionResponses) {\n            if (typeof functionResponse !== 'object' ||\n                functionResponse === null ||\n                !('name' in functionResponse) ||\n                !('response' in functionResponse)) {\n                throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);\n            }\n            if (!apiClient.isVertexAI() && !('id' in functionResponse)) {\n                throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);\n            }\n        }\n        const clientMessage = {\n            toolResponse: { functionResponses: functionResponses },\n        };\n        return clientMessage;\n    }\n    /**\n      Send a message over the established connection.\n  \n      @param params - Contains two **optional** properties, `turns` and\n          `turnComplete`.\n  \n        - `turns` will be converted to a `Content[]`\n        - `turnComplete: true` [default] indicates that you are done sending\n          content and expect a response. If `turnComplete: false`, the server\n          will wait for additional messages before starting generation.\n  \n      @experimental\n  \n      @remarks\n      There are two ways to send messages to the live API:\n      `sendClientContent` and `sendRealtimeInput`.\n  \n      `sendClientContent` messages are added to the model context **in order**.\n      Having a conversation using `sendClientContent` messages is roughly\n      equivalent to using the `Chat.sendMessageStream`, except that the state of\n      the `chat` history is stored on the API server instead of locally.\n  \n      Because of `sendClientContent`'s order guarantee, the model cannot respons\n      as quickly to `sendClientContent` messages as to `sendRealtimeInput`\n      messages. This makes the biggest difference when sending objects that have\n      significant preprocessing time (typically images).\n  \n      The `sendClientContent` message sends a `Content[]`\n      which has more options than the `Blob` sent by `sendRealtimeInput`.\n  \n      So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:\n  \n      - Sending anything that can't be represented as a `Blob` (text,\n      `sendClientContent({turns=\"Hello?\"}`)).\n      - Managing turns when not using audio input and voice activity detection.\n        (`sendClientContent({turnComplete:true})` or the short form\n      `sendClientContent()`)\n      - Prefilling a conversation context\n        ```\n        sendClientContent({\n            turns: [\n              Content({role:user, parts:...}),\n              Content({role:user, parts:...}),\n              ...\n            ]\n        })\n        ```\n      @experimental\n     */\n    sendClientContent(params) {\n        params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);\n        const clientMessage = this.tLiveClientContent(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a realtime message over the established connection.\n  \n      @param params - Contains one property, `media`.\n  \n        - `media` will be converted to a `Blob`\n  \n      @experimental\n  \n      @remarks\n      Use `sendRealtimeInput` for realtime audio chunks and video frames (images).\n  \n      With `sendRealtimeInput` the api will respond to audio automatically\n      based on voice activity detection (VAD).\n  \n      `sendRealtimeInput` is optimized for responsivness at the expense of\n      deterministic ordering guarantees. Audio and video tokens are to the\n      context when they become available.\n  \n      Note: The Call signature expects a `Blob` object, but only a subset\n      of audio and image mimetypes are allowed.\n     */\n    sendRealtimeInput(params) {\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = {\n                'realtimeInput': liveSendRealtimeInputParametersToVertex(params),\n            };\n        }\n        else {\n            clientMessage = {\n                'realtimeInput': liveSendRealtimeInputParametersToMldev(params),\n            };\n        }\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a function response message over the established connection.\n  \n      @param params - Contains property `functionResponses`.\n  \n        - `functionResponses` will be converted to a `functionResponses[]`\n  \n      @remarks\n      Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.\n  \n      Use {@link types.LiveConnectConfig#tools} to configure the callable functions.\n  \n      @experimental\n     */\n    sendToolResponse(params) {\n        if (params.functionResponses == null) {\n            throw new Error('Tool response parameters are required.');\n        }\n        const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-live-2.5-flash-preview';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         }\n       });\n  \n       session.close();\n       ```\n     */\n    close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap(headers) {\n    const headerMap = {};\n    headers.forEach((value, key) => {\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)) {\n        headers.append(key, value);\n    }\n    return headers;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst DEFAULT_MAX_REMOTE_CALLS = 10;\n/** Returns whether automatic function calling is disabled. */\nfunction shouldDisableAfc(config) {\n    var _a, _b, _c;\n    if ((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.disable) {\n        return true;\n    }\n    let callableToolsPresent = false;\n    for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []) {\n        if (isCallableTool(tool)) {\n            callableToolsPresent = true;\n            break;\n        }\n    }\n    if (!callableToolsPresent) {\n        return true;\n    }\n    const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;\n    if ((maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls))) ||\n        maxCalls == 0) {\n        console.warn('Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:', maxCalls);\n        return true;\n    }\n    return false;\n}\nfunction isCallableTool(tool) {\n    return 'callTool' in tool && typeof tool.callTool === 'function';\n}\n// Checks whether the list of tools contains any CallableTools. Will return true\n// if there is at least one CallableTool.\nfunction hasCallableTools(params) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;\n}\n/**\n * Returns the indexes of the tools that are not compatible with AFC.\n */\nfunction findAfcIncompatibleToolIndexes(params) {\n    var _a;\n    // Use number[] for an array of numbers in TypeScript\n    const afcIncompatibleToolIndexes = [];\n    if (!((_a = params === null || params === void 0 ? void 0 : params.config) === null || _a === void 0 ? void 0 : _a.tools)) {\n        return afcIncompatibleToolIndexes;\n    }\n    params.config.tools.forEach((tool, index) => {\n        if (isCallableTool(tool)) {\n            return;\n        }\n        const geminiTool = tool;\n        if (geminiTool.functionDeclarations &&\n            geminiTool.functionDeclarations.length > 0) {\n            afcIncompatibleToolIndexes.push(index);\n        }\n    });\n    return afcIncompatibleToolIndexes;\n}\n/**\n * Returns whether to append automatic function calling history to the\n * response.\n */\nfunction shouldAppendAfcHistory(config) {\n    var _a;\n    return !((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.ignoreCallHistory);\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Models extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Makes an API request to generate content with a given model.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         * 'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContent({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     candidateCount: 2,\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */\n        this.generateContent = async (params) => {\n            var _a, _b, _c, _d, _e;\n            const transformedParams = await this.processParamsMaybeAddMcpUsage(params);\n            this.maybeMoveToResponseJsonSchem(params);\n            if (!hasCallableTools(params) || shouldDisableAfc(params.config)) {\n                return await this.generateContentInternal(transformedParams);\n            }\n            const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);\n            if (incompatibleToolIndexes.length > 0) {\n                const formattedIndexes = incompatibleToolIndexes\n                    .map((index) => `tools[${index}]`)\n                    .join(', ');\n                throw new Error(`Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations is not yet supported. Incompatible tools found at ${formattedIndexes}.`);\n            }\n            let response;\n            let functionResponseContent;\n            const automaticFunctionCallingHistory = tContents(transformedParams.contents);\n            const maxRemoteCalls = (_c = (_b = (_a = transformedParams.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n            let remoteCalls = 0;\n            while (remoteCalls < maxRemoteCalls) {\n                response = await this.generateContentInternal(transformedParams);\n                if (!response.functionCalls || response.functionCalls.length === 0) {\n                    break;\n                }\n                const responseContent = response.candidates[0].content;\n                const functionResponseParts = [];\n                for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []) {\n                    if (isCallableTool(tool)) {\n                        const callableTool = tool;\n                        const parts = await callableTool.callTool(response.functionCalls);\n                        functionResponseParts.push(...parts);\n                    }\n                }\n                remoteCalls++;\n                functionResponseContent = {\n                    role: 'user',\n                    parts: functionResponseParts,\n                };\n                transformedParams.contents = tContents(transformedParams.contents);\n                transformedParams.contents.push(responseContent);\n                transformedParams.contents.push(functionResponseContent);\n                if (shouldAppendAfcHistory(transformedParams.config)) {\n                    automaticFunctionCallingHistory.push(responseContent);\n                    automaticFunctionCallingHistory.push(functionResponseContent);\n                }\n            }\n            if (shouldAppendAfcHistory(transformedParams.config)) {\n                response.automaticFunctionCallingHistory =\n                    automaticFunctionCallingHistory;\n            }\n            return response;\n        };\n        /**\n         * Makes an API request to generate content with a given model and yields the\n         * response in chunks.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         *  'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content with streaming response.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContentStream({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     maxOutputTokens: 200,\n         *   }\n         * });\n         * for await (const chunk of response) {\n         *   console.log(chunk);\n         * }\n         * ```\n         */\n        this.generateContentStream = async (params) => {\n            var _a, _b, _c, _d, _e;\n            this.maybeMoveToResponseJsonSchem(params);\n            if (shouldDisableAfc(params.config)) {\n                const transformedParams = await this.processParamsMaybeAddMcpUsage(params);\n                return await this.generateContentStreamInternal(transformedParams);\n            }\n            const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);\n            if (incompatibleToolIndexes.length > 0) {\n                const formattedIndexes = incompatibleToolIndexes\n                    .map((index) => `tools[${index}]`)\n                    .join(', ');\n                throw new Error(`Incompatible tools found at ${formattedIndexes}. Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations\" is not yet supported.`);\n            }\n            // With tool compatibility confirmed, validate that the configuration are\n            // compatible with each other and raise an error if invalid.\n            const streamFunctionCall = (_c = (_b = (_a = params === null || params === void 0 ? void 0 : params.config) === null || _a === void 0 ? void 0 : _a.toolConfig) === null || _b === void 0 ? void 0 : _b.functionCallingConfig) === null || _c === void 0 ? void 0 : _c.streamFunctionCallArguments;\n            const disableAfc = (_e = (_d = params === null || params === void 0 ? void 0 : params.config) === null || _d === void 0 ? void 0 : _d.automaticFunctionCalling) === null || _e === void 0 ? void 0 : _e.disable;\n            if (streamFunctionCall && !disableAfc) {\n                throw new Error(\"Running in streaming mode with 'streamFunctionCallArguments' enabled, \" +\n                    'this feature is not compatible with automatic function calling (AFC). ' +\n                    \"Please set 'config.automaticFunctionCalling.disable' to true to disable AFC \" +\n                    \"or leave 'config.toolConfig.functionCallingConfig.streamFunctionCallArguments' \" +\n                    'to be undefined or set to false to disable streaming function call arguments feature.');\n            }\n            return await this.processAfcStream(params);\n        };\n        /**\n         * Generates an image based on a text description and configuration.\n         *\n         * @param params - The parameters for generating images.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.generateImages({\n         *  model: 'imagen-4.0-generate-001',\n         *  prompt: 'Robot holding a red skateboard',\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */\n        this.generateImages = async (params) => {\n            return await this.generateImagesInternal(params).then((apiResponse) => {\n                var _a;\n                let positivePromptSafetyAttributes;\n                const generatedImages = [];\n                if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {\n                    for (const generatedImage of apiResponse.generatedImages) {\n                        if (generatedImage &&\n                            (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) &&\n                            ((_a = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a === void 0 ? void 0 : _a.contentType) === 'Positive Prompt') {\n                            positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;\n                        }\n                        else {\n                            generatedImages.push(generatedImage);\n                        }\n                    }\n                }\n                let response;\n                if (positivePromptSafetyAttributes) {\n                    response = {\n                        generatedImages: generatedImages,\n                        positivePromptSafetyAttributes: positivePromptSafetyAttributes,\n                        sdkHttpResponse: apiResponse.sdkHttpResponse,\n                    };\n                }\n                else {\n                    response = {\n                        generatedImages: generatedImages,\n                        sdkHttpResponse: apiResponse.sdkHttpResponse,\n                    };\n                }\n                return response;\n            });\n        };\n        this.list = async (params) => {\n            var _a;\n            const defaultConfig = {\n                queryBase: true,\n            };\n            const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);\n            const actualParams = {\n                config: actualConfig,\n            };\n            if (this.apiClient.isVertexAI()) {\n                if (!actualParams.config.queryBase) {\n                    if ((_a = actualParams.config) === null || _a === void 0 ? void 0 : _a.filter) {\n                        throw new Error('Filtering tuned models list for Vertex AI is not currently supported');\n                    }\n                    else {\n                        actualParams.config.filter = 'labels.tune-type:*';\n                    }\n                }\n            }\n            return new Pager(PagedItem.PAGED_ITEM_MODELS, (x) => this.listInternal(x), await this.listInternal(actualParams), actualParams);\n        };\n        /**\n         * Edits an image based on a prompt, list of reference images, and configuration.\n         *\n         * @param params - The parameters for editing an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.editImage({\n         *  model: 'imagen-3.0-capability-001',\n         *  prompt: 'Generate an image containing a mug with the product logo [1] visible on the side of the mug.',\n         *  referenceImages: [subjectReferenceImage]\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */\n        this.editImage = async (params) => {\n            const paramsInternal = {\n                model: params.model,\n                prompt: params.prompt,\n                referenceImages: [],\n                config: params.config,\n            };\n            if (params.referenceImages) {\n                if (params.referenceImages) {\n                    paramsInternal.referenceImages = params.referenceImages.map((img) => img.toReferenceImageAPI());\n                }\n            }\n            return await this.editImageInternal(paramsInternal);\n        };\n        /**\n         * Upscales an image based on an image, upscale factor, and configuration.\n         * Only supported in Vertex AI currently.\n         *\n         * @param params - The parameters for upscaling an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.upscaleImage({\n         *  model: 'imagen-4.0-upscale-preview',\n         *  image: image,\n         *  upscaleFactor: 'x2',\n         *  config: {\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */\n        this.upscaleImage = async (params) => {\n            let apiConfig = {\n                numberOfImages: 1,\n                mode: 'upscale',\n            };\n            if (params.config) {\n                apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);\n            }\n            const apiParams = {\n                model: params.model,\n                image: params.image,\n                upscaleFactor: params.upscaleFactor,\n                config: apiConfig,\n            };\n            return await this.upscaleImageInternal(apiParams);\n        };\n        /**\n         *  Generates videos based on a text description and configuration.\n         *\n         * @param params - The parameters for generating videos.\n         * @return A Promise<GenerateVideosOperation> which allows you to track the progress and eventually retrieve the generated videos using the operations.get method.\n         *\n         * @example\n         * ```ts\n         * const operation = await ai.models.generateVideos({\n         *  model: 'veo-2.0-generate-001',\n         *  source: {\n         *    prompt: 'A neon hologram of a cat driving at top speed',\n         *  },\n         *  config: {\n         *    numberOfVideos: 1\n         * });\n         *\n         * while (!operation.done) {\n         *   await new Promise(resolve => setTimeout(resolve, 10000));\n         *   operation = await ai.operations.getVideosOperation({operation: operation});\n         * }\n         *\n         * console.log(operation.response?.generatedVideos?.[0]?.video?.uri);\n         * ```\n         */\n        this.generateVideos = async (params) => {\n            var _a, _b, _c, _d, _e, _f;\n            if ((params.prompt || params.image || params.video) && params.source) {\n                throw new Error('Source and prompt/image/video are mutually exclusive. Please only use source.');\n            }\n            // Gemini API does not support video bytes.\n            if (!this.apiClient.isVertexAI()) {\n                if (((_a = params.video) === null || _a === void 0 ? void 0 : _a.uri) && ((_b = params.video) === null || _b === void 0 ? void 0 : _b.videoBytes)) {\n                    params.video = {\n                        uri: params.video.uri,\n                        mimeType: params.video.mimeType,\n                    };\n                }\n                else if (((_d = (_c = params.source) === null || _c === void 0 ? void 0 : _c.video) === null || _d === void 0 ? void 0 : _d.uri) &&\n                    ((_f = (_e = params.source) === null || _e === void 0 ? void 0 : _e.video) === null || _f === void 0 ? void 0 : _f.videoBytes)) {\n                    params.source.video = {\n                        uri: params.source.video.uri,\n                        mimeType: params.source.video.mimeType,\n                    };\n                }\n            }\n            return await this.generateVideosInternal(params);\n        };\n    }\n    /**\n     * This logic is needed for GenerateContentConfig only.\n     * Previously we made GenerateContentConfig.responseSchema field to accept\n     * unknown. Since v1.9.0, we switch to use backend JSON schema support.\n     * To maintain backward compatibility, we move the data that was treated as\n     * JSON schema from the responseSchema field to the responseJsonSchema field.\n     */\n    maybeMoveToResponseJsonSchem(params) {\n        if (params.config && params.config.responseSchema) {\n            if (!params.config.responseJsonSchema) {\n                if (Object.keys(params.config.responseSchema).includes('$schema')) {\n                    params.config.responseJsonSchema = params.config.responseSchema;\n                    delete params.config.responseSchema;\n                }\n            }\n        }\n        return;\n    }\n    /**\n     * Transforms the CallableTools in the parameters to be simply Tools, it\n     * copies the params into a new object and replaces the tools, it does not\n     * modify the original params. Also sets the MCP usage header if there are\n     * MCP tools in the parameters.\n     */\n    async processParamsMaybeAddMcpUsage(params) {\n        var _a, _b, _c;\n        const tools = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools;\n        if (!tools) {\n            return params;\n        }\n        const transformedTools = await Promise.all(tools.map(async (tool) => {\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                return await callableTool.tool();\n            }\n            return tool;\n        }));\n        const newParams = {\n            model: params.model,\n            contents: params.contents,\n            config: Object.assign(Object.assign({}, params.config), { tools: transformedTools }),\n        };\n        newParams.config.tools = transformedTools;\n        if (params.config &&\n            params.config.tools &&\n            hasMcpToolUsage(params.config.tools)) {\n            const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};\n            let newHeaders = Object.assign({}, headers);\n            if (Object.keys(newHeaders).length === 0) {\n                newHeaders = this.apiClient.getDefaultHeaders();\n            }\n            setMcpUsageHeader(newHeaders);\n            newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), { headers: newHeaders });\n        }\n        return newParams;\n    }\n    async initAfcToolsMap(params) {\n        var _a, _b, _c;\n        const afcTools = new Map();\n        for (const tool of (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) !== null && _b !== void 0 ? _b : []) {\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                const toolDeclaration = await callableTool.tool();\n                for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []) {\n                    if (!declaration.name) {\n                        throw new Error('Function declaration name is required.');\n                    }\n                    if (afcTools.has(declaration.name)) {\n                        throw new Error(`Duplicate tool declaration name: ${declaration.name}`);\n                    }\n                    afcTools.set(declaration.name, callableTool);\n                }\n            }\n        }\n        return afcTools;\n    }\n    async processAfcStream(params) {\n        var _a, _b, _c;\n        const maxRemoteCalls = (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n        let wereFunctionsCalled = false;\n        let remoteCallCount = 0;\n        const afcToolsMap = await this.initAfcToolsMap(params);\n        return (function (models, afcTools, params) {\n            return __asyncGenerator(this, arguments, function* () {\n                var _a, e_1, _b, _c;\n                var _d, _e;\n                while (remoteCallCount < maxRemoteCalls) {\n                    if (wereFunctionsCalled) {\n                        remoteCallCount++;\n                        wereFunctionsCalled = false;\n                    }\n                    const transformedParams = yield __await(models.processParamsMaybeAddMcpUsage(params));\n                    const response = yield __await(models.generateContentStreamInternal(transformedParams));\n                    const functionResponses = [];\n                    const responseContents = [];\n                    try {\n                        for (var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _a = response_1_1.done, !_a; _f = true) {\n                            _c = response_1_1.value;\n                            _f = false;\n                            const chunk = _c;\n                            yield yield __await(chunk);\n                            if (chunk.candidates && ((_d = chunk.candidates[0]) === null || _d === void 0 ? void 0 : _d.content)) {\n                                responseContents.push(chunk.candidates[0].content);\n                                for (const part of (_e = chunk.candidates[0].content.parts) !== null && _e !== void 0 ? _e : []) {\n                                    if (remoteCallCount < maxRemoteCalls && part.functionCall) {\n                                        if (!part.functionCall.name) {\n                                            throw new Error('Function call name was not returned by the model.');\n                                        }\n                                        if (!afcTools.has(part.functionCall.name)) {\n                                            throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);\n                                        }\n                                        else {\n                                            const responseParts = yield __await(afcTools\n                                                .get(part.functionCall.name)\n                                                .callTool([part.functionCall]));\n                                            functionResponses.push(...responseParts);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (!_f && !_a && (_b = response_1.return)) yield __await(_b.call(response_1));\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                    if (functionResponses.length > 0) {\n                        wereFunctionsCalled = true;\n                        const typedResponseChunk = new GenerateContentResponse();\n                        typedResponseChunk.candidates = [\n                            {\n                                content: {\n                                    role: 'user',\n                                    parts: functionResponses,\n                                },\n                            },\n                        ];\n                        yield yield __await(typedResponseChunk);\n                        const newContents = [];\n                        newContents.push(...responseContents);\n                        newContents.push({\n                            role: 'user',\n                            parts: functionResponses,\n                        });\n                        const updatedContents = tContents(params.contents).concat(newContents);\n                        params.contents = updatedContents;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            });\n        })(this, afcToolsMap, params);\n    }\n    async generateContentInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:generateContent', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = generateContentResponseFromVertex(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:generateContent', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = generateContentResponseFromMldev(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async generateContentStreamInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:streamGenerateContent?alt=sse', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            });\n            return response.then(function (apiResponse) {\n                return __asyncGenerator(this, arguments, function* () {\n                    var _a, e_2, _b, _c;\n                    try {\n                        for (var _d = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a = apiResponse_1_1.done, !_a; _d = true) {\n                            _c = apiResponse_1_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromVertex((yield __await(chunk.json())), params);\n                            resp['sdkHttpResponse'] = {\n                                headers: chunk.headers,\n                            };\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    }\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                    finally {\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_1.return)) yield __await(_b.call(apiResponse_1));\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                    }\n                });\n            });\n        }\n        else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:streamGenerateContent?alt=sse', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            });\n            return response.then(function (apiResponse) {\n                return __asyncGenerator(this, arguments, function* () {\n                    var _a, e_3, _b, _c;\n                    try {\n                        for (var _d = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a = apiResponse_2_1.done, !_a; _d = true) {\n                            _c = apiResponse_2_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromMldev((yield __await(chunk.json())), params);\n                            resp['sdkHttpResponse'] = {\n                                headers: chunk.headers,\n                            };\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    }\n                    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                    finally {\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_2.return)) yield __await(_b.call(apiResponse_2));\n                        }\n                        finally { if (e_3) throw e_3.error; }\n                    }\n                });\n            });\n        }\n    }\n    /**\n     * Calculates embeddings for the given contents. Only text is supported.\n     *\n     * @param params - The parameters for embedding contents.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.embedContent({\n     *  model: 'text-embedding-004',\n     *  contents: [\n     *    'What is your name?',\n     *    'What is your favorite color?',\n     *  ],\n     *  config: {\n     *    outputDimensionality: 64,\n     *  },\n     * });\n     * console.log(response);\n     * ```\n     */\n    async embedContent(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = embedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = embedContentResponseFromVertex(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = embedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:batchEmbedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = embedContentResponseFromMldev(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Private method for generating images.\n     */\n    async generateImagesInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateImagesParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = generateImagesResponseFromVertex(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = generateImagesParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = generateImagesResponseFromMldev(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Private method for editing an image.\n     */\n    async editImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = editImageParametersInternalToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = editImageResponseFromVertex(apiResponse);\n                const typedResp = new EditImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Private method for upscaling an image.\n     */\n    async upscaleImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = upscaleImageResponseFromVertex(apiResponse);\n                const typedResp = new UpscaleImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Recontextualizes an image.\n     *\n     * There are two types of recontextualization currently supported:\n     * 1) Imagen Product Recontext - Generate images of products in new scenes\n     *    and contexts.\n     * 2) Virtual Try-On: Generate images of persons modeling fashion products.\n     *\n     * @param params - The parameters for recontextualizing an image.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response1 = await ai.models.recontextImage({\n     *  model: 'imagen-product-recontext-preview-06-30',\n     *  source: {\n     *    prompt: 'In a modern kitchen setting.',\n     *    productImages: [productImage],\n     *  },\n     *  config: {\n     *    numberOfImages: 1,\n     *  },\n     * });\n     * console.log(response1?.generatedImages?.[0]?.image?.imageBytes);\n     *\n     * const response2 = await ai.models.recontextImage({\n     *  model: 'virtual-try-on-001',\n     *  source: {\n     *    personImage: personImage,\n     *    productImages: [productImage],\n     *  },\n     *  config: {\n     *    numberOfImages: 1,\n     *  },\n     * });\n     * console.log(response2?.generatedImages?.[0]?.image?.imageBytes);\n     * ```\n     */\n    async recontextImage(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = recontextImageParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = recontextImageResponseFromVertex(apiResponse);\n                const typedResp = new RecontextImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Segments an image, creating a mask of a specified area.\n     *\n     * @param params - The parameters for segmenting an image.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.segmentImage({\n     *  model: 'image-segmentation-001',\n     *  source: {\n     *    image: image,\n     *  },\n     *  config: {\n     *    mode: 'foreground',\n     *  },\n     * });\n     * console.log(response?.generatedMasks?.[0]?.mask?.imageBytes);\n     * ```\n     */\n    async segmentImage(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = segmentImageParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = segmentImageResponseFromVertex(apiResponse);\n                const typedResp = new SegmentImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Fetches information about a model by name.\n     *\n     * @example\n     * ```ts\n     * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});\n     * ```\n     */\n    async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getModelParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = getModelParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listModelsParametersToVertex(this.apiClient, params);\n            path = formatMap('{models_url}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listModelsResponseFromVertex(apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = listModelsParametersToMldev(this.apiClient, params);\n            path = formatMap('{models_url}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listModelsResponseFromMldev(apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates a tuned model by its name.\n     *\n     * @param params - The parameters for updating the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.update({\n     *   model: 'tuned-model-name',\n     *   config: {\n     *     displayName: 'New display name',\n     *     description: 'New description',\n     *   },\n     * });\n     * ```\n     */\n    async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateModelParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'PATCH',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = updateModelParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'PATCH',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a tuned model by its name.\n     *\n     * @param params - The parameters for deleting the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.delete({model: 'tuned-model-name'});\n     * ```\n     */\n    async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteModelParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteModelResponseFromVertex(apiResponse);\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = deleteModelParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteModelResponseFromMldev(apiResponse);\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Counts the number of tokens in the given contents. Multimodal input is\n     * supported for Gemini models.\n     *\n     * @param params - The parameters for counting tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.countTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'The quick brown fox jumps over the lazy dog.'\n     * });\n     * console.log(response);\n     * ```\n     */\n    async countTokens(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = countTokensParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:countTokens', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = countTokensResponseFromVertex(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = countTokensParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:countTokens', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = countTokensResponseFromMldev(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Given a list of contents, returns a corresponding TokensInfo containing\n     * the list of tokens and list of token ids.\n     *\n     * This method is not supported by the Gemini Developer API.\n     *\n     * @param params - The parameters for computing tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.computeTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'What is your name?'\n     * });\n     * console.log(response);\n     * ```\n     */\n    async computeTokens(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = computeTokensParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:computeTokens', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = computeTokensResponseFromVertex(apiResponse);\n                const typedResp = new ComputeTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Private method for generating videos.\n     */\n    async generateVideosInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateVideosParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predictLongRunning', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = generateVideosOperationFromVertex(apiResponse);\n                const typedResp = new GenerateVideosOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = generateVideosParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:predictLongRunning', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = generateVideosOperationFromMldev(apiResponse);\n                const typedResp = new GenerateVideosOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Operations extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */\n    async getVideosOperation(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === '') {\n            throw new Error('Operation name is required.');\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split('/operations/')[0];\n            let httpOptions = undefined;\n            if (config && 'httpOptions' in config) {\n                httpOptions = config.httpOptions;\n            }\n            const rawOperation = await this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: { httpOptions: httpOptions },\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: true,\n            });\n        }\n        else {\n            const rawOperation = await this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config,\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: false,\n            });\n        }\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */\n    async get(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === '') {\n            throw new Error('Operation name is required.');\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split('/operations/')[0];\n            let httpOptions = undefined;\n            if (config && 'httpOptions' in config) {\n                httpOptions = config.httpOptions;\n            }\n            const rawOperation = await this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: { httpOptions: httpOptions },\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: true,\n            });\n        }\n        else {\n            const rawOperation = await this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config,\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: false,\n            });\n        }\n    }\n    async getVideosOperationInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getOperationParametersToVertex(params);\n            path = formatMap('{operationName}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response;\n        }\n        else {\n            const body = getOperationParametersToMldev(params);\n            path = formatMap('{operationName}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response;\n        }\n    }\n    async fetchPredictVideosOperationInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = fetchPredictOperationParametersToVertex(params);\n            path = formatMap('{resourceName}:fetchPredictOperation', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response;\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction blobToMldev(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction contentToMldev(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    const fromNewSessionExpireTime = getValueByPath(fromObject, [\n        'newSessionExpireTime',\n    ]);\n    if (parentObject !== undefined && fromNewSessionExpireTime != null) {\n        setValueByPath(parentObject, ['newSessionExpireTime'], fromNewSessionExpireTime);\n    }\n    const fromUses = getValueByPath(fromObject, ['uses']);\n    if (parentObject !== undefined && fromUses != null) {\n        setValueByPath(parentObject, ['uses'], fromUses);\n    }\n    const fromLiveConnectConstraints = getValueByPath(fromObject, [\n        'liveConnectConstraints',\n    ]);\n    if (parentObject !== undefined && fromLiveConnectConstraints != null) {\n        setValueByPath(parentObject, ['bidiGenerateContentSetup'], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));\n    }\n    const fromLockAdditionalFields = getValueByPath(fromObject, [\n        'lockAdditionalFields',\n    ]);\n    if (parentObject !== undefined && fromLockAdditionalFields != null) {\n        setValueByPath(parentObject, ['fieldMask'], fromLockAdditionalFields);\n    }\n    return toObject;\n}\nfunction createAuthTokenParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['config'], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction fileDataToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    if (getValueByPath(fromObject, ['partialArgs']) !== undefined) {\n        throw new Error('partialArgs parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['willContinue']) !== undefined) {\n        throw new Error('willContinue parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction googleMapsToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['authConfig']) !== undefined) {\n        throw new Error('authConfig parameter is not supported in Gemini API.');\n    }\n    const fromEnableWidget = getValueByPath(fromObject, ['enableWidget']);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, ['enableWidget'], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['blockingConfidence']) !== undefined) {\n        throw new Error('blockingConfidence parameter is not supported in Gemini API.');\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        'generationConfig',\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig'], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'responseModalities'], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topK'], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'mediaResolution'], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'seed'], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'speechConfig'], tLiveSpeechConfig(fromSpeechConfig));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'thinkingConfig'], fromThinkingConfig);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        'enableAffectiveDialog',\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'enableAffectiveDialog'], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['setup', 'systemInstruction'], contentToMldev(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['setup', 'tools'], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        'sessionResumption',\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, ['setup', 'sessionResumption'], sessionResumptionConfigToMldev(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        'inputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'inputAudioTranscription'], fromInputAudioTranscription);\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        'outputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'outputAudioTranscription'], fromOutputAudioTranscription);\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        'realtimeInputConfig',\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, ['setup', 'realtimeInputConfig'], fromRealtimeInputConfig);\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        'contextWindowCompression',\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, ['setup', 'contextWindowCompression'], fromContextWindowCompression);\n    }\n    const fromProactivity = getValueByPath(fromObject, ['proactivity']);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, ['setup', 'proactivity'], fromProactivity);\n    }\n    if (getValueByPath(fromObject, ['explicitVadSignal']) !== undefined) {\n        throw new Error('explicitVadSignal parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction liveConnectConstraintsToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['setup', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['config'], liveConnectConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction partToMldev(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallToMldev(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, ['handle']);\n    if (fromHandle != null) {\n        setValueByPath(toObject, ['handle'], fromHandle);\n    }\n    if (getValueByPath(fromObject, ['transparent']) !== undefined) {\n        throw new Error('transparent parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction toolToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, ['fileSearch']);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, ['fileSearch'], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], googleMapsToMldev(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Returns a comma-separated list of field masks from a given object.\n *\n * @param setup The object to extract field masks from.\n * @return A comma-separated list of field masks.\n */\nfunction getFieldMasks(setup) {\n    const fields = [];\n    for (const key in setup) {\n        if (Object.prototype.hasOwnProperty.call(setup, key)) {\n            const value = setup[key];\n            // 2nd layer, recursively get field masks see TODO(b/418290100)\n            if (typeof value === 'object' &&\n                value != null &&\n                Object.keys(value).length > 0) {\n                const field = Object.keys(value).map((kk) => `${key}.${kk}`);\n                fields.push(...field);\n            }\n            else {\n                fields.push(key); // 1st layer\n            }\n        }\n    }\n    return fields.join(',');\n}\n/**\n * Converts bidiGenerateContentSetup.\n * @param requestDict - The request dictionary.\n * @param config - The configuration object.\n * @return - The modified request dictionary.\n */\nfunction convertBidiSetupToTokenSetup(requestDict, config) {\n    // Convert bidiGenerateContentSetup from bidiGenerateContentSetup.setup.\n    let setupForMaskGeneration = null;\n    const bidiGenerateContentSetupValue = requestDict['bidiGenerateContentSetup'];\n    if (typeof bidiGenerateContentSetupValue === 'object' &&\n        bidiGenerateContentSetupValue !== null &&\n        'setup' in bidiGenerateContentSetupValue) {\n        // Now we know bidiGenerateContentSetupValue is an object and has a 'setup'\n        // property.\n        const innerSetup = bidiGenerateContentSetupValue\n            .setup;\n        if (typeof innerSetup === 'object' && innerSetup !== null) {\n            // Valid inner setup found.\n            requestDict['bidiGenerateContentSetup'] = innerSetup;\n            setupForMaskGeneration = innerSetup;\n        }\n        else {\n            // `bidiGenerateContentSetupValue.setup` is not a valid object; treat as\n            // if bidiGenerateContentSetup is invalid.\n            delete requestDict['bidiGenerateContentSetup'];\n        }\n    }\n    else if (bidiGenerateContentSetupValue !== undefined) {\n        // `bidiGenerateContentSetup` exists but not in the expected\n        // shape {setup: {...}}; treat as invalid.\n        delete requestDict['bidiGenerateContentSetup'];\n    }\n    const preExistingFieldMask = requestDict['fieldMask'];\n    // Handle mask generation setup.\n    if (setupForMaskGeneration) {\n        const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);\n        if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) &&\n            (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) {\n            // Case 1: lockAdditionalFields is an empty array. Lock only fields from\n            // bidi setup.\n            if (generatedMaskFromBidi) {\n                // Only assign if mask is not empty\n                requestDict['fieldMask'] = generatedMaskFromBidi;\n            }\n            else {\n                delete requestDict['fieldMask']; // If mask is empty, effectively no\n                // specific fields locked by bidi\n            }\n        }\n        else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) &&\n            config.lockAdditionalFields.length > 0 &&\n            preExistingFieldMask !== null &&\n            Array.isArray(preExistingFieldMask) &&\n            preExistingFieldMask.length > 0) {\n            // Case 2: Lock fields from bidi setup + additional fields\n            // (preExistingFieldMask).\n            const generationConfigFields = [\n                'temperature',\n                'topK',\n                'topP',\n                'maxOutputTokens',\n                'responseModalities',\n                'seed',\n                'speechConfig',\n            ];\n            let mappedFieldsFromPreExisting = [];\n            if (preExistingFieldMask.length > 0) {\n                mappedFieldsFromPreExisting = preExistingFieldMask.map((field) => {\n                    if (generationConfigFields.includes(field)) {\n                        return `generationConfig.${field}`;\n                    }\n                    return field; // Keep original field name if not in\n                    // generationConfigFields\n                });\n            }\n            const finalMaskParts = [];\n            if (generatedMaskFromBidi) {\n                finalMaskParts.push(generatedMaskFromBidi);\n            }\n            if (mappedFieldsFromPreExisting.length > 0) {\n                finalMaskParts.push(...mappedFieldsFromPreExisting);\n            }\n            if (finalMaskParts.length > 0) {\n                requestDict['fieldMask'] = finalMaskParts.join(',');\n            }\n            else {\n                // If no fields from bidi and no valid additional fields from\n                // pre-existing mask.\n                delete requestDict['fieldMask'];\n            }\n        }\n        else {\n            // Case 3: \"Lock all fields\" (meaning, don't send a field_mask, let server\n            // defaults apply or all are mutable). This is hit if:\n            //  - `config.lockAdditionalFields` is undefined.\n            //  - `config.lockAdditionalFields` is non-empty, BUT\n            //  `preExistingFieldMask` is null, not a string, or an empty string.\n            delete requestDict['fieldMask'];\n        }\n    }\n    else {\n        // No valid `bidiGenerateContentSetup` was found or extracted.\n        // \"Lock additional null fields if any\".\n        if (preExistingFieldMask !== null &&\n            Array.isArray(preExistingFieldMask) &&\n            preExistingFieldMask.length > 0) {\n            // If there's a pre-existing field mask, it's a string, and it's not\n            // empty, then we should lock all fields.\n            requestDict['fieldMask'] = preExistingFieldMask.join(',');\n        }\n        else {\n            delete requestDict['fieldMask'];\n        }\n    }\n    return requestDict;\n}\nclass Tokens extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates an ephemeral auth token resource.\n     *\n     * @experimental\n     *\n     * @remarks\n     * Ephemeral auth tokens is only supported in the Gemini Developer API.\n     * It can be used for the session connection to the Live constrained API.\n     * Support in v1alpha only.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created auth token.\n     *\n     * @example\n     * ```ts\n     * const ai = new GoogleGenAI({\n     *     apiKey: token.name,\n     *     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.\n     * });\n     *\n     * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig\n     * // when using the token in Live API sessions. Each session connection can\n     * // use a different configuration.\n     * const config: CreateAuthTokenConfig = {\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 2: If LiveEphemeralParameters is set, lock all fields in\n     * // LiveConnectConfig when using the token in Live API sessions. For\n     * // example, changing `outputAudioTranscription` in the Live API\n     * // connection will be ignored by the API.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     }\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // set, lock LiveConnectConfig with set and additional fields (e.g.\n     * // responseModalities, systemInstruction, temperature in this example) when\n     * // using the token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: ['temperature'],\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // empty array, lock LiveConnectConfig with set fields (e.g.\n     * // responseModalities, systemInstruction in this example) when using the\n     * // token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: [],\n     * }\n     * const token = await ai.tokens.create(config);\n     * ```\n     */\n    async create(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('The client.tokens.create method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = createAuthTokenParametersToMldev(this.apiClient, params);\n            path = formatMap('auth_tokens', body['_url']);\n            queryParams = body['_query'];\n            delete body['config'];\n            delete body['_url'];\n            delete body['_query'];\n            const transformedBody = convertBidiSetupToTokenSetup(body, params.config);\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(transformedBody),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction deleteDocumentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromForce = getValueByPath(fromObject, ['force']);\n    if (parentObject !== undefined && fromForce != null) {\n        setValueByPath(parentObject, ['_query', 'force'], fromForce);\n    }\n    return toObject;\n}\nfunction deleteDocumentParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        deleteDocumentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction getDocumentParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction listDocumentsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    return toObject;\n}\nfunction listDocumentsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromParent = getValueByPath(fromObject, ['parent']);\n    if (fromParent != null) {\n        setValueByPath(toObject, ['_url', 'parent'], fromParent);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listDocumentsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listDocumentsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromDocuments = getValueByPath(fromObject, ['documents']);\n    if (fromDocuments != null) {\n        let transformedList = fromDocuments;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['documents'], transformedList);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Documents extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists documents.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of documents.\n         *\n         * @example\n         * ```ts\n         * const documents = await ai.documents.list({parent:'rag_store_name', config: {'pageSize': 2}});\n         * for await (const document of documents) {\n         *   console.log(document);\n         * }\n         * ```\n         */\n        this.list = async (params) => {\n            return new Pager(PagedItem.PAGED_ITEM_DOCUMENTS, (x) => this.listInternal({ parent: params.parent, config: x.config }), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Gets a Document.\n     *\n     * @param params - The parameters for getting a document.\n     * @return Document.\n     */\n    async get(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = getDocumentParametersToMldev(params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a Document.\n     *\n     * @param params - The parameters for deleting a document.\n     */\n    async delete(params) {\n        var _a, _b;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = deleteDocumentParametersToMldev(params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = listDocumentsParametersToMldev(params);\n            path = formatMap('{parent}/documents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = listDocumentsResponseFromMldev(apiResponse);\n                const typedResp = new ListDocumentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass FileSearchStores extends BaseModule {\n    constructor(apiClient, documents = new Documents(apiClient)) {\n        super();\n        this.apiClient = apiClient;\n        this.documents = documents;\n        /**\n         * Lists file search stores.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of file search stores.\n         *\n         * @example\n         * ```ts\n         * const fileSearchStores = await ai.fileSearchStores.list({config: {'pageSize': 2}});\n         * for await (const fileSearchStore of fileSearchStores) {\n         *   console.log(fileSearchStore);\n         * }\n         * ```\n         */\n        this.list = async (params = {}) => {\n            return new Pager(PagedItem.PAGED_ITEM_FILE_SEARCH_STORES, (x) => this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Uploads a file asynchronously to a given File Search Store.\n     * This method is not available in Vertex AI.\n     * Supported upload sources:\n     * - Node.js: File path (string) or Blob object.\n     * - Browser: Blob object (e.g., File).\n     *\n     * @remarks\n     * The `mimeType` can be specified in the `config` parameter. If omitted:\n     *  - For file path (string) inputs, the `mimeType` will be inferred from the\n     *     file extension.\n     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`\n     *     property.\n     *\n     * This section can contain multiple paragraphs and code examples.\n     *\n     * @param params - Optional parameters specified in the\n     *        `types.UploadToFileSearchStoreParameters` interface.\n     *         @see {@link types.UploadToFileSearchStoreParameters#config} for the optional\n     *         config in the parameters.\n     * @return A promise that resolves to a long running operation.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     * the `mimeType` can be provided in the `params.config` parameter.\n     * @throws An error occurs if a suitable upload location cannot be established.\n     *\n     * @example\n     * The following code uploads a file to a given file search store.\n     *\n     * ```ts\n     * const operation = await ai.fileSearchStores.upload({fileSearchStoreName: 'fileSearchStores/foo-bar', file: 'file.txt', config: {\n     *   mimeType: 'text/plain',\n     * }});\n     * console.log(operation.name);\n     * ```\n     */\n    async uploadToFileSearchStore(params) {\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('Vertex AI does not support uploading files to a file search store.');\n        }\n        return this.apiClient.uploadFileToFileSearchStore(params.fileSearchStoreName, params.file, params.config);\n    }\n    /**\n     * Creates a File Search Store.\n     *\n     * @param params - The parameters for creating a File Search Store.\n     * @return FileSearchStore.\n     */\n    async create(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = createFileSearchStoreParametersToMldev(params);\n            path = formatMap('fileSearchStores', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets a File Search Store.\n     *\n     * @param params - The parameters for getting a File Search Store.\n     * @return FileSearchStore.\n     */\n    async get(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = getFileSearchStoreParametersToMldev(params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a File Search Store.\n     *\n     * @param params - The parameters for deleting a File Search Store.\n     */\n    async delete(params) {\n        var _a, _b;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = deleteFileSearchStoreParametersToMldev(params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = listFileSearchStoresParametersToMldev(params);\n            path = formatMap('fileSearchStores', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = listFileSearchStoresResponseFromMldev(apiResponse);\n                const typedResp = new ListFileSearchStoresResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async uploadToFileSearchStoreInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = uploadToFileSearchStoreParametersToMldev(params);\n            path = formatMap('upload/v1beta/{file_search_store_name}:uploadToFileSearchStore', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = uploadToFileSearchStoreResumableResponseFromMldev(apiResponse);\n                const typedResp = new UploadToFileSearchStoreResumableResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Imports a File from File Service to a FileSearchStore.\n     *\n     * This is a long-running operation, see aip.dev/151\n     *\n     * @param params - The parameters for importing a file to a file search store.\n     * @return ImportFileOperation.\n     */\n    async importFile(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = importFileParametersToMldev(params);\n            path = formatMap('{file_search_store_name}:importFile', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = importFileOperationFromMldev(apiResponse);\n                const typedResp = new ImportFileOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n/**\n * https://stackoverflow.com/a/2117523\n */\nlet uuid4Internal = function () {\n    const { crypto } = globalThis;\n    if (crypto === null || crypto === void 0 ? void 0 : crypto.randomUUID) {\n        uuid4Internal = crypto.randomUUID.bind(crypto);\n        return crypto.randomUUID();\n    }\n    const u8 = new Uint8Array(1);\n    const randomByte = crypto ? () => crypto.getRandomValues(u8)[0] : () => (Math.random() * 0xff) & 0xff;\n    return '10000000-1000-4000-8000-100000000000'.replace(/[018]/g, (c) => (+c ^ (randomByte() & (15 >> (+c / 4)))).toString(16));\n};\nconst uuid4 = () => uuid4Internal();\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nfunction isAbortError(err) {\n    return (typeof err === 'object' &&\n        err !== null &&\n        // Spec-compliant fetch implementations\n        (('name' in err && err.name === 'AbortError') ||\n            // Expo fetch\n            ('message' in err && String(err.message).includes('FetchRequestCanceledException'))));\n}\nconst castToError = (err) => {\n    if (err instanceof Error)\n        return err;\n    if (typeof err === 'object' && err !== null) {\n        try {\n            if (Object.prototype.toString.call(err) === '[object Error]') {\n                // @ts-ignore - not all envs have native support for cause yet\n                const error = new Error(err.message, err.cause ? { cause: err.cause } : {});\n                if (err.stack)\n                    error.stack = err.stack;\n                // @ts-ignore - not all envs have native support for cause yet\n                if (err.cause && !error.cause)\n                    error.cause = err.cause;\n                if (err.name)\n                    error.name = err.name;\n                return error;\n            }\n        }\n        catch (_a) { }\n        try {\n            return new Error(JSON.stringify(err));\n        }\n        catch (_b) { }\n    }\n    return new Error(err);\n};\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nclass GeminiNextGenAPIClientError extends Error {\n}\nclass APIError extends GeminiNextGenAPIClientError {\n    constructor(status, error, message, headers) {\n        super(`${APIError.makeMessage(status, error, message)}`);\n        this.status = status;\n        this.headers = headers;\n        this.error = error;\n    }\n    static makeMessage(status, error, message) {\n        const msg = (error === null || error === void 0 ? void 0 : error.message) ?\n            typeof error.message === 'string' ?\n                error.message\n                : JSON.stringify(error.message)\n            : error ? JSON.stringify(error)\n                : message;\n        if (status && msg) {\n            return `${status} ${msg}`;\n        }\n        if (status) {\n            return `${status} status code (no body)`;\n        }\n        if (msg) {\n            return msg;\n        }\n        return '(no status code or body)';\n    }\n    static generate(status, errorResponse, message, headers) {\n        if (!status || !headers) {\n            return new APIConnectionError({ message, cause: castToError(errorResponse) });\n        }\n        const error = errorResponse;\n        if (status === 400) {\n            return new BadRequestError(status, error, message, headers);\n        }\n        if (status === 401) {\n            return new AuthenticationError(status, error, message, headers);\n        }\n        if (status === 403) {\n            return new PermissionDeniedError(status, error, message, headers);\n        }\n        if (status === 404) {\n            return new NotFoundError(status, error, message, headers);\n        }\n        if (status === 409) {\n            return new ConflictError(status, error, message, headers);\n        }\n        if (status === 422) {\n            return new UnprocessableEntityError(status, error, message, headers);\n        }\n        if (status === 429) {\n            return new RateLimitError(status, error, message, headers);\n        }\n        if (status >= 500) {\n            return new InternalServerError(status, error, message, headers);\n        }\n        return new APIError(status, error, message, headers);\n    }\n}\nclass APIUserAbortError extends APIError {\n    constructor({ message } = {}) {\n        super(undefined, undefined, message || 'Request was aborted.', undefined);\n    }\n}\nclass APIConnectionError extends APIError {\n    constructor({ message, cause }) {\n        super(undefined, undefined, message || 'Connection error.', undefined);\n        // in some environments the 'cause' property is already declared\n        // @ts-ignore\n        if (cause)\n            this.cause = cause;\n    }\n}\nclass APIConnectionTimeoutError extends APIConnectionError {\n    constructor({ message } = {}) {\n        super({ message: message !== null && message !== void 0 ? message : 'Request timed out.' });\n    }\n}\nclass BadRequestError extends APIError {\n}\nclass AuthenticationError extends APIError {\n}\nclass PermissionDeniedError extends APIError {\n}\nclass NotFoundError extends APIError {\n}\nclass ConflictError extends APIError {\n}\nclass UnprocessableEntityError extends APIError {\n}\nclass RateLimitError extends APIError {\n}\nclass InternalServerError extends APIError {\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n// https://url.spec.whatwg.org/#url-scheme-string\nconst startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;\nconst isAbsoluteURL = (url) => {\n    return startsWithSchemeRegexp.test(url);\n};\nlet isArrayInternal = (val) => ((isArrayInternal = Array.isArray), isArrayInternal(val));\nconst isArray = isArrayInternal;\nlet isReadonlyArrayInternal = isArray;\nconst isReadonlyArray = isReadonlyArrayInternal;\n// https://stackoverflow.com/a/34491287\nfunction isEmptyObj(obj) {\n    if (!obj)\n        return true;\n    for (const _k in obj)\n        return false;\n    return true;\n}\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nfunction hasOwn(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nconst validatePositiveInteger = (name, n) => {\n    if (typeof n !== 'number' || !Number.isInteger(n)) {\n        throw new GeminiNextGenAPIClientError(`${name} must be an integer`);\n    }\n    if (n < 0) {\n        throw new GeminiNextGenAPIClientError(`${name} must be a positive integer`);\n    }\n    return n;\n};\nconst safeJSON = (text) => {\n    try {\n        return JSON.parse(text);\n    }\n    catch (err) {\n        return undefined;\n    }\n};\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nconst sleep$1 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst VERSION = '0.0.1';\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n/**\n * Note this does not detect 'browser'; for that, use getBrowserInfo().\n */\nfunction getDetectedPlatform() {\n    if (typeof Deno !== 'undefined' && Deno.build != null) {\n        return 'deno';\n    }\n    if (typeof EdgeRuntime !== 'undefined') {\n        return 'edge';\n    }\n    if (Object.prototype.toString.call(typeof globalThis.process !== 'undefined' ? globalThis.process : 0) === '[object process]') {\n        return 'node';\n    }\n    return 'unknown';\n}\nconst getPlatformProperties = () => {\n    var _a, _b, _c, _d, _e;\n    const detectedPlatform = getDetectedPlatform();\n    if (detectedPlatform === 'deno') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': normalizePlatform(Deno.build.os),\n            'X-Stainless-Arch': normalizeArch(Deno.build.arch),\n            'X-Stainless-Runtime': 'deno',\n            'X-Stainless-Runtime-Version': typeof Deno.version === 'string' ? Deno.version : (_b = (_a = Deno.version) === null || _a === void 0 ? void 0 : _a.deno) !== null && _b !== void 0 ? _b : 'unknown',\n        };\n    }\n    if (typeof EdgeRuntime !== 'undefined') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': 'Unknown',\n            'X-Stainless-Arch': `other:${EdgeRuntime}`,\n            'X-Stainless-Runtime': 'edge',\n            'X-Stainless-Runtime-Version': globalThis.process.version,\n        };\n    }\n    // Check if Node.js\n    if (detectedPlatform === 'node') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': normalizePlatform((_c = globalThis.process.platform) !== null && _c !== void 0 ? _c : 'unknown'),\n            'X-Stainless-Arch': normalizeArch((_d = globalThis.process.arch) !== null && _d !== void 0 ? _d : 'unknown'),\n            'X-Stainless-Runtime': 'node',\n            'X-Stainless-Runtime-Version': (_e = globalThis.process.version) !== null && _e !== void 0 ? _e : 'unknown',\n        };\n    }\n    const browserInfo = getBrowserInfo();\n    if (browserInfo) {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': 'Unknown',\n            'X-Stainless-Arch': 'unknown',\n            'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\n            'X-Stainless-Runtime-Version': browserInfo.version,\n        };\n    }\n    // TODO add support for Cloudflare workers, etc.\n    return {\n        'X-Stainless-Lang': 'js',\n        'X-Stainless-Package-Version': VERSION,\n        'X-Stainless-OS': 'Unknown',\n        'X-Stainless-Arch': 'unknown',\n        'X-Stainless-Runtime': 'unknown',\n        'X-Stainless-Runtime-Version': 'unknown',\n    };\n};\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\nfunction getBrowserInfo() {\n    if (typeof navigator === 'undefined' || !navigator) {\n        return null;\n    }\n    // NOTE: The order matters here!\n    const browserPatterns = [\n        { key: 'edge', pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'ie', pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'ie', pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'chrome', pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'firefox', pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'safari', pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/ },\n    ];\n    // Find the FIRST matching browser\n    for (const { key, pattern } of browserPatterns) {\n        const match = pattern.exec(navigator.userAgent);\n        if (match) {\n            const major = match[1] || 0;\n            const minor = match[2] || 0;\n            const patch = match[3] || 0;\n            return { browser: key, version: `${major}.${minor}.${patch}` };\n        }\n    }\n    return null;\n}\nconst normalizeArch = (arch) => {\n    // Node docs:\n    // - https://nodejs.org/api/process.html#processarch\n    // Deno docs:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    if (arch === 'x32')\n        return 'x32';\n    if (arch === 'x86_64' || arch === 'x64')\n        return 'x64';\n    if (arch === 'arm')\n        return 'arm';\n    if (arch === 'aarch64' || arch === 'arm64')\n        return 'arm64';\n    if (arch)\n        return `other:${arch}`;\n    return 'unknown';\n};\nconst normalizePlatform = (platform) => {\n    // Node platforms:\n    // - https://nodejs.org/api/process.html#processplatform\n    // Deno platforms:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    // - https://github.com/denoland/deno/issues/14799\n    platform = platform.toLowerCase();\n    // NOTE: this iOS check is untested and may not work\n    // Node does not work natively on IOS, there is a fork at\n    // https://github.com/nodejs-mobile/nodejs-mobile\n    // however it is unknown at the time of writing how to detect if it is running\n    if (platform.includes('ios'))\n        return 'iOS';\n    if (platform === 'android')\n        return 'Android';\n    if (platform === 'darwin')\n        return 'MacOS';\n    if (platform === 'win32')\n        return 'Windows';\n    if (platform === 'freebsd')\n        return 'FreeBSD';\n    if (platform === 'openbsd')\n        return 'OpenBSD';\n    if (platform === 'linux')\n        return 'Linux';\n    if (platform)\n        return `Other:${platform}`;\n    return 'Unknown';\n};\nlet _platformHeaders;\nconst getPlatformHeaders = () => {\n    return (_platformHeaders !== null && _platformHeaders !== void 0 ? _platformHeaders : (_platformHeaders = getPlatformProperties()));\n};\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction getDefaultFetch() {\n    if (typeof fetch !== 'undefined') {\n        return fetch;\n    }\n    throw new Error('`fetch` is not defined as a global; Either pass `fetch` to the client, `new GeminiNextGenAPIClient({ fetch })` or polyfill the global, `globalThis.fetch = fetch`');\n}\nfunction makeReadableStream(...args) {\n    const ReadableStream = globalThis.ReadableStream;\n    if (typeof ReadableStream === 'undefined') {\n        // Note: All of the platforms / runtimes we officially support already define\n        // `ReadableStream` as a global, so this should only ever be hit on unsupported runtimes.\n        throw new Error('`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`');\n    }\n    return new ReadableStream(...args);\n}\nfunction ReadableStreamFrom(iterable) {\n    let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();\n    return makeReadableStream({\n        start() { },\n        async pull(controller) {\n            const { done, value } = await iter.next();\n            if (done) {\n                controller.close();\n            }\n            else {\n                controller.enqueue(value);\n            }\n        },\n        async cancel() {\n            var _a;\n            await ((_a = iter.return) === null || _a === void 0 ? void 0 : _a.call(iter));\n        },\n    });\n}\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nfunction ReadableStreamToAsyncIterable(stream) {\n    if (stream[Symbol.asyncIterator])\n        return stream;\n    const reader = stream.getReader();\n    return {\n        async next() {\n            try {\n                const result = await reader.read();\n                if (result === null || result === void 0 ? void 0 : result.done)\n                    reader.releaseLock(); // release lock when stream becomes closed\n                return result;\n            }\n            catch (e) {\n                reader.releaseLock(); // release lock when stream becomes errored\n                throw e;\n            }\n        },\n        async return() {\n            const cancelPromise = reader.cancel();\n            reader.releaseLock();\n            await cancelPromise;\n            return { done: true, value: undefined };\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\n/**\n * Cancels a ReadableStream we don't need to consume.\n * See https://undici.nodejs.org/#/?id=garbage-collection\n */\nasync function CancelReadableStream(stream) {\n    var _a, _b;\n    if (stream === null || typeof stream !== 'object')\n        return;\n    if (stream[Symbol.asyncIterator]) {\n        await ((_b = (_a = stream[Symbol.asyncIterator]()).return) === null || _b === void 0 ? void 0 : _b.call(_a));\n        return;\n    }\n    const reader = stream.getReader();\n    const cancelPromise = reader.cancel();\n    reader.releaseLock();\n    await cancelPromise;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst FallbackEncoder = ({ headers, body }) => {\n    return {\n        bodyHeaders: {\n            'content-type': 'application/json',\n        },\n        body: JSON.stringify(body),\n    };\n};\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst checkFileSupport = () => {\n    var _a;\n    if (typeof File === 'undefined') {\n        const { process } = globalThis;\n        const isOldNode = typeof ((_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) === 'string' && parseInt(process.versions.node.split('.')) < 20;\n        throw new Error('`File` is not defined as a global, which is required for file uploads.' +\n            (isOldNode ?\n                \" Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`.\"\n                : ''));\n    }\n};\n/**\n * Construct a `File` instance. This is used to ensure a helpful error is thrown\n * for environments that don't define a global `File` yet.\n */\nfunction makeFile(fileBits, fileName, options) {\n    checkFileSupport();\n    return new File(fileBits, fileName !== null && fileName !== void 0 ? fileName : 'unknown_file', options);\n}\nfunction getName(value) {\n    return (((typeof value === 'object' &&\n        value !== null &&\n        (('name' in value && value.name && String(value.name)) ||\n            ('url' in value && value.url && String(value.url)) ||\n            ('filename' in value && value.filename && String(value.filename)) ||\n            ('path' in value && value.path && String(value.path)))) ||\n        '')\n        .split(/[\\\\/]/)\n        .pop() || undefined);\n}\nconst isAsyncIterable = (value) => value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * This check adds the arrayBuffer() method type because it is available and used at runtime\n */\nconst isBlobLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.size === 'number' &&\n    typeof value.type === 'string' &&\n    typeof value.text === 'function' &&\n    typeof value.slice === 'function' &&\n    typeof value.arrayBuffer === 'function';\n/**\n * This check adds the arrayBuffer() method type because it is available and used at runtime\n */\nconst isFileLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.name === 'string' &&\n    typeof value.lastModified === 'number' &&\n    isBlobLike(value);\nconst isResponseLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.url === 'string' &&\n    typeof value.blob === 'function';\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file. Can be an {@link Uploadable}, BlobLikePart, or AsyncIterable of BlobLikeParts\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\nasync function toFile(value, name, options) {\n    checkFileSupport();\n    // If it's a promise, resolve it.\n    value = await value;\n    // If we've been given a `File` we don't need to do anything\n    if (isFileLike(value)) {\n        if (value instanceof File) {\n            return value;\n        }\n        return makeFile([await value.arrayBuffer()], value.name);\n    }\n    if (isResponseLike(value)) {\n        const blob = await value.blob();\n        name || (name = new URL(value.url).pathname.split(/[\\\\/]/).pop());\n        return makeFile(await getBytes(blob), name, options);\n    }\n    const parts = await getBytes(value);\n    name || (name = getName(value));\n    if (!(options === null || options === void 0 ? void 0 : options.type)) {\n        const type = parts.find((part) => typeof part === 'object' && 'type' in part && part.type);\n        if (typeof type === 'string') {\n            options = Object.assign(Object.assign({}, options), { type });\n        }\n    }\n    return makeFile(parts, name, options);\n}\nasync function getBytes(value) {\n    var _a, e_1, _b, _c;\n    var _d;\n    let parts = [];\n    if (typeof value === 'string' ||\n        ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\n        value instanceof ArrayBuffer) {\n        parts.push(value);\n    }\n    else if (isBlobLike(value)) {\n        parts.push(value instanceof Blob ? value : await value.arrayBuffer());\n    }\n    else if (isAsyncIterable(value) // includes Readable, ReadableStream, etc.\n    ) {\n        try {\n            for (var _e = true, value_1 = __asyncValues(value), value_1_1; value_1_1 = await value_1.next(), _a = value_1_1.done, !_a; _e = true) {\n                _c = value_1_1.value;\n                _e = false;\n                const chunk = _c;\n                parts.push(...(await getBytes(chunk))); // TODO, consider validating?\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (!_e && !_a && (_b = value_1.return)) await _b.call(value_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    else {\n        const constructor = (_d = value === null || value === void 0 ? void 0 : value.constructor) === null || _d === void 0 ? void 0 : _d.name;\n        throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ''}${propsForError(value)}`);\n    }\n    return parts;\n}\nfunction propsForError(value) {\n    if (typeof value !== 'object' || value === null)\n        return '';\n    const props = Object.getOwnPropertyNames(value);\n    return `; props: [${props.map((p) => `\"${p}\"`).join(', ')}]`;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass APIResource {\n    constructor(client) {\n        this._client = client;\n    }\n}\n/**\n * The key path from the client. For example, a resource accessible as `client.resource.subresource` would\n * have a property `static override readonly _key = Object.freeze(['resource', 'subresource'] as const);`.\n */\nAPIResource._key = [];\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Percent-encode everything that isn't safe to have in a path without encoding safe chars.\n *\n * Taken from https://datatracker.ietf.org/doc/html/rfc3986#section-3.3:\n * > unreserved  = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n * > sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n * > pchar       = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n */\nfunction encodeURIPath(str) {\n    return str.replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);\n}\nconst EMPTY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));\nconst createPathTagFunction = (pathEncoder = encodeURIPath) => (function path(statics, ...params) {\n    // If there are no params, no processing is needed.\n    if (statics.length === 1)\n        return statics[0];\n    let postPath = false;\n    const invalidSegments = [];\n    const path = statics.reduce((previousValue, currentValue, index) => {\n        var _a, _b, _c;\n        if (/[?#]/.test(currentValue)) {\n            postPath = true;\n        }\n        const value = params[index];\n        let encoded = (postPath ? encodeURIComponent : pathEncoder)('' + value);\n        if (index !== params.length &&\n            (value == null ||\n                (typeof value === 'object' &&\n                    // handle values from other realms\n                    value.toString ===\n                        ((_c = Object.getPrototypeOf((_b = Object.getPrototypeOf((_a = value.hasOwnProperty) !== null && _a !== void 0 ? _a : EMPTY)) !== null && _b !== void 0 ? _b : EMPTY)) === null || _c === void 0 ? void 0 : _c.toString)))) {\n            encoded = value + '';\n            invalidSegments.push({\n                start: previousValue.length + currentValue.length,\n                length: encoded.length,\n                error: `Value of type ${Object.prototype.toString\n                    .call(value)\n                    .slice(8, -1)} is not a valid path parameter`,\n            });\n        }\n        return previousValue + currentValue + (index === params.length ? '' : encoded);\n    }, '');\n    const pathOnly = path.split(/[?#]/, 1)[0];\n    const invalidSegmentPattern = /(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)/gi;\n    let match;\n    // Find all invalid segments\n    while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {\n        invalidSegments.push({\n            start: match.index,\n            length: match[0].length,\n            error: `Value \"${match[0]}\" can\\'t be safely passed as a path parameter`,\n        });\n    }\n    invalidSegments.sort((a, b) => a.start - b.start);\n    if (invalidSegments.length > 0) {\n        let lastEnd = 0;\n        const underline = invalidSegments.reduce((acc, segment) => {\n            const spaces = ' '.repeat(segment.start - lastEnd);\n            const arrows = '^'.repeat(segment.length);\n            lastEnd = segment.start + segment.length;\n            return acc + spaces + arrows;\n        }, '');\n        throw new GeminiNextGenAPIClientError(`Path parameters result in path with invalid segments:\\n${invalidSegments\n            .map((e) => e.error)\n            .join('\\n')}\\n${path}\\n${underline}`);\n    }\n    return path;\n});\n/**\n * URI-encodes path params and ensures no unsafe /./ or /../ path segments are introduced.\n */\nconst path = /* @__PURE__ */ createPathTagFunction(encodeURIPath);\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass BaseInteractions extends APIResource {\n    create(params, options) {\n        var _a;\n        const { api_version = this._client.apiVersion } = params, body = __rest(params, [\"api_version\"]);\n        if ('model' in body && 'agent_config' in body) {\n            throw new GeminiNextGenAPIClientError(`Invalid request: specified \\`model\\` and \\`agent_config\\`. If specifying \\`model\\`, use \\`generation_config\\`.`);\n        }\n        if ('agent' in body && 'generation_config' in body) {\n            throw new GeminiNextGenAPIClientError(`Invalid request: specified \\`agent\\` and \\`generation_config\\`. If specifying \\`agent\\`, use \\`agent_config\\`.`);\n        }\n        return this._client.post(path `/${api_version}/interactions`, Object.assign(Object.assign({ body }, options), { stream: (_a = params.stream) !== null && _a !== void 0 ? _a : false }));\n    }\n    /**\n     * Deletes the interaction by id.\n     *\n     * @example\n     * ```ts\n     * const interaction = await client.interactions.delete('id', {\n     *   api_version: 'api_version',\n     * });\n     * ```\n     */\n    delete(id, params = {}, options) {\n        const { api_version = this._client.apiVersion } = params !== null && params !== void 0 ? params : {};\n        return this._client.delete(path `/${api_version}/interactions/${id}`, options);\n    }\n    /**\n     * Cancels an interaction by id. This only applies to background interactions that are still running.\n     *\n     * @example\n     * ```ts\n     * const interaction = await client.interactions.cancel('id', {\n     *   api_version: 'api_version',\n     * });\n     * ```\n     */\n    cancel(id, params = {}, options) {\n        const { api_version = this._client.apiVersion } = params !== null && params !== void 0 ? params : {};\n        return this._client.post(path `/${api_version}/interactions/${id}/cancel`, options);\n    }\n    get(id, params = {}, options) {\n        var _a;\n        const _b = params !== null && params !== void 0 ? params : {}, { api_version = this._client.apiVersion } = _b, query = __rest(_b, [\"api_version\"]);\n        return this._client.get(path `/${api_version}/interactions/${id}`, Object.assign(Object.assign({ query }, options), { stream: (_a = params === null || params === void 0 ? void 0 : params.stream) !== null && _a !== void 0 ? _a : false }));\n    }\n}\nBaseInteractions._key = Object.freeze(['interactions']);\nclass Interactions extends BaseInteractions {\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction concatBytes(buffers) {\n    let length = 0;\n    for (const buffer of buffers) {\n        length += buffer.length;\n    }\n    const output = new Uint8Array(length);\n    let index = 0;\n    for (const buffer of buffers) {\n        output.set(buffer, index);\n        index += buffer.length;\n    }\n    return output;\n}\nlet encodeUTF8_;\nfunction encodeUTF8(str) {\n    let encoder;\n    return (encodeUTF8_ !== null && encodeUTF8_ !== void 0 ? encodeUTF8_ : ((encoder = new globalThis.TextEncoder()), (encodeUTF8_ = encoder.encode.bind(encoder))))(str);\n}\nlet decodeUTF8_;\nfunction decodeUTF8(bytes) {\n    let decoder;\n    return (decodeUTF8_ !== null && decodeUTF8_ !== void 0 ? decodeUTF8_ : ((decoder = new globalThis.TextDecoder()), (decodeUTF8_ = decoder.decode.bind(decoder))))(bytes);\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nclass LineDecoder {\n    constructor() {\n        this.buffer = new Uint8Array();\n        this.carriageReturnIndex = null;\n    }\n    decode(chunk) {\n        if (chunk == null) {\n            return [];\n        }\n        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n            : typeof chunk === 'string' ? encodeUTF8(chunk)\n                : chunk;\n        this.buffer = concatBytes([this.buffer, binaryChunk]);\n        const lines = [];\n        let patternIndex;\n        while ((patternIndex = findNewlineIndex(this.buffer, this.carriageReturnIndex)) != null) {\n            if (patternIndex.carriage && this.carriageReturnIndex == null) {\n                // skip until we either get a corresponding `\\n`, a new `\\r` or nothing\n                this.carriageReturnIndex = patternIndex.index;\n                continue;\n            }\n            // we got double \\r or \\rtext\\n\n            if (this.carriageReturnIndex != null &&\n                (patternIndex.index !== this.carriageReturnIndex + 1 || patternIndex.carriage)) {\n                lines.push(decodeUTF8(this.buffer.subarray(0, this.carriageReturnIndex - 1)));\n                this.buffer = this.buffer.subarray(this.carriageReturnIndex);\n                this.carriageReturnIndex = null;\n                continue;\n            }\n            const endIndex = this.carriageReturnIndex !== null ? patternIndex.preceding - 1 : patternIndex.preceding;\n            const line = decodeUTF8(this.buffer.subarray(0, endIndex));\n            lines.push(line);\n            this.buffer = this.buffer.subarray(patternIndex.index);\n            this.carriageReturnIndex = null;\n        }\n        return lines;\n    }\n    flush() {\n        if (!this.buffer.length) {\n            return [];\n        }\n        return this.decode('\\n');\n    }\n}\n// prettier-ignore\nLineDecoder.NEWLINE_CHARS = new Set(['\\n', '\\r']);\nLineDecoder.NEWLINE_REGEXP = /\\r\\n|[\\n\\r]/g;\n/**\n * This function searches the buffer for the end patterns, (\\r or \\n)\n * and returns an object with the index preceding the matched newline and the\n * index after the newline char. `null` is returned if no new line is found.\n *\n * ```ts\n * findNewLineIndex('abc\\ndef') -> { preceding: 2, index: 3 }\n * ```\n */\nfunction findNewlineIndex(buffer, startIndex) {\n    const newline = 0x0a; // \\n\n    const carriage = 0x0d; // \\r\n    for (let i = startIndex !== null && startIndex !== void 0 ? startIndex : 0; i < buffer.length; i++) {\n        if (buffer[i] === newline) {\n            return { preceding: i, index: i + 1, carriage: false };\n        }\n        if (buffer[i] === carriage) {\n            return { preceding: i, index: i + 1, carriage: true };\n        }\n    }\n    return null;\n}\nfunction findDoubleNewlineIndex(buffer) {\n    // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n    // and returns the index right after the first occurrence of any pattern,\n    // or -1 if none of the patterns are found.\n    const newline = 0x0a; // \\n\n    const carriage = 0x0d; // \\r\n    for (let i = 0; i < buffer.length - 1; i++) {\n        if (buffer[i] === newline && buffer[i + 1] === newline) {\n            // \\n\\n\n            return i + 2;\n        }\n        if (buffer[i] === carriage && buffer[i + 1] === carriage) {\n            // \\r\\r\n            return i + 2;\n        }\n        if (buffer[i] === carriage &&\n            buffer[i + 1] === newline &&\n            i + 3 < buffer.length &&\n            buffer[i + 2] === carriage &&\n            buffer[i + 3] === newline) {\n            // \\r\\n\\r\\n\n            return i + 4;\n        }\n    }\n    return -1;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nconst levelNumbers = {\n    off: 0,\n    error: 200,\n    warn: 300,\n    info: 400,\n    debug: 500,\n};\nconst parseLogLevel = (maybeLevel, sourceName, client) => {\n    if (!maybeLevel) {\n        return undefined;\n    }\n    if (hasOwn(levelNumbers, maybeLevel)) {\n        return maybeLevel;\n    }\n    loggerFor(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`);\n    return undefined;\n};\nfunction noop() { }\nfunction makeLogFn(fnLevel, logger, logLevel) {\n    if (!logger || levelNumbers[fnLevel] > levelNumbers[logLevel]) {\n        return noop;\n    }\n    else {\n        // Don't wrap logger functions, we want the stacktrace intact!\n        return logger[fnLevel].bind(logger);\n    }\n}\nconst noopLogger = {\n    error: noop,\n    warn: noop,\n    info: noop,\n    debug: noop,\n};\nlet cachedLoggers = /* @__PURE__ */ new WeakMap();\nfunction loggerFor(client) {\n    var _a;\n    const logger = client.logger;\n    const logLevel = (_a = client.logLevel) !== null && _a !== void 0 ? _a : 'off';\n    if (!logger) {\n        return noopLogger;\n    }\n    const cachedLogger = cachedLoggers.get(logger);\n    if (cachedLogger && cachedLogger[0] === logLevel) {\n        return cachedLogger[1];\n    }\n    const levelLogger = {\n        error: makeLogFn('error', logger, logLevel),\n        warn: makeLogFn('warn', logger, logLevel),\n        info: makeLogFn('info', logger, logLevel),\n        debug: makeLogFn('debug', logger, logLevel),\n    };\n    cachedLoggers.set(logger, [logLevel, levelLogger]);\n    return levelLogger;\n}\nconst formatRequestDetails = (details) => {\n    if (details.options) {\n        details.options = Object.assign({}, details.options);\n        delete details.options['headers']; // redundant + leaks internals\n    }\n    if (details.headers) {\n        details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [\n            name,\n            (name.toLowerCase() === 'x-goog-api-key' ||\n                name.toLowerCase() === 'authorization' ||\n                name.toLowerCase() === 'cookie' ||\n                name.toLowerCase() === 'set-cookie') ?\n                '***'\n                : value,\n        ]));\n    }\n    if ('retryOfRequestLogID' in details) {\n        if (details.retryOfRequestLogID) {\n            details.retryOf = details.retryOfRequestLogID;\n        }\n        delete details.retryOfRequestLogID;\n    }\n    return details;\n};\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Stream {\n    constructor(iterator, controller, client) {\n        this.iterator = iterator;\n        this.controller = controller;\n        this.client = client;\n    }\n    static fromSSEResponse(response, controller, client) {\n        let consumed = false;\n        const logger = client ? loggerFor(client) : console;\n        function iterator() {\n            return __asyncGenerator(this, arguments, function* iterator_1() {\n                var _a, e_1, _b, _c;\n                if (consumed) {\n                    throw new GeminiNextGenAPIClientError('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n                }\n                consumed = true;\n                let done = false;\n                try {\n                    try {\n                        for (var _d = true, _e = __asyncValues(_iterSSEMessages(response, controller)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n                            _c = _f.value;\n                            _d = false;\n                            const sse = _c;\n                            if (done)\n                                continue;\n                            if (sse.data.startsWith('[DONE]')) {\n                                done = true;\n                                continue;\n                            }\n                            else {\n                                try {\n                                    // @ts-ignore\n                                    yield yield __await(JSON.parse(sse.data));\n                                }\n                                catch (e) {\n                                    logger.error(`Could not parse message into JSON:`, sse.data);\n                                    logger.error(`From chunk:`, sse.raw);\n                                    throw e;\n                                }\n                            }\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                    done = true;\n                }\n                catch (e) {\n                    // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                    if (isAbortError(e))\n                        return yield __await(void 0);\n                    throw e;\n                }\n                finally {\n                    // If the user `break`s, abort the ongoing request.\n                    if (!done)\n                        controller.abort();\n                }\n            });\n        }\n        return new Stream(iterator, controller, client);\n    }\n    /**\n     * Generates a Stream from a newline-separated ReadableStream\n     * where each item is a JSON value.\n     */\n    static fromReadableStream(readableStream, controller, client) {\n        let consumed = false;\n        function iterLines() {\n            return __asyncGenerator(this, arguments, function* iterLines_1() {\n                var _a, e_2, _b, _c;\n                const lineDecoder = new LineDecoder();\n                const iter = ReadableStreamToAsyncIterable(readableStream);\n                try {\n                    for (var _d = true, iter_1 = __asyncValues(iter), iter_1_1; iter_1_1 = yield __await(iter_1.next()), _a = iter_1_1.done, !_a; _d = true) {\n                        _c = iter_1_1.value;\n                        _d = false;\n                        const chunk = _c;\n                        for (const line of lineDecoder.decode(chunk)) {\n                            yield yield __await(line);\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (!_d && !_a && (_b = iter_1.return)) yield __await(_b.call(iter_1));\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n                for (const line of lineDecoder.flush()) {\n                    yield yield __await(line);\n                }\n            });\n        }\n        function iterator() {\n            return __asyncGenerator(this, arguments, function* iterator_2() {\n                var _a, e_3, _b, _c;\n                if (consumed) {\n                    throw new GeminiNextGenAPIClientError('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n                }\n                consumed = true;\n                let done = false;\n                try {\n                    try {\n                        for (var _d = true, _e = __asyncValues(iterLines()), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n                            _c = _f.value;\n                            _d = false;\n                            const line = _c;\n                            if (done)\n                                continue;\n                            // @ts-ignore\n                            if (line)\n                                yield yield __await(JSON.parse(line));\n                        }\n                    }\n                    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                    finally {\n                        try {\n                            if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n                        }\n                        finally { if (e_3) throw e_3.error; }\n                    }\n                    done = true;\n                }\n                catch (e) {\n                    // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                    if (isAbortError(e))\n                        return yield __await(void 0);\n                    throw e;\n                }\n                finally {\n                    // If the user `break`s, abort the ongoing request.\n                    if (!done)\n                        controller.abort();\n                }\n            });\n        }\n        return new Stream(iterator, controller, client);\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterator();\n    }\n    /**\n     * Splits the stream into two streams which can be\n     * independently read from at different speeds.\n     */\n    tee() {\n        const left = [];\n        const right = [];\n        const iterator = this.iterator();\n        const teeIterator = (queue) => {\n            return {\n                next: () => {\n                    if (queue.length === 0) {\n                        const result = iterator.next();\n                        left.push(result);\n                        right.push(result);\n                    }\n                    return queue.shift();\n                },\n            };\n        };\n        return [\n            new Stream(() => teeIterator(left), this.controller, this.client),\n            new Stream(() => teeIterator(right), this.controller, this.client),\n        ];\n    }\n    /**\n     * Converts this stream to a newline-separated ReadableStream of\n     * JSON stringified values in the stream\n     * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n     */\n    toReadableStream() {\n        const self = this;\n        let iter;\n        return makeReadableStream({\n            async start() {\n                iter = self[Symbol.asyncIterator]();\n            },\n            async pull(ctrl) {\n                try {\n                    const { value, done } = await iter.next();\n                    if (done)\n                        return ctrl.close();\n                    const bytes = encodeUTF8(JSON.stringify(value) + '\\n');\n                    ctrl.enqueue(bytes);\n                }\n                catch (err) {\n                    ctrl.error(err);\n                }\n            },\n            async cancel() {\n                var _a;\n                await ((_a = iter.return) === null || _a === void 0 ? void 0 : _a.call(iter));\n            },\n        });\n    }\n}\nfunction _iterSSEMessages(response, controller) {\n    return __asyncGenerator(this, arguments, function* _iterSSEMessages_1() {\n        var _a, e_4, _b, _c;\n        if (!response.body) {\n            controller.abort();\n            if (typeof globalThis.navigator !== 'undefined' &&\n                globalThis.navigator.product === 'ReactNative') {\n                throw new GeminiNextGenAPIClientError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);\n            }\n            throw new GeminiNextGenAPIClientError(`Attempted to iterate over a response with no body`);\n        }\n        const sseDecoder = new SSEDecoder();\n        const lineDecoder = new LineDecoder();\n        const iter = ReadableStreamToAsyncIterable(response.body);\n        try {\n            for (var _d = true, _e = __asyncValues(iterSSEChunks(iter)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n                _c = _f.value;\n                _d = false;\n                const sseChunk = _c;\n                for (const line of lineDecoder.decode(sseChunk)) {\n                    const sse = sseDecoder.decode(line);\n                    if (sse)\n                        yield yield __await(sse);\n                }\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        for (const line of lineDecoder.flush()) {\n            const sse = sseDecoder.decode(line);\n            if (sse)\n                yield yield __await(sse);\n        }\n    });\n}\n/**\n * Given an async iterable iterator, iterates over it and yields full\n * SSE chunks, i.e. yields when a double new-line is encountered.\n */\nfunction iterSSEChunks(iterator) {\n    return __asyncGenerator(this, arguments, function* iterSSEChunks_1() {\n        var _a, e_5, _b, _c;\n        let data = new Uint8Array();\n        try {\n            for (var _d = true, iterator_3 = __asyncValues(iterator), iterator_3_1; iterator_3_1 = yield __await(iterator_3.next()), _a = iterator_3_1.done, !_a; _d = true) {\n                _c = iterator_3_1.value;\n                _d = false;\n                const chunk = _c;\n                if (chunk == null) {\n                    continue;\n                }\n                const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n                    : typeof chunk === 'string' ? encodeUTF8(chunk)\n                        : chunk;\n                let newData = new Uint8Array(data.length + binaryChunk.length);\n                newData.set(data);\n                newData.set(binaryChunk, data.length);\n                data = newData;\n                let patternIndex;\n                while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\n                    yield yield __await(data.slice(0, patternIndex));\n                    data = data.slice(patternIndex);\n                }\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (!_d && !_a && (_b = iterator_3.return)) yield __await(_b.call(iterator_3));\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n        if (data.length > 0) {\n            yield yield __await(data);\n        }\n    });\n}\nclass SSEDecoder {\n    constructor() {\n        this.event = null;\n        this.data = [];\n        this.chunks = [];\n    }\n    decode(line) {\n        if (line.endsWith('\\r')) {\n            line = line.substring(0, line.length - 1);\n        }\n        if (!line) {\n            // empty line and we didn't previously encounter any messages\n            if (!this.event && !this.data.length)\n                return null;\n            const sse = {\n                event: this.event,\n                data: this.data.join('\\n'),\n                raw: this.chunks,\n            };\n            this.event = null;\n            this.data = [];\n            this.chunks = [];\n            return sse;\n        }\n        this.chunks.push(line);\n        if (line.startsWith(':')) {\n            return null;\n        }\n        let [fieldname, _, value] = partition(line, ':');\n        if (value.startsWith(' ')) {\n            value = value.substring(1);\n        }\n        if (fieldname === 'event') {\n            this.event = value;\n        }\n        else if (fieldname === 'data') {\n            this.data.push(value);\n        }\n        return null;\n    }\n}\nfunction partition(str, delimiter) {\n    const index = str.indexOf(delimiter);\n    if (index !== -1) {\n        return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n    }\n    return [str, '', ''];\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nasync function defaultParseResponse(client, props) {\n    const { response, requestLogID, retryOfRequestLogID, startTime } = props;\n    const body = await (async () => {\n        var _a;\n        if (props.options.stream) {\n            loggerFor(client).debug('response', response.status, response.url, response.headers, response.body);\n            // Note: there is an invariant here that isn't represented in the type system\n            // that if you set `stream: true` the response type must also be `Stream<T>`\n            if (props.options.__streamClass) {\n                return props.options.__streamClass.fromSSEResponse(response, props.controller, client);\n            }\n            return Stream.fromSSEResponse(response, props.controller, client);\n        }\n        // fetch refuses to read the body when the status code is 204.\n        if (response.status === 204) {\n            return null;\n        }\n        if (props.options.__binaryResponse) {\n            return response;\n        }\n        const contentType = response.headers.get('content-type');\n        const mediaType = (_a = contentType === null || contentType === void 0 ? void 0 : contentType.split(';')[0]) === null || _a === void 0 ? void 0 : _a.trim();\n        const isJSON = (mediaType === null || mediaType === void 0 ? void 0 : mediaType.includes('application/json')) || (mediaType === null || mediaType === void 0 ? void 0 : mediaType.endsWith('+json'));\n        if (isJSON) {\n            const contentLength = response.headers.get('content-length');\n            if (contentLength === '0') {\n                // if there is no content we can't do anything\n                return undefined;\n            }\n            const json = await response.json();\n            return json;\n        }\n        const text = await response.text();\n        return text;\n    })();\n    loggerFor(client).debug(`[${requestLogID}] response parsed`, formatRequestDetails({\n        retryOfRequestLogID,\n        url: response.url,\n        status: response.status,\n        body,\n        durationMs: Date.now() - startTime,\n    }));\n    return body;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nclass APIPromise extends Promise {\n    constructor(client, responsePromise, parseResponse = defaultParseResponse) {\n        super((resolve) => {\n            // this is maybe a bit weird but this has to be a no-op to not implicitly\n            // parse the response body; instead .then, .catch, .finally are overridden\n            // to parse the response\n            resolve(null);\n        });\n        this.responsePromise = responsePromise;\n        this.parseResponse = parseResponse;\n        this.client = client;\n    }\n    _thenUnwrap(transform) {\n        return new APIPromise(this.client, this.responsePromise, async (client, props) => transform(await this.parseResponse(client, props), props));\n    }\n    /**\n     * Gets the raw `Response` instance instead of parsing the response\n     * data.\n     *\n     * If you want to parse the response body but still get the `Response`\n     * instance, you can use {@link withResponse()}.\n     *\n     *  Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` or add `\"lib\": [\"DOM\"]`\n     * to your `tsconfig.json`.\n     */\n    asResponse() {\n        return this.responsePromise.then((p) => p.response);\n    }\n    /**\n     * Gets the parsed response data and the raw `Response` instance.\n     *\n     * If you just want to get the raw `Response` instance without parsing it,\n     * you can use {@link asResponse()}.\n     *\n     *  Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` or add `\"lib\": [\"DOM\"]`\n     * to your `tsconfig.json`.\n     */\n    async withResponse() {\n        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n        return { data, response };\n    }\n    parse() {\n        if (!this.parsedPromise) {\n            this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(this.client, data));\n        }\n        return this.parsedPromise;\n    }\n    then(onfulfilled, onrejected) {\n        return this.parse().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.parse().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.parse().finally(onfinally);\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nconst brand_privateNullableHeaders = /* @__PURE__ */ Symbol('brand.privateNullableHeaders');\nfunction* iterateHeaders(headers) {\n    if (!headers)\n        return;\n    if (brand_privateNullableHeaders in headers) {\n        const { values, nulls } = headers;\n        yield* values.entries();\n        for (const name of nulls) {\n            yield [name, null];\n        }\n        return;\n    }\n    let shouldClear = false;\n    let iter;\n    if (headers instanceof Headers) {\n        iter = headers.entries();\n    }\n    else if (isReadonlyArray(headers)) {\n        iter = headers;\n    }\n    else {\n        shouldClear = true;\n        iter = Object.entries(headers !== null && headers !== void 0 ? headers : {});\n    }\n    for (let row of iter) {\n        const name = row[0];\n        if (typeof name !== 'string')\n            throw new TypeError('expected header name to be a string');\n        const values = isReadonlyArray(row[1]) ? row[1] : [row[1]];\n        let didClear = false;\n        for (const value of values) {\n            if (value === undefined)\n                continue;\n            // Objects keys always overwrite older headers, they never append.\n            // Yield a null to clear the header before adding the new values.\n            if (shouldClear && !didClear) {\n                didClear = true;\n                yield [name, null];\n            }\n            yield [name, value];\n        }\n    }\n}\nconst buildHeaders = (newHeaders) => {\n    const targetHeaders = new Headers();\n    const nullHeaders = new Set();\n    for (const headers of newHeaders) {\n        const seenHeaders = new Set();\n        for (const [name, value] of iterateHeaders(headers)) {\n            const lowerName = name.toLowerCase();\n            if (!seenHeaders.has(lowerName)) {\n                targetHeaders.delete(name);\n                seenHeaders.add(lowerName);\n            }\n            if (value === null) {\n                targetHeaders.delete(name);\n                nullHeaders.add(lowerName);\n            }\n            else {\n                targetHeaders.append(name, value);\n                nullHeaders.delete(lowerName);\n            }\n        }\n    }\n    return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };\n};\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n/**\n * Read an environment variable.\n *\n * Trims beginning and trailing whitespace.\n *\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n */\nconst readEnv = (env) => {\n    var _a, _b, _c, _d, _e, _f;\n    if (typeof globalThis.process !== 'undefined') {\n        return (_c = (_b = (_a = globalThis.process.env) === null || _a === void 0 ? void 0 : _a[env]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : undefined;\n    }\n    if (typeof globalThis.Deno !== 'undefined') {\n        return (_f = (_e = (_d = globalThis.Deno.env) === null || _d === void 0 ? void 0 : _d.get) === null || _e === void 0 ? void 0 : _e.call(_d, env)) === null || _f === void 0 ? void 0 : _f.trim();\n    }\n    return undefined;\n};\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nvar _a;\n/**\n * Base class for Gemini Next Gen API API clients.\n */\nclass BaseGeminiNextGenAPIClient {\n    /**\n     * API Client for interfacing with the Gemini Next Gen API API.\n     *\n     * @param {string | null | undefined} [opts.apiKey=process.env['GEMINI_API_KEY'] ?? null]\n     * @param {string | undefined} [opts.apiVersion=v1beta]\n     * @param {string} [opts.baseURL=process.env['GEMINI_NEXT_GEN_API_BASE_URL'] ?? https://generativelanguage.googleapis.com] - Override the default base URL for the API.\n     * @param {number} [opts.timeout=1 minute] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n     * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.\n     * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n     * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.\n     * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.\n     */\n    constructor(_b) {\n        var _c, _d, _e, _f, _g, _h, _j;\n        var { baseURL = readEnv('GEMINI_NEXT_GEN_API_BASE_URL'), apiKey = (_c = readEnv('GEMINI_API_KEY')) !== null && _c !== void 0 ? _c : null, apiVersion = 'v1beta' } = _b, opts = __rest(_b, [\"baseURL\", \"apiKey\", \"apiVersion\"]);\n        const options = Object.assign(Object.assign({ apiKey,\n            apiVersion }, opts), { baseURL: baseURL || `https://generativelanguage.googleapis.com` });\n        this.baseURL = options.baseURL;\n        this.timeout = (_d = options.timeout) !== null && _d !== void 0 ? _d : BaseGeminiNextGenAPIClient.DEFAULT_TIMEOUT /* 1 minute */;\n        this.logger = (_e = options.logger) !== null && _e !== void 0 ? _e : console;\n        const defaultLogLevel = 'warn';\n        // Set default logLevel early so that we can log a warning in parseLogLevel.\n        this.logLevel = defaultLogLevel;\n        this.logLevel =\n            (_g = (_f = parseLogLevel(options.logLevel, 'ClientOptions.logLevel', this)) !== null && _f !== void 0 ? _f : parseLogLevel(readEnv('GEMINI_NEXT_GEN_API_LOG'), \"process.env['GEMINI_NEXT_GEN_API_LOG']\", this)) !== null && _g !== void 0 ? _g : defaultLogLevel;\n        this.fetchOptions = options.fetchOptions;\n        this.maxRetries = (_h = options.maxRetries) !== null && _h !== void 0 ? _h : 2;\n        this.fetch = (_j = options.fetch) !== null && _j !== void 0 ? _j : getDefaultFetch();\n        this.encoder = FallbackEncoder;\n        this._options = options;\n        this.apiKey = apiKey;\n        this.apiVersion = apiVersion;\n        this.clientAdapter = options.clientAdapter;\n    }\n    /**\n     * Create a new client instance re-using the same options given to the current client with optional overriding.\n     */\n    withOptions(options) {\n        const client = new this.constructor(Object.assign(Object.assign(Object.assign({}, this._options), { baseURL: this.baseURL, maxRetries: this.maxRetries, timeout: this.timeout, logger: this.logger, logLevel: this.logLevel, fetch: this.fetch, fetchOptions: this.fetchOptions, apiKey: this.apiKey, apiVersion: this.apiVersion }), options));\n        return client;\n    }\n    /**\n     * Check whether the base URL is set to its default.\n     */\n    baseURLOverridden() {\n        return this.baseURL !== 'https://generativelanguage.googleapis.com';\n    }\n    defaultQuery() {\n        return this._options.defaultQuery;\n    }\n    validateHeaders({ values, nulls }) {\n        // The headers object handles case insensitivity.\n        if (values.has('authorization') || values.has('x-goog-api-key')) {\n            return;\n        }\n        if (this.apiKey && values.get('x-goog-api-key')) {\n            return;\n        }\n        if (nulls.has('x-goog-api-key')) {\n            return;\n        }\n        throw new Error('Could not resolve authentication method. Expected the apiKey to be set. Or for the \"x-goog-api-key\" headers to be explicitly omitted');\n    }\n    async authHeaders(opts) {\n        const existingHeaders = buildHeaders([opts.headers]);\n        if (existingHeaders.values.has('authorization') || existingHeaders.values.has('x-goog-api-key')) {\n            return undefined;\n        }\n        if (this.apiKey) {\n            return buildHeaders([{ 'x-goog-api-key': this.apiKey }]);\n        }\n        if (this.clientAdapter.isVertexAI()) {\n            return buildHeaders([await this.clientAdapter.getAuthHeaders()]);\n        }\n        return undefined;\n    }\n    /**\n     * Basic re-implementation of `qs.stringify` for primitive types.\n     */\n    stringifyQuery(query) {\n        return Object.entries(query)\n            .filter(([_, value]) => typeof value !== 'undefined')\n            .map(([key, value]) => {\n            if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n                return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n            }\n            if (value === null) {\n                return `${encodeURIComponent(key)}=`;\n            }\n            throw new GeminiNextGenAPIClientError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);\n        })\n            .join('&');\n    }\n    getUserAgent() {\n        return `${this.constructor.name}/JS ${VERSION}`;\n    }\n    defaultIdempotencyKey() {\n        return `stainless-node-retry-${uuid4()}`;\n    }\n    makeStatusError(status, error, message, headers) {\n        return APIError.generate(status, error, message, headers);\n    }\n    buildURL(path, query, defaultBaseURL) {\n        const baseURL = (!this.baseURLOverridden() && defaultBaseURL) || this.baseURL;\n        const url = isAbsoluteURL(path) ?\n            new URL(path)\n            : new URL(baseURL + (baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\n        const defaultQuery = this.defaultQuery();\n        if (!isEmptyObj(defaultQuery)) {\n            query = Object.assign(Object.assign({}, defaultQuery), query);\n        }\n        if (typeof query === 'object' && query && !Array.isArray(query)) {\n            url.search = this.stringifyQuery(query);\n        }\n        return url.toString();\n    }\n    /**\n     * Used as a callback for mutating the given `FinalRequestOptions` object.\n  \n     */\n    async prepareOptions(options) {\n        if (this.clientAdapter &&\n            this.clientAdapter.isVertexAI() &&\n            !options.path.startsWith(`/${this.apiVersion}/projects/`)) {\n            const oldPath = options.path.slice(this.apiVersion.length + 1);\n            options.path = `/${this.apiVersion}/projects/${this.clientAdapter.getProject()}/locations/${this.clientAdapter.getLocation()}${oldPath}`;\n        }\n    }\n    /**\n     * Used as a callback for mutating the given `RequestInit` object.\n     *\n     * This is useful for cases where you want to add certain headers based off of\n     * the request properties, e.g. `method` or `url`.\n     */\n    async prepareRequest(request, { url, options }) { }\n    get(path, opts) {\n        return this.methodRequest('get', path, opts);\n    }\n    post(path, opts) {\n        return this.methodRequest('post', path, opts);\n    }\n    patch(path, opts) {\n        return this.methodRequest('patch', path, opts);\n    }\n    put(path, opts) {\n        return this.methodRequest('put', path, opts);\n    }\n    delete(path, opts) {\n        return this.methodRequest('delete', path, opts);\n    }\n    methodRequest(method, path, opts) {\n        return this.request(Promise.resolve(opts).then((opts) => {\n            return Object.assign({ method, path }, opts);\n        }));\n    }\n    request(options, remainingRetries = null) {\n        return new APIPromise(this, this.makeRequest(options, remainingRetries, undefined));\n    }\n    async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {\n        var _b, _c, _d;\n        const options = await optionsInput;\n        const maxRetries = (_b = options.maxRetries) !== null && _b !== void 0 ? _b : this.maxRetries;\n        if (retriesRemaining == null) {\n            retriesRemaining = maxRetries;\n        }\n        await this.prepareOptions(options);\n        const { req, url, timeout } = await this.buildRequest(options, {\n            retryCount: maxRetries - retriesRemaining,\n        });\n        await this.prepareRequest(req, { url, options });\n        /** Not an API request ID, just for correlating local log entries. */\n        const requestLogID = 'log_' + ((Math.random() * (1 << 24)) | 0).toString(16).padStart(6, '0');\n        const retryLogStr = retryOfRequestLogID === undefined ? '' : `, retryOf: ${retryOfRequestLogID}`;\n        const startTime = Date.now();\n        loggerFor(this).debug(`[${requestLogID}] sending request`, formatRequestDetails({\n            retryOfRequestLogID,\n            method: options.method,\n            url,\n            options,\n            headers: req.headers,\n        }));\n        if ((_c = options.signal) === null || _c === void 0 ? void 0 : _c.aborted) {\n            throw new APIUserAbortError();\n        }\n        const controller = new AbortController();\n        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);\n        const headersTime = Date.now();\n        if (response instanceof globalThis.Error) {\n            const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n            if ((_d = options.signal) === null || _d === void 0 ? void 0 : _d.aborted) {\n                throw new APIUserAbortError();\n            }\n            // detect native connection timeout errors\n            // deno throws \"TypeError: error sending request for url (https://example/): client error (Connect): tcp connect error: Operation timed out (os error 60): Operation timed out (os error 60)\"\n            // undici throws \"TypeError: fetch failed\" with cause \"ConnectTimeoutError: Connect Timeout Error (attempted address: example:443, timeout: 1ms)\"\n            // others do not provide enough information to distinguish timeouts from other connection errors\n            const isTimeout = isAbortError(response) ||\n                /timed? ?out/i.test(String(response) + ('cause' in response ? String(response.cause) : ''));\n            if (retriesRemaining) {\n                loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} - ${retryMessage}`);\n                loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} (${retryMessage})`, formatRequestDetails({\n                    retryOfRequestLogID,\n                    url,\n                    durationMs: headersTime - startTime,\n                    message: response.message,\n                }));\n                return this.retryRequest(options, retriesRemaining, retryOfRequestLogID !== null && retryOfRequestLogID !== void 0 ? retryOfRequestLogID : requestLogID);\n            }\n            loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} - error; no more retries left`);\n            loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} (error; no more retries left)`, formatRequestDetails({\n                retryOfRequestLogID,\n                url,\n                durationMs: headersTime - startTime,\n                message: response.message,\n            }));\n            if (isTimeout) {\n                throw new APIConnectionTimeoutError();\n            }\n            throw new APIConnectionError({ cause: response });\n        }\n        const responseInfo = `[${requestLogID}${retryLogStr}] ${req.method} ${url} ${response.ok ? 'succeeded' : 'failed'} with status ${response.status} in ${headersTime - startTime}ms`;\n        if (!response.ok) {\n            const shouldRetry = await this.shouldRetry(response);\n            if (retriesRemaining && shouldRetry) {\n                const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n                // We don't need the body of this response.\n                await CancelReadableStream(response.body);\n                loggerFor(this).info(`${responseInfo} - ${retryMessage}`);\n                loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({\n                    retryOfRequestLogID,\n                    url: response.url,\n                    status: response.status,\n                    headers: response.headers,\n                    durationMs: headersTime - startTime,\n                }));\n                return this.retryRequest(options, retriesRemaining, retryOfRequestLogID !== null && retryOfRequestLogID !== void 0 ? retryOfRequestLogID : requestLogID, response.headers);\n            }\n            const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;\n            loggerFor(this).info(`${responseInfo} - ${retryMessage}`);\n            const errText = await response.text().catch((err) => castToError(err).message);\n            const errJSON = safeJSON(errText);\n            const errMessage = errJSON ? undefined : errText;\n            loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({\n                retryOfRequestLogID,\n                url: response.url,\n                status: response.status,\n                headers: response.headers,\n                message: errMessage,\n                durationMs: Date.now() - startTime,\n            }));\n            // @ts-ignore\n            const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);\n            throw err;\n        }\n        loggerFor(this).info(responseInfo);\n        loggerFor(this).debug(`[${requestLogID}] response start`, formatRequestDetails({\n            retryOfRequestLogID,\n            url: response.url,\n            status: response.status,\n            headers: response.headers,\n            durationMs: headersTime - startTime,\n        }));\n        return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };\n    }\n    async fetchWithTimeout(url, init, ms, controller) {\n        const _b = init || {}, { signal, method } = _b, options = __rest(_b, [\"signal\", \"method\"]);\n        const abort = controller.abort.bind(controller);\n        if (signal)\n            signal.addEventListener('abort', abort, { once: true });\n        const timeout = setTimeout(abort, ms);\n        const isReadableBody = (globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream) ||\n            (typeof options.body === 'object' && options.body !== null && Symbol.asyncIterator in options.body);\n        const fetchOptions = Object.assign(Object.assign(Object.assign({ signal: controller.signal }, (isReadableBody ? { duplex: 'half' } : {})), { method: 'GET' }), options);\n        if (method) {\n            // Custom methods like 'patch' need to be uppercased\n            // See https://github.com/nodejs/undici/issues/2294\n            fetchOptions.method = method.toUpperCase();\n        }\n        try {\n            // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\n            return await this.fetch.call(undefined, url, fetchOptions);\n        }\n        finally {\n            clearTimeout(timeout);\n        }\n    }\n    async shouldRetry(response) {\n        // Note this is not a standard header.\n        const shouldRetryHeader = response.headers.get('x-should-retry');\n        // If the server explicitly says whether or not to retry, obey.\n        if (shouldRetryHeader === 'true')\n            return true;\n        if (shouldRetryHeader === 'false')\n            return false;\n        // Retry on request timeouts.\n        if (response.status === 408)\n            return true;\n        // Retry on lock timeouts.\n        if (response.status === 409)\n            return true;\n        // Retry on rate limits.\n        if (response.status === 429)\n            return true;\n        // Retry internal errors.\n        if (response.status >= 500)\n            return true;\n        return false;\n    }\n    async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {\n        var _b;\n        let timeoutMillis;\n        // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.\n        const retryAfterMillisHeader = responseHeaders === null || responseHeaders === void 0 ? void 0 : responseHeaders.get('retry-after-ms');\n        if (retryAfterMillisHeader) {\n            const timeoutMs = parseFloat(retryAfterMillisHeader);\n            if (!Number.isNaN(timeoutMs)) {\n                timeoutMillis = timeoutMs;\n            }\n        }\n        // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n        const retryAfterHeader = responseHeaders === null || responseHeaders === void 0 ? void 0 : responseHeaders.get('retry-after');\n        if (retryAfterHeader && !timeoutMillis) {\n            const timeoutSeconds = parseFloat(retryAfterHeader);\n            if (!Number.isNaN(timeoutSeconds)) {\n                timeoutMillis = timeoutSeconds * 1000;\n            }\n            else {\n                timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\n            }\n        }\n        // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n        // just do what it says, but otherwise calculate a default\n        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {\n            const maxRetries = (_b = options.maxRetries) !== null && _b !== void 0 ? _b : this.maxRetries;\n            timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\n        }\n        await sleep$1(timeoutMillis);\n        return this.makeRequest(options, retriesRemaining - 1, requestLogID);\n    }\n    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {\n        const initialRetryDelay = 0.5;\n        const maxRetryDelay = 8.0;\n        const numRetries = maxRetries - retriesRemaining;\n        // Apply exponential backoff, but not more than the max.\n        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\n        // Apply some jitter, take up to at most 25 percent of the retry time.\n        const jitter = 1 - Math.random() * 0.25;\n        return sleepSeconds * jitter * 1000;\n    }\n    async buildRequest(inputOptions, { retryCount = 0 } = {}) {\n        var _b, _c, _d;\n        const options = Object.assign({}, inputOptions);\n        const { method, path, query, defaultBaseURL } = options;\n        const url = this.buildURL(path, query, defaultBaseURL);\n        if ('timeout' in options)\n            validatePositiveInteger('timeout', options.timeout);\n        options.timeout = (_b = options.timeout) !== null && _b !== void 0 ? _b : this.timeout;\n        const { bodyHeaders, body } = this.buildBody({ options });\n        const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });\n        const req = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ method, headers: reqHeaders }, (options.signal && { signal: options.signal })), (globalThis.ReadableStream &&\n            body instanceof globalThis.ReadableStream && { duplex: 'half' })), (body && { body })), ((_c = this.fetchOptions) !== null && _c !== void 0 ? _c : {})), ((_d = options.fetchOptions) !== null && _d !== void 0 ? _d : {}));\n        return { req, url, timeout: options.timeout };\n    }\n    async buildHeaders({ options, method, bodyHeaders, retryCount, }) {\n        let idempotencyHeaders = {};\n        if (this.idempotencyHeader && method !== 'get') {\n            if (!options.idempotencyKey)\n                options.idempotencyKey = this.defaultIdempotencyKey();\n            idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;\n        }\n        const authHeaders = await this.authHeaders(options);\n        let headers = buildHeaders([\n            idempotencyHeaders,\n            Object.assign(Object.assign({ Accept: 'application/json', 'User-Agent': this.getUserAgent(), 'X-Stainless-Retry-Count': String(retryCount) }, (options.timeout ? { 'X-Stainless-Timeout': String(Math.trunc(options.timeout / 1000)) } : {})), getPlatformHeaders()),\n            this._options.defaultHeaders,\n            bodyHeaders,\n            options.headers,\n            authHeaders,\n        ]);\n        this.validateHeaders(headers);\n        return headers.values;\n    }\n    buildBody({ options: { body, headers: rawHeaders } }) {\n        if (!body) {\n            return { bodyHeaders: undefined, body: undefined };\n        }\n        const headers = buildHeaders([rawHeaders]);\n        if (\n        // Pass raw type verbatim\n        ArrayBuffer.isView(body) ||\n            body instanceof ArrayBuffer ||\n            body instanceof DataView ||\n            (typeof body === 'string' &&\n                // Preserve legacy string encoding behavior for now\n                headers.values.has('content-type')) ||\n            // `Blob` is superset of `File`\n            (globalThis.Blob && body instanceof globalThis.Blob) ||\n            // `FormData` -> `multipart/form-data`\n            body instanceof FormData ||\n            // `URLSearchParams` -> `application/x-www-form-urlencoded`\n            body instanceof URLSearchParams ||\n            // Send chunked stream (each chunk has own `length`)\n            (globalThis.ReadableStream && body instanceof globalThis.ReadableStream)) {\n            return { bodyHeaders: undefined, body: body };\n        }\n        else if (typeof body === 'object' &&\n            (Symbol.asyncIterator in body ||\n                (Symbol.iterator in body && 'next' in body && typeof body.next === 'function'))) {\n            return { bodyHeaders: undefined, body: ReadableStreamFrom(body) };\n        }\n        else {\n            return this.encoder({ body, headers });\n        }\n    }\n}\nBaseGeminiNextGenAPIClient.DEFAULT_TIMEOUT = 60000; // 1 minute\n/**\n * API Client for interfacing with the Gemini Next Gen API API.\n */\nclass GeminiNextGenAPIClient extends BaseGeminiNextGenAPIClient {\n    constructor() {\n        super(...arguments);\n        this.interactions = new Interactions(this);\n    }\n}\n_a = GeminiNextGenAPIClient;\nGeminiNextGenAPIClient.GeminiNextGenAPIClient = _a;\nGeminiNextGenAPIClient.GeminiNextGenAPIClientError = GeminiNextGenAPIClientError;\nGeminiNextGenAPIClient.APIError = APIError;\nGeminiNextGenAPIClient.APIConnectionError = APIConnectionError;\nGeminiNextGenAPIClient.APIConnectionTimeoutError = APIConnectionTimeoutError;\nGeminiNextGenAPIClient.APIUserAbortError = APIUserAbortError;\nGeminiNextGenAPIClient.NotFoundError = NotFoundError;\nGeminiNextGenAPIClient.ConflictError = ConflictError;\nGeminiNextGenAPIClient.RateLimitError = RateLimitError;\nGeminiNextGenAPIClient.BadRequestError = BadRequestError;\nGeminiNextGenAPIClient.AuthenticationError = AuthenticationError;\nGeminiNextGenAPIClient.InternalServerError = InternalServerError;\nGeminiNextGenAPIClient.PermissionDeniedError = PermissionDeniedError;\nGeminiNextGenAPIClient.UnprocessableEntityError = UnprocessableEntityError;\nGeminiNextGenAPIClient.toFile = toFile;\nGeminiNextGenAPIClient.Interactions = Interactions;\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction cancelTuningJobParametersToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction cancelTuningJobParametersToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction cancelTuningJobResponseFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction cancelTuningJobResponseFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToMldev(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['validationDataset']) !== undefined) {\n        throw new Error('validationDataset parameter is not supported in Gemini API.');\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        'tunedModelDisplayName',\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromTunedModelDisplayName);\n    }\n    if (getValueByPath(fromObject, ['description']) !== undefined) {\n        throw new Error('description parameter is not supported in Gemini API.');\n    }\n    const fromEpochCount = getValueByPath(fromObject, ['epochCount']);\n    if (parentObject !== undefined && fromEpochCount != null) {\n        setValueByPath(parentObject, ['tuningTask', 'hyperparameters', 'epochCount'], fromEpochCount);\n    }\n    const fromLearningRateMultiplier = getValueByPath(fromObject, [\n        'learningRateMultiplier',\n    ]);\n    if (fromLearningRateMultiplier != null) {\n        setValueByPath(toObject, ['tuningTask', 'hyperparameters', 'learningRateMultiplier'], fromLearningRateMultiplier);\n    }\n    if (getValueByPath(fromObject, ['exportLastCheckpointOnly']) !==\n        undefined) {\n        throw new Error('exportLastCheckpointOnly parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['preTunedModelCheckpointId']) !==\n        undefined) {\n        throw new Error('preTunedModelCheckpointId parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['adapterSize']) !== undefined) {\n        throw new Error('adapterSize parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['tuningMode']) !== undefined) {\n        throw new Error('tuningMode parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['customBaseModel']) !== undefined) {\n        throw new Error('customBaseModel parameter is not supported in Gemini API.');\n    }\n    const fromBatchSize = getValueByPath(fromObject, ['batchSize']);\n    if (parentObject !== undefined && fromBatchSize != null) {\n        setValueByPath(parentObject, ['tuningTask', 'hyperparameters', 'batchSize'], fromBatchSize);\n    }\n    const fromLearningRate = getValueByPath(fromObject, ['learningRate']);\n    if (parentObject !== undefined && fromLearningRate != null) {\n        setValueByPath(parentObject, ['tuningTask', 'hyperparameters', 'learningRate'], fromLearningRate);\n    }\n    if (getValueByPath(fromObject, ['labels']) !== undefined) {\n        throw new Error('labels parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['beta']) !== undefined) {\n        throw new Error('beta parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['baseTeacherModel']) !== undefined) {\n        throw new Error('baseTeacherModel parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['tunedTeacherModelSource']) !== undefined) {\n        throw new Error('tunedTeacherModelSource parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['sftLossWeightMultiplier']) !== undefined) {\n        throw new Error('sftLossWeightMultiplier parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['outputUri']) !== undefined) {\n        throw new Error('outputUri parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToVertex(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    let discriminatorValidationDataset = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorValidationDataset === undefined) {\n        discriminatorValidationDataset = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorValidationDataset === 'SUPERVISED_FINE_TUNING') {\n        const fromValidationDataset = getValueByPath(fromObject, [\n            'validationDataset',\n        ]);\n        if (parentObject !== undefined && fromValidationDataset != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec'], tuningValidationDatasetToVertex(fromValidationDataset));\n        }\n    }\n    else if (discriminatorValidationDataset === 'PREFERENCE_TUNING') {\n        const fromValidationDataset = getValueByPath(fromObject, [\n            'validationDataset',\n        ]);\n        if (parentObject !== undefined && fromValidationDataset != null) {\n            setValueByPath(parentObject, ['preferenceOptimizationSpec'], tuningValidationDatasetToVertex(fromValidationDataset));\n        }\n    }\n    else if (discriminatorValidationDataset === 'DISTILLATION') {\n        const fromValidationDataset = getValueByPath(fromObject, [\n            'validationDataset',\n        ]);\n        if (parentObject !== undefined && fromValidationDataset != null) {\n            setValueByPath(parentObject, ['distillationSpec'], tuningValidationDatasetToVertex(fromValidationDataset));\n        }\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        'tunedModelDisplayName',\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, ['tunedModelDisplayName'], fromTunedModelDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, ['description'], fromDescription);\n    }\n    let discriminatorEpochCount = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorEpochCount === undefined) {\n        discriminatorEpochCount = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorEpochCount === 'SUPERVISED_FINE_TUNING') {\n        const fromEpochCount = getValueByPath(fromObject, ['epochCount']);\n        if (parentObject !== undefined && fromEpochCount != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'hyperParameters', 'epochCount'], fromEpochCount);\n        }\n    }\n    else if (discriminatorEpochCount === 'PREFERENCE_TUNING') {\n        const fromEpochCount = getValueByPath(fromObject, ['epochCount']);\n        if (parentObject !== undefined && fromEpochCount != null) {\n            setValueByPath(parentObject, ['preferenceOptimizationSpec', 'hyperParameters', 'epochCount'], fromEpochCount);\n        }\n    }\n    else if (discriminatorEpochCount === 'DISTILLATION') {\n        const fromEpochCount = getValueByPath(fromObject, ['epochCount']);\n        if (parentObject !== undefined && fromEpochCount != null) {\n            setValueByPath(parentObject, ['distillationSpec', 'hyperParameters', 'epochCount'], fromEpochCount);\n        }\n    }\n    let discriminatorLearningRateMultiplier = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorLearningRateMultiplier === undefined) {\n        discriminatorLearningRateMultiplier = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorLearningRateMultiplier === 'SUPERVISED_FINE_TUNING') {\n        const fromLearningRateMultiplier = getValueByPath(fromObject, [\n            'learningRateMultiplier',\n        ]);\n        if (parentObject !== undefined && fromLearningRateMultiplier != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'hyperParameters', 'learningRateMultiplier'], fromLearningRateMultiplier);\n        }\n    }\n    else if (discriminatorLearningRateMultiplier === 'PREFERENCE_TUNING') {\n        const fromLearningRateMultiplier = getValueByPath(fromObject, [\n            'learningRateMultiplier',\n        ]);\n        if (parentObject !== undefined && fromLearningRateMultiplier != null) {\n            setValueByPath(parentObject, [\n                'preferenceOptimizationSpec',\n                'hyperParameters',\n                'learningRateMultiplier',\n            ], fromLearningRateMultiplier);\n        }\n    }\n    else if (discriminatorLearningRateMultiplier === 'DISTILLATION') {\n        const fromLearningRateMultiplier = getValueByPath(fromObject, [\n            'learningRateMultiplier',\n        ]);\n        if (parentObject !== undefined && fromLearningRateMultiplier != null) {\n            setValueByPath(parentObject, ['distillationSpec', 'hyperParameters', 'learningRateMultiplier'], fromLearningRateMultiplier);\n        }\n    }\n    let discriminatorExportLastCheckpointOnly = getValueByPath(rootObject, ['config', 'method']);\n    if (discriminatorExportLastCheckpointOnly === undefined) {\n        discriminatorExportLastCheckpointOnly = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorExportLastCheckpointOnly === 'SUPERVISED_FINE_TUNING') {\n        const fromExportLastCheckpointOnly = getValueByPath(fromObject, [\n            'exportLastCheckpointOnly',\n        ]);\n        if (parentObject !== undefined && fromExportLastCheckpointOnly != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'exportLastCheckpointOnly'], fromExportLastCheckpointOnly);\n        }\n    }\n    else if (discriminatorExportLastCheckpointOnly === 'PREFERENCE_TUNING') {\n        const fromExportLastCheckpointOnly = getValueByPath(fromObject, [\n            'exportLastCheckpointOnly',\n        ]);\n        if (parentObject !== undefined && fromExportLastCheckpointOnly != null) {\n            setValueByPath(parentObject, ['preferenceOptimizationSpec', 'exportLastCheckpointOnly'], fromExportLastCheckpointOnly);\n        }\n    }\n    else if (discriminatorExportLastCheckpointOnly === 'DISTILLATION') {\n        const fromExportLastCheckpointOnly = getValueByPath(fromObject, [\n            'exportLastCheckpointOnly',\n        ]);\n        if (parentObject !== undefined && fromExportLastCheckpointOnly != null) {\n            setValueByPath(parentObject, ['distillationSpec', 'exportLastCheckpointOnly'], fromExportLastCheckpointOnly);\n        }\n    }\n    let discriminatorAdapterSize = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorAdapterSize === undefined) {\n        discriminatorAdapterSize = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorAdapterSize === 'SUPERVISED_FINE_TUNING') {\n        const fromAdapterSize = getValueByPath(fromObject, ['adapterSize']);\n        if (parentObject !== undefined && fromAdapterSize != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'hyperParameters', 'adapterSize'], fromAdapterSize);\n        }\n    }\n    else if (discriminatorAdapterSize === 'PREFERENCE_TUNING') {\n        const fromAdapterSize = getValueByPath(fromObject, ['adapterSize']);\n        if (parentObject !== undefined && fromAdapterSize != null) {\n            setValueByPath(parentObject, ['preferenceOptimizationSpec', 'hyperParameters', 'adapterSize'], fromAdapterSize);\n        }\n    }\n    else if (discriminatorAdapterSize === 'DISTILLATION') {\n        const fromAdapterSize = getValueByPath(fromObject, ['adapterSize']);\n        if (parentObject !== undefined && fromAdapterSize != null) {\n            setValueByPath(parentObject, ['distillationSpec', 'hyperParameters', 'adapterSize'], fromAdapterSize);\n        }\n    }\n    let discriminatorTuningMode = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorTuningMode === undefined) {\n        discriminatorTuningMode = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorTuningMode === 'SUPERVISED_FINE_TUNING') {\n        const fromTuningMode = getValueByPath(fromObject, ['tuningMode']);\n        if (parentObject !== undefined && fromTuningMode != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'tuningMode'], fromTuningMode);\n        }\n    }\n    const fromCustomBaseModel = getValueByPath(fromObject, [\n        'customBaseModel',\n    ]);\n    if (parentObject !== undefined && fromCustomBaseModel != null) {\n        setValueByPath(parentObject, ['customBaseModel'], fromCustomBaseModel);\n    }\n    let discriminatorBatchSize = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorBatchSize === undefined) {\n        discriminatorBatchSize = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorBatchSize === 'SUPERVISED_FINE_TUNING') {\n        const fromBatchSize = getValueByPath(fromObject, ['batchSize']);\n        if (parentObject !== undefined && fromBatchSize != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'hyperParameters', 'batchSize'], fromBatchSize);\n        }\n    }\n    let discriminatorLearningRate = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorLearningRate === undefined) {\n        discriminatorLearningRate = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorLearningRate === 'SUPERVISED_FINE_TUNING') {\n        const fromLearningRate = getValueByPath(fromObject, [\n            'learningRate',\n        ]);\n        if (parentObject !== undefined && fromLearningRate != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'hyperParameters', 'learningRate'], fromLearningRate);\n        }\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    const fromBeta = getValueByPath(fromObject, ['beta']);\n    if (parentObject !== undefined && fromBeta != null) {\n        setValueByPath(parentObject, ['preferenceOptimizationSpec', 'hyperParameters', 'beta'], fromBeta);\n    }\n    const fromBaseTeacherModel = getValueByPath(fromObject, [\n        'baseTeacherModel',\n    ]);\n    if (parentObject !== undefined && fromBaseTeacherModel != null) {\n        setValueByPath(parentObject, ['distillationSpec', 'baseTeacherModel'], fromBaseTeacherModel);\n    }\n    const fromTunedTeacherModelSource = getValueByPath(fromObject, [\n        'tunedTeacherModelSource',\n    ]);\n    if (parentObject !== undefined && fromTunedTeacherModelSource != null) {\n        setValueByPath(parentObject, ['distillationSpec', 'tunedTeacherModelSource'], fromTunedTeacherModelSource);\n    }\n    const fromSftLossWeightMultiplier = getValueByPath(fromObject, [\n        'sftLossWeightMultiplier',\n    ]);\n    if (parentObject !== undefined && fromSftLossWeightMultiplier != null) {\n        setValueByPath(parentObject, ['distillationSpec', 'hyperParameters', 'sftLossWeightMultiplier'], fromSftLossWeightMultiplier);\n    }\n    const fromOutputUri = getValueByPath(fromObject, ['outputUri']);\n    if (parentObject !== undefined && fromOutputUri != null) {\n        setValueByPath(parentObject, ['outputUri'], fromOutputUri);\n    }\n    return toObject;\n}\nfunction createTuningJobParametersPrivateToMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        'preTunedModel',\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, ['preTunedModel'], fromPreTunedModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        'trainingDataset',\n    ]);\n    if (fromTrainingDataset != null) {\n        tuningDatasetToMldev(fromTrainingDataset);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createTuningJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createTuningJobParametersPrivateToVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        'preTunedModel',\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, ['preTunedModel'], fromPreTunedModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        'trainingDataset',\n    ]);\n    if (fromTrainingDataset != null) {\n        tuningDatasetToVertex(fromTrainingDataset, toObject, rootObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createTuningJobConfigToVertex(fromConfig, toObject, rootObject);\n    }\n    return toObject;\n}\nfunction getTuningJobParametersToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction getTuningJobParametersToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToMldev(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToVertex(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listTuningJobsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listTuningJobsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, ['tunedModels']);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return tuningJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['tuningJobs'], transformedList);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, ['tuningJobs']);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return tuningJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['tuningJobs'], transformedList);\n    }\n    return toObject;\n}\nfunction tunedModelFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['name']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], fromModel);\n    }\n    const fromEndpoint = getValueByPath(fromObject, ['name']);\n    if (fromEndpoint != null) {\n        setValueByPath(toObject, ['endpoint'], fromEndpoint);\n    }\n    return toObject;\n}\nfunction tuningDatasetToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['gcsUri']) !== undefined) {\n        throw new Error('gcsUri parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['vertexDatasetResource']) !== undefined) {\n        throw new Error('vertexDatasetResource parameter is not supported in Gemini API.');\n    }\n    const fromExamples = getValueByPath(fromObject, ['examples']);\n    if (fromExamples != null) {\n        let transformedList = fromExamples;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['examples', 'examples'], transformedList);\n    }\n    return toObject;\n}\nfunction tuningDatasetToVertex(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    let discriminatorGcsUri = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorGcsUri === undefined) {\n        discriminatorGcsUri = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorGcsUri === 'SUPERVISED_FINE_TUNING') {\n        const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n        if (parentObject !== undefined && fromGcsUri != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'trainingDatasetUri'], fromGcsUri);\n        }\n    }\n    else if (discriminatorGcsUri === 'PREFERENCE_TUNING') {\n        const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n        if (parentObject !== undefined && fromGcsUri != null) {\n            setValueByPath(parentObject, ['preferenceOptimizationSpec', 'trainingDatasetUri'], fromGcsUri);\n        }\n    }\n    else if (discriminatorGcsUri === 'DISTILLATION') {\n        const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n        if (parentObject !== undefined && fromGcsUri != null) {\n            setValueByPath(parentObject, ['distillationSpec', 'promptDatasetUri'], fromGcsUri);\n        }\n    }\n    let discriminatorVertexDatasetResource = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorVertexDatasetResource === undefined) {\n        discriminatorVertexDatasetResource = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorVertexDatasetResource === 'SUPERVISED_FINE_TUNING') {\n        const fromVertexDatasetResource = getValueByPath(fromObject, [\n            'vertexDatasetResource',\n        ]);\n        if (parentObject !== undefined && fromVertexDatasetResource != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'trainingDatasetUri'], fromVertexDatasetResource);\n        }\n    }\n    else if (discriminatorVertexDatasetResource === 'PREFERENCE_TUNING') {\n        const fromVertexDatasetResource = getValueByPath(fromObject, [\n            'vertexDatasetResource',\n        ]);\n        if (parentObject !== undefined && fromVertexDatasetResource != null) {\n            setValueByPath(parentObject, ['preferenceOptimizationSpec', 'trainingDatasetUri'], fromVertexDatasetResource);\n        }\n    }\n    else if (discriminatorVertexDatasetResource === 'DISTILLATION') {\n        const fromVertexDatasetResource = getValueByPath(fromObject, [\n            'vertexDatasetResource',\n        ]);\n        if (parentObject !== undefined && fromVertexDatasetResource != null) {\n            setValueByPath(parentObject, ['distillationSpec', 'promptDatasetUri'], fromVertexDatasetResource);\n        }\n    }\n    if (getValueByPath(fromObject, ['examples']) !== undefined) {\n        throw new Error('examples parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction tuningJobFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromState = getValueByPath(fromObject, ['state']);\n    if (fromState != null) {\n        setValueByPath(toObject, ['state'], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        'tuningTask',\n        'startTime',\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        'tuningTask',\n        'completeTime',\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, ['_self']);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, ['tunedModel'], tunedModelFromMldev(fromTunedModel));\n    }\n    return toObject;\n}\nfunction tuningJobFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromState = getValueByPath(fromObject, ['state']);\n    if (fromState != null) {\n        setValueByPath(toObject, ['state'], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, ['startTime']);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, ['endTime']);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, ['tunedModel']);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, ['tunedModel'], fromTunedModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        'preTunedModel',\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, ['preTunedModel'], fromPreTunedModel);\n    }\n    const fromSupervisedTuningSpec = getValueByPath(fromObject, [\n        'supervisedTuningSpec',\n    ]);\n    if (fromSupervisedTuningSpec != null) {\n        setValueByPath(toObject, ['supervisedTuningSpec'], fromSupervisedTuningSpec);\n    }\n    const fromPreferenceOptimizationSpec = getValueByPath(fromObject, [\n        'preferenceOptimizationSpec',\n    ]);\n    if (fromPreferenceOptimizationSpec != null) {\n        setValueByPath(toObject, ['preferenceOptimizationSpec'], fromPreferenceOptimizationSpec);\n    }\n    const fromDistillationSpec = getValueByPath(fromObject, [\n        'distillationSpec',\n    ]);\n    if (fromDistillationSpec != null) {\n        setValueByPath(toObject, ['distillationSpec'], fromDistillationSpec);\n    }\n    const fromTuningDataStats = getValueByPath(fromObject, [\n        'tuningDataStats',\n    ]);\n    if (fromTuningDataStats != null) {\n        setValueByPath(toObject, ['tuningDataStats'], fromTuningDataStats);\n    }\n    const fromEncryptionSpec = getValueByPath(fromObject, [\n        'encryptionSpec',\n    ]);\n    if (fromEncryptionSpec != null) {\n        setValueByPath(toObject, ['encryptionSpec'], fromEncryptionSpec);\n    }\n    const fromPartnerModelTuningSpec = getValueByPath(fromObject, [\n        'partnerModelTuningSpec',\n    ]);\n    if (fromPartnerModelTuningSpec != null) {\n        setValueByPath(toObject, ['partnerModelTuningSpec'], fromPartnerModelTuningSpec);\n    }\n    const fromCustomBaseModel = getValueByPath(fromObject, [\n        'customBaseModel',\n    ]);\n    if (fromCustomBaseModel != null) {\n        setValueByPath(toObject, ['customBaseModel'], fromCustomBaseModel);\n    }\n    const fromExperiment = getValueByPath(fromObject, ['experiment']);\n    if (fromExperiment != null) {\n        setValueByPath(toObject, ['experiment'], fromExperiment);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (fromLabels != null) {\n        setValueByPath(toObject, ['labels'], fromLabels);\n    }\n    const fromOutputUri = getValueByPath(fromObject, ['outputUri']);\n    if (fromOutputUri != null) {\n        setValueByPath(toObject, ['outputUri'], fromOutputUri);\n    }\n    const fromPipelineJob = getValueByPath(fromObject, ['pipelineJob']);\n    if (fromPipelineJob != null) {\n        setValueByPath(toObject, ['pipelineJob'], fromPipelineJob);\n    }\n    const fromServiceAccount = getValueByPath(fromObject, [\n        'serviceAccount',\n    ]);\n    if (fromServiceAccount != null) {\n        setValueByPath(toObject, ['serviceAccount'], fromServiceAccount);\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        'tunedModelDisplayName',\n    ]);\n    if (fromTunedModelDisplayName != null) {\n        setValueByPath(toObject, ['tunedModelDisplayName'], fromTunedModelDisplayName);\n    }\n    const fromVeoTuningSpec = getValueByPath(fromObject, [\n        'veoTuningSpec',\n    ]);\n    if (fromVeoTuningSpec != null) {\n        setValueByPath(toObject, ['veoTuningSpec'], fromVeoTuningSpec);\n    }\n    return toObject;\n}\nfunction tuningOperationFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    return toObject;\n}\nfunction tuningValidationDatasetToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['validationDatasetUri'], fromGcsUri);\n    }\n    const fromVertexDatasetResource = getValueByPath(fromObject, [\n        'vertexDatasetResource',\n    ]);\n    if (fromVertexDatasetResource != null) {\n        setValueByPath(toObject, ['validationDatasetUri'], fromVertexDatasetResource);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Tunings extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists tuning jobs.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of tuning jobs.\n         *\n         * @example\n         * ```ts\n         * const tuningJobs = await ai.tunings.list({config: {'pageSize': 2}});\n         * for await (const tuningJob of tuningJobs) {\n         *   console.log(tuningJob);\n         * }\n         * ```\n         */\n        this.list = async (params = {}) => {\n            return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x) => this.listInternal(x), await this.listInternal(params), params);\n        };\n        /**\n         * Gets a TuningJob.\n         *\n         * @param name - The resource name of the tuning job.\n         * @return - A TuningJob object.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */\n        this.get = async (params) => {\n            return await this.getInternal(params);\n        };\n        /**\n         * Creates a supervised fine-tuning job.\n         *\n         * @param params - The parameters for the tuning job.\n         * @return - A TuningJob operation.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */\n        this.tune = async (params) => {\n            var _a;\n            if (this.apiClient.isVertexAI()) {\n                if (params.baseModel.startsWith('projects/')) {\n                    const preTunedModel = {\n                        tunedModelName: params.baseModel,\n                    };\n                    if ((_a = params.config) === null || _a === void 0 ? void 0 : _a.preTunedModelCheckpointId) {\n                        preTunedModel.checkpointId = params.config.preTunedModelCheckpointId;\n                    }\n                    const paramsPrivate = Object.assign(Object.assign({}, params), { preTunedModel: preTunedModel });\n                    paramsPrivate.baseModel = undefined;\n                    return await this.tuneInternal(paramsPrivate);\n                }\n                else {\n                    const paramsPrivate = Object.assign({}, params);\n                    return await this.tuneInternal(paramsPrivate);\n                }\n            }\n            else {\n                const paramsPrivate = Object.assign({}, params);\n                const operation = await this.tuneMldevInternal(paramsPrivate);\n                let tunedModelName = '';\n                if (operation['metadata'] !== undefined &&\n                    operation['metadata']['tunedModel'] !== undefined) {\n                    tunedModelName = operation['metadata']['tunedModel'];\n                }\n                else if (operation['name'] !== undefined &&\n                    operation['name'].includes('/operations/')) {\n                    tunedModelName = operation['name'].split('/operations/')[0];\n                }\n                const tuningJob = {\n                    name: tunedModelName,\n                    state: JobState.JOB_STATE_QUEUED,\n                };\n                return tuningJob;\n            }\n        };\n    }\n    async getInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getTuningJobParametersToVertex(params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = getTuningJobParametersToMldev(params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = tuningJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listTuningJobsParametersToVertex(params);\n            path = formatMap('tuningJobs', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listTuningJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = listTuningJobsParametersToMldev(params);\n            path = formatMap('tunedModels', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listTuningJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Cancels a tuning job.\n     *\n     * @param params - The parameters for the cancel request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.tunings.cancel({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async cancel(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = cancelTuningJobParametersToVertex(params);\n            path = formatMap('{name}:cancel', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = cancelTuningJobResponseFromVertex(apiResponse);\n                const typedResp = new CancelTuningJobResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = cancelTuningJobParametersToMldev(params);\n            path = formatMap('{name}:cancel', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = cancelTuningJobResponseFromMldev(apiResponse);\n                const typedResp = new CancelTuningJobResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async tuneInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createTuningJobParametersPrivateToVertex(params, params);\n            path = formatMap('tuningJobs', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    async tuneMldevInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = createTuningJobParametersPrivateToMldev(params);\n            path = formatMap('tunedModels', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = tuningOperationFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass BrowserDownloader {\n    async download(_params, _apiClient) {\n        throw new Error('Download to file is not supported in the browser, please use a browser compliant download like an <a> tag.');\n    }\n}\n\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 8; // bytes\nconst MAX_RETRY_COUNT = 3;\nconst INITIAL_RETRY_DELAY_MS = 1000;\nconst DELAY_MULTIPLIER = 2;\nconst X_GOOG_UPLOAD_STATUS_HEADER_FIELD = 'x-goog-upload-status';\nasync function uploadBlob(file, uploadUrl, apiClient) {\n    var _a;\n    const response = await uploadBlobInternal(file, uploadUrl, apiClient);\n    const responseJson = (await (response === null || response === void 0 ? void 0 : response.json()));\n    if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== 'final') {\n        throw new Error('Failed to upload file: Upload status is not finalized.');\n    }\n    return responseJson['file'];\n}\nasync function uploadBlobToFileSearchStore(file, uploadUrl, apiClient) {\n    var _a;\n    const response = await uploadBlobInternal(file, uploadUrl, apiClient);\n    const responseJson = (await (response === null || response === void 0 ? void 0 : response.json()));\n    if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== 'final') {\n        throw new Error('Failed to upload file: Upload status is not finalized.');\n    }\n    const resp = uploadToFileSearchStoreOperationFromMldev(responseJson);\n    const typedResp = new UploadToFileSearchStoreOperation();\n    Object.assign(typedResp, resp);\n    return typedResp;\n}\nasync function uploadBlobInternal(file, uploadUrl, apiClient) {\n    var _a, _b;\n    let fileSize = 0;\n    let offset = 0;\n    let response = new HttpResponse(new Response());\n    let uploadCommand = 'upload';\n    fileSize = file.size;\n    while (offset < fileSize) {\n        const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n        const chunk = file.slice(offset, offset + chunkSize);\n        if (offset + chunkSize >= fileSize) {\n            uploadCommand += ', finalize';\n        }\n        let retryCount = 0;\n        let currentDelayMs = INITIAL_RETRY_DELAY_MS;\n        while (retryCount < MAX_RETRY_COUNT) {\n            response = await apiClient.request({\n                path: '',\n                body: chunk,\n                httpMethod: 'POST',\n                httpOptions: {\n                    apiVersion: '',\n                    baseUrl: uploadUrl,\n                    headers: {\n                        'X-Goog-Upload-Command': uploadCommand,\n                        'X-Goog-Upload-Offset': String(offset),\n                        'Content-Length': String(chunkSize),\n                    },\n                },\n            });\n            if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {\n                break;\n            }\n            retryCount++;\n            await sleep(currentDelayMs);\n            currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;\n        }\n        offset += chunkSize;\n        // The `x-goog-upload-status` header field can be `active`, `final` and\n        //`cancelled` in resposne.\n        if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== 'active') {\n            break;\n        }\n        // TODO(b/401391430) Investigate why the upload status is not finalized\n        // even though all content has been uploaded.\n        if (fileSize <= offset) {\n            throw new Error('All content has been uploaded, but the upload status is not finalized.');\n        }\n    }\n    return response;\n}\nasync function getBlobStat(file) {\n    const fileStat = { size: file.size, type: file.type };\n    return fileStat;\n}\nfunction sleep(ms) {\n    return new Promise((resolvePromise) => setTimeout(resolvePromise, ms));\n}\n\nclass BrowserUploader {\n    async upload(file, uploadUrl, apiClient) {\n        if (typeof file === 'string') {\n            throw new Error('File path is not supported in browser uploader.');\n        }\n        return await uploadBlob(file, uploadUrl, apiClient);\n    }\n    async uploadToFileSearchStore(file, uploadUrl, apiClient) {\n        if (typeof file === 'string') {\n            throw new Error('File path is not supported in browser uploader.');\n        }\n        return await uploadBlobToFileSearchStore(file, uploadUrl, apiClient);\n    }\n    async stat(file) {\n        if (typeof file === 'string') {\n            throw new Error('File path is not supported in browser uploader.');\n        }\n        else {\n            return await getBlobStat(file);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass BrowserWebSocketFactory {\n    create(url, headers, callbacks) {\n        return new BrowserWebSocket(url, headers, callbacks);\n    }\n}\nclass BrowserWebSocket {\n    constructor(url, headers, callbacks) {\n        this.url = url;\n        this.headers = headers;\n        this.callbacks = callbacks;\n    }\n    connect() {\n        this.ws = new WebSocket(this.url);\n        this.ws.onopen = this.callbacks.onopen;\n        this.ws.onerror = this.callbacks.onerror;\n        this.ws.onclose = this.callbacks.onclose;\n        this.ws.onmessage = this.callbacks.onmessage;\n    }\n    send(message) {\n        if (this.ws === undefined) {\n            throw new Error('WebSocket is not connected');\n        }\n        this.ws.send(message);\n    }\n    close() {\n        if (this.ws === undefined) {\n            throw new Error('WebSocket is not connected');\n        }\n        this.ws.close();\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst GOOGLE_API_KEY_HEADER = 'x-goog-api-key';\n// TODO(b/395122533): We need a secure client side authentication mechanism.\nclass WebAuth {\n    constructor(apiKey) {\n        this.apiKey = apiKey;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async addAuthHeaders(headers, url) {\n        if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {\n            return;\n        }\n        if (this.apiKey.startsWith('auth_tokens/')) {\n            throw new Error('Ephemeral tokens are only supported by the live API.');\n        }\n        // Check if API key is empty or null\n        if (!this.apiKey) {\n            throw new Error('API key is missing. Please provide a valid API key.');\n        }\n        headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst LANGUAGE_LABEL_PREFIX = 'gl-node/';\n/**\n * The Google GenAI SDK.\n *\n * @remarks\n * Provides access to the GenAI features through either the {@link\n * https://cloud.google.com/vertex-ai/docs/reference/rest | Gemini API} or\n * the {@link https://cloud.google.com/vertex-ai/docs/reference/rest | Vertex AI\n * API}.\n *\n * The {@link GoogleGenAIOptions.vertexai} value determines which of the API\n * services to use.\n *\n * When using the Gemini API, a {@link GoogleGenAIOptions.apiKey} must also be\n * set. When using Vertex AI, currently only {@link GoogleGenAIOptions.apiKey}\n * is supported via Express mode. {@link GoogleGenAIOptions.project} and {@link\n * GoogleGenAIOptions.location} should not be set.\n *\n * @example\n * Initializing the SDK for using the Gemini API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n *\n * @example\n * Initializing the SDK for using the Vertex AI API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({\n *   vertexai: true,\n *   project: 'PROJECT_ID',\n *   location: 'PROJECT_LOCATION'\n * });\n * ```\n *\n */\nclass GoogleGenAI {\n    get interactions() {\n        if (this._interactions !== undefined) {\n            return this._interactions;\n        }\n        console.warn('GoogleGenAI.interactions: Interactions usage is experimental and may change in future versions.');\n        const httpOpts = this.httpOptions;\n        // Unsupported Options Warnings\n        if (httpOpts === null || httpOpts === void 0 ? void 0 : httpOpts.extraBody) {\n            console.warn('GoogleGenAI.interactions: Client level httpOptions.extraBody is not supported by the interactions client and will be ignored.');\n        }\n        const nextGenClient = new GeminiNextGenAPIClient({\n            baseURL: this.apiClient.getBaseUrl(),\n            apiKey: this.apiKey,\n            apiVersion: this.apiClient.getApiVersion(),\n            clientAdapter: this.apiClient,\n            defaultHeaders: this.apiClient.getDefaultHeaders(),\n            timeout: httpOpts === null || httpOpts === void 0 ? void 0 : httpOpts.timeout,\n        });\n        this._interactions = nextGenClient.interactions;\n        return this._interactions;\n    }\n    constructor(options) {\n        var _a;\n        if (options.apiKey == null) {\n            throw new Error('An API Key must be set when running in a browser');\n        }\n        // Web client only supports API key mode for Vertex AI.\n        if (options.project || options.location) {\n            throw new Error('Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location.');\n        }\n        this.vertexai = (_a = options.vertexai) !== null && _a !== void 0 ? _a : false;\n        this.apiKey = options.apiKey;\n        const baseUrl = getBaseUrl(options.httpOptions, options.vertexai, \n        /*vertexBaseUrlFromEnv*/ undefined, \n        /*geminiBaseUrlFromEnv*/ undefined);\n        if (baseUrl) {\n            if (options.httpOptions) {\n                options.httpOptions.baseUrl = baseUrl;\n            }\n            else {\n                options.httpOptions = { baseUrl: baseUrl };\n            }\n        }\n        this.apiVersion = options.apiVersion;\n        this.httpOptions = options.httpOptions;\n        const auth = new WebAuth(this.apiKey);\n        this.apiClient = new ApiClient({\n            auth: auth,\n            apiVersion: this.apiVersion,\n            apiKey: this.apiKey,\n            vertexai: this.vertexai,\n            httpOptions: this.httpOptions,\n            userAgentExtra: LANGUAGE_LABEL_PREFIX + 'web',\n            uploader: new BrowserUploader(),\n            downloader: new BrowserDownloader(),\n        });\n        this.models = new Models(this.apiClient);\n        this.live = new Live(this.apiClient, auth, new BrowserWebSocketFactory());\n        this.batches = new Batches(this.apiClient);\n        this.chats = new Chats(this.models, this.apiClient);\n        this.caches = new Caches(this.apiClient);\n        this.files = new Files(this.apiClient);\n        this.operations = new Operations(this.apiClient);\n        this.authTokens = new Tokens(this.apiClient);\n        this.tunings = new Tunings(this.apiClient);\n        this.fileSearchStores = new FileSearchStores(this.apiClient);\n    }\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dlbmFpL2Rpc3Qvd2ViL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBLHVCQUF1QixzQ0FBc0M7QUFDN0Q7QUFDQTtBQUNBLHVCQUF1Qiw2Q0FBNkM7QUFDcEU7QUFDQSwrQkFBK0IseUJBQXlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFJLEtBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxzQkFBc0IsV0FBVztBQUNsRjtBQUNBO0FBQ0EsZ0ZBQWdGLElBQUk7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxTQUFTO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGNBQWMsY0FBYyxHQUFHLGNBQWMsRUFBRTtBQUN2RCxRQUFRO0FBQ1I7QUFDQSxXQUFXLGNBQWMsWUFBWSxlQUFlLEdBQUcsWUFBWSxlQUFlO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnRUFBZ0U7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Q7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnRUFBZ0U7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOERBQThEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDREQUE0RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdFQUFnRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Q7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvREFBb0Q7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9EQUFvRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9FQUFvRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwREFBMEQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBEQUEwRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNERBQTREO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsV0FBVyx3QkFBd0IsbUJBQW1CLDBCQUEwQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdDQUF3Qyx5QkFBeUIsT0FBTztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLFdBQVcsd0JBQXdCLG1CQUFtQiwwQkFBMEI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3REFBd0Q7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QyxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEMsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUyxVQUFVLFNBQVM7QUFDN0Q7QUFDQTtBQUNBLCtDQUErQyxNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCLGFBQWEsd0JBQXdCLEdBQUcsaUJBQWlCO0FBQzNHO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCLGFBQWEsd0JBQXdCLHFCQUFxQixpQkFBaUI7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxZQUFZO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlCQUF5QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx5QkFBeUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0NBQStDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUcsU0FBUyxlQUFlLEdBQUcsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUyxhQUFhLEdBQUcsZUFBZSxFQUFFO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxvQkFBb0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZUFBZTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CLEdBQUcsYUFBYTtBQUNuRTtBQUNBLDRDQUE0QyxlQUFlO0FBQzNELCtCQUErQixvQkFBb0IsYUFBYSxxQkFBcUIsR0FBRyxhQUFhO0FBQ3JHO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CLGFBQWEscUJBQXFCLEdBQUcsZUFBZSxHQUFHLGFBQWE7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWUsR0FBRyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxLQUFLO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGFBQWE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsNEVBQTRFLElBQUk7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQkFBaUI7QUFDL0M7QUFDQTtBQUNBLDZFQUE2RSxJQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxXQUFXO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFdBQVc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msd0NBQXdDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdLQUFnSztBQUNoSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTLGNBQWM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsYUFBYTtBQUNiO0FBQ0EseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUyxjQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUyxlQUFlO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUEwRDtBQUM3RTtBQUNBLHNCQUFzQiw2REFBNkQ7QUFDbkY7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFDQUFxQztBQUN4RCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxxREFBcUQsYUFBYTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvQkFBb0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU8sUUFBUSxhQUFhO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZLFFBQVEsYUFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWSxHQUFHO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUs7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZLEdBQUc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWSxHQUFHO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsU0FBUyxlQUFlO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZLEdBQUc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWSxHQUFHO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBNQUEwTSxjQUFjO0FBQ3hOLDhCQUE4QixzQkFBc0I7QUFDcEQsMEJBQTBCLFlBQVksc0JBQXNCLHFDQUFxQywyQ0FBMkMsTUFBTTtBQUNsSiw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5Q0FBeUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOEJBQThCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsZ0dBQWdHO0FBQzFNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTLGVBQWU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5Q0FBeUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMENBQTBDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsS0FBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw0QkFBNEI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkIsYUFBYSw0QkFBNEI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxrQkFBa0Isb0JBQW9CO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMEVBQTBFLGtCQUFrQixvQkFBb0I7QUFDaEg7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsY0FBYztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxPQUFPLElBQUksMEJBQTBCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixxQkFBcUIsSUFBSSxFQUFFO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEdBQUc7QUFDNUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrQkFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG9CQUFvQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx1SkFBdUosVUFBVSwyQ0FBMkMsU0FBUyxHQUFHLGdCQUFnQixzQ0FBc0MsSUFBSTtBQUMzVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csSUFBSSxvQkFBb0IsbUJBQW1CLGNBQWMsbUJBQW1CO0FBQ3BMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUcseUNBQXlDO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQixtQ0FBbUMsV0FBVywyQ0FBMkMsT0FBTztBQUN4STtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUIsOEJBQThCLFdBQVc7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SUFBd0ksbUNBQW1DLHdCQUF3QixHQUFHO0FBQ3RNO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQixtQ0FBbUMsV0FBVyxxQkFBcUIsT0FBTyxHQUFHLFFBQVEsR0FBRyxPQUFPO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUSxhQUFhLFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Ysb0JBQW9CO0FBQ3RHO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQW9EO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHdCQUF3QjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0NBQXNDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1Qyx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFDQUFxQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBLG1MQUFtTCxpQkFBaUI7QUFDcE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBLCtEQUErRCxpQkFBaUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxxQkFBcUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsb0JBQW9CLHlCQUF5QjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZ0NBQWdDLHFCQUFxQjtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsaUJBQWlCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSCw4RUFBOEU7QUFDOUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscU1BQXFNLGdCQUFnQixpQkFBaUIsdUJBQXVCO0FBQzdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5Ryx1RkFBdUY7QUFDaE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsdUZBQXVGO0FBQ2hNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywwQkFBMEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxJQUFJLEdBQUcsR0FBRztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVEsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxNQUFNO0FBQ3pEO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrQ0FBa0MsZUFBZTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YseUNBQXlDO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxTQUFTLGVBQWU7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQXNEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUJBQXVCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLG1CQUFtQixJQUFJO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBNkM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVEsRUFBRSxJQUFJO0FBQ3BDO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDRDQUE0QztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVSxJQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVUsSUFBSTtBQUNoQyxnQkFBZ0Isa0ZBQWtGO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE1BQU07QUFDdkQ7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsb0JBQW9CO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhEQUE4RDtBQUN4RSxVQUFVLDREQUE0RDtBQUN0RSxVQUFVLGtFQUFrRTtBQUM1RSxVQUFVLGtFQUFrRTtBQUM1RSxVQUFVLG9FQUFvRTtBQUM5RSxVQUFVLDZGQUE2RjtBQUN2RztBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQkFBMEIsTUFBTSxHQUFHLE1BQU0sR0FBRyxNQUFNO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxpRUFBaUUsT0FBTztBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDLHdEQUF3RCxpQkFBaUI7QUFDekUsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjLE1BQU07QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsNERBQTREO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYSxFQUFFLGlCQUFpQixlQUFlLFlBQVksT0FBTyxFQUFFLHFCQUFxQjtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVSxxQkFBcUIsRUFBRSxlQUFlO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLG1DQUFtQztBQUNuQyxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVEQUF1RCxJQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0dBQXdHO0FBQ3hHO0FBQ0Esd0JBQXdCLElBQUksS0FBSyxJQUFJLFVBQVU7QUFDL0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdDQUF3QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWSw4Q0FBOEMsTUFBTSxjQUFjLHFFQUFxRTtBQUM3TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsZ0JBQWdCLHdDQUF3QztBQUN4RCw0Q0FBNEMsWUFBWSxnQkFBZ0IsR0FBRztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsZ0JBQWdCLHdDQUF3QztBQUN4RCwwQ0FBMEMsWUFBWSxnQkFBZ0IsR0FBRztBQUN6RTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLHFFQUFxRSxJQUFJLHdDQUF3QztBQUNqSCx5Q0FBeUMsWUFBWSxnQkFBZ0IsR0FBRyxpQ0FBaUMsT0FBTyxjQUFjLHFIQUFxSDtBQUNuUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwyQkFBMkI7QUFDM0IsZ0ZBQWdGLG1CQUFtQjtBQUNuRztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixZQUFZLGFBQWEsMkJBQTJCLG9CQUFvQiwwQ0FBMEM7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEcsa0RBQWtEO0FBQzlKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Ysa0VBQWtFO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGtEQUFrRDtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGtEQUFrRDtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRiw4RUFBOEU7QUFDbEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQXlEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscUJBQXFCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQyxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEpBQTRKO0FBQzFLLHNEQUFzRDtBQUN0RCx3QkFBd0IsV0FBVyxpRUFBaUU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLG9CQUFvQiwrTkFBK047QUFDM1U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywrQkFBK0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3QkFBd0IsR0FBRywwQkFBMEI7QUFDL0U7QUFDQTtBQUNBLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQSwyRUFBMkUsZUFBZSw2SEFBNkgsU0FBUyw0Q0FBNEM7QUFDNVEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0IsTUFBTSxRQUFRO0FBQ3REO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBLCtCQUErQixnQkFBZ0IsWUFBWSxnQ0FBZ0MsYUFBYSxpQ0FBaUMsRUFBRSxRQUFRO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQSxTQUFTO0FBQ1QseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQTtBQUNBLG1GQUFtRixvQkFBb0I7QUFDdkc7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhLGVBQWUsb0NBQW9DLElBQUksYUFBYTtBQUMxSCwwQ0FBMEMsYUFBYSxlQUFlLG9DQUFvQyxHQUFHLGFBQWE7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFDQUFxQyxhQUFhLGVBQWUsb0NBQW9DLFNBQVM7QUFDOUcsc0NBQXNDLGFBQWEsZUFBZSxvQ0FBb0MsUUFBUTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUJBQWlCO0FBQzVEO0FBQ0EsaUNBQWlDLGFBQWEsRUFBRSxZQUFZLElBQUksWUFBWSxFQUFFLEtBQUssRUFBRSxzQ0FBc0MsY0FBYyxpQkFBaUIsS0FBSyx3QkFBd0I7QUFDdkw7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWMsSUFBSSxhQUFhO0FBQ3ZFLDBDQUEwQyxhQUFhLG9CQUFvQixhQUFhO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHVEQUF1RCxnQ0FBZ0M7QUFDdkYsb0NBQW9DLGNBQWMsSUFBSSxhQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhLG9CQUFvQixhQUFhO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDZCQUE2QixJQUFJLGlCQUFpQjtBQUNsRDtBQUNBO0FBQ0Esc0RBQXNELFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDJCQUEyQixzQkFBc0IsaUJBQWlCLElBQUksTUFBTSxlQUFlO0FBQ3BLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUJBQWlCLElBQUk7QUFDNUQ7QUFDQSx3Q0FBd0M7QUFDeEMsZ0JBQWdCLHNDQUFzQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0IsbUJBQW1CLFNBQVM7QUFDaEUscURBQXFELHdEQUF3RDtBQUM3Ryw0RkFBNEYsNkJBQTZCLHVCQUF1Qix3QkFBd0I7QUFDeEssMkRBQTJELGdCQUFnQixlQUFlLE1BQU0saUVBQWlFLG9FQUFvRTtBQUNyTyxpQkFBaUI7QUFDakI7QUFDQSx5QkFBeUIsMkNBQTJDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw4R0FBOEcsdUJBQXVCLG9FQUFvRSxJQUFJO0FBQ3ZQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVyw2QkFBNkI7QUFDeEQ7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVMsZUFBZTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhLDhCQUE4QjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZLEdBQUc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELHdFQUF3RTtBQUN4RSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0EsUUFBUSxtQ0FBbUM7QUFDM0M7QUFDQTtBQUNBLGlDQUFpQyxpQ0FBaUM7QUFDbEUsOENBQThDO0FBQzlDLG1DQUFtQyxrQ0FBa0MsS0FBSztBQUMxRSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsK0JBQStCLHlCQUF5QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOGpGO0FBQzlqRiIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZWJ1cm9uZHVhbC9ub2RlX21vZHVsZXMvQGdvb2dsZS9nZW5haS9kaXN0L3dlYi9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xubGV0IF9kZWZhdWx0QmFzZUdlbWluaVVybCA9IHVuZGVmaW5lZDtcbmxldCBfZGVmYXVsdEJhc2VWZXJ0ZXhVcmwgPSB1bmRlZmluZWQ7XG4vKipcbiAqIE92ZXJyaWRlcyB0aGUgYmFzZSBVUkxzIGZvciB0aGUgR2VtaW5pIEFQSSBhbmQgVmVydGV4IEFJIEFQSS5cbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGluaXRpYWxpemluZyB0aGUgU0RLLiBJZiB0aGVcbiAqIGJhc2UgVVJMcyBhcmUgc2V0IGFmdGVyIGluaXRpYWxpemluZyB0aGUgU0RLLCB0aGUgYmFzZSBVUkxzIHdpbGwgbm90IGJlXG4gKiB1cGRhdGVkLiBCYXNlIFVSTHMgcHJvdmlkZWQgaW4gdGhlIEh0dHBPcHRpb25zIHdpbGwgYWxzbyB0YWtlIHByZWNlZGVuY2Ugb3ZlclxuICogVVJMcyBzZXQgaGVyZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7R29vZ2xlR2VuQUksIHNldERlZmF1bHRCYXNlVXJsc30gZnJvbSAnQGdvb2dsZS9nZW5haSc7XG4gKiAvLyBPdmVycmlkZSB0aGUgYmFzZSBVUkwgZm9yIHRoZSBHZW1pbmkgQVBJLlxuICogc2V0RGVmYXVsdEJhc2VVcmxzKHtnZW1pbmlVcmw6J2h0dHBzOi8vZ2VtaW5pLmdvb2dsZS5jb20nfSk7XG4gKlxuICogLy8gT3ZlcnJpZGUgdGhlIGJhc2UgVVJMIGZvciB0aGUgVmVydGV4IEFJIEFQSS5cbiAqIHNldERlZmF1bHRCYXNlVXJscyh7dmVydGV4VXJsOiAnaHR0cHM6Ly92ZXJ0ZXhhaS5nb29nbGVhcGlzLmNvbSd9KTtcbiAqXG4gKiBjb25zdCBhaSA9IG5ldyBHb29nbGVHZW5BSSh7YXBpS2V5OiAnR0VNSU5JX0FQSV9LRVknfSk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gc2V0RGVmYXVsdEJhc2VVcmxzKGJhc2VVcmxQYXJhbXMpIHtcbiAgICBfZGVmYXVsdEJhc2VHZW1pbmlVcmwgPSBiYXNlVXJsUGFyYW1zLmdlbWluaVVybDtcbiAgICBfZGVmYXVsdEJhc2VWZXJ0ZXhVcmwgPSBiYXNlVXJsUGFyYW1zLnZlcnRleFVybDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBiYXNlIFVSTHMgZm9yIHRoZSBHZW1pbmkgQVBJIGFuZCBWZXJ0ZXggQUkgQVBJLlxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0QmFzZVVybHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2VtaW5pVXJsOiBfZGVmYXVsdEJhc2VHZW1pbmlVcmwsXG4gICAgICAgIHZlcnRleFVybDogX2RlZmF1bHRCYXNlVmVydGV4VXJsLFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGRlZmF1bHQgYmFzZSBVUkwgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBwcmlvcml0eTpcbiAqICAgMS4gQmFzZSBVUkxzIHNldCB2aWEgSHR0cE9wdGlvbnMuXG4gKiAgIDIuIEJhc2UgVVJMcyBzZXQgdmlhIHRoZSBsYXRlc3QgY2FsbCB0byBzZXREZWZhdWx0QmFzZVVybHMuXG4gKiAgIDMuIEJhc2UgVVJMcyBzZXQgdmlhIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0QmFzZVVybChodHRwT3B0aW9ucywgdmVydGV4YWksIHZlcnRleEJhc2VVcmxGcm9tRW52LCBnZW1pbmlCYXNlVXJsRnJvbUVudikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCEoaHR0cE9wdGlvbnMgPT09IG51bGwgfHwgaHR0cE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGh0dHBPcHRpb25zLmJhc2VVcmwpKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRCYXNlVXJscyA9IGdldERlZmF1bHRCYXNlVXJscygpO1xuICAgICAgICBpZiAodmVydGV4YWkpIHtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBkZWZhdWx0QmFzZVVybHMudmVydGV4VXJsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2ZXJ0ZXhCYXNlVXJsRnJvbUVudjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoX2IgPSBkZWZhdWx0QmFzZVVybHMuZ2VtaW5pVXJsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBnZW1pbmlCYXNlVXJsRnJvbUVudjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaHR0cE9wdGlvbnMuYmFzZVVybDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgQmFzZU1vZHVsZSB7XG59XG5mdW5jdGlvbiBmb3JtYXRNYXAodGVtcGxhdGVTdHJpbmcsIHZhbHVlTWFwKSB7XG4gICAgLy8gVXNlIGEgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbmQgYWxsIHBsYWNlaG9sZGVycyBpbiB0aGUgdGVtcGxhdGUgc3RyaW5nXG4gICAgY29uc3QgcmVnZXggPSAvXFx7KFtefV0rKVxcfS9nO1xuICAgIC8vIFJlcGxhY2UgZWFjaCBwbGFjZWhvbGRlciB3aXRoIGl0cyBjb3JyZXNwb25kaW5nIHZhbHVlIGZyb20gdGhlIHZhbHVlTWFwXG4gICAgcmV0dXJuIHRlbXBsYXRlU3RyaW5nLnJlcGxhY2UocmVnZXgsIChtYXRjaCwga2V5KSA9PiB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWVNYXAsIGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVNYXBba2V5XTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIGEgc3RyaW5nIGlmIGl0J3Mgbm90IGEgc3RyaW5nIGFscmVhZHlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsID8gU3RyaW5nKHZhbHVlKSA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSGFuZGxlIG1pc3Npbmcga2V5c1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgJyR7a2V5fScgbm90IGZvdW5kIGluIHZhbHVlTWFwLmApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXRWYWx1ZUJ5UGF0aChkYXRhLCBrZXlzLCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGtleS5lbmRzV2l0aCgnW10nKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5TmFtZSA9IGtleS5zbGljZSgwLCAtMik7XG4gICAgICAgICAgICBpZiAoIShrZXlOYW1lIGluIGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFba2V5TmFtZV0gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiB2YWx1ZS5sZW5ndGggfSwgKCkgPT4gKHt9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlIG11c3QgYmUgYSBsaXN0IGdpdmVuIGFuIGFycmF5IHBhdGggJHtrZXl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVtrZXlOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheURhdGEgPSBkYXRhW2tleU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFycmF5RGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBhcnJheURhdGFbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChlbnRyeSwga2V5cy5zbGljZShpICsgMSksIHZhbHVlW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBkIG9mIGFycmF5RGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgoZCwga2V5cy5zbGljZShpICsgMSksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkuZW5kc1dpdGgoJ1swXScpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlOYW1lID0ga2V5LnNsaWNlKDAsIC0zKTtcbiAgICAgICAgICAgIGlmICghKGtleU5hbWUgaW4gZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2tleU5hbWVdID0gW3t9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFycmF5RGF0YSA9IGRhdGFba2V5TmFtZV07XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChhcnJheURhdGFbMF0sIGtleXMuc2xpY2UoaSArIDEpLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhW2tleV0gfHwgdHlwZW9mIGRhdGFba2V5XSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBkYXRhW2tleV07XG4gICAgfVxuICAgIGNvbnN0IGtleVRvU2V0ID0ga2V5c1trZXlzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGV4aXN0aW5nRGF0YSA9IGRhdGFba2V5VG9TZXRdO1xuICAgIGlmIChleGlzdGluZ0RhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIXZhbHVlIHx8XG4gICAgICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZXhpc3RpbmdEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBleGlzdGluZ0RhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBleGlzdGluZ0RhdGEgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGV4aXN0aW5nRGF0YSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc2V0IHZhbHVlIGZvciBhbiBleGlzdGluZyBrZXkuIEtleTogJHtrZXlUb1NldH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGtleVRvU2V0ID09PSAnX3NlbGYnICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUFzUmVjb3JkID0gdmFsdWU7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGRhdGEsIHZhbHVlQXNSZWNvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YVtrZXlUb1NldF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFZhbHVlQnlQYXRoKGRhdGEsIGtleXMsIGRlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlzWzBdID09PSAnX3NlbGYnKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKGtleS5lbmRzV2l0aCgnW10nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleU5hbWUgPSBrZXkuc2xpY2UoMCwgLTIpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlOYW1lIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXlEYXRhID0gZGF0YVtrZXlOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5RGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5RGF0YS5tYXAoKGQpID0+IGdldFZhbHVlQnlQYXRoKGQsIGtleXMuc2xpY2UoaSArIDEpLCBkZWZhdWx0VmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG4vKipcbiAqIE1vdmVzIHZhbHVlcyBmcm9tIHNvdXJjZSBwYXRocyB0byBkZXN0aW5hdGlvbiBwYXRocy5cbiAqXG4gKiBFeGFtcGxlczpcbiAqICAgbW92ZVZhbHVlQnlQYXRoKFxuICogICAgIHsncmVxdWVzdHMnOiBbeydjb250ZW50JzogdjF9LCB7J2NvbnRlbnQnOiB2Mn1dfSxcbiAqICAgICB7J3JlcXVlc3RzW10uKic6ICdyZXF1ZXN0c1tdLnJlcXVlc3QuKid9XG4gKiAgIClcbiAqICAgICAtPiB7J3JlcXVlc3RzJzogW3sncmVxdWVzdCc6IHsnY29udGVudCc6IHYxfX0sIHsncmVxdWVzdCc6IHsnY29udGVudCc6IHYyfX1dfVxuICovXG5mdW5jdGlvbiBtb3ZlVmFsdWVCeVBhdGgoZGF0YSwgcGF0aHMpIHtcbiAgICBmb3IgKGNvbnN0IFtzb3VyY2VQYXRoLCBkZXN0UGF0aF0gb2YgT2JqZWN0LmVudHJpZXMocGF0aHMpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZUtleXMgPSBzb3VyY2VQYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIGNvbnN0IGRlc3RLZXlzID0gZGVzdFBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGtleXMgdG8gZXhjbHVkZSBmcm9tIHdpbGRjYXJkIHRvIGF2b2lkIGN5Y2xpYyByZWZlcmVuY2VzXG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVLZXlzID0gbmV3IFNldCgpO1xuICAgICAgICBsZXQgd2lsZGNhcmRJZHggPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlS2V5c1tpXSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgd2lsZGNhcmRJZHggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3aWxkY2FyZElkeCAhPT0gLTEgJiYgZGVzdEtleXMubGVuZ3RoID4gd2lsZGNhcmRJZHgpIHtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGludGVybWVkaWF0ZSBrZXkgYmV0d2VlbiBzb3VyY2UgYW5kIGRlc3QgcGF0aHNcbiAgICAgICAgICAgIC8vIEV4YW1wbGU6IHNvdXJjZT1bJ3JlcXVlc3RzW10nLCAnKiddLCBkZXN0PVsncmVxdWVzdHNbXScsICdyZXF1ZXN0JywgJyonXVxuICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBleGNsdWRlICdyZXF1ZXN0J1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHdpbGRjYXJkSWR4OyBpIDwgZGVzdEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBkZXN0S2V5c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnKicgJiYgIWtleS5lbmRzV2l0aCgnW10nKSAmJiAha2V5LmVuZHNXaXRoKCdbMF0nKSkge1xuICAgICAgICAgICAgICAgICAgICBleGNsdWRlS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX21vdmVWYWx1ZVJlY3Vyc2l2ZShkYXRhLCBzb3VyY2VLZXlzLCBkZXN0S2V5cywgMCwgZXhjbHVkZUtleXMpO1xuICAgIH1cbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgbW92ZXMgdmFsdWVzIGZyb20gc291cmNlIHBhdGggdG8gZGVzdGluYXRpb24gcGF0aC5cbiAqL1xuZnVuY3Rpb24gX21vdmVWYWx1ZVJlY3Vyc2l2ZShkYXRhLCBzb3VyY2VLZXlzLCBkZXN0S2V5cywga2V5SWR4LCBleGNsdWRlS2V5cykge1xuICAgIGlmIChrZXlJZHggPj0gc291cmNlS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnIHx8IGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBzb3VyY2VLZXlzW2tleUlkeF07XG4gICAgaWYgKGtleS5lbmRzV2l0aCgnW10nKSkge1xuICAgICAgICBjb25zdCBrZXlOYW1lID0ga2V5LnNsaWNlKDAsIC0yKTtcbiAgICAgICAgY29uc3QgZGF0YVJlY29yZCA9IGRhdGE7XG4gICAgICAgIGlmIChrZXlOYW1lIGluIGRhdGFSZWNvcmQgJiYgQXJyYXkuaXNBcnJheShkYXRhUmVjb3JkW2tleU5hbWVdKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGRhdGFSZWNvcmRba2V5TmFtZV0pIHtcbiAgICAgICAgICAgICAgICBfbW92ZVZhbHVlUmVjdXJzaXZlKGl0ZW0sIHNvdXJjZUtleXMsIGRlc3RLZXlzLCBrZXlJZHggKyAxLCBleGNsdWRlS2V5cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoa2V5ID09PSAnKicpIHtcbiAgICAgICAgLy8gd2lsZGNhcmQgLSBtb3ZlIGFsbCBmaWVsZHNcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBkYXRhICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhUmVjb3JkID0gZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IGtleXNUb01vdmUgPSBPYmplY3Qua2V5cyhkYXRhUmVjb3JkKS5maWx0ZXIoKGspID0+ICFrLnN0YXJ0c1dpdGgoJ18nKSAmJiAhZXhjbHVkZUtleXMuaGFzKGspKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlc1RvTW92ZSA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGtleXNUb01vdmUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNUb01vdmVba10gPSBkYXRhUmVjb3JkW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IHZhbHVlcyBhdCBkZXN0aW5hdGlvblxuICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModmFsdWVzVG9Nb3ZlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rlc3RLZXlzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkayBvZiBkZXN0S2V5cy5zbGljZShrZXlJZHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkayA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEZXN0S2V5cy5wdXNoKGspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGVzdEtleXMucHVzaChkayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgoZGF0YVJlY29yZCwgbmV3RGVzdEtleXMsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGtleXNUb01vdmUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YVJlY29yZFtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTmF2aWdhdGUgdG8gbmV4dCBsZXZlbFxuICAgICAgICBjb25zdCBkYXRhUmVjb3JkID0gZGF0YTtcbiAgICAgICAgaWYgKGtleSBpbiBkYXRhUmVjb3JkKSB7XG4gICAgICAgICAgICBfbW92ZVZhbHVlUmVjdXJzaXZlKGRhdGFSZWNvcmRba2V5XSwgc291cmNlS2V5cywgZGVzdEtleXMsIGtleUlkeCArIDEsIGV4Y2x1ZGVLZXlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gdEJ5dGVzJDEoZnJvbUJ5dGVzKSB7XG4gICAgaWYgKHR5cGVvZiBmcm9tQnl0ZXMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnJvbUltYWdlQnl0ZXMgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICAvLyBUT0RPKGIvMzg5MTMzOTE0KTogUmVtb3ZlIGR1bW15IGJ5dGVzIGNvbnZlcnRlci5cbiAgICByZXR1cm4gZnJvbUJ5dGVzO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgR29vZ2xlIEdlbiBBSSBTREsgZ2VuZXJhdG9yIERPIE5PVCBFRElULlxuZnVuY3Rpb24gZmV0Y2hQcmVkaWN0T3BlcmF0aW9uUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21PcGVyYXRpb25OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3BlcmF0aW9uTmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PcGVyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb3BlcmF0aW9uTmFtZSddLCBmcm9tT3BlcmF0aW9uTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNvdXJjZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc291cmNlTmFtZSddKTtcbiAgICBpZiAoZnJvbVJlc291cmNlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAncmVzb3VyY2VOYW1lJ10sIGZyb21SZXNvdXJjZU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2UnLFxuICAgICAgICAnZ2VuZXJhdGVWaWRlb1Jlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21NbGRldiQxKGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4JDEoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGVkU2FtcGxlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZFZpZGVvcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkVmlkZW9zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZENvdW50J10sIGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkUmVhc29ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJ10sIGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZFZpZGVvcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW9zJ10pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkVmlkZW9zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRWaWRlb3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkVmlkZW9Gcm9tVmVydGV4JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRWaWRlb3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkQ291bnQnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkVmlkZW9Gcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB2aWRlb0Zyb21NbGRldiQxKGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRWaWRlb0Zyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB2aWRlb0Zyb21WZXJ0ZXgkMShmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0T3BlcmF0aW9uUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU9wZXJhdGlvbk5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvcGVyYXRpb25OYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU9wZXJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ29wZXJhdGlvbk5hbWUnXSwgZnJvbU9wZXJhdGlvbk5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU9wZXJhdGlvbk5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvcGVyYXRpb25OYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU9wZXJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ29wZXJhdGlvbk5hbWUnXSwgZnJvbU9wZXJhdGlvbk5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbXBvcnRGaWxlT3BlcmF0aW9uRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBpbXBvcnRGaWxlUmVzcG9uc2VGcm9tTWxkZXYkMShmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1wb3J0RmlsZVJlc3BvbnNlRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmVudCddKTtcbiAgICBpZiAoZnJvbVBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmVudCddLCBmcm9tUGFyZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvY3VtZW50TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9jdW1lbnROYW1lJ10pO1xuICAgIGlmIChmcm9tRG9jdW1lbnROYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9jdW1lbnROYW1lJ10sIGZyb21Eb2N1bWVudE5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZU9wZXJhdGlvbkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzcG9uc2VGcm9tTWxkZXYoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmVudCddKTtcbiAgICBpZiAoZnJvbVBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmVudCddLCBmcm9tUGFyZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvY3VtZW50TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9jdW1lbnROYW1lJ10pO1xuICAgIGlmIChmcm9tRG9jdW1lbnROYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9jdW1lbnROYW1lJ10sIGZyb21Eb2N1bWVudE5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0Zyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuY29kZWRWaWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb0J5dGVzJ10sIHRCeXRlcyQxKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5jb2RpbmcnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvRnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdieXRlc0Jhc2U2NEVuY29kZWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9CeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSwgdEJ5dGVzJDEoZnJvbVZpZGVvQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKiogT3V0Y29tZSBvZiB0aGUgY29kZSBleGVjdXRpb24uICovXG52YXIgT3V0Y29tZTtcbihmdW5jdGlvbiAoT3V0Y29tZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIHN0YXR1cy4gVGhpcyB2YWx1ZSBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICovXG4gICAgT3V0Y29tZVtcIk9VVENPTUVfVU5TUEVDSUZJRURcIl0gPSBcIk9VVENPTUVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBDb2RlIGV4ZWN1dGlvbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAqL1xuICAgIE91dGNvbWVbXCJPVVRDT01FX09LXCJdID0gXCJPVVRDT01FX09LXCI7XG4gICAgLyoqXG4gICAgICogQ29kZSBleGVjdXRpb24gZmluaXNoZWQgYnV0IHdpdGggYSBmYWlsdXJlLiBgc3RkZXJyYCBzaG91bGQgY29udGFpbiB0aGUgcmVhc29uLlxuICAgICAqL1xuICAgIE91dGNvbWVbXCJPVVRDT01FX0ZBSUxFRFwiXSA9IFwiT1VUQ09NRV9GQUlMRURcIjtcbiAgICAvKipcbiAgICAgKiBDb2RlIGV4ZWN1dGlvbiByYW4gZm9yIHRvbyBsb25nLCBhbmQgd2FzIGNhbmNlbGxlZC4gVGhlcmUgbWF5IG9yIG1heSBub3QgYmUgYSBwYXJ0aWFsIG91dHB1dCBwcmVzZW50LlxuICAgICAqL1xuICAgIE91dGNvbWVbXCJPVVRDT01FX0RFQURMSU5FX0VYQ0VFREVEXCJdID0gXCJPVVRDT01FX0RFQURMSU5FX0VYQ0VFREVEXCI7XG59KShPdXRjb21lIHx8IChPdXRjb21lID0ge30pKTtcbi8qKiBQcm9ncmFtbWluZyBsYW5ndWFnZSBvZiB0aGUgYGNvZGVgLiAqL1xudmFyIExhbmd1YWdlO1xuKGZ1bmN0aW9uIChMYW5ndWFnZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIGxhbmd1YWdlLiBUaGlzIHZhbHVlIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBMYW5ndWFnZVtcIkxBTkdVQUdFX1VOU1BFQ0lGSUVEXCJdID0gXCJMQU5HVUFHRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFB5dGhvbiA+PSAzLjEwLCB3aXRoIG51bXB5IGFuZCBzaW1weSBhdmFpbGFibGUuXG4gICAgICovXG4gICAgTGFuZ3VhZ2VbXCJQWVRIT05cIl0gPSBcIlBZVEhPTlwiO1xufSkoTGFuZ3VhZ2UgfHwgKExhbmd1YWdlID0ge30pKTtcbi8qKiBTcGVjaWZpZXMgaG93IHRoZSByZXNwb25zZSBzaG91bGQgYmUgc2NoZWR1bGVkIGluIHRoZSBjb252ZXJzYXRpb24uICovXG52YXIgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmc7XG4oZnVuY3Rpb24gKEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmdbXCJTQ0hFRFVMSU5HX1VOU1BFQ0lGSUVEXCJdID0gXCJTQ0hFRFVMSU5HX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogT25seSBhZGQgdGhlIHJlc3VsdCB0byB0aGUgY29udmVyc2F0aW9uIGNvbnRleHQsIGRvIG5vdCBpbnRlcnJ1cHQgb3IgdHJpZ2dlciBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nW1wiU0lMRU5UXCJdID0gXCJTSUxFTlRcIjtcbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHJlc3VsdCB0byB0aGUgY29udmVyc2F0aW9uIGNvbnRleHQsIGFuZCBwcm9tcHQgdG8gZ2VuZXJhdGUgb3V0cHV0IHdpdGhvdXQgaW50ZXJydXB0aW5nIG9uZ29pbmcgZ2VuZXJhdGlvbi5cbiAgICAgKi9cbiAgICBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZ1tcIldIRU5fSURMRVwiXSA9IFwiV0hFTl9JRExFXCI7XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSByZXN1bHQgdG8gdGhlIGNvbnZlcnNhdGlvbiBjb250ZXh0LCBpbnRlcnJ1cHQgb25nb2luZyBnZW5lcmF0aW9uIGFuZCBwcm9tcHQgdG8gZ2VuZXJhdGUgb3V0cHV0LlxuICAgICAqL1xuICAgIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nW1wiSU5URVJSVVBUXCJdID0gXCJJTlRFUlJVUFRcIjtcbn0pKEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nIHx8IChGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZyA9IHt9KSk7XG4vKiogVGhlIHR5cGUgb2YgdGhlIGRhdGEuICovXG52YXIgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIC8qKlxuICAgICAqIE5vdCBzcGVjaWZpZWQsIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBUeXBlW1wiVFlQRV9VTlNQRUNJRklFRFwiXSA9IFwiVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgc3RyaW5nIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiU1RSSU5HXCJdID0gXCJTVFJJTkdcIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIG51bWJlciB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIk5VTUJFUlwiXSA9IFwiTlVNQkVSXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBpbnRlZ2VyIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiSU5URUdFUlwiXSA9IFwiSU5URUdFUlwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgYm9vbGVhbiB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIkJPT0xFQU5cIl0gPSBcIkJPT0xFQU5cIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIGFycmF5IHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiQVJSQVlcIl0gPSBcIkFSUkFZXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBvYmplY3QgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJPQkpFQ1RcIl0gPSBcIk9CSkVDVFwiO1xuICAgIC8qKlxuICAgICAqIE51bGwgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJOVUxMXCJdID0gXCJOVUxMXCI7XG59KShUeXBlIHx8IChUeXBlID0ge30pKTtcbi8qKiBUaGUgQVBJIHNwZWMgdGhhdCB0aGUgZXh0ZXJuYWwgQVBJIGltcGxlbWVudHMuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgQXBpU3BlYztcbihmdW5jdGlvbiAoQXBpU3BlYykge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIEFQSSBzcGVjLiBUaGlzIHZhbHVlIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBBcGlTcGVjW1wiQVBJX1NQRUNfVU5TUEVDSUZJRURcIl0gPSBcIkFQSV9TUEVDX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogU2ltcGxlIHNlYXJjaCBBUEkgc3BlYy5cbiAgICAgKi9cbiAgICBBcGlTcGVjW1wiU0lNUExFX1NFQVJDSFwiXSA9IFwiU0lNUExFX1NFQVJDSFwiO1xuICAgIC8qKlxuICAgICAqIEVsYXN0aWMgc2VhcmNoIEFQSSBzcGVjLlxuICAgICAqL1xuICAgIEFwaVNwZWNbXCJFTEFTVElDX1NFQVJDSFwiXSA9IFwiRUxBU1RJQ19TRUFSQ0hcIjtcbn0pKEFwaVNwZWMgfHwgKEFwaVNwZWMgPSB7fSkpO1xuLyoqIFR5cGUgb2YgYXV0aCBzY2hlbWUuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgQXV0aFR5cGU7XG4oZnVuY3Rpb24gKEF1dGhUeXBlKSB7XG4gICAgQXV0aFR5cGVbXCJBVVRIX1RZUEVfVU5TUEVDSUZJRURcIl0gPSBcIkFVVEhfVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE5vIEF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJOT19BVVRIXCJdID0gXCJOT19BVVRIXCI7XG4gICAgLyoqXG4gICAgICogQVBJIEtleSBBdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiQVBJX0tFWV9BVVRIXCJdID0gXCJBUElfS0VZX0FVVEhcIjtcbiAgICAvKipcbiAgICAgKiBIVFRQIEJhc2ljIEF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJIVFRQX0JBU0lDX0FVVEhcIl0gPSBcIkhUVFBfQkFTSUNfQVVUSFwiO1xuICAgIC8qKlxuICAgICAqIEdvb2dsZSBTZXJ2aWNlIEFjY291bnQgQXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIkdPT0dMRV9TRVJWSUNFX0FDQ09VTlRfQVVUSFwiXSA9IFwiR09PR0xFX1NFUlZJQ0VfQUNDT1VOVF9BVVRIXCI7XG4gICAgLyoqXG4gICAgICogT0F1dGggYXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIk9BVVRIXCJdID0gXCJPQVVUSFwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5JRCBDb25uZWN0IChPSURDKSBBdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiT0lEQ19BVVRIXCJdID0gXCJPSURDX0FVVEhcIjtcbn0pKEF1dGhUeXBlIHx8IChBdXRoVHlwZSA9IHt9KSk7XG4vKiogVGhlIGxvY2F0aW9uIG9mIHRoZSBBUEkga2V5LiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIEh0dHBFbGVtZW50TG9jYXRpb247XG4oZnVuY3Rpb24gKEh0dHBFbGVtZW50TG9jYXRpb24pIHtcbiAgICBIdHRwRWxlbWVudExvY2F0aW9uW1wiSFRUUF9JTl9VTlNQRUNJRklFRFwiXSA9IFwiSFRUUF9JTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgaXMgaW4gdGhlIEhUVFAgcmVxdWVzdCBxdWVyeS5cbiAgICAgKi9cbiAgICBIdHRwRWxlbWVudExvY2F0aW9uW1wiSFRUUF9JTl9RVUVSWVwiXSA9IFwiSFRUUF9JTl9RVUVSWVwiO1xuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgaXMgaW4gdGhlIEhUVFAgcmVxdWVzdCBoZWFkZXIuXG4gICAgICovXG4gICAgSHR0cEVsZW1lbnRMb2NhdGlvbltcIkhUVFBfSU5fSEVBREVSXCJdID0gXCJIVFRQX0lOX0hFQURFUlwiO1xuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgaXMgaW4gdGhlIEhUVFAgcmVxdWVzdCBwYXRoLlxuICAgICAqL1xuICAgIEh0dHBFbGVtZW50TG9jYXRpb25bXCJIVFRQX0lOX1BBVEhcIl0gPSBcIkhUVFBfSU5fUEFUSFwiO1xuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgaXMgaW4gdGhlIEhUVFAgcmVxdWVzdCBib2R5LlxuICAgICAqL1xuICAgIEh0dHBFbGVtZW50TG9jYXRpb25bXCJIVFRQX0lOX0JPRFlcIl0gPSBcIkhUVFBfSU5fQk9EWVwiO1xuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgaXMgaW4gdGhlIEhUVFAgcmVxdWVzdCBjb29raWUuXG4gICAgICovXG4gICAgSHR0cEVsZW1lbnRMb2NhdGlvbltcIkhUVFBfSU5fQ09PS0lFXCJdID0gXCJIVFRQX0lOX0NPT0tJRVwiO1xufSkoSHR0cEVsZW1lbnRMb2NhdGlvbiB8fCAoSHR0cEVsZW1lbnRMb2NhdGlvbiA9IHt9KSk7XG4vKiogU2l0ZXMgd2l0aCBjb25maWRlbmNlIGxldmVsIGNob3NlbiAmIGFib3ZlIHRoaXMgdmFsdWUgd2lsbCBiZSBibG9ja2VkIGZyb20gdGhlIHNlYXJjaCByZXN1bHRzLiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIFBoaXNoQmxvY2tUaHJlc2hvbGQ7XG4oZnVuY3Rpb24gKFBoaXNoQmxvY2tUaHJlc2hvbGQpIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0cyB0byB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBQaGlzaEJsb2NrVGhyZXNob2xkW1wiUEhJU0hfQkxPQ0tfVEhSRVNIT0xEX1VOU1BFQ0lGSUVEXCJdID0gXCJQSElTSF9CTE9DS19USFJFU0hPTERfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBCbG9ja3MgTG93IGFuZCBhYm92ZSBjb25maWRlbmNlIFVSTCB0aGF0IGlzIHJpc2t5LlxuICAgICAqL1xuICAgIFBoaXNoQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2tzIE1lZGl1bSBhbmQgYWJvdmUgY29uZmlkZW5jZSBVUkwgdGhhdCBpcyByaXNreS5cbiAgICAgKi9cbiAgICBQaGlzaEJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrcyBIaWdoIGFuZCBhYm92ZSBjb25maWRlbmNlIFVSTCB0aGF0IGlzIHJpc2t5LlxuICAgICAqL1xuICAgIFBoaXNoQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19ISUdIX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfSElHSF9BTkRfQUJPVkVcIjtcbiAgICAvKipcbiAgICAgKiBCbG9ja3MgSGlnaGVyIGFuZCBhYm92ZSBjb25maWRlbmNlIFVSTCB0aGF0IGlzIHJpc2t5LlxuICAgICAqL1xuICAgIFBoaXNoQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19ISUdIRVJfQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19ISUdIRVJfQU5EX0FCT1ZFXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2tzIFZlcnkgaGlnaCBhbmQgYWJvdmUgY29uZmlkZW5jZSBVUkwgdGhhdCBpcyByaXNreS5cbiAgICAgKi9cbiAgICBQaGlzaEJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfVkVSWV9ISUdIX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfVkVSWV9ISUdIX0FORF9BQk9WRVwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrcyBFeHRyZW1lbHkgaGlnaCBjb25maWRlbmNlIFVSTCB0aGF0IGlzIHJpc2t5LlxuICAgICAqL1xuICAgIFBoaXNoQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19PTkxZX0VYVFJFTUVMWV9ISUdIXCJdID0gXCJCTE9DS19PTkxZX0VYVFJFTUVMWV9ISUdIXCI7XG59KShQaGlzaEJsb2NrVGhyZXNob2xkIHx8IChQaGlzaEJsb2NrVGhyZXNob2xkID0ge30pKTtcbi8qKiBTcGVjaWZpZXMgdGhlIGZ1bmN0aW9uIEJlaGF2aW9yLiBDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEJpZGlHZW5lcmF0ZUNvbnRlbnQgbWV0aG9kLiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuICovXG52YXIgQmVoYXZpb3I7XG4oZnVuY3Rpb24gKEJlaGF2aW9yKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgQmVoYXZpb3JbXCJVTlNQRUNJRklFRFwiXSA9IFwiVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBJZiBzZXQsIHRoZSBzeXN0ZW0gd2lsbCB3YWl0IHRvIHJlY2VpdmUgdGhlIGZ1bmN0aW9uIHJlc3BvbnNlIGJlZm9yZSBjb250aW51aW5nIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICovXG4gICAgQmVoYXZpb3JbXCJCTE9DS0lOR1wiXSA9IFwiQkxPQ0tJTkdcIjtcbiAgICAvKipcbiAgICAgKiBJZiBzZXQsIHRoZSBzeXN0ZW0gd2lsbCBub3Qgd2FpdCB0byByZWNlaXZlIHRoZSBmdW5jdGlvbiByZXNwb25zZS4gSW5zdGVhZCwgaXQgd2lsbCBhdHRlbXB0IHRvIGhhbmRsZSBmdW5jdGlvbiByZXNwb25zZXMgYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlIHdoaWxlIG1haW50YWluaW5nIHRoZSBjb252ZXJzYXRpb24gYmV0d2VlbiB0aGUgdXNlciBhbmQgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIEJlaGF2aW9yW1wiTk9OX0JMT0NLSU5HXCJdID0gXCJOT05fQkxPQ0tJTkdcIjtcbn0pKEJlaGF2aW9yIHx8IChCZWhhdmlvciA9IHt9KSk7XG4vKiogVGhlIG1vZGUgb2YgdGhlIHByZWRpY3RvciB0byBiZSB1c2VkIGluIGR5bmFtaWMgcmV0cmlldmFsLiAqL1xudmFyIER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlO1xuKGZ1bmN0aW9uIChEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZSkge1xuICAgIC8qKlxuICAgICAqIEFsd2F5cyB0cmlnZ2VyIHJldHJpZXZhbC5cbiAgICAgKi9cbiAgICBEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZVtcIk1PREVfVU5TUEVDSUZJRURcIl0gPSBcIk1PREVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBSdW4gcmV0cmlldmFsIG9ubHkgd2hlbiBzeXN0ZW0gZGVjaWRlcyBpdCBpcyBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGVbXCJNT0RFX0RZTkFNSUNcIl0gPSBcIk1PREVfRFlOQU1JQ1wiO1xufSkoRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGUgfHwgKER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlID0ge30pKTtcbi8qKiBGdW5jdGlvbiBjYWxsaW5nIG1vZGUuICovXG52YXIgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZTtcbihmdW5jdGlvbiAoRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIGZ1bmN0aW9uIGNhbGxpbmcgbW9kZS4gVGhpcyB2YWx1ZSBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICovXG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIk1PREVfVU5TUEVDSUZJRURcIl0gPSBcIk1PREVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IG1vZGVsIGJlaGF2aW9yLCBtb2RlbCBkZWNpZGVzIHRvIHByZWRpY3QgZWl0aGVyIGZ1bmN0aW9uIGNhbGxzIG9yIG5hdHVyYWwgbGFuZ3VhZ2UgcmVzcG9uc2UuXG4gICAgICovXG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIkFVVE9cIl0gPSBcIkFVVE9cIjtcbiAgICAvKipcbiAgICAgKiBNb2RlbCBpcyBjb25zdHJhaW5lZCB0byBhbHdheXMgcHJlZGljdGluZyBmdW5jdGlvbiBjYWxscyBvbmx5LiBJZiBcImFsbG93ZWRfZnVuY3Rpb25fbmFtZXNcIiBhcmUgc2V0LCB0aGUgcHJlZGljdGVkIGZ1bmN0aW9uIGNhbGxzIHdpbGwgYmUgbGltaXRlZCB0byBhbnkgb25lIG9mIFwiYWxsb3dlZF9mdW5jdGlvbl9uYW1lc1wiLCBlbHNlIHRoZSBwcmVkaWN0ZWQgZnVuY3Rpb24gY2FsbHMgd2lsbCBiZSBhbnkgb25lIG9mIHRoZSBwcm92aWRlZCBcImZ1bmN0aW9uX2RlY2xhcmF0aW9uc1wiLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGVbXCJBTllcIl0gPSBcIkFOWVwiO1xuICAgIC8qKlxuICAgICAqIE1vZGVsIHdpbGwgbm90IHByZWRpY3QgYW55IGZ1bmN0aW9uIGNhbGxzLiBNb2RlbCBiZWhhdmlvciBpcyBzYW1lIGFzIHdoZW4gbm90IHBhc3NpbmcgYW55IGZ1bmN0aW9uIGRlY2xhcmF0aW9ucy5cbiAgICAgKi9cbiAgICBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlW1wiTk9ORVwiXSA9IFwiTk9ORVwiO1xuICAgIC8qKlxuICAgICAqIE1vZGVsIGlzIGNvbnN0cmFpbmVkIHRvIHByZWRpY3QgZWl0aGVyIGZ1bmN0aW9uIGNhbGxzIG9yIG5hdHVyYWwgbGFuZ3VhZ2UgcmVzcG9uc2UuIElmIFwiYWxsb3dlZF9mdW5jdGlvbl9uYW1lc1wiIGFyZSBzZXQsIHRoZSBwcmVkaWN0ZWQgZnVuY3Rpb24gY2FsbHMgd2lsbCBiZSBsaW1pdGVkIHRvIGFueSBvbmUgb2YgXCJhbGxvd2VkX2Z1bmN0aW9uX25hbWVzXCIsIGVsc2UgdGhlIHByZWRpY3RlZCBmdW5jdGlvbiBjYWxscyB3aWxsIGJlIGFueSBvbmUgb2YgdGhlIHByb3ZpZGVkIFwiZnVuY3Rpb25fZGVjbGFyYXRpb25zXCIuXG4gICAgICovXG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIlZBTElEQVRFRFwiXSA9IFwiVkFMSURBVEVEXCI7XG59KShGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlIHx8IChGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlID0ge30pKTtcbi8qKiBUaGUgbnVtYmVyIG9mIHRob3VnaHRzIHRva2VucyB0aGF0IHRoZSBtb2RlbCBzaG91bGQgZ2VuZXJhdGUuICovXG52YXIgVGhpbmtpbmdMZXZlbDtcbihmdW5jdGlvbiAoVGhpbmtpbmdMZXZlbCkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIHRoaW5raW5nIGxldmVsLlxuICAgICAqL1xuICAgIFRoaW5raW5nTGV2ZWxbXCJUSElOS0lOR19MRVZFTF9VTlNQRUNJRklFRFwiXSA9IFwiVEhJTktJTkdfTEVWRUxfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBMb3cgdGhpbmtpbmcgbGV2ZWwuXG4gICAgICovXG4gICAgVGhpbmtpbmdMZXZlbFtcIkxPV1wiXSA9IFwiTE9XXCI7XG4gICAgLyoqXG4gICAgICogTWVkaXVtIHRoaW5raW5nIGxldmVsLlxuICAgICAqL1xuICAgIFRoaW5raW5nTGV2ZWxbXCJNRURJVU1cIl0gPSBcIk1FRElVTVwiO1xuICAgIC8qKlxuICAgICAqIEhpZ2ggdGhpbmtpbmcgbGV2ZWwuXG4gICAgICovXG4gICAgVGhpbmtpbmdMZXZlbFtcIkhJR0hcIl0gPSBcIkhJR0hcIjtcbiAgICAvKipcbiAgICAgKiBNSU5JTUFMIHRoaW5raW5nIGxldmVsLlxuICAgICAqL1xuICAgIFRoaW5raW5nTGV2ZWxbXCJNSU5JTUFMXCJdID0gXCJNSU5JTUFMXCI7XG59KShUaGlua2luZ0xldmVsIHx8IChUaGlua2luZ0xldmVsID0ge30pKTtcbi8qKiBIYXJtIGNhdGVnb3J5LiAqL1xudmFyIEhhcm1DYXRlZ29yeTtcbihmdW5jdGlvbiAoSGFybUNhdGVnb3J5KSB7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9DQVRFR09SWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGhhcmFzc21lbnQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9IQVJBU1NNRU5UXCJdID0gXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBoYXRlIHNwZWVjaC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0hBVEVfU1BFRUNIXCJdID0gXCJIQVJNX0NBVEVHT1JZX0hBVEVfU1BFRUNIXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgc2V4dWFsbHkgZXhwbGljaXQgY29udGVudC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX1NFWFVBTExZX0VYUExJQ0lUXCJdID0gXCJIQVJNX0NBVEVHT1JZX1NFWFVBTExZX0VYUExJQ0lUXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgZGFuZ2Vyb3VzIGNvbnRlbnQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9EQU5HRVJPVVNfQ09OVEVOVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9EQU5HRVJPVVNfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIERlcHJlY2F0ZWQ6IEVsZWN0aW9uIGZpbHRlciBpcyBub3QgbG9uZ2VyIHN1cHBvcnRlZC4gVGhlIGhhcm0gY2F0ZWdvcnkgaXMgY2l2aWMgaW50ZWdyaXR5LlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfQ0lWSUNfSU5URUdSSVRZXCJdID0gXCJIQVJNX0NBVEVHT1JZX0NJVklDX0lOVEVHUklUWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGltYWdlIGhhdGUuIFRoaXMgZW51bSB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9JTUFHRV9IQVRFXCJdID0gXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0hBVEVcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBpbWFnZSBkYW5nZXJvdXMgY29udGVudC4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0RBTkdFUk9VU19DT05URU5UXCJdID0gXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0RBTkdFUk9VU19DT05URU5UXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgaW1hZ2UgaGFyYXNzbWVudC4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0hBUkFTU01FTlRcIl0gPSBcIkhBUk1fQ0FURUdPUllfSU1BR0VfSEFSQVNTTUVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGltYWdlIHNleHVhbGx5IGV4cGxpY2l0IGNvbnRlbnQuIFRoaXMgZW51bSB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9JTUFHRV9TRVhVQUxMWV9FWFBMSUNJVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9JTUFHRV9TRVhVQUxMWV9FWFBMSUNJVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGZvciBqYWlsYnJlYWsgcHJvbXB0cy4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0pBSUxCUkVBS1wiXSA9IFwiSEFSTV9DQVRFR09SWV9KQUlMQlJFQUtcIjtcbn0pKEhhcm1DYXRlZ29yeSB8fCAoSGFybUNhdGVnb3J5ID0ge30pKTtcbi8qKiBTcGVjaWZ5IGlmIHRoZSB0aHJlc2hvbGQgaXMgdXNlZCBmb3IgcHJvYmFiaWxpdHkgb3Igc2V2ZXJpdHkgc2NvcmUuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aHJlc2hvbGQgaXMgdXNlZCBmb3IgcHJvYmFiaWxpdHkgc2NvcmUuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgSGFybUJsb2NrTWV0aG9kO1xuKGZ1bmN0aW9uIChIYXJtQmxvY2tNZXRob2QpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBibG9jayBtZXRob2QgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSGFybUJsb2NrTWV0aG9kW1wiSEFSTV9CTE9DS19NRVRIT0RfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fQkxPQ0tfTUVUSE9EX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gYmxvY2sgbWV0aG9kIHVzZXMgYm90aCBwcm9iYWJpbGl0eSBhbmQgc2V2ZXJpdHkgc2NvcmVzLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja01ldGhvZFtcIlNFVkVSSVRZXCJdID0gXCJTRVZFUklUWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGJsb2NrIG1ldGhvZCB1c2VzIHRoZSBwcm9iYWJpbGl0eSBzY29yZS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tNZXRob2RbXCJQUk9CQUJJTElUWVwiXSA9IFwiUFJPQkFCSUxJVFlcIjtcbn0pKEhhcm1CbG9ja01ldGhvZCB8fCAoSGFybUJsb2NrTWV0aG9kID0ge30pKTtcbi8qKiBUaGUgaGFybSBibG9jayB0aHJlc2hvbGQuICovXG52YXIgSGFybUJsb2NrVGhyZXNob2xkO1xuKGZ1bmN0aW9uIChIYXJtQmxvY2tUaHJlc2hvbGQpIHtcbiAgICAvKipcbiAgICAgKiBVbnNwZWNpZmllZCBoYXJtIGJsb2NrIHRocmVzaG9sZC5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJIQVJNX0JMT0NLX1RIUkVTSE9MRF9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9CTE9DS19USFJFU0hPTERfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBCbG9jayBsb3cgdGhyZXNob2xkIGFuZCBhYm92ZSAoaS5lLiBibG9jayBtb3JlKS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2sgbWVkaXVtIHRocmVzaG9sZCBhbmQgYWJvdmUuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrIG9ubHkgaGlnaCB0aHJlc2hvbGQgKGkuZS4gYmxvY2sgbGVzcykuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfT05MWV9ISUdIXCJdID0gXCJCTE9DS19PTkxZX0hJR0hcIjtcbiAgICAvKipcbiAgICAgKiBCbG9jayBub25lLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkJMT0NLX05PTkVcIl0gPSBcIkJMT0NLX05PTkVcIjtcbiAgICAvKipcbiAgICAgKiBUdXJuIG9mZiB0aGUgc2FmZXR5IGZpbHRlci5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJPRkZcIl0gPSBcIk9GRlwiO1xufSkoSGFybUJsb2NrVGhyZXNob2xkIHx8IChIYXJtQmxvY2tUaHJlc2hvbGQgPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBUaGUgcmVhc29uIHdoeSB0aGUgbW9kZWwgc3RvcHBlZCBnZW5lcmF0aW5nIHRva2Vucy5cblxuSWYgZW1wdHksIHRoZSBtb2RlbCBoYXMgbm90IHN0b3BwZWQgZ2VuZXJhdGluZyB0aGUgdG9rZW5zLiAqL1xudmFyIEZpbmlzaFJlYXNvbjtcbihmdW5jdGlvbiAoRmluaXNoUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbmlzaCByZWFzb24gaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiRklOSVNIX1JFQVNPTl9VTlNQRUNJRklFRFwiXSA9IFwiRklOSVNIX1JFQVNPTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gcmVhY2hlZCBhIG5hdHVyYWwgc3RvcHBpbmcgcG9pbnQgb3IgYSBjb25maWd1cmVkIHN0b3Agc2VxdWVuY2UuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiU1RPUFwiXSA9IFwiU1RPUFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gcmVhY2hlZCB0aGUgY29uZmlndXJlZCBtYXhpbXVtIG91dHB1dCB0b2tlbnMuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiTUFYX1RPS0VOU1wiXSA9IFwiTUFYX1RPS0VOU1wiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIHRoZSBjb250ZW50IHBvdGVudGlhbGx5IGNvbnRhaW5zIHNhZmV0eSB2aW9sYXRpb25zLiBOT1RFOiBXaGVuIHN0cmVhbWluZywgW2NvbnRlbnRdW10gaXMgZW1wdHkgaWYgY29udGVudCBmaWx0ZXJzIGJsb2NrcyB0aGUgb3V0cHV0LlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIlNBRkVUWVwiXSA9IFwiU0FGRVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIG9mIHBvdGVudGlhbCByZWNpdGF0aW9uLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIlJFQ0lUQVRJT05cIl0gPSBcIlJFQ0lUQVRJT05cIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2Ugb2YgdXNpbmcgYW4gdW5zdXBwb3J0ZWQgbGFuZ3VhZ2UuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiTEFOR1VBR0VcIl0gPSBcIkxBTkdVQUdFXCI7XG4gICAgLyoqXG4gICAgICogQWxsIG90aGVyIHJlYXNvbnMgdGhhdCBzdG9wcGVkIHRoZSB0b2tlbiBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIk9USEVSXCJdID0gXCJPVEhFUlwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIHRoZSBjb250ZW50IGNvbnRhaW5zIGZvcmJpZGRlbiB0ZXJtcy5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJCTE9DS0xJU1RcIl0gPSBcIkJMT0NLTElTVFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBmb3IgcG90ZW50aWFsbHkgY29udGFpbmluZyBwcm9oaWJpdGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiUFJPSElCSVRFRF9DT05URU5UXCJdID0gXCJQUk9ISUJJVEVEX0NPTlRFTlRcIjtcbiAgICAvKipcbiAgICAgKiBUb2tlbiBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSB0aGUgY29udGVudCBwb3RlbnRpYWxseSBjb250YWlucyBTZW5zaXRpdmUgUGVyc29uYWxseSBJZGVudGlmaWFibGUgSW5mb3JtYXRpb24gKFNQSUkpLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIlNQSUlcIl0gPSBcIlNQSUlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbCBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiTUFMRk9STUVEX0ZVTkNUSU9OX0NBTExcIl0gPSBcIk1BTEZPUk1FRF9GVU5DVElPTl9DQUxMXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2UgZ2VuZXJhdGVkIGltYWdlcyBoYXZlIHNhZmV0eSB2aW9sYXRpb25zLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIklNQUdFX1NBRkVUWVwiXSA9IFwiSU1BR0VfU0FGRVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHRvb2wgY2FsbCBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiVU5FWFBFQ1RFRF9UT09MX0NBTExcIl0gPSBcIlVORVhQRUNURURfVE9PTF9DQUxMXCI7XG4gICAgLyoqXG4gICAgICogSW1hZ2UgZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2UgdGhlIGdlbmVyYXRlZCBpbWFnZXMgaGF2ZSBwcm9oaWJpdGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiSU1BR0VfUFJPSElCSVRFRF9DT05URU5UXCJdID0gXCJJTUFHRV9QUk9ISUJJVEVEX0NPTlRFTlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwgd2FzIGV4cGVjdGVkIHRvIGdlbmVyYXRlIGFuIGltYWdlLCBidXQgbm9uZSB3YXMgZ2VuZXJhdGVkLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIk5PX0lNQUdFXCJdID0gXCJOT19JTUFHRVwiO1xuICAgIC8qKlxuICAgICAqIEltYWdlIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIHRoZSBnZW5lcmF0ZWQgaW1hZ2UgbWF5IGJlIGEgcmVjaXRhdGlvbiBmcm9tIGEgc291cmNlLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIklNQUdFX1JFQ0lUQVRJT05cIl0gPSBcIklNQUdFX1JFQ0lUQVRJT05cIjtcbiAgICAvKipcbiAgICAgKiBJbWFnZSBnZW5lcmF0aW9uIHN0b3BwZWQgZm9yIGEgcmVhc29uIG5vdCBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIklNQUdFX09USEVSXCJdID0gXCJJTUFHRV9PVEhFUlwiO1xufSkoRmluaXNoUmVhc29uIHx8IChGaW5pc2hSZWFzb24gPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBIYXJtIHByb2JhYmlsaXR5IGxldmVscyBpbiB0aGUgY29udGVudC4gKi9cbnZhciBIYXJtUHJvYmFiaWxpdHk7XG4oZnVuY3Rpb24gKEhhcm1Qcm9iYWJpbGl0eSkge1xuICAgIC8qKlxuICAgICAqIEhhcm0gcHJvYmFiaWxpdHkgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSGFybVByb2JhYmlsaXR5W1wiSEFSTV9QUk9CQUJJTElUWV9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9QUk9CQUJJTElUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE5lZ2xpZ2libGUgbGV2ZWwgb2YgaGFybS5cbiAgICAgKi9cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJORUdMSUdJQkxFXCJdID0gXCJORUdMSUdJQkxFXCI7XG4gICAgLyoqXG4gICAgICogTG93IGxldmVsIG9mIGhhcm0uXG4gICAgICovXG4gICAgSGFybVByb2JhYmlsaXR5W1wiTE9XXCJdID0gXCJMT1dcIjtcbiAgICAvKipcbiAgICAgKiBNZWRpdW0gbGV2ZWwgb2YgaGFybS5cbiAgICAgKi9cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJNRURJVU1cIl0gPSBcIk1FRElVTVwiO1xuICAgIC8qKlxuICAgICAqIEhpZ2ggbGV2ZWwgb2YgaGFybS5cbiAgICAgKi9cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJISUdIXCJdID0gXCJISUdIXCI7XG59KShIYXJtUHJvYmFiaWxpdHkgfHwgKEhhcm1Qcm9iYWJpbGl0eSA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIEhhcm0gc2V2ZXJpdHkgbGV2ZWxzIGluIHRoZSBjb250ZW50LiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIEhhcm1TZXZlcml0eTtcbihmdW5jdGlvbiAoSGFybVNldmVyaXR5KSB7XG4gICAgLyoqXG4gICAgICogSGFybSBzZXZlcml0eSB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBIYXJtU2V2ZXJpdHlbXCJIQVJNX1NFVkVSSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJIQVJNX1NFVkVSSVRZX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogTmVnbGlnaWJsZSBsZXZlbCBvZiBoYXJtIHNldmVyaXR5LlxuICAgICAqL1xuICAgIEhhcm1TZXZlcml0eVtcIkhBUk1fU0VWRVJJVFlfTkVHTElHSUJMRVwiXSA9IFwiSEFSTV9TRVZFUklUWV9ORUdMSUdJQkxFXCI7XG4gICAgLyoqXG4gICAgICogTG93IGxldmVsIG9mIGhhcm0gc2V2ZXJpdHkuXG4gICAgICovXG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9MT1dcIl0gPSBcIkhBUk1fU0VWRVJJVFlfTE9XXCI7XG4gICAgLyoqXG4gICAgICogTWVkaXVtIGxldmVsIG9mIGhhcm0gc2V2ZXJpdHkuXG4gICAgICovXG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9NRURJVU1cIl0gPSBcIkhBUk1fU0VWRVJJVFlfTUVESVVNXCI7XG4gICAgLyoqXG4gICAgICogSGlnaCBsZXZlbCBvZiBoYXJtIHNldmVyaXR5LlxuICAgICAqL1xuICAgIEhhcm1TZXZlcml0eVtcIkhBUk1fU0VWRVJJVFlfSElHSFwiXSA9IFwiSEFSTV9TRVZFUklUWV9ISUdIXCI7XG59KShIYXJtU2V2ZXJpdHkgfHwgKEhhcm1TZXZlcml0eSA9IHt9KSk7XG4vKiogU3RhdHVzIG9mIHRoZSB1cmwgcmV0cmlldmFsLiAqL1xudmFyIFVybFJldHJpZXZhbFN0YXR1cztcbihmdW5jdGlvbiAoVXJsUmV0cmlldmFsU3RhdHVzKSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB2YWx1ZS4gVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgVXJsUmV0cmlldmFsU3RhdHVzW1wiVVJMX1JFVFJJRVZBTF9TVEFUVVNfVU5TUEVDSUZJRURcIl0gPSBcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVXJsIHJldHJpZXZhbCBpcyBzdWNjZXNzZnVsLlxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1NVQ0NFU1NcIl0gPSBcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1NVQ0NFU1NcIjtcbiAgICAvKipcbiAgICAgKiBVcmwgcmV0cmlldmFsIGlzIGZhaWxlZCBkdWUgdG8gZXJyb3IuXG4gICAgICovXG4gICAgVXJsUmV0cmlldmFsU3RhdHVzW1wiVVJMX1JFVFJJRVZBTF9TVEFUVVNfRVJST1JcIl0gPSBcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX0VSUk9SXCI7XG4gICAgLyoqXG4gICAgICogVXJsIHJldHJpZXZhbCBpcyBmYWlsZWQgYmVjYXVzZSB0aGUgY29udGVudCBpcyBiZWhpbmQgcGF5d2FsbC4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLlxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1BBWVdBTExcIl0gPSBcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1BBWVdBTExcIjtcbiAgICAvKipcbiAgICAgKiBVcmwgcmV0cmlldmFsIGlzIGZhaWxlZCBiZWNhdXNlIHRoZSBjb250ZW50IGlzIHVuc2FmZS4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLlxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1VOU0FGRVwiXSA9IFwiVVJMX1JFVFJJRVZBTF9TVEFUVVNfVU5TQUZFXCI7XG59KShVcmxSZXRyaWV2YWxTdGF0dXMgfHwgKFVybFJldHJpZXZhbFN0YXR1cyA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIFRoZSByZWFzb24gd2h5IHRoZSBwcm9tcHQgd2FzIGJsb2NrZWQuICovXG52YXIgQmxvY2tlZFJlYXNvbjtcbihmdW5jdGlvbiAoQmxvY2tlZFJlYXNvbikge1xuICAgIC8qKlxuICAgICAqIFRoZSBibG9ja2VkIHJlYXNvbiBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiQkxPQ0tFRF9SRUFTT05fVU5TUEVDSUZJRURcIl0gPSBcIkJMT0NLRURfUkVBU09OX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHByb21wdCB3YXMgYmxvY2tlZCBmb3Igc2FmZXR5IHJlYXNvbnMuXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIlNBRkVUWVwiXSA9IFwiU0FGRVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHByb21wdCB3YXMgYmxvY2tlZCBmb3Igb3RoZXIgcmVhc29ucy4gRm9yIGV4YW1wbGUsIGl0IG1heSBiZSBkdWUgdG8gdGhlIHByb21wdCdzIGxhbmd1YWdlLCBvciBiZWNhdXNlIGl0IGNvbnRhaW5zIG90aGVyIGhhcm1mdWwgY29udGVudC5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiT1RIRVJcIl0gPSBcIk9USEVSXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHByb21wdCB3YXMgYmxvY2tlZCBiZWNhdXNlIGl0IGNvbnRhaW5zIGEgdGVybSBmcm9tIHRoZSB0ZXJtaW5vbG9neSBibG9ja2xpc3QuXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIkJMT0NLTElTVFwiXSA9IFwiQkxPQ0tMSVNUXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHByb21wdCB3YXMgYmxvY2tlZCBiZWNhdXNlIGl0IGNvbnRhaW5zIHByb2hpYml0ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiUFJPSElCSVRFRF9DT05URU5UXCJdID0gXCJQUk9ISUJJVEVEX0NPTlRFTlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvbXB0IHdhcyBibG9ja2VkIGJlY2F1c2UgaXQgY29udGFpbnMgY29udGVudCB0aGF0IGlzIHVuc2FmZSBmb3IgaW1hZ2UgZ2VuZXJhdGlvbi5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiSU1BR0VfU0FGRVRZXCJdID0gXCJJTUFHRV9TQUZFVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvbXB0IHdhcyBibG9ja2VkIGJ5IE1vZGVsIEFybW9yLiBUaGlzIGVudW0gdmFsdWUgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJNT0RFTF9BUk1PUlwiXSA9IFwiTU9ERUxfQVJNT1JcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvbXB0IHdhcyBibG9ja2VkIGFzIGEgamFpbGJyZWFrIGF0dGVtcHQuIFRoaXMgZW51bSB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIkpBSUxCUkVBS1wiXSA9IFwiSkFJTEJSRUFLXCI7XG59KShCbG9ja2VkUmVhc29uIHx8IChCbG9ja2VkUmVhc29uID0ge30pKTtcbi8qKiBPdXRwdXQgb25seS4gVGhlIHRyYWZmaWMgdHlwZSBmb3IgdGhpcyByZXF1ZXN0LiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIFRyYWZmaWNUeXBlO1xuKGZ1bmN0aW9uIChUcmFmZmljVHlwZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIHJlcXVlc3QgdHJhZmZpYyB0eXBlLlxuICAgICAqL1xuICAgIFRyYWZmaWNUeXBlW1wiVFJBRkZJQ19UWVBFX1VOU1BFQ0lGSUVEXCJdID0gXCJUUkFGRklDX1RZUEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVxdWVzdCB3YXMgcHJvY2Vzc2VkIHVzaW5nIFBheS1Bcy1Zb3UtR28gcXVvdGEuXG4gICAgICovXG4gICAgVHJhZmZpY1R5cGVbXCJPTl9ERU1BTkRcIl0gPSBcIk9OX0RFTUFORFwiO1xuICAgIC8qKlxuICAgICAqIFR5cGUgZm9yIFByb3Zpc2lvbmVkIFRocm91Z2hwdXQgdHJhZmZpYy5cbiAgICAgKi9cbiAgICBUcmFmZmljVHlwZVtcIlBST1ZJU0lPTkVEX1RIUk9VR0hQVVRcIl0gPSBcIlBST1ZJU0lPTkVEX1RIUk9VR0hQVVRcIjtcbn0pKFRyYWZmaWNUeXBlIHx8IChUcmFmZmljVHlwZSA9IHt9KSk7XG4vKiogU2VydmVyIGNvbnRlbnQgbW9kYWxpdGllcy4gKi9cbnZhciBNb2RhbGl0eTtcbihmdW5jdGlvbiAoTW9kYWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kYWxpdHkgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJNT0RBTElUWV9VTlNQRUNJRklFRFwiXSA9IFwiTU9EQUxJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIG1vZGVsIHNob3VsZCByZXR1cm4gdGV4dFxuICAgICAqL1xuICAgIE1vZGFsaXR5W1wiVEVYVFwiXSA9IFwiVEVYVFwiO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgbW9kZWwgc2hvdWxkIHJldHVybiBpbWFnZXMuXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJJTUFHRVwiXSA9IFwiSU1BR0VcIjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIG1vZGVsIHNob3VsZCByZXR1cm4gYXVkaW8uXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJBVURJT1wiXSA9IFwiQVVESU9cIjtcbn0pKE1vZGFsaXR5IHx8IChNb2RhbGl0eSA9IHt9KSk7XG4vKiogVGhlIG1lZGlhIHJlc29sdXRpb24gdG8gdXNlLiAqL1xudmFyIE1lZGlhUmVzb2x1dGlvbjtcbihmdW5jdGlvbiAoTWVkaWFSZXNvbHV0aW9uKSB7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBoYXMgbm90IGJlZW4gc2V0XG4gICAgICovXG4gICAgTWVkaWFSZXNvbHV0aW9uW1wiTUVESUFfUkVTT0xVVElPTl9VTlNQRUNJRklFRFwiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIGxvdyAoNjQgdG9rZW5zKS5cbiAgICAgKi9cbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX0xPV1wiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9MT1dcIjtcbiAgICAvKipcbiAgICAgKiBNZWRpYSByZXNvbHV0aW9uIHNldCB0byBtZWRpdW0gKDI1NiB0b2tlbnMpLlxuICAgICAqL1xuICAgIE1lZGlhUmVzb2x1dGlvbltcIk1FRElBX1JFU09MVVRJT05fTUVESVVNXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX01FRElVTVwiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIGhpZ2ggKHpvb21lZCByZWZyYW1pbmcgd2l0aCAyNTYgdG9rZW5zKS5cbiAgICAgKi9cbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX0hJR0hcIl0gPSBcIk1FRElBX1JFU09MVVRJT05fSElHSFwiO1xufSkoTWVkaWFSZXNvbHV0aW9uIHx8IChNZWRpYVJlc29sdXRpb24gPSB7fSkpO1xuLyoqIFR1bmluZyBtb2RlLiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIFR1bmluZ01vZGU7XG4oZnVuY3Rpb24gKFR1bmluZ01vZGUpIHtcbiAgICAvKipcbiAgICAgKiBUdW5pbmcgbW9kZSBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBUdW5pbmdNb2RlW1wiVFVOSU5HX01PREVfVU5TUEVDSUZJRURcIl0gPSBcIlRVTklOR19NT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogRnVsbCBmaW5lLXR1bmluZyBtb2RlLlxuICAgICAqL1xuICAgIFR1bmluZ01vZGVbXCJUVU5JTkdfTU9ERV9GVUxMXCJdID0gXCJUVU5JTkdfTU9ERV9GVUxMXCI7XG4gICAgLyoqXG4gICAgICogUEVGVCBhZGFwdGVyIHR1bmluZyBtb2RlLlxuICAgICAqL1xuICAgIFR1bmluZ01vZGVbXCJUVU5JTkdfTU9ERV9QRUZUX0FEQVBURVJcIl0gPSBcIlRVTklOR19NT0RFX1BFRlRfQURBUFRFUlwiO1xufSkoVHVuaW5nTW9kZSB8fCAoVHVuaW5nTW9kZSA9IHt9KSk7XG4vKiogQWRhcHRlciBzaXplIGZvciB0dW5pbmcuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgQWRhcHRlclNpemU7XG4oZnVuY3Rpb24gKEFkYXB0ZXJTaXplKSB7XG4gICAgLyoqXG4gICAgICogQWRhcHRlciBzaXplIGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX1VOU1BFQ0lGSUVEXCJdID0gXCJBREFQVEVSX1NJWkVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMS5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9PTkVcIl0gPSBcIkFEQVBURVJfU0laRV9PTkVcIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMi5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9UV09cIl0gPSBcIkFEQVBURVJfU0laRV9UV09cIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgNC5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9GT1VSXCJdID0gXCJBREFQVEVSX1NJWkVfRk9VUlwiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSA4LlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX0VJR0hUXCJdID0gXCJBREFQVEVSX1NJWkVfRUlHSFRcIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMTYuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfU0lYVEVFTlwiXSA9IFwiQURBUFRFUl9TSVpFX1NJWFRFRU5cIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMzIuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfVEhJUlRZX1RXT1wiXSA9IFwiQURBUFRFUl9TSVpFX1RISVJUWV9UV09cIjtcbn0pKEFkYXB0ZXJTaXplIHx8IChBZGFwdGVyU2l6ZSA9IHt9KSk7XG4vKiogSm9iIHN0YXRlLiAqL1xudmFyIEpvYlN0YXRlO1xuKGZ1bmN0aW9uIChKb2JTdGF0ZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2Igc3RhdGUgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfVU5TUEVDSUZJRURcIl0gPSBcIkpPQl9TVEFURV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGJlZW4ganVzdCBjcmVhdGVkIG9yIHJlc3VtZWQgYW5kIHByb2Nlc3NpbmcgaGFzIG5vdCB5ZXQgYmVndW4uXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfUVVFVUVEXCJdID0gXCJKT0JfU1RBVEVfUVVFVUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZpY2UgaXMgcHJlcGFyaW5nIHRvIHJ1biB0aGUgam9iLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1BFTkRJTkdcIl0gPSBcIkpPQl9TVEFURV9QRU5ESU5HXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9SVU5OSU5HXCJdID0gXCJKT0JfU1RBVEVfUlVOTklOR1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9TVUNDRUVERURcIl0gPSBcIkpPQl9TVEFURV9TVUNDRUVERURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGZhaWxlZC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9GQUlMRURcIl0gPSBcIkpPQl9TVEFURV9GQUlMRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGlzIGJlaW5nIGNhbmNlbGxlZC4gRnJvbSB0aGlzIHN0YXRlIHRoZSBqb2IgbWF5IG9ubHkgZ28gdG8gZWl0aGVyIGBKT0JfU1RBVEVfU1VDQ0VFREVEYCwgYEpPQl9TVEFURV9GQUlMRURgIG9yIGBKT0JfU1RBVEVfQ0FOQ0VMTEVEYC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9DQU5DRUxMSU5HXCJdID0gXCJKT0JfU1RBVEVfQ0FOQ0VMTElOR1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGJlZW4gY2FuY2VsbGVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX0NBTkNFTExFRFwiXSA9IFwiSk9CX1NUQVRFX0NBTkNFTExFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGJlZW4gc3RvcHBlZCwgYW5kIGNhbiBiZSByZXN1bWVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1BBVVNFRFwiXSA9IFwiSk9CX1NUQVRFX1BBVVNFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGV4cGlyZWQuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfRVhQSVJFRFwiXSA9IFwiSk9CX1NUQVRFX0VYUElSRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGlzIGJlaW5nIHVwZGF0ZWQuIE9ubHkgam9icyBpbiB0aGUgYEpPQl9TVEFURV9SVU5OSU5HYCBzdGF0ZSBjYW4gYmUgdXBkYXRlZC4gQWZ0ZXIgdXBkYXRpbmcsIHRoZSBqb2IgZ29lcyBiYWNrIHRvIHRoZSBgSk9CX1NUQVRFX1JVTk5JTkdgIHN0YXRlLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1VQREFUSU5HXCJdID0gXCJKT0JfU1RBVEVfVVBEQVRJTkdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGlzIHBhcnRpYWxseSBzdWNjZWVkZWQsIHNvbWUgcmVzdWx0cyBtYXkgYmUgbWlzc2luZyBkdWUgdG8gZXJyb3JzLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1BBUlRJQUxMWV9TVUNDRUVERURcIl0gPSBcIkpPQl9TVEFURV9QQVJUSUFMTFlfU1VDQ0VFREVEXCI7XG59KShKb2JTdGF0ZSB8fCAoSm9iU3RhdGUgPSB7fSkpO1xuLyoqIFRoZSB0dW5pbmcgdGFzay4gRWl0aGVyIEkyViBvciBUMlYuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgVHVuaW5nVGFzaztcbihmdW5jdGlvbiAoVHVuaW5nVGFzaykge1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdmFsdWUuIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIFR1bmluZ1Rhc2tbXCJUVU5JTkdfVEFTS19VTlNQRUNJRklFRFwiXSA9IFwiVFVOSU5HX1RBU0tfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUdW5pbmcgdGFzayBmb3IgaW1hZ2UgdG8gdmlkZW8uXG4gICAgICovXG4gICAgVHVuaW5nVGFza1tcIlRVTklOR19UQVNLX0kyVlwiXSA9IFwiVFVOSU5HX1RBU0tfSTJWXCI7XG4gICAgLyoqXG4gICAgICogVHVuaW5nIHRhc2sgZm9yIHRleHQgdG8gdmlkZW8uXG4gICAgICovXG4gICAgVHVuaW5nVGFza1tcIlRVTklOR19UQVNLX1QyVlwiXSA9IFwiVFVOSU5HX1RBU0tfVDJWXCI7XG4gICAgLyoqXG4gICAgICogVHVuaW5nIHRhc2sgZm9yIHJlZmVyZW5jZSB0byB2aWRlby5cbiAgICAgKi9cbiAgICBUdW5pbmdUYXNrW1wiVFVOSU5HX1RBU0tfUjJWXCJdID0gXCJUVU5JTkdfVEFTS19SMlZcIjtcbn0pKFR1bmluZ1Rhc2sgfHwgKFR1bmluZ1Rhc2sgPSB7fSkpO1xuLyoqIFRoZSB0b2tlbml6YXRpb24gcXVhbGl0eSB1c2VkIGZvciBnaXZlbiBtZWRpYS4gKi9cbnZhciBQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWw7XG4oZnVuY3Rpb24gKFBhcnRNZWRpYVJlc29sdXRpb25MZXZlbCkge1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gaGFzIG5vdCBiZWVuIHNldC5cbiAgICAgKi9cbiAgICBQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWxbXCJNRURJQV9SRVNPTFVUSU9OX1VOU1BFQ0lGSUVEXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBzZXQgdG8gbG93LlxuICAgICAqL1xuICAgIFBhcnRNZWRpYVJlc29sdXRpb25MZXZlbFtcIk1FRElBX1JFU09MVVRJT05fTE9XXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX0xPV1wiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIG1lZGl1bS5cbiAgICAgKi9cbiAgICBQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWxbXCJNRURJQV9SRVNPTFVUSU9OX01FRElVTVwiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9NRURJVU1cIjtcbiAgICAvKipcbiAgICAgKiBNZWRpYSByZXNvbHV0aW9uIHNldCB0byBoaWdoLlxuICAgICAqL1xuICAgIFBhcnRNZWRpYVJlc29sdXRpb25MZXZlbFtcIk1FRElBX1JFU09MVVRJT05fSElHSFwiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9ISUdIXCI7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBzZXQgdG8gdWx0cmEgaGlnaC5cbiAgICAgKi9cbiAgICBQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWxbXCJNRURJQV9SRVNPTFVUSU9OX1VMVFJBX0hJR0hcIl0gPSBcIk1FRElBX1JFU09MVVRJT05fVUxUUkFfSElHSFwiO1xufSkoUGFydE1lZGlhUmVzb2x1dGlvbkxldmVsIHx8IChQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWwgPSB7fSkpO1xuLyoqIFJlc291cmNlIHNjb3BlLiAqL1xudmFyIFJlc291cmNlU2NvcGU7XG4oZnVuY3Rpb24gKFJlc291cmNlU2NvcGUpIHtcbiAgICAvKipcbiAgICAgKiBXaGVuIHNldHRpbmcgYmFzZV91cmwsIHRoaXMgdmFsdWUgY29uZmlndXJlcyByZXNvdXJjZSBzY29wZSB0byBiZSB0aGUgY29sbGVjdGlvbi5cbiAgICAgICAgVGhlIHJlc291cmNlIG5hbWUgd2lsbCBub3QgaW5jbHVkZSBhcGkgdmVyc2lvbiwgcHJvamVjdCwgb3IgbG9jYXRpb24uXG4gICAgICAgIEZvciBleGFtcGxlLCBpZiBiYXNlX3VybCBpcyBzZXQgdG8gXCJodHRwczovL2FpcGxhdGZvcm0uZ29vZ2xlYXBpcy5jb21cIixcbiAgICAgICAgdGhlbiB0aGUgcmVzb3VyY2UgbmFtZSBmb3IgYSBNb2RlbCB3b3VsZCBiZVxuICAgICAgICBcImh0dHBzOi8vYWlwbGF0Zm9ybS5nb29nbGVhcGlzLmNvbS9wdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvZ2VtaW5pLTMtcHJvLXByZXZpZXdcbiAgICAgKi9cbiAgICBSZXNvdXJjZVNjb3BlW1wiQ09MTEVDVElPTlwiXSA9IFwiQ09MTEVDVElPTlwiO1xufSkoUmVzb3VyY2VTY29wZSB8fCAoUmVzb3VyY2VTY29wZSA9IHt9KSk7XG4vKiogT3B0aW9ucyBmb3IgZmVhdHVyZSBzZWxlY3Rpb24gcHJlZmVyZW5jZS4gKi9cbnZhciBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZTtcbihmdW5jdGlvbiAoRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UpIHtcbiAgICBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZVtcIkZFQVRVUkVfU0VMRUNUSU9OX1BSRUZFUkVOQ0VfVU5TUEVDSUZJRURcIl0gPSBcIkZFQVRVUkVfU0VMRUNUSU9OX1BSRUZFUkVOQ0VfVU5TUEVDSUZJRURcIjtcbiAgICBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZVtcIlBSSU9SSVRJWkVfUVVBTElUWVwiXSA9IFwiUFJJT1JJVElaRV9RVUFMSVRZXCI7XG4gICAgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2VbXCJCQUxBTkNFRFwiXSA9IFwiQkFMQU5DRURcIjtcbiAgICBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZVtcIlBSSU9SSVRJWkVfQ09TVFwiXSA9IFwiUFJJT1JJVElaRV9DT1NUXCI7XG59KShGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSB8fCAoRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UgPSB7fSkpO1xuLyoqIFRoZSBlbnZpcm9ubWVudCBiZWluZyBvcGVyYXRlZC4gKi9cbnZhciBFbnZpcm9ubWVudDtcbihmdW5jdGlvbiAoRW52aXJvbm1lbnQpIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0cyB0byBicm93c2VyLlxuICAgICAqL1xuICAgIEVudmlyb25tZW50W1wiRU5WSVJPTk1FTlRfVU5TUEVDSUZJRURcIl0gPSBcIkVOVklST05NRU5UX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogT3BlcmF0ZXMgaW4gYSB3ZWIgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBFbnZpcm9ubWVudFtcIkVOVklST05NRU5UX0JST1dTRVJcIl0gPSBcIkVOVklST05NRU5UX0JST1dTRVJcIjtcbn0pKEVudmlyb25tZW50IHx8IChFbnZpcm9ubWVudCA9IHt9KSk7XG4vKiogRW51bSB0aGF0IGNvbnRyb2xzIHRoZSBzYWZldHkgZmlsdGVyIGxldmVsIGZvciBvYmplY3Rpb25hYmxlIGNvbnRlbnQuICovXG52YXIgU2FmZXR5RmlsdGVyTGV2ZWw7XG4oZnVuY3Rpb24gKFNhZmV0eUZpbHRlckxldmVsKSB7XG4gICAgU2FmZXR5RmlsdGVyTGV2ZWxbXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCI7XG4gICAgU2FmZXR5RmlsdGVyTGV2ZWxbXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCI7XG4gICAgU2FmZXR5RmlsdGVyTGV2ZWxbXCJCTE9DS19PTkxZX0hJR0hcIl0gPSBcIkJMT0NLX09OTFlfSElHSFwiO1xuICAgIFNhZmV0eUZpbHRlckxldmVsW1wiQkxPQ0tfTk9ORVwiXSA9IFwiQkxPQ0tfTk9ORVwiO1xufSkoU2FmZXR5RmlsdGVyTGV2ZWwgfHwgKFNhZmV0eUZpbHRlckxldmVsID0ge30pKTtcbi8qKiBFbnVtIHRoYXQgY29udHJvbHMgdGhlIGdlbmVyYXRpb24gb2YgcGVvcGxlLiAqL1xudmFyIFBlcnNvbkdlbmVyYXRpb247XG4oZnVuY3Rpb24gKFBlcnNvbkdlbmVyYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBCbG9jayBnZW5lcmF0aW9uIG9mIGltYWdlcyBvZiBwZW9wbGUuXG4gICAgICovXG4gICAgUGVyc29uR2VuZXJhdGlvbltcIkRPTlRfQUxMT1dcIl0gPSBcIkRPTlRfQUxMT1dcIjtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBpbWFnZXMgb2YgYWR1bHRzLCBidXQgbm90IGNoaWxkcmVuLlxuICAgICAqL1xuICAgIFBlcnNvbkdlbmVyYXRpb25bXCJBTExPV19BRFVMVFwiXSA9IFwiQUxMT1dfQURVTFRcIjtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBpbWFnZXMgdGhhdCBpbmNsdWRlIGFkdWx0cyBhbmQgY2hpbGRyZW4uXG4gICAgICovXG4gICAgUGVyc29uR2VuZXJhdGlvbltcIkFMTE9XX0FMTFwiXSA9IFwiQUxMT1dfQUxMXCI7XG59KShQZXJzb25HZW5lcmF0aW9uIHx8IChQZXJzb25HZW5lcmF0aW9uID0ge30pKTtcbi8qKiBFbnVtIHRoYXQgc3BlY2lmaWVzIHRoZSBsYW5ndWFnZSBvZiB0aGUgdGV4dCBpbiB0aGUgcHJvbXB0LiAqL1xudmFyIEltYWdlUHJvbXB0TGFuZ3VhZ2U7XG4oZnVuY3Rpb24gKEltYWdlUHJvbXB0TGFuZ3VhZ2UpIHtcbiAgICAvKipcbiAgICAgKiBBdXRvLWRldGVjdCB0aGUgbGFuZ3VhZ2UuXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImF1dG9cIl0gPSBcImF1dG9cIjtcbiAgICAvKipcbiAgICAgKiBFbmdsaXNoXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImVuXCJdID0gXCJlblwiO1xuICAgIC8qKlxuICAgICAqIEphcGFuZXNlXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImphXCJdID0gXCJqYVwiO1xuICAgIC8qKlxuICAgICAqIEtvcmVhblxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJrb1wiXSA9IFwia29cIjtcbiAgICAvKipcbiAgICAgKiBIaW5kaVxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJoaVwiXSA9IFwiaGlcIjtcbiAgICAvKipcbiAgICAgKiBDaGluZXNlXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcInpoXCJdID0gXCJ6aFwiO1xuICAgIC8qKlxuICAgICAqIFBvcnR1Z3Vlc2VcbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wicHRcIl0gPSBcInB0XCI7XG4gICAgLyoqXG4gICAgICogU3BhbmlzaFxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJlc1wiXSA9IFwiZXNcIjtcbn0pKEltYWdlUHJvbXB0TGFuZ3VhZ2UgfHwgKEltYWdlUHJvbXB0TGFuZ3VhZ2UgPSB7fSkpO1xuLyoqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBtYXNrIG1vZGUgb2YgYSBtYXNrIHJlZmVyZW5jZSBpbWFnZS4gKi9cbnZhciBNYXNrUmVmZXJlbmNlTW9kZTtcbihmdW5jdGlvbiAoTWFza1JlZmVyZW5jZU1vZGUpIHtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9ERUZBVUxUXCJdID0gXCJNQVNLX01PREVfREVGQVVMVFwiO1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX1VTRVJfUFJPVklERURcIl0gPSBcIk1BU0tfTU9ERV9VU0VSX1BST1ZJREVEXCI7XG4gICAgTWFza1JlZmVyZW5jZU1vZGVbXCJNQVNLX01PREVfQkFDS0dST1VORFwiXSA9IFwiTUFTS19NT0RFX0JBQ0tHUk9VTkRcIjtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9GT1JFR1JPVU5EXCJdID0gXCJNQVNLX01PREVfRk9SRUdST1VORFwiO1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX1NFTUFOVElDXCJdID0gXCJNQVNLX01PREVfU0VNQU5USUNcIjtcbn0pKE1hc2tSZWZlcmVuY2VNb2RlIHx8IChNYXNrUmVmZXJlbmNlTW9kZSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIGNvbnRyb2wgdHlwZSBvZiBhIGNvbnRyb2wgcmVmZXJlbmNlIGltYWdlLiAqL1xudmFyIENvbnRyb2xSZWZlcmVuY2VUeXBlO1xuKGZ1bmN0aW9uIChDb250cm9sUmVmZXJlbmNlVHlwZSkge1xuICAgIENvbnRyb2xSZWZlcmVuY2VUeXBlW1wiQ09OVFJPTF9UWVBFX0RFRkFVTFRcIl0gPSBcIkNPTlRST0xfVFlQRV9ERUZBVUxUXCI7XG4gICAgQ29udHJvbFJlZmVyZW5jZVR5cGVbXCJDT05UUk9MX1RZUEVfQ0FOTllcIl0gPSBcIkNPTlRST0xfVFlQRV9DQU5OWVwiO1xuICAgIENvbnRyb2xSZWZlcmVuY2VUeXBlW1wiQ09OVFJPTF9UWVBFX1NDUklCQkxFXCJdID0gXCJDT05UUk9MX1RZUEVfU0NSSUJCTEVcIjtcbiAgICBDb250cm9sUmVmZXJlbmNlVHlwZVtcIkNPTlRST0xfVFlQRV9GQUNFX01FU0hcIl0gPSBcIkNPTlRST0xfVFlQRV9GQUNFX01FU0hcIjtcbn0pKENvbnRyb2xSZWZlcmVuY2VUeXBlIHx8IChDb250cm9sUmVmZXJlbmNlVHlwZSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIHN1YmplY3QgdHlwZSBvZiBhIHN1YmplY3QgcmVmZXJlbmNlIGltYWdlLiAqL1xudmFyIFN1YmplY3RSZWZlcmVuY2VUeXBlO1xuKGZ1bmN0aW9uIChTdWJqZWN0UmVmZXJlbmNlVHlwZSkge1xuICAgIFN1YmplY3RSZWZlcmVuY2VUeXBlW1wiU1VCSkVDVF9UWVBFX0RFRkFVTFRcIl0gPSBcIlNVQkpFQ1RfVFlQRV9ERUZBVUxUXCI7XG4gICAgU3ViamVjdFJlZmVyZW5jZVR5cGVbXCJTVUJKRUNUX1RZUEVfUEVSU09OXCJdID0gXCJTVUJKRUNUX1RZUEVfUEVSU09OXCI7XG4gICAgU3ViamVjdFJlZmVyZW5jZVR5cGVbXCJTVUJKRUNUX1RZUEVfQU5JTUFMXCJdID0gXCJTVUJKRUNUX1RZUEVfQU5JTUFMXCI7XG4gICAgU3ViamVjdFJlZmVyZW5jZVR5cGVbXCJTVUJKRUNUX1RZUEVfUFJPRFVDVFwiXSA9IFwiU1VCSkVDVF9UWVBFX1BST0RVQ1RcIjtcbn0pKFN1YmplY3RSZWZlcmVuY2VUeXBlIHx8IChTdWJqZWN0UmVmZXJlbmNlVHlwZSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIGVkaXRpbmcgbW9kZS4gKi9cbnZhciBFZGl0TW9kZTtcbihmdW5jdGlvbiAoRWRpdE1vZGUpIHtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9ERUZBVUxUXCJdID0gXCJFRElUX01PREVfREVGQVVMVFwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX0lOUEFJTlRfUkVNT1ZBTFwiXSA9IFwiRURJVF9NT0RFX0lOUEFJTlRfUkVNT1ZBTFwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX0lOUEFJTlRfSU5TRVJUSU9OXCJdID0gXCJFRElUX01PREVfSU5QQUlOVF9JTlNFUlRJT05cIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9PVVRQQUlOVFwiXSA9IFwiRURJVF9NT0RFX09VVFBBSU5UXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfQ09OVFJPTExFRF9FRElUSU5HXCJdID0gXCJFRElUX01PREVfQ09OVFJPTExFRF9FRElUSU5HXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfU1RZTEVcIl0gPSBcIkVESVRfTU9ERV9TVFlMRVwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX0JHU1dBUFwiXSA9IFwiRURJVF9NT0RFX0JHU1dBUFwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX1BST0RVQ1RfSU1BR0VcIl0gPSBcIkVESVRfTU9ERV9QUk9EVUNUX0lNQUdFXCI7XG59KShFZGl0TW9kZSB8fCAoRWRpdE1vZGUgPSB7fSkpO1xuLyoqIEVudW0gdGhhdCByZXByZXNlbnRzIHRoZSBzZWdtZW50YXRpb24gbW9kZS4gKi9cbnZhciBTZWdtZW50TW9kZTtcbihmdW5jdGlvbiAoU2VnbWVudE1vZGUpIHtcbiAgICBTZWdtZW50TW9kZVtcIkZPUkVHUk9VTkRcIl0gPSBcIkZPUkVHUk9VTkRcIjtcbiAgICBTZWdtZW50TW9kZVtcIkJBQ0tHUk9VTkRcIl0gPSBcIkJBQ0tHUk9VTkRcIjtcbiAgICBTZWdtZW50TW9kZVtcIlBST01QVFwiXSA9IFwiUFJPTVBUXCI7XG4gICAgU2VnbWVudE1vZGVbXCJTRU1BTlRJQ1wiXSA9IFwiU0VNQU5USUNcIjtcbiAgICBTZWdtZW50TW9kZVtcIklOVEVSQUNUSVZFXCJdID0gXCJJTlRFUkFDVElWRVwiO1xufSkoU2VnbWVudE1vZGUgfHwgKFNlZ21lbnRNb2RlID0ge30pKTtcbi8qKiBFbnVtIGZvciB0aGUgcmVmZXJlbmNlIHR5cGUgb2YgYSB2aWRlbyBnZW5lcmF0aW9uIHJlZmVyZW5jZSBpbWFnZS4gKi9cbnZhciBWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlO1xuKGZ1bmN0aW9uIChWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlKSB7XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgaW1hZ2UgdGhhdCBwcm92aWRlcyBhc3NldHMgdG8gdGhlIGdlbmVyYXRlZCB2aWRlbyxcbiAgICAgICAgc3VjaCBhcyB0aGUgc2NlbmUsIGFuIG9iamVjdCwgYSBjaGFyYWN0ZXIsIGV0Yy5cbiAgICAgKi9cbiAgICBWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlW1wiQVNTRVRcIl0gPSBcIkFTU0VUXCI7XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgaW1hZ2UgdGhhdCBwcm92aWRlcyBhZXN0aGV0aWNzIGluY2x1ZGluZyBjb2xvcnMsXG4gICAgICAgIGxpZ2h0aW5nLCB0ZXh0dXJlLCBldGMuLCB0byBiZSB1c2VkIGFzIHRoZSBzdHlsZSBvZiB0aGUgZ2VuZXJhdGVkIHZpZGVvLFxuICAgICAgICBzdWNoIGFzICdhbmltZScsICdwaG90b2dyYXBoeScsICdvcmlnYW1pJywgZXRjLlxuICAgICAqL1xuICAgIFZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZVR5cGVbXCJTVFlMRVwiXSA9IFwiU1RZTEVcIjtcbn0pKFZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZVR5cGUgfHwgKFZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZVR5cGUgPSB7fSkpO1xuLyoqIEVudW0gZm9yIHRoZSBtYXNrIG1vZGUgb2YgYSB2aWRlbyBnZW5lcmF0aW9uIG1hc2suICovXG52YXIgVmlkZW9HZW5lcmF0aW9uTWFza01vZGU7XG4oZnVuY3Rpb24gKFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGltYWdlIG1hc2sgY29udGFpbnMgYSBtYXNrZWQgcmVjdGFuZ3VsYXIgcmVnaW9uIHdoaWNoIGlzXG4gICAgICAgIGFwcGxpZWQgb24gdGhlIGZpcnN0IGZyYW1lIG9mIHRoZSBpbnB1dCB2aWRlby4gVGhlIG9iamVjdCBkZXNjcmliZWQgaW5cbiAgICAgICAgdGhlIHByb21wdCBpcyBpbnNlcnRlZCBpbnRvIHRoaXMgcmVnaW9uIGFuZCB3aWxsIGFwcGVhciBpbiBzdWJzZXF1ZW50XG4gICAgICAgIGZyYW1lcy5cbiAgICAgKi9cbiAgICBWaWRlb0dlbmVyYXRpb25NYXNrTW9kZVtcIklOU0VSVFwiXSA9IFwiSU5TRVJUXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGltYWdlIG1hc2sgaXMgdXNlZCB0byBkZXRlcm1pbmUgYW4gb2JqZWN0IGluIHRoZVxuICAgICAgICBmaXJzdCB2aWRlbyBmcmFtZSB0byB0cmFjay4gVGhpcyBvYmplY3QgaXMgcmVtb3ZlZCBmcm9tIHRoZSB2aWRlby5cbiAgICAgKi9cbiAgICBWaWRlb0dlbmVyYXRpb25NYXNrTW9kZVtcIlJFTU9WRVwiXSA9IFwiUkVNT1ZFXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGltYWdlIG1hc2sgaXMgdXNlZCB0byBkZXRlcm1pbmUgYSByZWdpb24gaW4gdGhlXG4gICAgICAgIHZpZGVvLiBPYmplY3RzIGluIHRoaXMgcmVnaW9uIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBWaWRlb0dlbmVyYXRpb25NYXNrTW9kZVtcIlJFTU9WRV9TVEFUSUNcIl0gPSBcIlJFTU9WRV9TVEFUSUNcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaW1hZ2UgbWFzayBjb250YWlucyBhIG1hc2tlZCByZWN0YW5ndWxhciByZWdpb24gd2hlcmVcbiAgICAgICAgdGhlIGlucHV0IHZpZGVvIHdpbGwgZ28uIFRoZSByZW1haW5pbmcgYXJlYSB3aWxsIGJlIGdlbmVyYXRlZC4gVmlkZW9cbiAgICAgICAgbWFza3MgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgVmlkZW9HZW5lcmF0aW9uTWFza01vZGVbXCJPVVRQQUlOVFwiXSA9IFwiT1VUUEFJTlRcIjtcbn0pKFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlIHx8IChWaWRlb0dlbmVyYXRpb25NYXNrTW9kZSA9IHt9KSk7XG4vKiogRW51bSB0aGF0IGNvbnRyb2xzIHRoZSBjb21wcmVzc2lvbiBxdWFsaXR5IG9mIHRoZSBnZW5lcmF0ZWQgdmlkZW9zLiAqL1xudmFyIFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5O1xuKGZ1bmN0aW9uIChWaWRlb0NvbXByZXNzaW9uUXVhbGl0eSkge1xuICAgIC8qKlxuICAgICAqIE9wdGltaXplZCB2aWRlbyBjb21wcmVzc2lvbiBxdWFsaXR5LiBUaGlzIHdpbGwgcHJvZHVjZSB2aWRlb3NcbiAgICAgICAgd2l0aCBhIGNvbXByZXNzZWQsIHNtYWxsZXIgZmlsZSBzaXplLlxuICAgICAqL1xuICAgIFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5W1wiT1BUSU1JWkVEXCJdID0gXCJPUFRJTUlaRURcIjtcbiAgICAvKipcbiAgICAgKiBMb3NzbGVzcyB2aWRlbyBjb21wcmVzc2lvbiBxdWFsaXR5LiBUaGlzIHdpbGwgcHJvZHVjZSB2aWRlb3NcbiAgICAgICAgd2l0aCBhIGxhcmdlciBmaWxlIHNpemUuXG4gICAgICovXG4gICAgVmlkZW9Db21wcmVzc2lvblF1YWxpdHlbXCJMT1NTTEVTU1wiXSA9IFwiTE9TU0xFU1NcIjtcbn0pKFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5IHx8IChWaWRlb0NvbXByZXNzaW9uUXVhbGl0eSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIHR1bmluZyBtZXRob2QuICovXG52YXIgVHVuaW5nTWV0aG9kO1xuKGZ1bmN0aW9uIChUdW5pbmdNZXRob2QpIHtcbiAgICAvKipcbiAgICAgKiBTdXBlcnZpc2VkIGZpbmUgdHVuaW5nLlxuICAgICAqL1xuICAgIFR1bmluZ01ldGhvZFtcIlNVUEVSVklTRURfRklORV9UVU5JTkdcIl0gPSBcIlNVUEVSVklTRURfRklORV9UVU5JTkdcIjtcbiAgICAvKipcbiAgICAgKiBQcmVmZXJlbmNlIG9wdGltaXphdGlvbiB0dW5pbmcuXG4gICAgICovXG4gICAgVHVuaW5nTWV0aG9kW1wiUFJFRkVSRU5DRV9UVU5JTkdcIl0gPSBcIlBSRUZFUkVOQ0VfVFVOSU5HXCI7XG4gICAgLyoqXG4gICAgICogRGlzdGlsbGF0aW9uIHR1bmluZy5cbiAgICAgKi9cbiAgICBUdW5pbmdNZXRob2RbXCJESVNUSUxMQVRJT05cIl0gPSBcIkRJU1RJTExBVElPTlwiO1xufSkoVHVuaW5nTWV0aG9kIHx8IChUdW5pbmdNZXRob2QgPSB7fSkpO1xuLyoqIFN0YXRlIGZvciB0aGUgbGlmZWN5Y2xlIG9mIGEgRG9jdW1lbnQuICovXG52YXIgRG9jdW1lbnRTdGF0ZTtcbihmdW5jdGlvbiAoRG9jdW1lbnRTdGF0ZSkge1xuICAgIERvY3VtZW50U3RhdGVbXCJTVEFURV9VTlNQRUNJRklFRFwiXSA9IFwiU1RBVEVfVU5TUEVDSUZJRURcIjtcbiAgICBEb2N1bWVudFN0YXRlW1wiU1RBVEVfUEVORElOR1wiXSA9IFwiU1RBVEVfUEVORElOR1wiO1xuICAgIERvY3VtZW50U3RhdGVbXCJTVEFURV9BQ1RJVkVcIl0gPSBcIlNUQVRFX0FDVElWRVwiO1xuICAgIERvY3VtZW50U3RhdGVbXCJTVEFURV9GQUlMRURcIl0gPSBcIlNUQVRFX0ZBSUxFRFwiO1xufSkoRG9jdW1lbnRTdGF0ZSB8fCAoRG9jdW1lbnRTdGF0ZSA9IHt9KSk7XG4vKiogU3RhdGUgZm9yIHRoZSBsaWZlY3ljbGUgb2YgYSBGaWxlLiAqL1xudmFyIEZpbGVTdGF0ZTtcbihmdW5jdGlvbiAoRmlsZVN0YXRlKSB7XG4gICAgRmlsZVN0YXRlW1wiU1RBVEVfVU5TUEVDSUZJRURcIl0gPSBcIlNUQVRFX1VOU1BFQ0lGSUVEXCI7XG4gICAgRmlsZVN0YXRlW1wiUFJPQ0VTU0lOR1wiXSA9IFwiUFJPQ0VTU0lOR1wiO1xuICAgIEZpbGVTdGF0ZVtcIkFDVElWRVwiXSA9IFwiQUNUSVZFXCI7XG4gICAgRmlsZVN0YXRlW1wiRkFJTEVEXCJdID0gXCJGQUlMRURcIjtcbn0pKEZpbGVTdGF0ZSB8fCAoRmlsZVN0YXRlID0ge30pKTtcbi8qKiBTb3VyY2Ugb2YgdGhlIEZpbGUuICovXG52YXIgRmlsZVNvdXJjZTtcbihmdW5jdGlvbiAoRmlsZVNvdXJjZSkge1xuICAgIEZpbGVTb3VyY2VbXCJTT1VSQ0VfVU5TUEVDSUZJRURcIl0gPSBcIlNPVVJDRV9VTlNQRUNJRklFRFwiO1xuICAgIEZpbGVTb3VyY2VbXCJVUExPQURFRFwiXSA9IFwiVVBMT0FERURcIjtcbiAgICBGaWxlU291cmNlW1wiR0VORVJBVEVEXCJdID0gXCJHRU5FUkFURURcIjtcbiAgICBGaWxlU291cmNlW1wiUkVHSVNURVJFRFwiXSA9IFwiUkVHSVNURVJFRFwiO1xufSkoRmlsZVNvdXJjZSB8fCAoRmlsZVNvdXJjZSA9IHt9KSk7XG4vKiogVGhlIHJlYXNvbiB3aHkgdGhlIHR1cm4gaXMgY29tcGxldGUuICovXG52YXIgVHVybkNvbXBsZXRlUmVhc29uO1xuKGZ1bmN0aW9uIChUdXJuQ29tcGxldGVSZWFzb24pIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHZhbHVlLiBSZWFzb24gaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgVHVybkNvbXBsZXRlUmVhc29uW1wiVFVSTl9DT01QTEVURV9SRUFTT05fVU5TUEVDSUZJRURcIl0gPSBcIlRVUk5fQ09NUExFVEVfUkVBU09OX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIGNhbGwgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIFR1cm5Db21wbGV0ZVJlYXNvbltcIk1BTEZPUk1FRF9GVU5DVElPTl9DQUxMXCJdID0gXCJNQUxGT1JNRURfRlVOQ1RJT05fQ0FMTFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSByZXNwb25zZSBpcyByZWplY3RlZCBieSB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgVHVybkNvbXBsZXRlUmVhc29uW1wiUkVTUE9OU0VfUkVKRUNURURcIl0gPSBcIlJFU1BPTlNFX1JFSkVDVEVEXCI7XG4gICAgLyoqXG4gICAgICogTmVlZHMgbW9yZSBpbnB1dCBmcm9tIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIFR1cm5Db21wbGV0ZVJlYXNvbltcIk5FRURfTU9SRV9JTlBVVFwiXSA9IFwiTkVFRF9NT1JFX0lOUFVUXCI7XG59KShUdXJuQ29tcGxldGVSZWFzb24gfHwgKFR1cm5Db21wbGV0ZVJlYXNvbiA9IHt9KSk7XG4vKiogU2VydmVyIGNvbnRlbnQgbW9kYWxpdGllcy4gKi9cbnZhciBNZWRpYU1vZGFsaXR5O1xuKGZ1bmN0aW9uIChNZWRpYU1vZGFsaXR5KSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGFsaXR5IGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJNT0RBTElUWV9VTlNQRUNJRklFRFwiXSA9IFwiTU9EQUxJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBQbGFpbiB0ZXh0LlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJURVhUXCJdID0gXCJURVhUXCI7XG4gICAgLyoqXG4gICAgICogSW1hZ2VzLlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJJTUFHRVwiXSA9IFwiSU1BR0VcIjtcbiAgICAvKipcbiAgICAgKiBWaWRlby5cbiAgICAgKi9cbiAgICBNZWRpYU1vZGFsaXR5W1wiVklERU9cIl0gPSBcIlZJREVPXCI7XG4gICAgLyoqXG4gICAgICogQXVkaW8uXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIkFVRElPXCJdID0gXCJBVURJT1wiO1xuICAgIC8qKlxuICAgICAqIERvY3VtZW50LCBlLmcuIFBERi5cbiAgICAgKi9cbiAgICBNZWRpYU1vZGFsaXR5W1wiRE9DVU1FTlRcIl0gPSBcIkRPQ1VNRU5UXCI7XG59KShNZWRpYU1vZGFsaXR5IHx8IChNZWRpYU1vZGFsaXR5ID0ge30pKTtcbi8qKiBUaGUgdHlwZSBvZiB0aGUgVkFEIHNpZ25hbC4gKi9cbnZhciBWYWRTaWduYWxUeXBlO1xuKGZ1bmN0aW9uIChWYWRTaWduYWxUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgaXMgVkFEX1NJR05BTF9UWVBFX1VOU1BFQ0lGSUVELlxuICAgICAqL1xuICAgIFZhZFNpZ25hbFR5cGVbXCJWQURfU0lHTkFMX1RZUEVfVU5TUEVDSUZJRURcIl0gPSBcIlZBRF9TSUdOQUxfVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IG9mIHNlbnRlbmNlIHNpZ25hbC5cbiAgICAgKi9cbiAgICBWYWRTaWduYWxUeXBlW1wiVkFEX1NJR05BTF9UWVBFX1NPU1wiXSA9IFwiVkFEX1NJR05BTF9UWVBFX1NPU1wiO1xuICAgIC8qKlxuICAgICAqIEVuZCBvZiBzZW50ZW5jZSBzaWduYWwuXG4gICAgICovXG4gICAgVmFkU2lnbmFsVHlwZVtcIlZBRF9TSUdOQUxfVFlQRV9FT1NcIl0gPSBcIlZBRF9TSUdOQUxfVFlQRV9FT1NcIjtcbn0pKFZhZFNpZ25hbFR5cGUgfHwgKFZhZFNpZ25hbFR5cGUgPSB7fSkpO1xuLyoqIFRoZSB0eXBlIG9mIHRoZSB2b2ljZSBhY3Rpdml0eSBzaWduYWwuICovXG52YXIgVm9pY2VBY3Rpdml0eVR5cGU7XG4oZnVuY3Rpb24gKFZvaWNlQWN0aXZpdHlUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgaXMgVk9JQ0VfQUNUSVZJVFlfVFlQRV9VTlNQRUNJRklFRC5cbiAgICAgKi9cbiAgICBWb2ljZUFjdGl2aXR5VHlwZVtcIlRZUEVfVU5TUEVDSUZJRURcIl0gPSBcIlRZUEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBTdGFydCBvZiBzZW50ZW5jZSBzaWduYWwuXG4gICAgICovXG4gICAgVm9pY2VBY3Rpdml0eVR5cGVbXCJBQ1RJVklUWV9TVEFSVFwiXSA9IFwiQUNUSVZJVFlfU1RBUlRcIjtcbiAgICAvKipcbiAgICAgKiBFbmQgb2Ygc2VudGVuY2Ugc2lnbmFsLlxuICAgICAqL1xuICAgIFZvaWNlQWN0aXZpdHlUeXBlW1wiQUNUSVZJVFlfRU5EXCJdID0gXCJBQ1RJVklUWV9FTkRcIjtcbn0pKFZvaWNlQWN0aXZpdHlUeXBlIHx8IChWb2ljZUFjdGl2aXR5VHlwZSA9IHt9KSk7XG4vKiogU3RhcnQgb2Ygc3BlZWNoIHNlbnNpdGl2aXR5LiAqL1xudmFyIFN0YXJ0U2Vuc2l0aXZpdHk7XG4oZnVuY3Rpb24gKFN0YXJ0U2Vuc2l0aXZpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyBTVEFSVF9TRU5TSVRJVklUWV9MT1cuXG4gICAgICovXG4gICAgU3RhcnRTZW5zaXRpdml0eVtcIlNUQVJUX1NFTlNJVElWSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJTVEFSVF9TRU5TSVRJVklUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpYyBkZXRlY3Rpb24gd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IG9mIHNwZWVjaCBtb3JlIG9mdGVuLlxuICAgICAqL1xuICAgIFN0YXJ0U2Vuc2l0aXZpdHlbXCJTVEFSVF9TRU5TSVRJVklUWV9ISUdIXCJdID0gXCJTVEFSVF9TRU5TSVRJVklUWV9ISUdIXCI7XG4gICAgLyoqXG4gICAgICogQXV0b21hdGljIGRldGVjdGlvbiB3aWxsIGRldGVjdCB0aGUgc3RhcnQgb2Ygc3BlZWNoIGxlc3Mgb2Z0ZW4uXG4gICAgICovXG4gICAgU3RhcnRTZW5zaXRpdml0eVtcIlNUQVJUX1NFTlNJVElWSVRZX0xPV1wiXSA9IFwiU1RBUlRfU0VOU0lUSVZJVFlfTE9XXCI7XG59KShTdGFydFNlbnNpdGl2aXR5IHx8IChTdGFydFNlbnNpdGl2aXR5ID0ge30pKTtcbi8qKiBFbmQgb2Ygc3BlZWNoIHNlbnNpdGl2aXR5LiAqL1xudmFyIEVuZFNlbnNpdGl2aXR5O1xuKGZ1bmN0aW9uIChFbmRTZW5zaXRpdml0eSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGlzIEVORF9TRU5TSVRJVklUWV9MT1cuXG4gICAgICovXG4gICAgRW5kU2Vuc2l0aXZpdHlbXCJFTkRfU0VOU0lUSVZJVFlfVU5TUEVDSUZJRURcIl0gPSBcIkVORF9TRU5TSVRJVklUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpYyBkZXRlY3Rpb24gZW5kcyBzcGVlY2ggbW9yZSBvZnRlbi5cbiAgICAgKi9cbiAgICBFbmRTZW5zaXRpdml0eVtcIkVORF9TRU5TSVRJVklUWV9ISUdIXCJdID0gXCJFTkRfU0VOU0lUSVZJVFlfSElHSFwiO1xuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpYyBkZXRlY3Rpb24gZW5kcyBzcGVlY2ggbGVzcyBvZnRlbi5cbiAgICAgKi9cbiAgICBFbmRTZW5zaXRpdml0eVtcIkVORF9TRU5TSVRJVklUWV9MT1dcIl0gPSBcIkVORF9TRU5TSVRJVklUWV9MT1dcIjtcbn0pKEVuZFNlbnNpdGl2aXR5IHx8IChFbmRTZW5zaXRpdml0eSA9IHt9KSk7XG4vKiogVGhlIGRpZmZlcmVudCB3YXlzIG9mIGhhbmRsaW5nIHVzZXIgYWN0aXZpdHkuICovXG52YXIgQWN0aXZpdHlIYW5kbGluZztcbihmdW5jdGlvbiAoQWN0aXZpdHlIYW5kbGluZykge1xuICAgIC8qKlxuICAgICAqIElmIHVuc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBgU1RBUlRfT0ZfQUNUSVZJVFlfSU5URVJSVVBUU2AuXG4gICAgICovXG4gICAgQWN0aXZpdHlIYW5kbGluZ1tcIkFDVElWSVRZX0hBTkRMSU5HX1VOU1BFQ0lGSUVEXCJdID0gXCJBQ1RJVklUWV9IQU5ETElOR19VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHN0YXJ0IG9mIGFjdGl2aXR5IHdpbGwgaW50ZXJydXB0IHRoZSBtb2RlbCdzIHJlc3BvbnNlIChhbHNvIGNhbGxlZCBcImJhcmdlIGluXCIpLiBUaGUgbW9kZWwncyBjdXJyZW50IHJlc3BvbnNlIHdpbGwgYmUgY3V0LW9mZiBpbiB0aGUgbW9tZW50IG9mIHRoZSBpbnRlcnJ1cHRpb24uIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgICovXG4gICAgQWN0aXZpdHlIYW5kbGluZ1tcIlNUQVJUX09GX0FDVElWSVRZX0lOVEVSUlVQVFNcIl0gPSBcIlNUQVJUX09GX0FDVElWSVRZX0lOVEVSUlVQVFNcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwncyByZXNwb25zZSB3aWxsIG5vdCBiZSBpbnRlcnJ1cHRlZC5cbiAgICAgKi9cbiAgICBBY3Rpdml0eUhhbmRsaW5nW1wiTk9fSU5URVJSVVBUSU9OXCJdID0gXCJOT19JTlRFUlJVUFRJT05cIjtcbn0pKEFjdGl2aXR5SGFuZGxpbmcgfHwgKEFjdGl2aXR5SGFuZGxpbmcgPSB7fSkpO1xuLyoqIE9wdGlvbnMgYWJvdXQgd2hpY2ggaW5wdXQgaXMgaW5jbHVkZWQgaW4gdGhlIHVzZXIncyB0dXJuLiAqL1xudmFyIFR1cm5Db3ZlcmFnZTtcbihmdW5jdGlvbiAoVHVybkNvdmVyYWdlKSB7XG4gICAgLyoqXG4gICAgICogSWYgdW5zcGVjaWZpZWQsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIGBUVVJOX0lOQ0xVREVTX09OTFlfQUNUSVZJVFlgLlxuICAgICAqL1xuICAgIFR1cm5Db3ZlcmFnZVtcIlRVUk5fQ09WRVJBR0VfVU5TUEVDSUZJRURcIl0gPSBcIlRVUk5fQ09WRVJBR0VfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdXNlcnMgdHVybiBvbmx5IGluY2x1ZGVzIGFjdGl2aXR5IHNpbmNlIHRoZSBsYXN0IHR1cm4sIGV4Y2x1ZGluZyBpbmFjdGl2aXR5IChlLmcuIHNpbGVuY2Ugb24gdGhlIGF1ZGlvIHN0cmVhbSkuIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgICovXG4gICAgVHVybkNvdmVyYWdlW1wiVFVSTl9JTkNMVURFU19PTkxZX0FDVElWSVRZXCJdID0gXCJUVVJOX0lOQ0xVREVTX09OTFlfQUNUSVZJVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdXNlcnMgdHVybiBpbmNsdWRlcyBhbGwgcmVhbHRpbWUgaW5wdXQgc2luY2UgdGhlIGxhc3QgdHVybiwgaW5jbHVkaW5nIGluYWN0aXZpdHkgKGUuZy4gc2lsZW5jZSBvbiB0aGUgYXVkaW8gc3RyZWFtKS5cbiAgICAgKi9cbiAgICBUdXJuQ292ZXJhZ2VbXCJUVVJOX0lOQ0xVREVTX0FMTF9JTlBVVFwiXSA9IFwiVFVSTl9JTkNMVURFU19BTExfSU5QVVRcIjtcbn0pKFR1cm5Db3ZlcmFnZSB8fCAoVHVybkNvdmVyYWdlID0ge30pKTtcbi8qKiBTY2FsZSBvZiB0aGUgZ2VuZXJhdGVkIG11c2ljLiAqL1xudmFyIFNjYWxlO1xuKGZ1bmN0aW9uIChTY2FsZSkge1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdmFsdWUuIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIFNjYWxlW1wiU0NBTEVfVU5TUEVDSUZJRURcIl0gPSBcIlNDQUxFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQyBtYWpvciBvciBBIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiQ19NQUpPUl9BX01JTk9SXCJdID0gXCJDX01BSk9SX0FfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBEYiBtYWpvciBvciBCYiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkRfRkxBVF9NQUpPUl9CX0ZMQVRfTUlOT1JcIl0gPSBcIkRfRkxBVF9NQUpPUl9CX0ZMQVRfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBEIG1ham9yIG9yIEIgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJEX01BSk9SX0JfTUlOT1JcIl0gPSBcIkRfTUFKT1JfQl9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEViIG1ham9yIG9yIEMgbWlub3JcbiAgICAgKi9cbiAgICBTY2FsZVtcIkVfRkxBVF9NQUpPUl9DX01JTk9SXCJdID0gXCJFX0ZMQVRfTUFKT1JfQ19NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEUgbWFqb3Igb3IgRGIgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJFX01BSk9SX0RfRkxBVF9NSU5PUlwiXSA9IFwiRV9NQUpPUl9EX0ZMQVRfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBGIG1ham9yIG9yIEQgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJGX01BSk9SX0RfTUlOT1JcIl0gPSBcIkZfTUFKT1JfRF9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEdiIG1ham9yIG9yIEViIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiR19GTEFUX01BSk9SX0VfRkxBVF9NSU5PUlwiXSA9IFwiR19GTEFUX01BSk9SX0VfRkxBVF9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEcgbWFqb3Igb3IgRSBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkdfTUFKT1JfRV9NSU5PUlwiXSA9IFwiR19NQUpPUl9FX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogQWIgbWFqb3Igb3IgRiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkFfRkxBVF9NQUpPUl9GX01JTk9SXCJdID0gXCJBX0ZMQVRfTUFKT1JfRl9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEEgbWFqb3Igb3IgR2IgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJBX01BSk9SX0dfRkxBVF9NSU5PUlwiXSA9IFwiQV9NQUpPUl9HX0ZMQVRfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBCYiBtYWpvciBvciBHIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiQl9GTEFUX01BSk9SX0dfTUlOT1JcIl0gPSBcIkJfRkxBVF9NQUpPUl9HX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogQiBtYWpvciBvciBBYiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkJfTUFKT1JfQV9GTEFUX01JTk9SXCJdID0gXCJCX01BSk9SX0FfRkxBVF9NSU5PUlwiO1xufSkoU2NhbGUgfHwgKFNjYWxlID0ge30pKTtcbi8qKiBUaGUgbW9kZSBvZiBtdXNpYyBnZW5lcmF0aW9uLiAqL1xudmFyIE11c2ljR2VuZXJhdGlvbk1vZGU7XG4oZnVuY3Rpb24gKE11c2ljR2VuZXJhdGlvbk1vZGUpIHtcbiAgICAvKipcbiAgICAgKiBSZWx5IG9uIHRoZSBzZXJ2ZXIgZGVmYXVsdCBnZW5lcmF0aW9uIG1vZGUuXG4gICAgICovXG4gICAgTXVzaWNHZW5lcmF0aW9uTW9kZVtcIk1VU0lDX0dFTkVSQVRJT05fTU9ERV9VTlNQRUNJRklFRFwiXSA9IFwiTVVTSUNfR0VORVJBVElPTl9NT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogU3RlZXIgdGV4dCBwcm9tcHRzIHRvIHJlZ2lvbnMgb2YgbGF0ZW50IHNwYWNlIHdpdGggaGlnaGVyIHF1YWxpdHlcbiAgICAgICAgbXVzaWMuXG4gICAgICovXG4gICAgTXVzaWNHZW5lcmF0aW9uTW9kZVtcIlFVQUxJVFlcIl0gPSBcIlFVQUxJVFlcIjtcbiAgICAvKipcbiAgICAgKiBTdGVlciB0ZXh0IHByb21wdHMgdG8gcmVnaW9ucyBvZiBsYXRlbnQgc3BhY2Ugd2l0aCBhIGxhcmdlclxuICAgICAgICBkaXZlcnNpdHkgb2YgbXVzaWMuXG4gICAgICovXG4gICAgTXVzaWNHZW5lcmF0aW9uTW9kZVtcIkRJVkVSU0lUWVwiXSA9IFwiRElWRVJTSVRZXCI7XG4gICAgLyoqXG4gICAgICogU3RlZXIgdGV4dCBwcm9tcHRzIHRvIHJlZ2lvbnMgb2YgbGF0ZW50IHNwYWNlIG1vcmUgbGlrZWx5IHRvXG4gICAgICAgIGdlbmVyYXRlIG11c2ljIHdpdGggdm9jYWxzLlxuICAgICAqL1xuICAgIE11c2ljR2VuZXJhdGlvbk1vZGVbXCJWT0NBTElaQVRJT05cIl0gPSBcIlZPQ0FMSVpBVElPTlwiO1xufSkoTXVzaWNHZW5lcmF0aW9uTW9kZSB8fCAoTXVzaWNHZW5lcmF0aW9uTW9kZSA9IHt9KSk7XG4vKiogVGhlIHBsYXliYWNrIGNvbnRyb2wgc2lnbmFsIHRvIGFwcGx5IHRvIHRoZSBtdXNpYyBnZW5lcmF0aW9uLiAqL1xudmFyIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbDtcbihmdW5jdGlvbiAoTGl2ZU11c2ljUGxheWJhY2tDb250cm9sKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sW1wiUExBWUJBQ0tfQ09OVFJPTF9VTlNQRUNJRklFRFwiXSA9IFwiUExBWUJBQ0tfQ09OVFJPTF9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IGdlbmVyYXRpbmcgdGhlIG11c2ljLlxuICAgICAqL1xuICAgIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbFtcIlBMQVlcIl0gPSBcIlBMQVlcIjtcbiAgICAvKipcbiAgICAgKiBIb2xkIHRoZSBtdXNpYyBnZW5lcmF0aW9uLiBVc2UgUExBWSB0byByZXN1bWUgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2xbXCJQQVVTRVwiXSA9IFwiUEFVU0VcIjtcbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSBtdXNpYyBnZW5lcmF0aW9uIGFuZCByZXNldCB0aGUgY29udGV4dCAocHJvbXB0cyByZXRhaW5lZCkuXG4gICAgICAgIFVzZSBQTEFZIHRvIHJlc3RhcnQgdGhlIG11c2ljIGdlbmVyYXRpb24uXG4gICAgICovXG4gICAgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sW1wiU1RPUFwiXSA9IFwiU1RPUFwiO1xuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBjb250ZXh0IG9mIHRoZSBtdXNpYyBnZW5lcmF0aW9uIHdpdGhvdXQgc3RvcHBpbmcgaXQuXG4gICAgICAgIFJldGFpbnMgdGhlIGN1cnJlbnQgcHJvbXB0cyBhbmQgY29uZmlnLlxuICAgICAqL1xuICAgIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbFtcIlJFU0VUX0NPTlRFWFRcIl0gPSBcIlJFU0VUX0NPTlRFWFRcIjtcbn0pKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbCB8fCAoTGl2ZU11c2ljUGxheWJhY2tDb250cm9sID0ge30pKTtcbi8qKiBSYXcgbWVkaWEgYnl0ZXMgZm9yIGZ1bmN0aW9uIHJlc3BvbnNlLlxuXG5UZXh0IHNob3VsZCBub3QgYmUgc2VudCBhcyByYXcgYnl0ZXMsIHVzZSB0aGUgRnVuY3Rpb25SZXNwb25zZS5yZXNwb25zZVxuZmllbGQuICovXG5jbGFzcyBGdW5jdGlvblJlc3BvbnNlQmxvYiB7XG59XG4vKiogVVJJIGJhc2VkIGRhdGEgZm9yIGZ1bmN0aW9uIHJlc3BvbnNlLiAqL1xuY2xhc3MgRnVuY3Rpb25SZXNwb25zZUZpbGVEYXRhIHtcbn1cbi8qKiBBIGRhdGF0eXBlIGNvbnRhaW5pbmcgbWVkaWEgdGhhdCBpcyBwYXJ0IG9mIGEgYEZ1bmN0aW9uUmVzcG9uc2VgIG1lc3NhZ2UuXG5cbkEgYEZ1bmN0aW9uUmVzcG9uc2VQYXJ0YCBjb25zaXN0cyBvZiBkYXRhIHdoaWNoIGhhcyBhbiBhc3NvY2lhdGVkIGRhdGF0eXBlLiBBXG5gRnVuY3Rpb25SZXNwb25zZVBhcnRgIGNhbiBvbmx5IGNvbnRhaW4gb25lIG9mIHRoZSBhY2NlcHRlZCB0eXBlcyBpblxuYEZ1bmN0aW9uUmVzcG9uc2VQYXJ0LmRhdGFgLlxuXG5BIGBGdW5jdGlvblJlc3BvbnNlUGFydGAgbXVzdCBoYXZlIGEgZml4ZWQgSUFOQSBNSU1FIHR5cGUgaWRlbnRpZnlpbmcgdGhlXG50eXBlIGFuZCBzdWJ0eXBlIG9mIHRoZSBtZWRpYSBpZiB0aGUgYGlubGluZV9kYXRhYCBmaWVsZCBpcyBmaWxsZWQgd2l0aCByYXdcbmJ5dGVzLiAqL1xuY2xhc3MgRnVuY3Rpb25SZXNwb25zZVBhcnQge1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYEZ1bmN0aW9uUmVzcG9uc2VQYXJ0YCBvYmplY3QgZnJvbSBhIGBiYXNlNjRgIGVuY29kZWQgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uUmVzcG9uc2VQYXJ0RnJvbUJhc2U2NChkYXRhLCBtaW1lVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlubGluZURhdGE6IHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGUsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBGdW5jdGlvblJlc3BvbnNlUGFydGAgb2JqZWN0IGZyb20gYSBgVVJJYCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uUmVzcG9uc2VQYXJ0RnJvbVVyaSh1cmksIG1pbWVUeXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZURhdGE6IHtcbiAgICAgICAgICAgIGZpbGVVcmk6IHVyaSxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqIEEgZnVuY3Rpb24gcmVzcG9uc2UuICovXG5jbGFzcyBGdW5jdGlvblJlc3BvbnNlIHtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGBVUklgIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21VcmkodXJpLCBtaW1lVHlwZSwgbWVkaWFSZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBmaWxlRGF0YToge1xuICAgICAgICAgICAgZmlsZVVyaTogdXJpLFxuICAgICAgICAgICAgbWltZVR5cGU6IG1pbWVUeXBlLFxuICAgICAgICB9IH0sIChtZWRpYVJlc29sdXRpb24gJiYgeyBtZWRpYVJlc29sdXRpb246IHsgbGV2ZWw6IG1lZGlhUmVzb2x1dGlvbiB9IH0pKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGB0ZXh0YCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tVGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIGEgYEZ1bmN0aW9uQ2FsbGAgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbUZ1bmN0aW9uQ2FsbChuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnVuY3Rpb25DYWxsOiB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIGEgYEZ1bmN0aW9uUmVzcG9uc2VgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21GdW5jdGlvblJlc3BvbnNlKGlkLCBuYW1lLCByZXNwb25zZSwgcGFydHMgPSBbXSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZ1bmN0aW9uUmVzcG9uc2U6IE9iamVjdC5hc3NpZ24oeyBpZDogaWQsIG5hbWU6IG5hbWUsIHJlc3BvbnNlOiByZXNwb25zZSB9LCAocGFydHMubGVuZ3RoID4gMCAmJiB7IHBhcnRzIH0pKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIGEgYGJhc2U2NGAgZW5jb2RlZCBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21CYXNlNjQoZGF0YSwgbWltZVR5cGUsIG1lZGlhUmVzb2x1dGlvbikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgaW5saW5lRGF0YToge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZSxcbiAgICAgICAgfSB9LCAobWVkaWFSZXNvbHV0aW9uICYmIHsgbWVkaWFSZXNvbHV0aW9uOiB7IGxldmVsOiBtZWRpYVJlc29sdXRpb24gfSB9KSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gdGhlIGBvdXRjb21lYCBhbmQgYG91dHB1dGAgb2YgYSBgQ29kZUV4ZWN1dGlvblJlc3VsdGAgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbUNvZGVFeGVjdXRpb25SZXN1bHQob3V0Y29tZSwgb3V0cHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZUV4ZWN1dGlvblJlc3VsdDoge1xuICAgICAgICAgICAgb3V0Y29tZTogb3V0Y29tZSxcbiAgICAgICAgICAgIG91dHB1dDogb3V0cHV0LFxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gdGhlIGBjb2RlYCBhbmQgYGxhbmd1YWdlYCBvZiBhbiBgRXhlY3V0YWJsZUNvZGVgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21FeGVjdXRhYmxlQ29kZShjb2RlLCBsYW5ndWFnZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGV4ZWN1dGFibGVDb2RlOiB7XG4gICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlLFxuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBfaXNQYXJ0KG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICgnZmlsZURhdGEnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ3RleHQnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2Z1bmN0aW9uQ2FsbCcgaW4gb2JqIHx8XG4gICAgICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScgaW4gb2JqIHx8XG4gICAgICAgICAgICAnaW5saW5lRGF0YScgaW4gb2JqIHx8XG4gICAgICAgICAgICAndmlkZW9NZXRhZGF0YScgaW4gb2JqIHx8XG4gICAgICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcgaW4gb2JqIHx8XG4gICAgICAgICAgICAnZXhlY3V0YWJsZUNvZGUnIGluIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIF90b1BhcnRzKHBhcnRPclN0cmluZykge1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgaWYgKHR5cGVvZiBwYXJ0T3JTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhcnRzLnB1c2goY3JlYXRlUGFydEZyb21UZXh0KHBhcnRPclN0cmluZykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChfaXNQYXJ0KHBhcnRPclN0cmluZykpIHtcbiAgICAgICAgcGFydHMucHVzaChwYXJ0T3JTdHJpbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhcnRPclN0cmluZykpIHtcbiAgICAgICAgaWYgKHBhcnRPclN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFydE9yU3RyaW5nIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0T3JTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGNyZWF0ZVBhcnRGcm9tVGV4dChwYXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfaXNQYXJ0KHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZWxlbWVudCBpbiBQYXJ0VW5pb24gbXVzdCBiZSBhIFBhcnQgb2JqZWN0IG9yIHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRPclN0cmluZyBtdXN0IGJlIGEgUGFydCBvYmplY3QsIHN0cmluZywgb3IgYXJyYXknKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYENvbnRlbnRgIG9iamVjdCB3aXRoIGEgdXNlciByb2xlIGZyb20gYSBgUGFydExpc3RVbmlvbmAgb2JqZWN0IG9yIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVVc2VyQ29udGVudChwYXJ0T3JTdHJpbmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgIHBhcnRzOiBfdG9QYXJ0cyhwYXJ0T3JTdHJpbmcpLFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgQ29udGVudGAgb2JqZWN0IHdpdGggYSBtb2RlbCByb2xlIGZyb20gYSBgUGFydExpc3RVbmlvbmAgb2JqZWN0IG9yIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNb2RlbENvbnRlbnQocGFydE9yU3RyaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogJ21vZGVsJyxcbiAgICAgICAgcGFydHM6IF90b1BhcnRzKHBhcnRPclN0cmluZyksXG4gICAgfTtcbn1cbi8qKiBBIHdyYXBwZXIgY2xhc3MgZm9yIHRoZSBodHRwIHJlc3BvbnNlLiAqL1xuY2xhc3MgSHR0cFJlc3BvbnNlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgICAgICAvLyBQcm9jZXNzIHRoZSBoZWFkZXJzLlxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiByZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaGVhZGVyc1twYWlyWzBdXSA9IHBhaXJbMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgLy8gS2VlcCB0aGUgb3JpZ2luYWwgcmVzcG9uc2UuXG4gICAgICAgIHRoaXMucmVzcG9uc2VJbnRlcm5hbCA9IHJlc3BvbnNlO1xuICAgIH1cbiAgICBqc29uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZUludGVybmFsLmpzb24oKTtcbiAgICB9XG59XG4vKiogQ29udGVudCBmaWx0ZXIgcmVzdWx0cyBmb3IgYSBwcm9tcHQgc2VudCBpbiB0aGUgcmVxdWVzdC4gTm90ZTogVGhpcyBpcyBzZW50IG9ubHkgaW4gdGhlIGZpcnN0IHN0cmVhbSBjaHVuayBhbmQgb25seSBpZiBubyBjYW5kaWRhdGVzIHdlcmUgZ2VuZXJhdGVkIGR1ZSB0byBjb250ZW50IHZpb2xhdGlvbnMuICovXG5jbGFzcyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVByb21wdEZlZWRiYWNrIHtcbn1cbi8qKiBVc2FnZSBtZXRhZGF0YSBhYm91dCB0aGUgY29udGVudCBnZW5lcmF0aW9uIHJlcXVlc3QgYW5kIHJlc3BvbnNlLiBUaGlzIG1lc3NhZ2UgcHJvdmlkZXMgYSBkZXRhaWxlZCBicmVha2Rvd24gb2YgdG9rZW4gdXNhZ2UgYW5kIG90aGVyIHJlbGV2YW50IG1ldHJpY3MuIFRoaXMgZGF0YSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4gKi9cbmNsYXNzIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlVXNhZ2VNZXRhZGF0YSB7XG59XG4vKiogUmVzcG9uc2UgbWVzc2FnZSBmb3IgUHJlZGljdGlvblNlcnZpY2UuR2VuZXJhdGVDb250ZW50LiAqL1xuY2xhc3MgR2VuZXJhdGVDb250ZW50UmVzcG9uc2Uge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHQgcGFydHMgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgdGV4dCBmcm9tIHRoZSBmaXJzdFxuICAgICAqIG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBub24tdGV4dCBwYXJ0cyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0XG4gICAgICogcGFydHMgd2lsbCBiZSByZXR1cm5lZCwgYW5kIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgdGhvdWdodCBwYXJ0cyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0XG4gICAgICogcGFydHMgZXhjbHVkaW5nIHRoZSB0aG91Z2h0IHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50KHtcbiAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogICBjb250ZW50czpcbiAgICAgKiAgICAgJ1doeSBpcyB0aGUgc2t5IGJsdWU/JyxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUuZGVidWcocmVzcG9uc2UudGV4dCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgIGlmICgoKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmRpZGF0ZXMgJiYgdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgdGV4dCBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgbGV0IGFueVRleHRQYXJ0VGV4dCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBub25UZXh0UGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBbXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCBmaWVsZFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgIT09ICd0ZXh0JyAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWUgIT09ICd0aG91Z2h0JyAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWUgIT09ICd0aG91Z2h0U2lnbmF0dXJlJyAmJlxuICAgICAgICAgICAgICAgICAgICAoZmllbGRWYWx1ZSAhPT0gbnVsbCB8fCBmaWVsZFZhbHVlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vblRleHRQYXJ0cy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0LnRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0LnRob3VnaHQgPT09ICdib29sZWFuJyAmJiBwYXJ0LnRob3VnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFueVRleHRQYXJ0VGV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBwYXJ0LnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vblRleHRQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHRoZXJlIGFyZSBub24tdGV4dCBwYXJ0cyAke25vblRleHRQYXJ0c30gaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dCBwYXJ0cy4gUGxlYXNlIHJlZmVyIHRvIHRoZSBub24gdGV4dCBwYXJ0cyBmb3IgYSBmdWxsIHJlc3BvbnNlIGZyb20gbW9kZWwuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFydC50ZXh0ID09PSAnJyBpcyBkaWZmZXJlbnQgZnJvbSBwYXJ0LnRleHQgaXMgbnVsbFxuICAgICAgICByZXR1cm4gYW55VGV4dFBhcnRUZXh0ID8gdGV4dCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaW5saW5lIGRhdGEgcGFydHMgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlXG4gICAgICogaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBpbmxpbmUgZGF0YSBmcm9tIHRoZVxuICAgICAqIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLiBJZiB0aGVyZSBhcmUgbm9uLWlubGluZSBkYXRhIHBhcnRzIGluIHRoZVxuICAgICAqIHJlc3BvbnNlLCB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaW5saW5lIGRhdGEgcGFydHMgd2lsbCBiZSByZXR1cm5lZCwgYW5kXG4gICAgICogYSB3YXJuaW5nIHdpbGwgYmUgbG9nZ2VkLlxuICAgICAqL1xuICAgIGdldCBkYXRhKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGRhdGEgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gJyc7XG4gICAgICAgIGNvbnN0IG5vbkRhdGFQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9oID0gKF9nID0gKF9mID0gKF9lID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VbMF0pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jb250ZW50KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucGFydHMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IFtdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gJ2lubGluZURhdGEnICYmXG4gICAgICAgICAgICAgICAgICAgIChmaWVsZFZhbHVlICE9PSBudWxsIHx8IGZpZWxkVmFsdWUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uRGF0YVBhcnRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFydC5pbmxpbmVEYXRhICYmIHR5cGVvZiBwYXJ0LmlubGluZURhdGEuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkYXRhICs9IGF0b2IocGFydC5pbmxpbmVEYXRhLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub25EYXRhUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGB0aGVyZSBhcmUgbm9uLWRhdGEgcGFydHMgJHtub25EYXRhUGFydHN9IGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvbmNhdGVuYXRpb24gb2YgYWxsIGRhdGEgcGFydHMuIFBsZWFzZSByZWZlciB0byB0aGUgbm9uIGRhdGEgcGFydHMgZm9yIGEgZnVsbCByZXNwb25zZSBmcm9tIG1vZGVsLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA+IDAgPyBidG9hKGRhdGEpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmdW5jdGlvbiBjYWxscyBmcm9tIHRoZSBmaXJzdCBjYW5kaWRhdGUgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBmdW5jdGlvbiBjYWxscyBmcm9tXG4gICAgICogdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBubyBmdW5jdGlvbiBjYWxscyBpbiB0aGUgcmVzcG9uc2UsIHVuZGVmaW5lZCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNvbnRyb2xMaWdodEZ1bmN0aW9uRGVjbGFyYXRpb246IEZ1bmN0aW9uRGVjbGFyYXRpb24gPSB7XG4gICAgICogICBuYW1lOiAnY29udHJvbExpZ2h0JyxcbiAgICAgKiAgIHBhcmFtZXRlcnM6IHtcbiAgICAgKiAgIHR5cGU6IFR5cGUuT0JKRUNULFxuICAgICAqICAgZGVzY3JpcHRpb246ICdTZXQgdGhlIGJyaWdodG5lc3MgYW5kIGNvbG9yIHRlbXBlcmF0dXJlIG9mIGEgcm9vbSBsaWdodC4nLFxuICAgICAqICAgcHJvcGVydGllczoge1xuICAgICAqICAgICBicmlnaHRuZXNzOiB7XG4gICAgICogICAgICAgdHlwZTogVHlwZS5OVU1CRVIsXG4gICAgICogICAgICAgZGVzY3JpcHRpb246XG4gICAgICogICAgICAgICAnTGlnaHQgbGV2ZWwgZnJvbSAwIHRvIDEwMC4gWmVybyBpcyBvZmYgYW5kIDEwMCBpcyBmdWxsIGJyaWdodG5lc3MuJyxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgY29sb3JUZW1wZXJhdHVyZToge1xuICAgICAqICAgICAgIHR5cGU6IFR5cGUuU1RSSU5HLFxuICAgICAqICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAqICAgICAgICAgJ0NvbG9yIHRlbXBlcmF0dXJlIG9mIHRoZSBsaWdodCBmaXh0dXJlIHdoaWNoIGNhbiBiZSBgZGF5bGlnaHRgLCBgY29vbGAgb3IgYHdhcm1gLicsXG4gICAgICogICAgIH0sXG4gICAgICogICB9LFxuICAgICAqICAgcmVxdWlyZWQ6IFsnYnJpZ2h0bmVzcycsICdjb2xvclRlbXBlcmF0dXJlJ10sXG4gICAgICogIH07XG4gICAgICogIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogICAgIGNvbnRlbnRzOiAnRGltIHRoZSBsaWdodHMgc28gdGhlIHJvb20gZmVlbHMgY296eSBhbmQgd2FybS4nLFxuICAgICAqICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICB0b29sczogW3tmdW5jdGlvbkRlY2xhcmF0aW9uczogW2NvbnRyb2xMaWdodEZ1bmN0aW9uRGVjbGFyYXRpb25dfV0sXG4gICAgICogICAgICAgdG9vbENvbmZpZzoge1xuICAgICAqICAgICAgICAgZnVuY3Rpb25DYWxsaW5nQ29uZmlnOiB7XG4gICAgICogICAgICAgICAgIG1vZGU6IEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUuQU5ZLFxuICAgICAqICAgICAgICAgICBhbGxvd2VkRnVuY3Rpb25OYW1lczogWydjb250cm9sTGlnaHQnXSxcbiAgICAgKiAgICAgICAgIH0sXG4gICAgICogICAgICAgfSxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgIH0pO1xuICAgICAqICBjb25zb2xlLmRlYnVnKEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgZnVuY3Rpb25DYWxscygpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgaWYgKCgoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wYXJ0cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlcyAmJiB0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBmdW5jdGlvbiBjYWxscyBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxscyA9IChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LmZ1bmN0aW9uQ2FsbCkubWFwKChwYXJ0KSA9PiBwYXJ0LmZ1bmN0aW9uQ2FsbCkuZmlsdGVyKChmdW5jdGlvbkNhbGwpID0+IGZ1bmN0aW9uQ2FsbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKChmdW5jdGlvbkNhbGxzID09PSBudWxsIHx8IGZ1bmN0aW9uQ2FsbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZ1bmN0aW9uQ2FsbHMubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb25DYWxscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgZXhlY3V0YWJsZSBjb2RlIGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZSBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgdGhlIGV4ZWN1dGFibGUgY29kZSBmcm9tXG4gICAgICogdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBubyBleGVjdXRhYmxlIGNvZGUgaW4gdGhlIHJlc3BvbnNlLCB1bmRlZmluZWQgd2lsbCBiZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICAgY29udGVudHM6XG4gICAgICogICAgICdXaGF0IGlzIHRoZSBzdW0gb2YgdGhlIGZpcnN0IDUwIHByaW1lIG51bWJlcnM/IEdlbmVyYXRlIGFuZCBydW4gY29kZSBmb3IgdGhlIGNhbGN1bGF0aW9uLCBhbmQgbWFrZSBzdXJlIHlvdSBnZXQgYWxsIDUwLidcbiAgICAgKiAgIGNvbmZpZzoge1xuICAgICAqICAgICB0b29sczogW3tjb2RlRXhlY3V0aW9uOiB7fX1dLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUuZGVidWcocmVzcG9uc2UuZXhlY3V0YWJsZUNvZGUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBleGVjdXRhYmxlQ29kZSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2o7XG4gICAgICAgIGlmICgoKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmRpZGF0ZXMgJiYgdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgZXhlY3V0YWJsZSBjb2RlIGZyb20gdGhlIGZpcnN0IG9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGVjdXRhYmxlQ29kZSA9IChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LmV4ZWN1dGFibGVDb2RlKS5tYXAoKHBhcnQpID0+IHBhcnQuZXhlY3V0YWJsZUNvZGUpLmZpbHRlcigoZXhlY3V0YWJsZUNvZGUpID0+IGV4ZWN1dGFibGVDb2RlICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoKGV4ZWN1dGFibGVDb2RlID09PSBudWxsIHx8IGV4ZWN1dGFibGVDb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGVjdXRhYmxlQ29kZS5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2ogPSBleGVjdXRhYmxlQ29kZSA9PT0gbnVsbCB8fCBleGVjdXRhYmxlQ29kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhlY3V0YWJsZUNvZGVbMF0pID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5jb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjb2RlIGV4ZWN1dGlvbiByZXN1bHQgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgY29kZSBleGVjdXRpb24gcmVzdWx0IGZyb21cbiAgICAgKiB0aGUgZmlyc3Qgb25lIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogSWYgdGhlcmUgYXJlIG5vIGNvZGUgZXhlY3V0aW9uIHJlc3VsdCBpbiB0aGUgcmVzcG9uc2UsIHVuZGVmaW5lZCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICAgY29udGVudHM6XG4gICAgICogICAgICdXaGF0IGlzIHRoZSBzdW0gb2YgdGhlIGZpcnN0IDUwIHByaW1lIG51bWJlcnM/IEdlbmVyYXRlIGFuZCBydW4gY29kZSBmb3IgdGhlIGNhbGN1bGF0aW9uLCBhbmQgbWFrZSBzdXJlIHlvdSBnZXQgYWxsIDUwLidcbiAgICAgKiAgIGNvbmZpZzoge1xuICAgICAqICAgICB0b29sczogW3tjb2RlRXhlY3V0aW9uOiB7fX1dLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUuZGVidWcocmVzcG9uc2UuY29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGNvZGVFeGVjdXRpb25SZXN1bHQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvZGUgZXhlY3V0aW9uIHJlc3VsdCBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZUV4ZWN1dGlvblJlc3VsdCA9IChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LmNvZGVFeGVjdXRpb25SZXN1bHQpLm1hcCgocGFydCkgPT4gcGFydC5jb2RlRXhlY3V0aW9uUmVzdWx0KS5maWx0ZXIoKGNvZGVFeGVjdXRpb25SZXN1bHQpID0+IGNvZGVFeGVjdXRpb25SZXN1bHQgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICgoY29kZUV4ZWN1dGlvblJlc3VsdCA9PT0gbnVsbCB8fCBjb2RlRXhlY3V0aW9uUmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2RlRXhlY3V0aW9uUmVzdWx0Lmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChfaiA9IGNvZGVFeGVjdXRpb25SZXN1bHQgPT09IG51bGwgfHwgY29kZUV4ZWN1dGlvblJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29kZUV4ZWN1dGlvblJlc3VsdFswXSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLm91dHB1dDtcbiAgICB9XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSBlbWJlZF9jb250ZW50IG1ldGhvZC4gKi9cbmNsYXNzIEVtYmVkQ29udGVudFJlc3BvbnNlIHtcbn1cbi8qKiBUaGUgb3V0cHV0IGltYWdlcyByZXNwb25zZS4gKi9cbmNsYXNzIEdlbmVyYXRlSW1hZ2VzUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgcmVxdWVzdCB0byBlZGl0IGFuIGltYWdlLiAqL1xuY2xhc3MgRWRpdEltYWdlUmVzcG9uc2Uge1xufVxuY2xhc3MgVXBzY2FsZUltYWdlUmVzcG9uc2Uge1xufVxuLyoqIFRoZSBvdXRwdXQgaW1hZ2VzIHJlc3BvbnNlLiAqL1xuY2xhc3MgUmVjb250ZXh0SW1hZ2VSZXNwb25zZSB7XG59XG4vKiogVGhlIG91dHB1dCBpbWFnZXMgcmVzcG9uc2UuICovXG5jbGFzcyBTZWdtZW50SW1hZ2VSZXNwb25zZSB7XG59XG5jbGFzcyBMaXN0TW9kZWxzUmVzcG9uc2Uge1xufVxuY2xhc3MgRGVsZXRlTW9kZWxSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIGNvdW50aW5nIHRva2Vucy4gKi9cbmNsYXNzIENvdW50VG9rZW5zUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciBjb21wdXRpbmcgdG9rZW5zLiAqL1xuY2xhc3MgQ29tcHV0ZVRva2Vuc1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSB3aXRoIGdlbmVyYXRlZCB2aWRlb3MuICovXG5jbGFzcyBHZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlIHtcbn1cbi8qKiBBIHZpZGVvIGdlbmVyYXRpb24gb3BlcmF0aW9uLiAqL1xuY2xhc3MgR2VuZXJhdGVWaWRlb3NPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhbiBPcGVyYXRpb24gb2YgdGhlIHNhbWUgdHlwZSBhcyB0aGUgb25lIGJlaW5nIGNhbGxlZCB3aXRoIHRoZSBmaWVsZHMgc2V0IGZyb20gdGhlIEFQSSByZXNwb25zZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfZnJvbUFQSVJlc3BvbnNlKHsgYXBpUmVzcG9uc2UsIF9pc1ZlcnRleEFJLCB9KSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IG5ldyBHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbigpO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IG9wID0gYXBpUmVzcG9uc2U7XG4gICAgICAgIGlmIChfaXNWZXJ0ZXhBSSkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21WZXJ0ZXgkMShvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbU1sZGV2JDEob3ApO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3BlcmF0aW9uLCByZXNwb25zZSk7XG4gICAgICAgIHJldHVybiBvcGVyYXRpb247XG4gICAgfVxufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgbGlzdCB0dW5pbmcgam9icyBtZXRob2QuICovXG5jbGFzcyBMaXN0VHVuaW5nSm9ic1Jlc3BvbnNlIHtcbn1cbi8qKiBFbXB0eSByZXNwb25zZSBmb3IgdHVuaW5ncy5jYW5jZWwgbWV0aG9kLiAqL1xuY2xhc3MgQ2FuY2VsVHVuaW5nSm9iUmVzcG9uc2Uge1xufVxuLyoqIEVtcHR5IHJlc3BvbnNlIGZvciBjYWNoZXMuZGVsZXRlIG1ldGhvZC4gKi9cbmNsYXNzIERlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZSB7XG59XG5jbGFzcyBMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBkb2N1bWVudHMubGlzdCByZXR1cm4gdmFsdWUuICovXG5jbGFzcyBMaXN0RG9jdW1lbnRzUmVzcG9uc2Uge1xufVxuLyoqIENvbmZpZyBmb3IgZmlsZV9zZWFyY2hfc3RvcmVzLmxpc3QgcmV0dXJuIHZhbHVlLiAqL1xuY2xhc3MgTGlzdEZpbGVTZWFyY2hTdG9yZXNSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSByZXN1bWFibGUgdXBsb2FkIG1ldGhvZC4gKi9cbmNsYXNzIFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzdW1hYmxlUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciBJbXBvcnRGaWxlIHRvIGltcG9ydCBhIEZpbGUgQVBJIGZpbGUgd2l0aCBhIGZpbGUgc2VhcmNoIHN0b3JlLiAqL1xuY2xhc3MgSW1wb3J0RmlsZVJlc3BvbnNlIHtcbn1cbi8qKiBMb25nLXJ1bm5pbmcgb3BlcmF0aW9uIGZvciBpbXBvcnRpbmcgYSBmaWxlIHRvIGEgRmlsZVNlYXJjaFN0b3JlLiAqL1xuY2xhc3MgSW1wb3J0RmlsZU9wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGFuIE9wZXJhdGlvbiBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBvbmUgYmVpbmcgY2FsbGVkIHdpdGggdGhlIGZpZWxkcyBzZXQgZnJvbSB0aGUgQVBJIHJlc3BvbnNlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9mcm9tQVBJUmVzcG9uc2UoeyBhcGlSZXNwb25zZSwgX2lzVmVydGV4QUksIH0pIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gbmV3IEltcG9ydEZpbGVPcGVyYXRpb24oKTtcbiAgICAgICAgY29uc3Qgb3AgPSBhcGlSZXNwb25zZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBpbXBvcnRGaWxlT3BlcmF0aW9uRnJvbU1sZGV2JDEob3ApO1xuICAgICAgICBPYmplY3QuYXNzaWduKG9wZXJhdGlvbiwgcmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uO1xuICAgIH1cbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGxpc3QgZmlsZXMgbWV0aG9kLiAqL1xuY2xhc3MgTGlzdEZpbGVzUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgY3JlYXRlIGZpbGUgbWV0aG9kLiAqL1xuY2xhc3MgQ3JlYXRlRmlsZVJlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGRlbGV0ZSBmaWxlIG1ldGhvZC4gKi9cbmNsYXNzIERlbGV0ZUZpbGVSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSBfcmVnaXN0ZXIgZmlsZSBtZXRob2QuICovXG5jbGFzcyBSZWdpc3RlckZpbGVzUmVzcG9uc2Uge1xufVxuLyoqIENvbmZpZyBmb3IgYGlubGluZWRfcmVzcG9uc2VzYCBwYXJhbWV0ZXIuICovXG5jbGFzcyBJbmxpbmVkUmVzcG9uc2Uge1xufVxuLyoqIENvbmZpZyBmb3IgYHJlc3BvbnNlYCBwYXJhbWV0ZXIuICovXG5jbGFzcyBTaW5nbGVFbWJlZENvbnRlbnRSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBgaW5saW5lZF9lbWJlZGRpbmdfcmVzcG9uc2VzYCBwYXJhbWV0ZXIuICovXG5jbGFzcyBJbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2Uge1xufVxuLyoqIENvbmZpZyBmb3IgYmF0Y2hlcy5saXN0IHJldHVybiB2YWx1ZS4gKi9cbmNsYXNzIExpc3RCYXRjaEpvYnNSZXNwb25zZSB7XG59XG4vKiogUmVwcmVzZW50cyBhIHNpbmdsZSByZXNwb25zZSBpbiBhIHJlcGxheS4gKi9cbmNsYXNzIFJlcGxheVJlc3BvbnNlIHtcbn1cbi8qKiBBIHJhdyByZWZlcmVuY2UgaW1hZ2UuXG5cbkEgcmF3IHJlZmVyZW5jZSBpbWFnZSByZXByZXNlbnRzIHRoZSBiYXNlIGltYWdlIHRvIGVkaXQsIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLlxuSXQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvdmlkZWQgaW4gYWRkaXRpb24gdG8gYSBtYXNrIHJlZmVyZW5jZSBpbWFnZSBvclxuYSBzdHlsZSByZWZlcmVuY2UgaW1hZ2UuICovXG5jbGFzcyBSYXdSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfUkFXJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VJbWFnZUFQSTtcbiAgICB9XG59XG4vKiogQSBtYXNrIHJlZmVyZW5jZSBpbWFnZS5cblxuVGhpcyBlbmNhcHN1bGF0ZXMgZWl0aGVyIGEgbWFzayBpbWFnZSBwcm92aWRlZCBieSB0aGUgdXNlciBhbmQgY29uZmlncyBmb3JcbnRoZSB1c2VyIHByb3ZpZGVkIG1hc2ssIG9yIG9ubHkgY29uZmlnIHBhcmFtZXRlcnMgZm9yIHRoZSBtb2RlbCB0byBnZW5lcmF0ZVxuYSBtYXNrLlxuXG5BIG1hc2sgaW1hZ2UgaXMgYW4gaW1hZ2Ugd2hvc2Ugbm9uLXplcm8gdmFsdWVzIGluZGljYXRlIHdoZXJlIHRvIGVkaXQgdGhlIGJhc2VcbmltYWdlLiBJZiB0aGUgdXNlciBwcm92aWRlcyBhIG1hc2sgaW1hZ2UsIHRoZSBtYXNrIG11c3QgYmUgaW4gdGhlIHNhbWVcbmRpbWVuc2lvbnMgYXMgdGhlIHJhdyBpbWFnZS4gKi9cbmNsYXNzIE1hc2tSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfTUFTSycsXG4gICAgICAgICAgICByZWZlcmVuY2VJbWFnZTogdGhpcy5yZWZlcmVuY2VJbWFnZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiB0aGlzLnJlZmVyZW5jZUlkLFxuICAgICAgICAgICAgbWFza0ltYWdlQ29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIGNvbnRyb2wgcmVmZXJlbmNlIGltYWdlLlxuXG5UaGUgaW1hZ2Ugb2YgdGhlIGNvbnRyb2wgcmVmZXJlbmNlIGltYWdlIGlzIGVpdGhlciBhIGNvbnRyb2wgaW1hZ2UgcHJvdmlkZWRcbmJ5IHRoZSB1c2VyLCBvciBhIHJlZ3VsYXIgaW1hZ2Ugd2hpY2ggdGhlIGJhY2tlbmQgd2lsbCB1c2UgdG8gZ2VuZXJhdGUgYVxuY29udHJvbCBpbWFnZSBvZi4gSW4gdGhlIGNhc2Ugb2YgdGhlIGxhdHRlciwgdGhlXG5lbmFibGVfY29udHJvbF9pbWFnZV9jb21wdXRhdGlvbiBmaWVsZCBpbiB0aGUgY29uZmlnIHNob3VsZCBiZSBzZXQgdG8gVHJ1ZS5cblxuQSBjb250cm9sIGltYWdlIGlzIGFuIGltYWdlIHRoYXQgcmVwcmVzZW50cyBhIHNrZXRjaCBpbWFnZSBvZiBhcmVhcyBmb3IgdGhlXG5tb2RlbCB0byBmaWxsIGluIGJhc2VkIG9uIHRoZSBwcm9tcHQuICovXG5jbGFzcyBDb250cm9sUmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qKiBJbnRlcm5hbCBtZXRob2QgdG8gY29udmVydCB0byBSZWZlcmVuY2VJbWFnZUFQSUludGVybmFsLiAqL1xuICAgIHRvUmVmZXJlbmNlSW1hZ2VBUEkoKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUltYWdlQVBJID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlVHlwZTogJ1JFRkVSRU5DRV9UWVBFX0NPTlRST0wnLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgICAgIGNvbnRyb2xJbWFnZUNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VJbWFnZUFQSTtcbiAgICB9XG59XG4vKiogQSBzdHlsZSByZWZlcmVuY2UgaW1hZ2UuXG5cblRoaXMgZW5jYXBzdWxhdGVzIGEgc3R5bGUgcmVmZXJlbmNlIGltYWdlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLCBhbmRcbmFkZGl0aW9uYWxseSBvcHRpb25hbCBjb25maWcgcGFyYW1ldGVycyBmb3IgdGhlIHN0eWxlIHJlZmVyZW5jZSBpbWFnZS5cblxuQSByYXcgcmVmZXJlbmNlIGltYWdlIGNhbiBhbHNvIGJlIHByb3ZpZGVkIGFzIGEgZGVzdGluYXRpb24gZm9yIHRoZSBzdHlsZSB0b1xuYmUgYXBwbGllZCB0by4gKi9cbmNsYXNzIFN0eWxlUmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qKiBJbnRlcm5hbCBtZXRob2QgdG8gY29udmVydCB0byBSZWZlcmVuY2VJbWFnZUFQSUludGVybmFsLiAqL1xuICAgIHRvUmVmZXJlbmNlSW1hZ2VBUEkoKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUltYWdlQVBJID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlVHlwZTogJ1JFRkVSRU5DRV9UWVBFX1NUWUxFJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgICAgICBzdHlsZUltYWdlQ29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIHN1YmplY3QgcmVmZXJlbmNlIGltYWdlLlxuXG5UaGlzIGVuY2Fwc3VsYXRlcyBhIHN1YmplY3QgcmVmZXJlbmNlIGltYWdlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLCBhbmRcbmFkZGl0aW9uYWxseSBvcHRpb25hbCBjb25maWcgcGFyYW1ldGVycyBmb3IgdGhlIHN1YmplY3QgcmVmZXJlbmNlIGltYWdlLlxuXG5BIHJhdyByZWZlcmVuY2UgaW1hZ2UgY2FuIGFsc28gYmUgcHJvdmlkZWQgYXMgYSBkZXN0aW5hdGlvbiBmb3IgdGhlIHN1YmplY3QgdG9cbmJlIGFwcGxpZWQgdG8uICovXG5jbGFzcyBTdWJqZWN0UmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfU1VCSkVDVCcsXG4gICAgICAgICAgICByZWZlcmVuY2VJbWFnZTogdGhpcy5yZWZlcmVuY2VJbWFnZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiB0aGlzLnJlZmVyZW5jZUlkLFxuICAgICAgICAgICAgc3ViamVjdEltYWdlQ29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIGNvbnRlbnQgcmVmZXJlbmNlIGltYWdlLlxuXG5BIGNvbnRlbnQgcmVmZXJlbmNlIGltYWdlIHJlcHJlc2VudHMgYSBzdWJqZWN0IHRvIHJlZmVyZW5jZSAoZXguIHBlcnNvbixcbnByb2R1Y3QsIGFuaW1hbCkgcHJvdmlkZWQgYnkgdGhlIHVzZXIuIEl0IGNhbiBvcHRpb25hbGx5IGJlIHByb3ZpZGVkIGluXG5hZGRpdGlvbiB0byBhIHN0eWxlIHJlZmVyZW5jZSBpbWFnZSAoZXguIGJhY2tncm91bmQsIHN0eWxlIHJlZmVyZW5jZSkuICovXG5jbGFzcyBDb250ZW50UmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qKiBJbnRlcm5hbCBtZXRob2QgdG8gY29udmVydCB0byBSZWZlcmVuY2VJbWFnZUFQSUludGVybmFsLiAqL1xuICAgIHRvUmVmZXJlbmNlSW1hZ2VBUEkoKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUltYWdlQVBJID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlVHlwZTogJ1JFRkVSRU5DRV9UWVBFX0NPTlRFTlQnLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBSZXNwb25zZSBtZXNzYWdlIGZvciBBUEkgY2FsbC4gKi9cbmNsYXNzIExpdmVTZXJ2ZXJNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0IHBhcnRzIGZyb20gdGhlIHNlcnZlciBjb250ZW50IGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBub24tdGV4dCBwYXJ0cyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0XG4gICAgICogcGFydHMgd2lsbCBiZSByZXR1cm5lZCwgYW5kIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgIGxldCBhbnlUZXh0UGFydEZvdW5kID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG5vblRleHRQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9jID0gKF9iID0gKF9hID0gdGhpcy5zZXJ2ZXJDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW9kZWxUdXJuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGFydHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gJ3RleHQnICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSAhPT0gJ3Rob3VnaHQnICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uVGV4dFBhcnRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQudGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQudGhvdWdodCA9PT0gJ2Jvb2xlYW4nICYmIHBhcnQudGhvdWdodCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW55VGV4dFBhcnRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBwYXJ0LnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vblRleHRQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHRoZXJlIGFyZSBub24tdGV4dCBwYXJ0cyAke25vblRleHRQYXJ0c30gaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dCBwYXJ0cy4gUGxlYXNlIHJlZmVyIHRvIHRoZSBub24gdGV4dCBwYXJ0cyBmb3IgYSBmdWxsIHJlc3BvbnNlIGZyb20gbW9kZWwuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFydC50ZXh0ID09PSAnJyBpcyBkaWZmZXJlbnQgZnJvbSBwYXJ0LnRleHQgaXMgbnVsbFxuICAgICAgICByZXR1cm4gYW55VGV4dFBhcnRGb3VuZCA/IHRleHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGlubGluZSBkYXRhIHBhcnRzIGZyb20gdGhlIHNlcnZlciBjb250ZW50IGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBub24taW5saW5lIGRhdGEgcGFydHMgaW4gdGhlXG4gICAgICogcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCBpbmxpbmUgZGF0YSBwYXJ0cyB3aWxsIGJlIHJldHVybmVkLCBhbmRcbiAgICAgKiBhIHdhcm5pbmcgd2lsbCBiZSBsb2dnZWQuXG4gICAgICovXG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBsZXQgZGF0YSA9ICcnO1xuICAgICAgICBjb25zdCBub25EYXRhUGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIChfYyA9IChfYiA9IChfYSA9IHRoaXMuc2VydmVyQ29udGVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vZGVsVHVybikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBhcnRzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCBmaWVsZFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgIT09ICdpbmxpbmVEYXRhJyAmJiBmaWVsZFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vbkRhdGFQYXJ0cy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnQuaW5saW5lRGF0YSAmJiB0eXBlb2YgcGFydC5pbmxpbmVEYXRhLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGF0YSArPSBhdG9iKHBhcnQuaW5saW5lRGF0YS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uRGF0YVBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdGhlcmUgYXJlIG5vbi1kYXRhIHBhcnRzICR7bm9uRGF0YVBhcnRzfSBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb25jYXRlbmF0aW9uIG9mIGFsbCBkYXRhIHBhcnRzLiBQbGVhc2UgcmVmZXIgdG8gdGhlIG5vbiBkYXRhIHBhcnRzIGZvciBhIGZ1bGwgcmVzcG9uc2UgZnJvbSBtb2RlbC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGggPiAwID8gYnRvYShkYXRhKSA6IHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKiogQ2xpZW50IGdlbmVyYXRlZCByZXNwb25zZSB0byBhIGBUb29sQ2FsbGAgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLlxuXG5JbmRpdmlkdWFsIGBGdW5jdGlvblJlc3BvbnNlYCBvYmplY3RzIGFyZSBtYXRjaGVkIHRvIHRoZSByZXNwZWN0aXZlXG5gRnVuY3Rpb25DYWxsYCBvYmplY3RzIGJ5IHRoZSBgaWRgIGZpZWxkLlxuXG5Ob3RlIHRoYXQgaW4gdGhlIHVuYXJ5IGFuZCBzZXJ2ZXItc3RyZWFtaW5nIEdlbmVyYXRlQ29udGVudCBBUElzIGZ1bmN0aW9uXG5jYWxsaW5nIGhhcHBlbnMgYnkgZXhjaGFuZ2luZyB0aGUgYENvbnRlbnRgIHBhcnRzLCB3aGlsZSBpbiB0aGUgYmlkaVxuR2VuZXJhdGVDb250ZW50IEFQSXMgZnVuY3Rpb24gY2FsbGluZyBoYXBwZW5zIG92ZXIgdGhpcyBkZWRpY2F0ZWQgc2V0IG9mXG5tZXNzYWdlcy4gKi9cbmNsYXNzIExpdmVDbGllbnRUb29sUmVzcG9uc2Uge1xufVxuLyoqIFBhcmFtZXRlcnMgZm9yIHNlbmRpbmcgdG9vbCByZXNwb25zZXMgdG8gdGhlIGxpdmUgQVBJLiAqL1xuY2xhc3MgTGl2ZVNlbmRUb29sUmVzcG9uc2VQYXJhbWV0ZXJzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqIFRvb2wgcmVzcG9uc2VzIHRvIHNlbmQgdG8gdGhlIHNlc3Npb24uICovXG4gICAgICAgIHRoaXMuZnVuY3Rpb25SZXNwb25zZXMgPSBbXTtcbiAgICB9XG59XG4vKiogUmVzcG9uc2UgbWVzc2FnZSBmb3IgdGhlIExpdmVNdXNpY0NsaWVudE1lc3NhZ2UgY2FsbC4gKi9cbmNsYXNzIExpdmVNdXNpY1NlcnZlck1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGF1ZGlvIGNodW5rIGZyb20gdGhlIHNlcnZlciBjb250ZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gYXVkaW8gY2h1bmtzIGluIHRoZSByZXNwb25zZSwgdW5kZWZpbmVkIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICovXG4gICAgZ2V0IGF1ZGlvQ2h1bmsoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlcnZlckNvbnRlbnQgJiZcbiAgICAgICAgICAgIHRoaXMuc2VydmVyQ29udGVudC5hdWRpb0NodW5rcyAmJlxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJDb250ZW50LmF1ZGlvQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcnZlckNvbnRlbnQuYXVkaW9DaHVua3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKiogVGhlIHJlc3BvbnNlIHdoZW4gbG9uZy1ydW5uaW5nIG9wZXJhdGlvbiBmb3IgdXBsb2FkaW5nIGEgZmlsZSB0byBhIEZpbGVTZWFyY2hTdG9yZSBjb21wbGV0ZS4gKi9cbmNsYXNzIFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzcG9uc2Uge1xufVxuLyoqIExvbmctcnVubmluZyBvcGVyYXRpb24gZm9yIHVwbG9hZGluZyBhIGZpbGUgdG8gYSBGaWxlU2VhcmNoU3RvcmUuICovXG5jbGFzcyBVcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZU9wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGFuIE9wZXJhdGlvbiBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBvbmUgYmVpbmcgY2FsbGVkIHdpdGggdGhlIGZpZWxkcyBzZXQgZnJvbSB0aGUgQVBJIHJlc3BvbnNlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9mcm9tQVBJUmVzcG9uc2UoeyBhcGlSZXNwb25zZSwgX2lzVmVydGV4QUksIH0pIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gbmV3IFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlT3BlcmF0aW9uKCk7XG4gICAgICAgIGNvbnN0IG9wID0gYXBpUmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVPcGVyYXRpb25Gcm9tTWxkZXYob3ApO1xuICAgICAgICBPYmplY3QuYXNzaWduKG9wZXJhdGlvbiwgcmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gdE1vZGVsKGFwaUNsaWVudCwgbW9kZWwpIHtcbiAgICBpZiAoIW1vZGVsIHx8IHR5cGVvZiBtb2RlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlbCBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAobW9kZWwuaW5jbHVkZXMoJy4uJykgfHwgbW9kZWwuaW5jbHVkZXMoJz8nKSB8fCBtb2RlbC5pbmNsdWRlcygnJicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBtb2RlbCBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoJ3B1Ymxpc2hlcnMvJykgfHxcbiAgICAgICAgICAgIG1vZGVsLnN0YXJ0c1dpdGgoJ3Byb2plY3RzLycpIHx8XG4gICAgICAgICAgICBtb2RlbC5zdGFydHNXaXRoKCdtb2RlbHMvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2RlbC5pbmRleE9mKCcvJykgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBtb2RlbC5zcGxpdCgnLycsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGBwdWJsaXNoZXJzLyR7cGFydHNbMF19L21vZGVscy8ke3BhcnRzWzFdfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYHB1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy8ke21vZGVsfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtb2RlbC5zdGFydHNXaXRoKCdtb2RlbHMvJykgfHwgbW9kZWwuc3RhcnRzV2l0aCgndHVuZWRNb2RlbHMvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgbW9kZWxzLyR7bW9kZWx9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRDYWNoZXNNb2RlbChhcGlDbGllbnQsIG1vZGVsKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRNb2RlbCA9IHRNb2RlbChhcGlDbGllbnQsIG1vZGVsKTtcbiAgICBpZiAoIXRyYW5zZm9ybWVkTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtZWRNb2RlbC5zdGFydHNXaXRoKCdwdWJsaXNoZXJzLycpICYmIGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgLy8gdmVydGV4IGNhY2hlcyBvbmx5IHN1cHBvcnQgbW9kZWwgbmFtZSBzdGFydCB3aXRoIHByb2plY3RzLlxuICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7YXBpQ2xpZW50LmdldFByb2plY3QoKX0vbG9jYXRpb25zLyR7YXBpQ2xpZW50LmdldExvY2F0aW9uKCl9LyR7dHJhbnNmb3JtZWRNb2RlbH1gO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm1lZE1vZGVsLnN0YXJ0c1dpdGgoJ21vZGVscy8nKSAmJiBhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIHJldHVybiBgcHJvamVjdHMvJHthcGlDbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHthcGlDbGllbnQuZ2V0TG9jYXRpb24oKX0vcHVibGlzaGVycy9nb29nbGUvJHt0cmFuc2Zvcm1lZE1vZGVsfWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRNb2RlbDtcbiAgICB9XG59XG5mdW5jdGlvbiB0QmxvYnMoYmxvYnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShibG9icykpIHtcbiAgICAgICAgcmV0dXJuIGJsb2JzLm1hcCgoYmxvYikgPT4gdEJsb2IoYmxvYikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt0QmxvYihibG9icyldO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRCbG9iKGJsb2IpIHtcbiAgICBpZiAodHlwZW9mIGJsb2IgPT09ICdvYmplY3QnICYmIGJsb2IgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGJsb2I7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIGlucHV0IGFzIEJsb2IuIFVuc3VwcG9ydGVkIGJsb2IgdHlwZTogJHt0eXBlb2YgYmxvYn1gKTtcbn1cbmZ1bmN0aW9uIHRJbWFnZUJsb2IoYmxvYikge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkQmxvYiA9IHRCbG9iKGJsb2IpO1xuICAgIGlmICh0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUgJiZcbiAgICAgICAgdHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlLnN0YXJ0c1dpdGgoJ2ltYWdlLycpKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZEJsb2I7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbWltZSB0eXBlOiAke3RyYW5zZm9ybWVkQmxvYi5taW1lVHlwZX1gKTtcbn1cbmZ1bmN0aW9uIHRBdWRpb0Jsb2IoYmxvYikge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkQmxvYiA9IHRCbG9iKGJsb2IpO1xuICAgIGlmICh0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUgJiZcbiAgICAgICAgdHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlLnN0YXJ0c1dpdGgoJ2F1ZGlvLycpKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZEJsb2I7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbWltZSB0eXBlOiAke3RyYW5zZm9ybWVkQmxvYi5taW1lVHlwZX1gKTtcbn1cbmZ1bmN0aW9uIHRQYXJ0KG9yaWdpbikge1xuICAgIGlmIChvcmlnaW4gPT09IG51bGwgfHwgb3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJ0VW5pb24gaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3JpZ2luID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4geyB0ZXh0OiBvcmlnaW4gfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJ0IHR5cGU6ICR7dHlwZW9mIG9yaWdpbn1gKTtcbn1cbmZ1bmN0aW9uIHRQYXJ0cyhvcmlnaW4pIHtcbiAgICBpZiAob3JpZ2luID09PSBudWxsIHx8XG4gICAgICAgIG9yaWdpbiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIChBcnJheS5pc0FycmF5KG9yaWdpbikgJiYgb3JpZ2luLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJ0TGlzdFVuaW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9yaWdpbikpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbi5tYXAoKGl0ZW0pID0+IHRQYXJ0KGl0ZW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIFt0UGFydChvcmlnaW4pXTtcbn1cbmZ1bmN0aW9uIF9pc0NvbnRlbnQob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3BhcnRzJyBpbiBvcmlnaW4gJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShvcmlnaW4ucGFydHMpKTtcbn1cbmZ1bmN0aW9uIF9pc0Z1bmN0aW9uQ2FsbFBhcnQob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbCcgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIF9pc0Z1bmN0aW9uUmVzcG9uc2VQYXJ0KG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyBpbiBvcmlnaW4pO1xufVxuZnVuY3Rpb24gdENvbnRlbnQob3JpZ2luKSB7XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCB8fCBvcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRlbnRVbmlvbiBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoX2lzQ29udGVudChvcmlnaW4pKSB7XG4gICAgICAgIC8vIF9pc0NvbnRlbnQgaXMgYSB1dGlsaXR5IGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZVxuICAgICAgICAvLyBvcmlnaW4gaXMgYSBDb250ZW50LlxuICAgICAgICByZXR1cm4gb3JpZ2luO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgIHBhcnRzOiB0UGFydHMob3JpZ2luKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdENvbnRlbnRzRm9yRW1iZWQoYXBpQ2xpZW50LCBvcmlnaW4pIHtcbiAgICBpZiAoIW9yaWdpbikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpICYmIEFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gb3JpZ2luLmZsYXRNYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0Q29udGVudChpdGVtKTtcbiAgICAgICAgICAgIGlmIChjb250ZW50LnBhcnRzICYmXG4gICAgICAgICAgICAgICAgY29udGVudC5wYXJ0cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgY29udGVudC5wYXJ0c1swXS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2NvbnRlbnQucGFydHNbMF0udGV4dF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0Q29udGVudChvcmlnaW4pO1xuICAgICAgICBpZiAoY29udGVudC5wYXJ0cyAmJlxuICAgICAgICAgICAgY29udGVudC5wYXJ0cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBjb250ZW50LnBhcnRzWzBdLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtjb250ZW50LnBhcnRzWzBdLnRleHRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gb3JpZ2luLm1hcCgoaXRlbSkgPT4gdENvbnRlbnQoaXRlbSkpO1xuICAgIH1cbiAgICByZXR1cm4gW3RDb250ZW50KG9yaWdpbildO1xufVxuZnVuY3Rpb24gdENvbnRlbnRzKG9yaWdpbikge1xuICAgIGlmIChvcmlnaW4gPT09IG51bGwgfHxcbiAgICAgICAgb3JpZ2luID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkob3JpZ2luKSAmJiBvcmlnaW4ubGVuZ3RoID09PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnRlbnRzIGFyZSByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xuICAgICAgICAvLyBJZiBpdCdzIG5vdCBhbiBhcnJheSwgaXQncyBhIHNpbmdsZSBjb250ZW50IG9yIGEgc2luZ2xlIFBhcnRVbmlvbi5cbiAgICAgICAgaWYgKF9pc0Z1bmN0aW9uQ2FsbFBhcnQob3JpZ2luKSB8fCBfaXNGdW5jdGlvblJlc3BvbnNlUGFydChvcmlnaW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIHNwZWNpZnkgZnVuY3Rpb25DYWxsIG9yIGZ1bmN0aW9uUmVzcG9uc2UgcGFydHMsIHBsZWFzZSB3cmFwIHRoZW0gaW4gYSBDb250ZW50IG9iamVjdCwgc3BlY2lmeWluZyB0aGUgcm9sZSBmb3IgdGhlbScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdENvbnRlbnQob3JpZ2luKV07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IGFjY3VtdWxhdGVkUGFydHMgPSBbXTtcbiAgICBjb25zdCBpc0NvbnRlbnRBcnJheSA9IF9pc0NvbnRlbnQob3JpZ2luWzBdKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygb3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IGlzQ29udGVudCA9IF9pc0NvbnRlbnQoaXRlbSk7XG4gICAgICAgIGlmIChpc0NvbnRlbnQgIT0gaXNDb250ZW50QXJyYXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWl4aW5nIENvbnRlbnQgYW5kIFBhcnRzIGlzIG5vdCBzdXBwb3J0ZWQsIHBsZWFzZSBncm91cCB0aGUgcGFydHMgaW50byBhIHRoZSBhcHByb3ByaWF0ZSBDb250ZW50IG9iamVjdHMgYW5kIHNwZWNpZnkgdGhlIHJvbGVzIGZvciB0aGVtJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ29udGVudCkge1xuICAgICAgICAgICAgLy8gYGlzQ29udGVudGAgY29udGFpbnMgdGhlIHJlc3VsdCBvZiBfaXNDb250ZW50LCB3aGljaCBpcyBhIHV0aWxpdHlcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZSBpdGVtIGlzIGEgQ29udGVudC5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9pc0Z1bmN0aW9uQ2FsbFBhcnQoaXRlbSkgfHwgX2lzRnVuY3Rpb25SZXNwb25zZVBhcnQoaXRlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG8gc3BlY2lmeSBmdW5jdGlvbkNhbGwgb3IgZnVuY3Rpb25SZXNwb25zZSBwYXJ0cywgcGxlYXNlIHdyYXAgdGhlbSwgYW5kIGFueSBvdGhlciBwYXJ0cywgaW4gQ29udGVudCBvYmplY3RzIGFzIGFwcHJvcHJpYXRlLCBzcGVjaWZ5aW5nIHRoZSByb2xlIGZvciB0aGVtJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlZFBhcnRzLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0NvbnRlbnRBcnJheSkge1xuICAgICAgICByZXN1bHQucHVzaCh7IHJvbGU6ICd1c2VyJywgcGFydHM6IHRQYXJ0cyhhY2N1bXVsYXRlZFBhcnRzKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qXG5UcmFuc2Zvcm0gdGhlIHR5cGUgZmllbGQgZnJvbSBhbiBhcnJheSBvZiB0eXBlcyB0byBhbiBhcnJheSBvZiBhbnlPZiBmaWVsZHMuXG5FeGFtcGxlOlxuICB7dHlwZTogWydTVFJJTkcnLCAnTlVNQkVSJ119XG53aWxsIGJlIHRyYW5zZm9ybWVkIHRvXG4gIHthbnlPZjogW3t0eXBlOiAnU1RSSU5HJ30sIHt0eXBlOiAnTlVNQkVSJ31dfVxuKi9cbmZ1bmN0aW9uIGZsYXR0ZW5UeXBlQXJyYXlUb0FueU9mKHR5cGVMaXN0LCByZXN1bHRpbmdTY2hlbWEpIHtcbiAgICBpZiAodHlwZUxpc3QuaW5jbHVkZXMoJ251bGwnKSkge1xuICAgICAgICByZXN1bHRpbmdTY2hlbWFbJ251bGxhYmxlJ10gPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBsaXN0V2l0aG91dE51bGwgPSB0eXBlTGlzdC5maWx0ZXIoKHR5cGUpID0+IHR5cGUgIT09ICdudWxsJyk7XG4gICAgaWYgKGxpc3RXaXRob3V0TnVsbC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmVzdWx0aW5nU2NoZW1hWyd0eXBlJ10gPSBPYmplY3QudmFsdWVzKFR5cGUpLmluY2x1ZGVzKGxpc3RXaXRob3V0TnVsbFswXS50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgPyBsaXN0V2l0aG91dE51bGxbMF0udG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgOiBUeXBlLlRZUEVfVU5TUEVDSUZJRUQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHRpbmdTY2hlbWFbJ2FueU9mJ10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIGxpc3RXaXRob3V0TnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0aW5nU2NoZW1hWydhbnlPZiddLnB1c2goe1xuICAgICAgICAgICAgICAgICd0eXBlJzogT2JqZWN0LnZhbHVlcyhUeXBlKS5pbmNsdWRlcyhpLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgICAgID8gaS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIDogVHlwZS5UWVBFX1VOU1BFQ0lGSUVELFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzSnNvblNjaGVtYShfanNvblNjaGVtYSkge1xuICAgIGNvbnN0IGdlbkFJU2NoZW1hID0ge307XG4gICAgY29uc3Qgc2NoZW1hRmllbGROYW1lcyA9IFsnaXRlbXMnXTtcbiAgICBjb25zdCBsaXN0U2NoZW1hRmllbGROYW1lcyA9IFsnYW55T2YnXTtcbiAgICBjb25zdCBkaWN0U2NoZW1hRmllbGROYW1lcyA9IFsncHJvcGVydGllcyddO1xuICAgIGlmIChfanNvblNjaGVtYVsndHlwZSddICYmIF9qc29uU2NoZW1hWydhbnlPZiddKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHlwZSBhbmQgYW55T2YgY2Fubm90IGJlIGJvdGggcG9wdWxhdGVkLicpO1xuICAgIH1cbiAgICAvKlxuICAgIFRoaXMgaXMgdG8gaGFuZGxlIHRoZSBudWxsYWJsZSBhcnJheSBvciBvYmplY3QuIFRoZSBfanNvblNjaGVtYSB3aWxsXG4gICAgYmUgaW4gdGhlIGZvcm1hdCBvZiB7YW55T2Y6IFt7dHlwZTogJ251bGwnfSwge3R5cGU6ICdvYmplY3QnfV19LiBUaGVcbiAgICBsb2dpYyBpcyB0byBjaGVjayBpZiBhbnlPZiBoYXMgMiBlbGVtZW50cyBhbmQgb25lIG9mIHRoZSBlbGVtZW50IGlzIG51bGwsXG4gICAgaWYgc28sIHRoZSBhbnlPZiBmaWVsZCBpcyB1bm5lY2Vzc2FyeSwgc28gd2UgbmVlZCB0byBnZXQgcmlkIG9mIHRoZSBhbnlPZlxuICAgIGZpZWxkIGFuZCBtYWtlIHRoZSBzY2hlbWEgbnVsbGFibGUuIFRoZW4gdXNlIHRoZSBvdGhlciBlbGVtZW50IGFzIHRoZSBuZXdcbiAgICBfanNvblNjaGVtYSBmb3IgcHJvY2Vzc2luZy4gVGhpcyBpcyBiZWNhdXNlIHRoZSBiYWNrZW5kIGRvZXNuJ3QgaGF2ZSBhIG51bGxcbiAgICB0eXBlLlxuICAgIFRoaXMgaGFzIHRvIGJlIGNoZWNrZWQgYmVmb3JlIHdlIHByb2Nlc3MgYW55IG90aGVyIGZpZWxkcy5cbiAgICBGb3IgZXhhbXBsZTpcbiAgICAgIGNvbnN0IG9iamVjdE51bGxhYmxlID0gei5vYmplY3Qoe1xuICAgICAgICBudWxsYWJsZUFycmF5OiB6LmFycmF5KHouc3RyaW5nKCkpLm51bGxhYmxlKCksXG4gICAgICB9KTtcbiAgICBXaWxsIGhhdmUgdGhlIHJhdyBfanNvblNjaGVtYSBhczpcbiAgICB7XG4gICAgICB0eXBlOiAnT0JKRUNUJyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBudWxsYWJsZUFycmF5OiB7XG4gICAgICAgICAgICAgYW55T2Y6IFtcbiAgICAgICAgICAgICAgICB7dHlwZTogJ251bGwnfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgaXRlbXM6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IFsgJ251bGxhYmxlQXJyYXknIF0sXG4gICAgfVxuICAgIFdpbGwgcmVzdWx0IGluIGZvbGxvd2luZyBzY2hlbWEgY29tcGF0aWJsZSB3aXRoIEdlbWluaSBBUEk6XG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdPQkpFQ1QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgIG51bGxhYmxlQXJyYXk6IHtcbiAgICAgICAgICAgICAgbnVsbGFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6ICdBUlJBWScsXG4gICAgICAgICAgICAgIGl0ZW1zOiB7dHlwZTogJ3N0cmluZyd9LFxuICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVkOiBbICdudWxsYWJsZUFycmF5JyBdLFxuICAgICAgfVxuICAgICovXG4gICAgY29uc3QgaW5jb21pbmdBbnlPZiA9IF9qc29uU2NoZW1hWydhbnlPZiddO1xuICAgIGlmIChpbmNvbWluZ0FueU9mICE9IG51bGwgJiYgaW5jb21pbmdBbnlPZi5sZW5ndGggPT0gMikge1xuICAgICAgICBpZiAoaW5jb21pbmdBbnlPZlswXVsndHlwZSddID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIGdlbkFJU2NoZW1hWydudWxsYWJsZSddID0gdHJ1ZTtcbiAgICAgICAgICAgIF9qc29uU2NoZW1hID0gaW5jb21pbmdBbnlPZlsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmNvbWluZ0FueU9mWzFdWyd0eXBlJ10gPT09ICdudWxsJykge1xuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbJ251bGxhYmxlJ10gPSB0cnVlO1xuICAgICAgICAgICAgX2pzb25TY2hlbWEgPSBpbmNvbWluZ0FueU9mWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChfanNvblNjaGVtYVsndHlwZSddIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZmxhdHRlblR5cGVBcnJheVRvQW55T2YoX2pzb25TY2hlbWFbJ3R5cGUnXSwgZ2VuQUlTY2hlbWEpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKF9qc29uU2NoZW1hKSkge1xuICAgICAgICAvLyBTa2lwIGlmIHRoZSBmaWVsZHZhbHVlIGlzIHVuZGVmaW5lZCBvciBudWxsLlxuICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGROYW1lID09ICd0eXBlJykge1xuICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHlwZTogbnVsbCBjYW4gbm90IGJlIHRoZSBvbmx5IHBvc3NpYmxlIHR5cGUgZm9yIHRoZSBmaWVsZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWVsZFZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZCB0aGUgdHlwZSBmaWVsZCB3aXRoIGFycmF5IG9mIHR5cGVzIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIGJlZ2lubmluZyBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbJ3R5cGUnXSA9IE9iamVjdC52YWx1ZXMoVHlwZSkuaW5jbHVkZXMoZmllbGRWYWx1ZS50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgICAgID8gZmllbGRWYWx1ZS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgOiBUeXBlLlRZUEVfVU5TUEVDSUZJRUQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NoZW1hRmllbGROYW1lcy5pbmNsdWRlcyhmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVtmaWVsZE5hbWVdID1cbiAgICAgICAgICAgICAgICBwcm9jZXNzSnNvblNjaGVtYShmaWVsZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaXN0U2NoZW1hRmllbGROYW1lcy5pbmNsdWRlcyhmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0U2NoZW1hRmllbGRWYWx1ZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGZpZWxkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVsndHlwZSddID09ICdudWxsJykge1xuICAgICAgICAgICAgICAgICAgICBnZW5BSVNjaGVtYVsnbnVsbGFibGUnXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0U2NoZW1hRmllbGRWYWx1ZS5wdXNoKHByb2Nlc3NKc29uU2NoZW1hKGl0ZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbkFJU2NoZW1hW2ZpZWxkTmFtZV0gPVxuICAgICAgICAgICAgICAgIGxpc3RTY2hlbWFGaWVsZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpY3RTY2hlbWFGaWVsZE5hbWVzLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpY3RTY2hlbWFGaWVsZFZhbHVlID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRpY3RTY2hlbWFGaWVsZFZhbHVlW2tleV0gPSBwcm9jZXNzSnNvblNjaGVtYSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVtmaWVsZE5hbWVdID1cbiAgICAgICAgICAgICAgICBkaWN0U2NoZW1hRmllbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFkZGl0aW9uYWxQcm9wZXJ0aWVzIGlzIG5vdCBpbmNsdWRlZCBpbiBKU09OU2NoZW1hLCBza2lwcGluZyBpdC5cbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgPT09ICdhZGRpdGlvbmFsUHJvcGVydGllcycpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbkFJU2NoZW1hW2ZpZWxkTmFtZV0gPSBmaWVsZFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZW5BSVNjaGVtYTtcbn1cbi8vIHdlIHRha2UgdGhlIHVua25vd24gaW4gdGhlIHNjaGVtYSBmaWVsZCBiZWNhdXNlIHdlIHdhbnQgZW5hYmxlIHVzZXIgdG8gcGFzc1xuLy8gdGhlIG91dHB1dCBvZiBtYWpvciBzY2hlbWEgZGVjbGFyYXRpb24gdG9vbHMgd2l0aG91dCBjYXN0aW5nLiBUb29scyBzdWNoIGFzXG4vLyB6b2RUb0pzb25TY2hlbWEsIHR5cGVib3gsIHpvZFRvSnNvblNjaGVtYSBmdW5jdGlvbiBjYW4gcmV0dXJuIEpzb25TY2hlbWE3VHlwZVxuLy8gb3Igb2JqZWN0LCBzZWUgZGV0YWlscyBpblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1N0ZWZhblRlcmRlbGwvem9kLXRvLWpzb24tc2NoZW1hL2Jsb2IvNzA1MjVlZmU1NTVjZDIyNjY5MWUwOTNkMTcxMzcwYTNiMTA5MjFkMS9zcmMvem9kVG9Kc29uU2NoZW1hLnRzI0w3XG4vLyB0eXBlYm94IGNhbiByZXR1cm4gdW5rbm93biwgc2VlIGRldGFpbHMgaW5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5jbGFpcnp4ODEvdHlwZWJveC9ibG9iLzVhNTQzMTQzOWY3ZDVjYTZiNDk0ZDBkMThmYmZkN2IxYTM1NmQ2N2Mvc3JjL3R5cGUvY3JlYXRlL3R5cGUudHMjTDM1XG4vLyBOb3RlOiBwcm9wZXIganNvbiBzY2hlbWFzIHdpdGggdGhlICRzY2hlbWEgZmllbGQgc2V0IG5ldmVyIGFycml2ZSB0byB0aGlzXG4vLyB0cmFuc2Zvcm1lci4gU2NoZW1hcyB3aXRoICRzY2hlbWEgYXJlIHJvdXRlZCB0byB0aGUgZXF1aXZhbGVudCBBUEkganNvblxuLy8gc2NoZW1hIGZpZWxkLlxuZnVuY3Rpb24gdFNjaGVtYShzY2hlbWEpIHtcbiAgICByZXR1cm4gcHJvY2Vzc0pzb25TY2hlbWEoc2NoZW1hKTtcbn1cbmZ1bmN0aW9uIHRTcGVlY2hDb25maWcoc3BlZWNoQ29uZmlnKSB7XG4gICAgaWYgKHR5cGVvZiBzcGVlY2hDb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBzcGVlY2hDb25maWc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzcGVlY2hDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2b2ljZUNvbmZpZzoge1xuICAgICAgICAgICAgICAgIHByZWJ1aWx0Vm9pY2VDb25maWc6IHtcbiAgICAgICAgICAgICAgICAgICAgdm9pY2VOYW1lOiBzcGVlY2hDb25maWcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHNwZWVjaENvbmZpZyB0eXBlOiAke3R5cGVvZiBzcGVlY2hDb25maWd9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdExpdmVTcGVlY2hDb25maWcoc3BlZWNoQ29uZmlnKSB7XG4gICAgaWYgKCdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZycgaW4gc3BlZWNoQ29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXVsdGlTcGVha2VyVm9pY2VDb25maWcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgbGl2ZSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiBzcGVlY2hDb25maWc7XG59XG5mdW5jdGlvbiB0VG9vbCh0b29sKSB7XG4gICAgaWYgKHRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmdW5jdGlvbkRlY2xhcmF0aW9uIG9mIHRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycykuaW5jbHVkZXMoJyRzY2hlbWEnKSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnMgPSBwcm9jZXNzSnNvblNjaGVtYShmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnNKc29uU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnNKc29uU2NoZW1hID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZnVuY3Rpb25EZWNsYXJhdGlvbi5wYXJhbWV0ZXJzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2UpLmluY2x1ZGVzKCckc2NoZW1hJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSA9IHByb2Nlc3NKc29uU2NoZW1hKGZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlSnNvblNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZUpzb25TY2hlbWEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9vbDtcbn1cbmZ1bmN0aW9uIHRUb29scyh0b29scykge1xuICAgIC8vIENoZWNrIGlmIHRoZSBpbmNvbWluZyB0eXBlIGlzIGRlZmluZWQuXG4gICAgaWYgKHRvb2xzID09PSB1bmRlZmluZWQgfHwgdG9vbHMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29scyBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodG9vbHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndG9vbHMgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYW4gYXJyYXkgb2YgVG9vbHMnKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCB0b29sIG9mIHRvb2xzKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRvb2wpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBQcmVwZW5kcyByZXNvdXJjZSBuYW1lIHdpdGggcHJvamVjdCwgbG9jYXRpb24sIHJlc291cmNlX3ByZWZpeCBpZiBuZWVkZWQuXG4gKlxuICogQHBhcmFtIGNsaWVudCBUaGUgQVBJIGNsaWVudC5cbiAqIEBwYXJhbSByZXNvdXJjZU5hbWUgVGhlIHJlc291cmNlIG5hbWUuXG4gKiBAcGFyYW0gcmVzb3VyY2VQcmVmaXggVGhlIHJlc291cmNlIHByZWZpeC5cbiAqIEBwYXJhbSBzcGxpdHNBZnRlclByZWZpeCBUaGUgbnVtYmVyIG9mIHNwbGl0cyBhZnRlciB0aGUgcHJlZml4LlxuICogQHJldHVybnMgVGhlIGNvbXBsZXRlZCByZXNvdXJjZSBuYW1lLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICcxMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gVHJ1ZVxuICogY2xpZW50LnByb2plY3QgPSAnYmFyJ1xuICogY2xpZW50LmxvY2F0aW9uID0gJ3VzLXdlc3QxJ1xuICogX3Jlc291cmNlX25hbWUoY2xpZW50LCByZXNvdXJjZV9uYW1lLCByZXNvdXJjZV9wcmVmaXgsIHNwbGl0c19hZnRlcl9wcmVmaXgpXG4gKiByZXR1cm5zOiAncHJvamVjdHMvYmFyL2xvY2F0aW9ucy91cy13ZXN0MS9jYWNoZWRDb250ZW50cy8xMjMnXG4gKiBgYGBcbiAqXG4gKiBgYGBcbiAqIHJlc291cmNlX25hbWUgPSAncHJvamVjdHMvZm9vL2xvY2F0aW9ucy91cy1jZW50cmFsMS9jYWNoZWRDb250ZW50cy8xMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gVHJ1ZVxuICogY2xpZW50LnByb2plY3QgPSAnYmFyJ1xuICogY2xpZW50LmxvY2F0aW9uID0gJ3VzLXdlc3QxJ1xuICogX3Jlc291cmNlX25hbWUoY2xpZW50LCByZXNvdXJjZV9uYW1lLCByZXNvdXJjZV9wcmVmaXgsIHNwbGl0c19hZnRlcl9wcmVmaXgpXG4gKiByZXR1cm5zOiAncHJvamVjdHMvZm9vL2xvY2F0aW9ucy91cy1jZW50cmFsMS9jYWNoZWRDb250ZW50cy8xMjMnXG4gKiBgYGBcbiAqXG4gKiBgYGBcbiAqIHJlc291cmNlX25hbWUgPSAnMTIzJ1xuICogcmVzb3VyY2VfcHJlZml4ID0gJ2NhY2hlZENvbnRlbnRzJ1xuICogc3BsaXRzX2FmdGVyX3ByZWZpeCA9IDFcbiAqIGNsaWVudC52ZXJ0ZXhhaSA9IEZhbHNlXG4gKiBfcmVzb3VyY2VfbmFtZShjbGllbnQsIHJlc291cmNlX25hbWUsIHJlc291cmNlX3ByZWZpeCwgc3BsaXRzX2FmdGVyX3ByZWZpeClcbiAqIHJldHVybnMgJ2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICdzb21lL3dyb25nL2NhY2hlZENvbnRlbnRzL3Jlc291cmNlL25hbWUvMTIzJ1xuICogcmVzb3VyY2VfcHJlZml4ID0gJ2NhY2hlZENvbnRlbnRzJ1xuICogc3BsaXRzX2FmdGVyX3ByZWZpeCA9IDFcbiAqIGNsaWVudC52ZXJ0ZXhhaSA9IEZhbHNlXG4gKiAjIGNsaWVudC52ZXJ0ZXhhaSA9IFRydWVcbiAqIF9yZXNvdXJjZV9uYW1lKGNsaWVudCwgcmVzb3VyY2VfbmFtZSwgcmVzb3VyY2VfcHJlZml4LCBzcGxpdHNfYWZ0ZXJfcHJlZml4KVxuICogLT4gJ3NvbWUvd3JvbmcvcmVzb3VyY2UvbmFtZS8xMjMnXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gcmVzb3VyY2VOYW1lKGNsaWVudCwgcmVzb3VyY2VOYW1lLCByZXNvdXJjZVByZWZpeCwgc3BsaXRzQWZ0ZXJQcmVmaXggPSAxKSB7XG4gICAgY29uc3Qgc2hvdWxkQXBwZW5kUHJlZml4ID0gIXJlc291cmNlTmFtZS5zdGFydHNXaXRoKGAke3Jlc291cmNlUHJlZml4fS9gKSAmJlxuICAgICAgICByZXNvdXJjZU5hbWUuc3BsaXQoJy8nKS5sZW5ndGggPT09IHNwbGl0c0FmdGVyUHJlZml4O1xuICAgIGlmIChjbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIGlmIChyZXNvdXJjZU5hbWUuc3RhcnRzV2l0aCgncHJvamVjdHMvJykpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzb3VyY2VOYW1lLnN0YXJ0c1dpdGgoJ2xvY2F0aW9ucy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGBwcm9qZWN0cy8ke2NsaWVudC5nZXRQcm9qZWN0KCl9LyR7cmVzb3VyY2VOYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzb3VyY2VOYW1lLnN0YXJ0c1dpdGgoYCR7cmVzb3VyY2VQcmVmaXh9L2ApKSB7XG4gICAgICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7Y2xpZW50LmdldFByb2plY3QoKX0vbG9jYXRpb25zLyR7Y2xpZW50LmdldExvY2F0aW9uKCl9LyR7cmVzb3VyY2VOYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2hvdWxkQXBwZW5kUHJlZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7Y2xpZW50LmdldFByb2plY3QoKX0vbG9jYXRpb25zLyR7Y2xpZW50LmdldExvY2F0aW9uKCl9LyR7cmVzb3VyY2VQcmVmaXh9LyR7cmVzb3VyY2VOYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb3VyY2VOYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRBcHBlbmRQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIGAke3Jlc291cmNlUHJlZml4fS8ke3Jlc291cmNlTmFtZX1gO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb3VyY2VOYW1lO1xufVxuZnVuY3Rpb24gdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgbmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduYW1lIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc291cmNlTmFtZShhcGlDbGllbnQsIG5hbWUsICdjYWNoZWRDb250ZW50cycpO1xufVxuZnVuY3Rpb24gdFR1bmluZ0pvYlN0YXR1cyhzdGF0dXMpIHtcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICBjYXNlICdTVEFURV9VTlNQRUNJRklFRCc6XG4gICAgICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9VTlNQRUNJRklFRCc7XG4gICAgICAgIGNhc2UgJ0NSRUFUSU5HJzpcbiAgICAgICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1JVTk5JTkcnO1xuICAgICAgICBjYXNlICdBQ1RJVkUnOlxuICAgICAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfU1VDQ0VFREVEJztcbiAgICAgICAgY2FzZSAnRkFJTEVEJzpcbiAgICAgICAgICAgIHJldHVybiAnSk9CX1NUQVRFX0ZBSUxFRCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRCeXRlcyhmcm9tSW1hZ2VCeXRlcykge1xuICAgIHJldHVybiB0Qnl0ZXMkMShmcm9tSW1hZ2VCeXRlcyk7XG59XG5mdW5jdGlvbiBfaXNGaWxlKG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICduYW1lJyBpbiBvcmlnaW4pO1xufVxuZnVuY3Rpb24gaXNHZW5lcmF0ZWRWaWRlbyhvcmlnaW4pIHtcbiAgICByZXR1cm4gKG9yaWdpbiAhPT0gbnVsbCAmJlxuICAgICAgICBvcmlnaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAndmlkZW8nIGluIG9yaWdpbik7XG59XG5mdW5jdGlvbiBpc1ZpZGVvKG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICd1cmknIGluIG9yaWdpbik7XG59XG5mdW5jdGlvbiB0RmlsZU5hbWUoZnJvbU5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG5hbWU7XG4gICAgaWYgKF9pc0ZpbGUoZnJvbU5hbWUpKSB7XG4gICAgICAgIG5hbWUgPSBmcm9tTmFtZS5uYW1lO1xuICAgIH1cbiAgICBpZiAoaXNWaWRlbyhmcm9tTmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IGZyb21OYW1lLnVyaTtcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNHZW5lcmF0ZWRWaWRlbyhmcm9tTmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IChfYSA9IGZyb21OYW1lLnZpZGVvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXJpO1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZnJvbU5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBmcm9tTmFtZTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBleHRyYWN0IGZpbGUgbmFtZSBmcm9tIHRoZSBwcm92aWRlZCBpbnB1dC4nKTtcbiAgICB9XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkge1xuICAgICAgICBjb25zdCBzdWZmaXggPSBuYW1lLnNwbGl0KCdmaWxlcy8nKVsxXTtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBzdWZmaXgubWF0Y2goL1thLXowLTldKy8pO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGV4dHJhY3QgZmlsZSBuYW1lIGZyb20gVVJJICR7bmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gbWF0Y2hbMF07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aCgnZmlsZXMvJykpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUuc3BsaXQoJ2ZpbGVzLycpWzFdO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIHRNb2RlbHNVcmwoYXBpQ2xpZW50LCBiYXNlTW9kZWxzKSB7XG4gICAgbGV0IHJlcztcbiAgICBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICByZXMgPSBiYXNlTW9kZWxzID8gJ3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscycgOiAnbW9kZWxzJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcyA9IGJhc2VNb2RlbHMgPyAnbW9kZWxzJyA6ICd0dW5lZE1vZGVscyc7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB0RXh0cmFjdE1vZGVscyhyZXNwb25zZSkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFsnbW9kZWxzJywgJ3R1bmVkTW9kZWxzJywgJ3B1Ymxpc2hlck1vZGVscyddKSB7XG4gICAgICAgIGlmIChoYXNGaWVsZChyZXNwb25zZSwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gaGFzRmllbGQoZGF0YSwgZmllbGROYW1lKSB7XG4gICAgcmV0dXJuIGRhdGEgIT09IG51bGwgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGZpZWxkTmFtZSBpbiBkYXRhO1xufVxuZnVuY3Rpb24gbWNwVG9HZW1pbmlUb29sKG1jcFRvb2wsIGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgbWNwVG9vbFNjaGVtYSA9IG1jcFRvb2w7XG4gICAgY29uc3QgZnVuY3Rpb25EZWNsYXJhdGlvbiA9IHtcbiAgICAgICAgbmFtZTogbWNwVG9vbFNjaGVtYVsnbmFtZSddLFxuICAgICAgICBkZXNjcmlwdGlvbjogbWNwVG9vbFNjaGVtYVsnZGVzY3JpcHRpb24nXSxcbiAgICAgICAgcGFyYW1ldGVyc0pzb25TY2hlbWE6IG1jcFRvb2xTY2hlbWFbJ2lucHV0U2NoZW1hJ10sXG4gICAgfTtcbiAgICBpZiAobWNwVG9vbFNjaGVtYVsnb3V0cHV0U2NoZW1hJ10pIHtcbiAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvblsncmVzcG9uc2VKc29uU2NoZW1hJ10gPSBtY3BUb29sU2NoZW1hWydvdXRwdXRTY2hlbWEnXTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5iZWhhdmlvcikge1xuICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uWydiZWhhdmlvciddID0gY29uZmlnLmJlaGF2aW9yO1xuICAgIH1cbiAgICBjb25zdCBnZW1pbmlUb29sID0ge1xuICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgICAgICAgXSxcbiAgICB9O1xuICAgIHJldHVybiBnZW1pbmlUb29sO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGxpc3Qgb2YgTUNQIHRvb2xzIHRvIGEgc2luZ2xlIEdlbWluaSB0b29sIHdpdGggYSBsaXN0IG9mIGZ1bmN0aW9uXG4gKiBkZWNsYXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1jcFRvb2xzVG9HZW1pbmlUb29sKG1jcFRvb2xzLCBjb25maWcgPSB7fSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uRGVjbGFyYXRpb25zID0gW107XG4gICAgY29uc3QgdG9vbE5hbWVzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgbWNwVG9vbCBvZiBtY3BUb29scykge1xuICAgICAgICBjb25zdCBtY3BUb29sTmFtZSA9IG1jcFRvb2wubmFtZTtcbiAgICAgICAgaWYgKHRvb2xOYW1lcy5oYXMobWNwVG9vbE5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBmdW5jdGlvbiBuYW1lICR7bWNwVG9vbE5hbWV9IGZvdW5kIGluIE1DUCB0b29scy4gUGxlYXNlIGVuc3VyZSBmdW5jdGlvbiBuYW1lcyBhcmUgdW5pcXVlLmApO1xuICAgICAgICB9XG4gICAgICAgIHRvb2xOYW1lcy5hZGQobWNwVG9vbE5hbWUpO1xuICAgICAgICBjb25zdCBnZW1pbmlUb29sID0gbWNwVG9HZW1pbmlUb29sKG1jcFRvb2wsIGNvbmZpZyk7XG4gICAgICAgIGlmIChnZW1pbmlUb29sLmZ1bmN0aW9uRGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9ucy5wdXNoKC4uLmdlbWluaVRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGZ1bmN0aW9uRGVjbGFyYXRpb25zOiBmdW5jdGlvbkRlY2xhcmF0aW9ucyB9O1xufVxuLy8gVHJhbnNmb3JtcyBhIHNvdXJjZSBpbnB1dCBpbnRvIGEgQmF0Y2hKb2JTb3VyY2Ugb2JqZWN0IHdpdGggdmFsaWRhdGlvbi5cbmZ1bmN0aW9uIHRCYXRjaEpvYlNvdXJjZShjbGllbnQsIHNyYykge1xuICAgIGxldCBzb3VyY2VPYmo7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChjbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBpZiAoc3JjLnN0YXJ0c1dpdGgoJ2dzOi8vJykpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VPYmogPSB7IGZvcm1hdDogJ2pzb25sJywgZ2NzVXJpOiBbc3JjXSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3JjLnN0YXJ0c1dpdGgoJ2JxOi8vJykpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VPYmogPSB7IGZvcm1hdDogJ2JpZ3F1ZXJ5JywgYmlncXVlcnlVcmk6IHNyYyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBzdHJpbmcgc291cmNlIGZvciBWZXJ0ZXggQUk6ICR7c3JjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTUxERVZcbiAgICAgICAgICAgIGlmIChzcmMuc3RhcnRzV2l0aCgnZmlsZXMvJykpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VPYmogPSB7IGZpbGVOYW1lOiBzcmMgfTsgLy8gRGVmYXVsdCB0byBmaWxlTmFtZSBmb3Igc3RyaW5nIGlucHV0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHN0cmluZyBzb3VyY2UgZm9yIEdlbWluaSBBUEk6ICR7c3JjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgICAgICBpZiAoY2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmxpbmVkUmVxdWVzdFtdIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZU9iaiA9IHsgaW5saW5lZFJlcXVlc3RzOiBzcmMgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEl0J3MgYWxyZWFkeSBhIEJhdGNoSm9iU291cmNlIG9iamVjdFxuICAgICAgICBzb3VyY2VPYmogPSBzcmM7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRpb24gbG9naWNcbiAgICBjb25zdCB2ZXJ0ZXhTb3VyY2VzQ291bnQgPSBbc291cmNlT2JqLmdjc1VyaSwgc291cmNlT2JqLmJpZ3F1ZXJ5VXJpXS5maWx0ZXIoQm9vbGVhbikubGVuZ3RoO1xuICAgIGNvbnN0IG1sZGV2U291cmNlc0NvdW50ID0gW1xuICAgICAgICBzb3VyY2VPYmouaW5saW5lZFJlcXVlc3RzLFxuICAgICAgICBzb3VyY2VPYmouZmlsZU5hbWUsXG4gICAgXS5maWx0ZXIoQm9vbGVhbikubGVuZ3RoO1xuICAgIGlmIChjbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIGlmIChtbGRldlNvdXJjZXNDb3VudCA+IDAgfHwgdmVydGV4U291cmNlc0NvdW50ICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4YWN0bHkgb25lIG9mIGBnY3NVcmlgIG9yIGBiaWdxdWVyeVVyaWAgbXVzdCBiZSBzZXQgZm9yIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTUxERVZcbiAgICAgICAgaWYgKHZlcnRleFNvdXJjZXNDb3VudCA+IDAgfHwgbWxkZXZTb3VyY2VzQ291bnQgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhhY3RseSBvbmUgb2YgYGlubGluZWRSZXF1ZXN0c2AsIGBmaWxlTmFtZWAsICcgK1xuICAgICAgICAgICAgICAgICdtdXN0IGJlIHNldCBmb3IgR2VtaW5pIEFQSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlT2JqO1xufVxuZnVuY3Rpb24gdEJhdGNoSm9iRGVzdGluYXRpb24oZGVzdCkge1xuICAgIGlmICh0eXBlb2YgZGVzdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIGNvbnN0IGRlc3RTdHJpbmcgPSBkZXN0O1xuICAgIGlmIChkZXN0U3RyaW5nLnN0YXJ0c1dpdGgoJ2dzOi8vJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogJ2pzb25sJyxcbiAgICAgICAgICAgIGdjc1VyaTogZGVzdFN0cmluZyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVzdFN0cmluZy5zdGFydHNXaXRoKCdicTovLycpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6ICdiaWdxdWVyeScsXG4gICAgICAgICAgICBiaWdxdWVyeVVyaTogZGVzdFN0cmluZyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVzdGluYXRpb246ICR7ZGVzdFN0cmluZ31gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0UmVjdkJhdGNoSm9iRGVzdGluYXRpb24oZGVzdCkge1xuICAgIC8vIEVuc3VyZSBkZXN0IGlzIGEgbm9uLW51bGwgb2JqZWN0IGJlZm9yZSBwcm9jZWVkaW5nLlxuICAgIGlmICh0eXBlb2YgZGVzdCAhPT0gJ29iamVjdCcgfHwgZGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgbm90IGFuIG9iamVjdCwgaXQgY2Fubm90IGJlIGEgdmFsaWQgQmF0Y2hKb2JEZXN0aW5hdGlvblxuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgb3BlcmF0aW9ucyBwZXJmb3JtZWQuIFJldHVybiBpdCBjYXN0LCBvciBoYW5kbGUgYXMgYW4gZXJyb3IuXG4gICAgICAgIC8vIENhc3RpbmcgYW4gZW1wdHkgb2JqZWN0IG1pZ2h0IGJlIGEgc2FmZSBkZWZhdWx0LlxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIC8vIENhc3QgdG8gUmVjb3JkPHN0cmluZywgdW5rbm93bj4gdG8gYWxsb3cgc3RyaW5nIHByb3BlcnR5IGFjY2Vzcy5cbiAgICBjb25zdCBvYmogPSBkZXN0O1xuICAgIC8vIFNhZmVseSBhY2Nlc3MgbmVzdGVkIHByb3BlcnRpZXMuXG4gICAgY29uc3QgaW5saW5lUmVzcG9uc2VzVmFsID0gb2JqWydpbmxpbmVkUmVzcG9uc2VzJ107XG4gICAgaWYgKHR5cGVvZiBpbmxpbmVSZXNwb25zZXNWYWwgIT09ICdvYmplY3QnIHx8IGlubGluZVJlc3BvbnNlc1ZhbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgY29uc3QgaW5saW5lUmVzcG9uc2VzT2JqID0gaW5saW5lUmVzcG9uc2VzVmFsO1xuICAgIGNvbnN0IHJlc3BvbnNlc0FycmF5ID0gaW5saW5lUmVzcG9uc2VzT2JqWydpbmxpbmVkUmVzcG9uc2VzJ107XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3BvbnNlc0FycmF5KSB8fCByZXNwb25zZXNBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIGFueSByZXNwb25zZSBoYXMgdGhlICdlbWJlZGRpbmcnIHByb3BlcnR5LlxuICAgIGxldCBoYXNFbWJlZGRpbmcgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHJlc3BvbnNlSXRlbSBvZiByZXNwb25zZXNBcnJheSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlSXRlbSAhPT0gJ29iamVjdCcgfHwgcmVzcG9uc2VJdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZUl0ZW1PYmogPSByZXNwb25zZUl0ZW07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVmFsID0gcmVzcG9uc2VJdGVtT2JqWydyZXNwb25zZSddO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlVmFsICE9PSAnb2JqZWN0JyB8fCByZXNwb25zZVZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2VPYmogPSByZXNwb25zZVZhbDtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgdGhlICdlbWJlZGRpbmcnIGtleS5cbiAgICAgICAgaWYgKHJlc3BvbnNlT2JqWydlbWJlZGRpbmcnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoYXNFbWJlZGRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUGVyZm9ybSB0aGUgdHJhbnNmb3JtYXRpb24gaWYgYW4gZW1iZWRkaW5nIHdhcyBmb3VuZC5cbiAgICBpZiAoaGFzRW1iZWRkaW5nKSB7XG4gICAgICAgIG9ialsnaW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcyddID0gb2JqWydpbmxpbmVkUmVzcG9uc2VzJ107XG4gICAgICAgIGRlbGV0ZSBvYmpbJ2lubGluZWRSZXNwb25zZXMnXTtcbiAgICB9XG4gICAgLy8gQ2FzdCB0aGUgKHBvdGVudGlhbGx5KSBtb2RpZmllZCBvYmplY3QgdG8gdGhlIHRhcmdldCB0eXBlLlxuICAgIHJldHVybiBkZXN0O1xufVxuZnVuY3Rpb24gdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIG5hbWUpIHtcbiAgICBjb25zdCBuYW1lU3RyaW5nID0gbmFtZTtcbiAgICBpZiAoIWFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgY29uc3QgbWxkZXZQYXR0ZXJuID0gL2JhdGNoZXNcXC9bXi9dKyQvO1xuICAgICAgICBpZiAobWxkZXZQYXR0ZXJuLnRlc3QobmFtZVN0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lU3RyaW5nLnNwbGl0KCcvJykucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYmF0Y2ggam9iIG5hbWU6ICR7bmFtZVN0cmluZ30uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdmVydGV4UGF0dGVybiA9IC9ecHJvamVjdHNcXC9bXi9dK1xcL2xvY2F0aW9uc1xcL1teL10rXFwvYmF0Y2hQcmVkaWN0aW9uSm9ic1xcL1teL10rJC87XG4gICAgaWYgKHZlcnRleFBhdHRlcm4udGVzdChuYW1lU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gbmFtZVN0cmluZy5zcGxpdCgnLycpLnBvcCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICgvXlxcZCskLy50ZXN0KG5hbWVTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBuYW1lU3RyaW5nO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJhdGNoIGpvYiBuYW1lOiAke25hbWVTdHJpbmd9LmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRKb2JTdGF0ZShzdGF0ZSkge1xuICAgIGNvbnN0IHN0YXRlU3RyaW5nID0gc3RhdGU7XG4gICAgaWYgKHN0YXRlU3RyaW5nID09PSAnQkFUQ0hfU1RBVEVfVU5TUEVDSUZJRUQnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1VOU1BFQ0lGSUVEJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9QRU5ESU5HJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9QRU5ESU5HJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9SVU5OSU5HJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9SVU5OSU5HJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9TVUNDRUVERUQnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1NVQ0NFRURFRCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlU3RyaW5nID09PSAnQkFUQ0hfU1RBVEVfRkFJTEVEJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9GQUlMRUQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX0NBTkNFTExFRCcpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfQ0FOQ0VMTEVEJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9FWFBJUkVEJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9FWFBJUkVEJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzdGF0ZVN0cmluZztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIGJhdGNoSm9iRGVzdGluYXRpb25Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGVOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZXNGaWxlJ10pO1xuICAgIGlmIChmcm9tRmlsZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlTmFtZSddLCBmcm9tRmlsZU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lZFJlc3BvbnNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lubGluZWRSZXNwb25zZXMnLFxuICAgICAgICAnaW5saW5lZFJlc3BvbnNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmxpbmVkUmVzcG9uc2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21JbmxpbmVkUmVzcG9uc2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubGluZWRSZXNwb25zZUZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZWRSZXNwb25zZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzJyxcbiAgICAgICAgJ2lubGluZWRSZXNwb25zZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tSW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYkRlc3RpbmF0aW9uRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcmVkaWN0aW9uc0Zvcm1hdCddKTtcbiAgICBpZiAoZnJvbUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Zvcm1hdCddLCBmcm9tRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2djc0Rlc3RpbmF0aW9uJyxcbiAgICAgICAgJ291dHB1dFVyaVByZWZpeCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CaWdxdWVyeVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2JpZ3F1ZXJ5RGVzdGluYXRpb24nLFxuICAgICAgICAnb3V0cHV0VXJpJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUJpZ3F1ZXJ5VXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmlncXVlcnlVcmknXSwgZnJvbUJpZ3F1ZXJ5VXJpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JEZXN0aW5hdGlvblRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Gb3JtYXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Zvcm1hdCddKTtcbiAgICBpZiAoZnJvbUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWRpY3Rpb25zRm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NEZXN0aW5hdGlvbicsICdvdXRwdXRVcmlQcmVmaXgnXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CaWdxdWVyeVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmlncXVlcnlVcmknXSk7XG4gICAgaWYgKGZyb21CaWdxdWVyeVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JpZ3F1ZXJ5RGVzdGluYXRpb24nLCAnb3V0cHV0VXJpJ10sIGZyb21CaWdxdWVyeVVyaSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWxlTmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZWRSZXNwb25zZXMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lubGluZWRSZXNwb25zZXMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2Rpc3BsYXlOYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YScsICdzdGF0ZSddKTtcbiAgICBpZiAoZnJvbVN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGUnXSwgdEpvYlN0YXRlKGZyb21TdGF0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2NyZWF0ZVRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2VuZFRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ3VwZGF0ZVRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJywgJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCBmcm9tTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnLCAnb3V0cHV0J10pO1xuICAgIGlmIChmcm9tRGVzdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc3QnXSwgYmF0Y2hKb2JEZXN0aW5hdGlvbkZyb21NbGRldih0UmVjdkJhdGNoSm9iRGVzdGluYXRpb24oZnJvbURlc3QpKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGF0ZSddKTtcbiAgICBpZiAoZnJvbVN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGUnXSwgdEpvYlN0YXRlKGZyb21TdGF0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIGZyb21Nb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcmMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lucHV0Q29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3JjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3JjJ10sIGJhdGNoSm9iU291cmNlRnJvbVZlcnRleChmcm9tU3JjKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXN0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRDb25maWcnXSk7XG4gICAgaWYgKGZyb21EZXN0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzdCddLCBiYXRjaEpvYkRlc3RpbmF0aW9uRnJvbVZlcnRleCh0UmVjdkJhdGNoSm9iRGVzdGluYXRpb24oZnJvbURlc3QpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wbGV0aW9uU3RhdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb21wbGV0aW9uU3RhdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29tcGxldGlvblN0YXRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcGxldGlvblN0YXRzJ10sIGZyb21Db21wbGV0aW9uU3RhdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYlNvdXJjZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZvcm1hdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5zdGFuY2VzRm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NTb3VyY2UnLCAndXJpcyddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1VyaSddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJpZ3F1ZXJ5VXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYmlncXVlcnlTb3VyY2UnLFxuICAgICAgICAnaW5wdXRVcmknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQmlncXVlcnlVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiaWdxdWVyeVVyaSddLCBmcm9tQmlncXVlcnlVcmkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYlNvdXJjZVRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JtYXQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zvcm1hdCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2djc1VyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiaWdxdWVyeVVyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmlncXVlcnlVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlTmFtZSddKTtcbiAgICBpZiAoZnJvbUZpbGVOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZU5hbWUnXSwgZnJvbUZpbGVOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZWRSZXF1ZXN0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lubGluZWRSZXF1ZXN0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmxpbmVkUmVxdWVzdHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUlubGluZWRSZXF1ZXN0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmxpbmVkUmVxdWVzdFRvTWxkZXYoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3RzJywgJ3JlcXVlc3RzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iU291cmNlVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZvcm1hdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzRm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NTb3VyY2UnLCAndXJpcyddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJpZ3F1ZXJ5VXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiaWdxdWVyeVVyaSddKTtcbiAgICBpZiAoZnJvbUJpZ3F1ZXJ5VXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmlncXVlcnlTb3VyY2UnLCAnaW5wdXRVcmknXSwgZnJvbUJpZ3F1ZXJ5VXJpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGVOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lZFJlcXVlc3RzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmxpbmVkUmVxdWVzdHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBibG9iVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmRpZGF0ZUZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50J10pO1xuICAgIGlmIChmcm9tQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnQnXSwgZnJvbUNvbnRlbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2l0YXRpb25NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NpdGF0aW9uTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9uTWV0YWRhdGEnXSwgY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldiQxKGZyb21DaXRhdGlvbk1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbkNvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmluaXNoUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaW5pc2hSZWFzb24nXSk7XG4gICAgaWYgKGZyb21GaW5pc2hSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hSZWFzb24nXSwgZnJvbUZpbmlzaFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdmdMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21BdmdMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F2Z0xvZ3Byb2JzJ10sIGZyb21BdmdMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hcm91bmRpbmdNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dyb3VuZGluZ01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdyb3VuZGluZ01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ3JvdW5kaW5nTWV0YWRhdGEnXSwgZnJvbUdyb3VuZGluZ01ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluZGV4ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmRleCddKTtcbiAgICBpZiAoZnJvbUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5kZXgnXSwgZnJvbUluZGV4KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbG9ncHJvYnNSZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTG9ncHJvYnNSZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9ic1Jlc3VsdCddLCBmcm9tTG9ncHJvYnNSZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5UmF0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVJhdGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2FmZXR5UmF0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tU2FmZXR5UmF0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5UmF0aW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dE1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsQ29udGV4dE1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHRNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHRNZXRhZGF0YSddLCBmcm9tVXJsQ29udGV4dE1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DaXRhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NpdGF0aW9uU291cmNlcyddKTtcbiAgICBpZiAoZnJvbUNpdGF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2l0YXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaXRhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDQoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2JhdGNoJywgJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc3QnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rlc3QgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzdCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlc3QgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnb3V0cHV0Q29uZmlnJ10sIGJhdGNoSm9iRGVzdGluYXRpb25Ub1ZlcnRleCh0QmF0Y2hKb2JEZXN0aW5hdGlvbihmcm9tRGVzdCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcmMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NyYyddKTtcbiAgICBpZiAoZnJvbVNyYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JhdGNoJywgJ2lucHV0Q29uZmlnJ10sIGJhdGNoSm9iU291cmNlVG9NbGRldihhcGlDbGllbnQsIHRCYXRjaEpvYlNvdXJjZShhcGlDbGllbnQsIGZyb21TcmMpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZUJhdGNoSm9iQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcmMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NyYyddKTtcbiAgICBpZiAoZnJvbVNyYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lucHV0Q29uZmlnJ10sIGJhdGNoSm9iU291cmNlVG9WZXJ0ZXgodEJhdGNoSm9iU291cmNlKGFwaUNsaWVudCwgZnJvbVNyYykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlQmF0Y2hKb2JDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtYmVkZGluZ3NCYXRjaEpvYkNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnYmF0Y2gnLCAnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlRW1iZWRkaW5nc0JhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3JjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcmMnXSk7XG4gICAgaWYgKGZyb21TcmMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXRjaCcsICdpbnB1dENvbmZpZyddLCBlbWJlZGRpbmdzQmF0Y2hKb2JTb3VyY2VUb01sZGV2KGFwaUNsaWVudCwgZnJvbVNyYykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVFbWJlZGRpbmdzQmF0Y2hKb2JDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZVJlc291cmNlSm9iRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZVJlc291cmNlSm9iRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRCYXRjaFRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzRm9yRW1iZWQoYXBpQ2xpZW50LCBmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3JlcXVlc3QnLCAnY29udGVudCddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfc2VsZiddLCBlbWJlZENvbnRlbnRDb25maWdUb01sZGV2JDEoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICAgICAgbW92ZVZhbHVlQnlQYXRoKHRvT2JqZWN0LCB7ICdyZXF1ZXN0c1tdLionOiAncmVxdWVzdHNbXS5yZXF1ZXN0LionIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGFza1R5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rhc2tUeXBlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGFza1R5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncmVxdWVzdHNbXScsICd0YXNrVHlwZSddLCBmcm9tVGFza1R5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGl0bGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RpdGxlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGl0bGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncmVxdWVzdHNbXScsICd0aXRsZSddLCBmcm9tVGl0bGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXREaW1lbnNpb25hbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ291dHB1dERpbWVuc2lvbmFsaXR5J10sIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaW1lVHlwZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRvVHJ1bmNhdGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dG9UcnVuY2F0ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZGRpbmdzQmF0Y2hKb2JTb3VyY2VUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGVOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlTmFtZSddKTtcbiAgICBpZiAoZnJvbUZpbGVOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZV9uYW1lJ10sIGZyb21GaWxlTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVkUmVxdWVzdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmxpbmVkUmVxdWVzdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5saW5lZFJlcXVlc3RzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdHMnXSwgZW1iZWRDb250ZW50QmF0Y2hUb01sZGV2KGFwaUNsaWVudCwgZnJvbUlubGluZWRSZXF1ZXN0cykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YVRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRpYWxBcmdzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJ0aWFsQXJncyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd3aWxsQ29udGludWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dpbGxDb250aW51ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbGxvd2VkRnVuY3Rpb25OYW1lcyddLCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RyZWFtRnVuY3Rpb25DYWxsQXJndW1lbnRzJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJlYW1GdW5jdGlvbkNhbGxBcmd1bWVudHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldiQxKGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQ0KHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlc2VuY2VQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZXNlbmNlUGVuYWx0eSddLCBmcm9tUHJlc2VuY2VQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZyZXF1ZW5jeVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcmVxdWVuY3lQZW5hbHR5J10sIGZyb21GcmVxdWVuY3lQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNaW1lVHlwZSddLCBmcm9tUmVzcG9uc2VNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VTY2hlbWEnXSwgdFNjaGVtYShmcm9tUmVzcG9uc2VTY2hlbWEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JvdXRpbmdDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxTZWxlY3Rpb25Db25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZGVsU2VsZWN0aW9uQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlTZXR0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVNldHRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eVNldHRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TYWZldHlTZXR0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzYWZldHlTZXR0aW5nVG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NhZmV0eVNldHRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldiQ0KHRUb29sKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCB0b29sQ29uZmlnVG9NbGRldiQyKGZyb21Ub29sQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGFiZWxzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21DYWNoZWRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NhY2hlZENvbnRlbnQnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbUNhY2hlZENvbnRlbnQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVlY2hDb25maWcnXSwgdFNwZWVjaENvbmZpZyhmcm9tU3BlZWNoQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1ZGlvVGltZXN0YW1wJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdWRpb1RpbWVzdGFtcCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQ29uZmlnJ10sIGZyb21UaGlua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21JbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlQ29uZmlnJ10sIGltYWdlQ29uZmlnVG9NbGRldiQxKGZyb21JbWFnZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlRW5oYW5jZWRDaXZpY0Fuc3dlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVFbmhhbmNlZENpdmljQW5zd2VycycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmFibGVFbmhhbmNlZENpdmljQW5zd2VycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuYWJsZUVuaGFuY2VkQ2l2aWNBbnN3ZXJzJ10sIGZyb21FbmFibGVFbmhhbmNlZENpdmljQW5zd2Vycyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsQXJtb3JDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZGVsQXJtb3JDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYW5kaWRhdGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZUZyb21NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxWZXJzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFZlcnNpb24nXSk7XG4gICAgaWYgKGZyb21Nb2RlbFZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbFZlcnNpb24nXSwgZnJvbU1vZGVsVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRGZWVkYmFjayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdEZlZWRiYWNrJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb21wdEZlZWRiYWNrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0RmVlZGJhY2snXSwgZnJvbVByb21wdEZlZWRiYWNrKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlSWQnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VJZCddLCBmcm9tUmVzcG9uc2VJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCBmcm9tVXNhZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldEJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldEJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRCYXRjaEpvYk5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVNYXBzVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dGhDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dGhDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZVdpZGdldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10pO1xuICAgIGlmIChmcm9tRW5hYmxlV2lkZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10sIGZyb21FbmFibGVXaWRnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4Y2x1ZGVEb21haW5zIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jsb2NraW5nQ29uZmlkZW5jZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmxvY2tpbmdDb25maWRlbmNlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGZyb21UaW1lUmFuZ2VGaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZUNvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZVNpemUnXSk7XG4gICAgaWYgKGZyb21JbWFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZVNpemUnXSwgZnJvbUltYWdlU2l6ZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BlcnNvbkdlbmVyYXRpb24nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BlcnNvbkdlbmVyYXRpb24gcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0TWltZVR5cGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dE1pbWVUeXBlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eSddKSAhPT1cbiAgICAgICAgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGlubGluZWRSZXF1ZXN0VG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3QnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9NbGRldiQ0KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdCcsICdjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0JywgJ2dlbmVyYXRpb25Db25maWcnXSwgZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldiQxKGFwaUNsaWVudCwgZnJvbUNvbmZpZywgZ2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdCddLCB7fSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW5saW5lZFJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2JDEoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWx0ZXIgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0QmF0Y2hKb2JzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdEJhdGNoSm9ic0NvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmF0Y2hKb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvcGVyYXRpb25zJ10pO1xuICAgIGlmIChmcm9tQmF0Y2hKb2JzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21CYXRjaEpvYnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmF0Y2hKb2JGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXRjaEpvYnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhdGNoSm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2JhdGNoUHJlZGljdGlvbkpvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQmF0Y2hKb2JzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21CYXRjaEpvYnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmF0Y2hKb2JGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmF0Y2hKb2JzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFUb01sZGV2JDQoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmdW5jdGlvbkNhbGxUb01sZGV2JDQoZnJvbUZ1bmN0aW9uQ2FsbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb01sZGV2JDQoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgZnJvbVZpZGVvTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzYWZldHlTZXR0aW5nVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DYXRlZ29yeSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2F0ZWdvcnknXSk7XG4gICAgaWYgKGZyb21DYXRlZ29yeSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhdGVnb3J5J10sIGZyb21DYXRlZ29yeSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGhvZCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RocmVzaG9sZCddKTtcbiAgICBpZiAoZnJvbVRocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RocmVzaG9sZCddLCBmcm9tVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbmZpZ1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbENvbmZpZyddLCBmcm9tUmV0cmlldmFsQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxpbmdDb25maWcnXSwgZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldiQyKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBmcm9tQ29tcHV0ZXJVc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUZpbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlU2VhcmNoJ10sIGZyb21GaWxlU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZ29vZ2xlTWFwc1RvTWxkZXYkNChmcm9tR29vZ2xlTWFwcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQ0KGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBQYWdlZEl0ZW07XG4oZnVuY3Rpb24gKFBhZ2VkSXRlbSkge1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fQkFUQ0hfSk9CU1wiXSA9IFwiYmF0Y2hKb2JzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9NT0RFTFNcIl0gPSBcIm1vZGVsc1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fVFVOSU5HX0pPQlNcIl0gPSBcInR1bmluZ0pvYnNcIjtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX0ZJTEVTXCJdID0gXCJmaWxlc1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fQ0FDSEVEX0NPTlRFTlRTXCJdID0gXCJjYWNoZWRDb250ZW50c1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fRklMRV9TRUFSQ0hfU1RPUkVTXCJdID0gXCJmaWxlU2VhcmNoU3RvcmVzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9ET0NVTUVOVFNcIl0gPSBcImRvY3VtZW50c1wiO1xufSkoUGFnZWRJdGVtIHx8IChQYWdlZEl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBQYWdlciBjbGFzcyBmb3IgaXRlcmF0aW5nIHRocm91Z2ggcGFnaW5hdGVkIHJlc3VsdHMuXG4gKi9cbmNsYXNzIFBhZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCByZXF1ZXN0LCByZXNwb25zZSwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMucGFnZUludGVybmFsID0gW107XG4gICAgICAgIHRoaXMucGFyYW1zSW50ZXJuYWwgPSB7fTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SW50ZXJuYWwgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLmluaXQobmFtZSwgcmVzcG9uc2UsIHBhcmFtcyk7XG4gICAgfVxuICAgIGluaXQobmFtZSwgcmVzcG9uc2UsIHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLm5hbWVJbnRlcm5hbCA9IG5hbWU7XG4gICAgICAgIHRoaXMucGFnZUludGVybmFsID0gcmVzcG9uc2VbdGhpcy5uYW1lSW50ZXJuYWxdIHx8IFtdO1xuICAgICAgICB0aGlzLnNka0h0dHBSZXNwb25zZUludGVybmFsID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZTtcbiAgICAgICAgdGhpcy5pZHhJbnRlcm5hbCA9IDA7XG4gICAgICAgIGxldCByZXF1ZXN0UGFyYW1zID0geyBjb25maWc6IHt9IH07XG4gICAgICAgIGlmICghcGFyYW1zIHx8IE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXF1ZXN0UGFyYW1zID0geyBjb25maWc6IHt9IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdFBhcmFtc1snY29uZmlnJ10pIHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXNbJ2NvbmZpZyddWydwYWdlVG9rZW4nXSA9IHJlc3BvbnNlWyduZXh0UGFnZVRva2VuJ107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJhbXNJbnRlcm5hbCA9IHJlcXVlc3RQYXJhbXM7XG4gICAgICAgIHRoaXMucGFnZUludGVybmFsU2l6ZSA9XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSByZXF1ZXN0UGFyYW1zWydjb25maWcnXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWydwYWdlU2l6ZSddKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLnBhZ2VJbnRlcm5hbC5sZW5ndGg7XG4gICAgfVxuICAgIGluaXROZXh0UGFnZShyZXNwb25zZSkge1xuICAgICAgICB0aGlzLmluaXQodGhpcy5uYW1lSW50ZXJuYWwsIHJlc3BvbnNlLCB0aGlzLnBhcmFtc0ludGVybmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBwYWdlLCB3aGljaCBpcyBhIGxpc3Qgb2YgaXRlbXMuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBmaXJzdCBwYWdlIGlzIHJldHJpZXZlZCB3aGVuIHRoZSBwYWdlciBpcyBjcmVhdGVkLiBUaGUgcmV0dXJuZWQgbGlzdCBvZlxuICAgICAqIGl0ZW1zIGNvdWxkIGJlIGEgc3Vic2V0IG9mIHRoZSBlbnRpcmUgbGlzdC5cbiAgICAgKi9cbiAgICBnZXQgcGFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZUludGVybmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0eXBlIG9mIHBhZ2VkIGl0ZW0gKGZvciBleGFtcGxlLCBgYGJhdGNoX2pvYnNgYCkuXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWVJbnRlcm5hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBwYWdlIGZldGNoZWQgZWFjaCB0aW1lIGJ5IHRoaXMgcGFnZXIuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHBhZ2UgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwYWdlIGxlbmd0aC5cbiAgICAgKi9cbiAgICBnZXQgcGFnZVNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VJbnRlcm5hbFNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhlYWRlcnMgb2YgdGhlIEFQSSByZXNwb25zZS5cbiAgICAgKi9cbiAgICBnZXQgc2RrSHR0cFJlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZGtIdHRwUmVzcG9uc2VJbnRlcm5hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFyYW1ldGVycyB3aGVuIG1ha2luZyB0aGUgQVBJIHJlcXVlc3QgZm9yIHRoZSBuZXh0IHBhZ2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFBhcmFtZXRlcnMgY29udGFpbiBhIHNldCBvZiBvcHRpb25hbCBjb25maWdzIHRoYXQgY2FuIGJlXG4gICAgICogdXNlZCB0byBjdXN0b21pemUgdGhlIEFQSSByZXF1ZXN0LiBGb3IgZXhhbXBsZSwgdGhlIGBwYWdlVG9rZW5gIHBhcmFtZXRlclxuICAgICAqIGNvbnRhaW5zIHRoZSB0b2tlbiB0byByZXF1ZXN0IHRoZSBuZXh0IHBhZ2UuXG4gICAgICovXG4gICAgZ2V0IHBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zSW50ZXJuYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgY3VycmVudCBwYWdlLlxuICAgICAqL1xuICAgIGdldCBwYWdlTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlSW50ZXJuYWwubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpdGVtIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRJdGVtKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VJbnRlcm5hbFtpbmRleF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXN5bmMgaXRlcmF0b3IgdGhhdCBzdXBwb3J0IGl0ZXJhdGluZyB0aHJvdWdoIGFsbCBpdGVtc1xuICAgICAqIHJldHJpZXZlZCBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBpdGVyYXRvciB3aWxsIGF1dG9tYXRpY2FsbHkgZmV0Y2ggdGhlIG5leHQgcGFnZSBpZiB0aGVyZSBhcmUgbW9yZSBpdGVtc1xuICAgICAqIHRvIGZldGNoIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHBhZ2VyID0gYXdhaXQgYWkuZmlsZXMubGlzdCh7Y29uZmlnOiB7cGFnZVNpemU6IDEwfX0pO1xuICAgICAqIGZvciBhd2FpdCAoY29uc3QgZmlsZSBvZiBwYWdlcikge1xuICAgICAqICAgY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHhJbnRlcm5hbCA+PSB0aGlzLnBhZ2VMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzTmV4dFBhZ2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uZXh0UGFnZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmdldEl0ZW0odGhpcy5pZHhJbnRlcm5hbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHhJbnRlcm5hbCArPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldHVybjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIG5leHQgcGFnZSBvZiBpdGVtcy4gVGhpcyBtYWtlcyBhIG5ldyBBUEkgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBhcmUgbm8gbW9yZSBwYWdlcyB0byBmZXRjaC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHBhZ2VyID0gYXdhaXQgYWkuZmlsZXMubGlzdCh7Y29uZmlnOiB7cGFnZVNpemU6IDEwfX0pO1xuICAgICAqIGxldCBwYWdlID0gcGFnZXIucGFnZTtcbiAgICAgKiB3aGlsZSAodHJ1ZSkge1xuICAgICAqICAgZm9yIChjb25zdCBmaWxlIG9mIHBhZ2UpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgKiAgIH1cbiAgICAgKiAgIGlmICghcGFnZXIuaGFzTmV4dFBhZ2UoKSkge1xuICAgICAqICAgICBicmVhaztcbiAgICAgKiAgIH1cbiAgICAgKiAgIHBhZ2UgPSBhd2FpdCBwYWdlci5uZXh0UGFnZSgpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBuZXh0UGFnZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc05leHRQYWdlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbW9yZSBwYWdlcyB0byBmZXRjaC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdEludGVybmFsKHRoaXMucGFyYW1zKTtcbiAgICAgICAgdGhpcy5pbml0TmV4dFBhZ2UocmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIG1vcmUgcGFnZXMgdG8gZmV0Y2ggZnJvbSB0aGUgQVBJLlxuICAgICAqL1xuICAgIGhhc05leHRQYWdlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5wYXJhbXNbJ2NvbmZpZyddKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbJ3BhZ2VUb2tlbiddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBCYXRjaGVzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdHMgYmF0Y2ggam9icy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIC0gQSBwYWdlciBvZiBiYXRjaCBqb2JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCBiYXRjaEpvYnMgPSBhd2FpdCBhaS5iYXRjaGVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDJ9fSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgYmF0Y2hKb2Igb2YgYmF0Y2hKb2JzKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coYmF0Y2hKb2IpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX0JBVENIX0pPQlMsICh4KSA9PiB0aGlzLmxpc3RJbnRlcm5hbCh4KSwgYXdhaXQgdGhpcy5saXN0SW50ZXJuYWwocGFyYW1zKSwgcGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBiYXRjaCBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRlIGJhdGNoIGpvYiByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIGJhdGNoIGpvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5iYXRjaGVzLmNyZWF0ZSh7XG4gICAgICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgICAgICogICBzcmM6IHtnY3NVcmk6ICdnczovL2J1Y2tldC9wYXRoL3RvL2ZpbGUuanNvbmwnLCBmb3JtYXQ6ICdqc29ubCd9LFxuICAgICAgICAgKiAgIGNvbmZpZzoge1xuICAgICAgICAgKiAgICAgZGVzdDoge2djc1VyaTogJ2dzOi8vYnVja2V0L3BhdGgvb3V0cHV0L2RpcmVjdG9yeScsIGZvcm1hdDogJ2pzb25sJ30sXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgIC8vIEZvcm1hdCBkZXN0aW5hdGlvbiBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAvLyBDYXN0IHBhcmFtcy5zcmMgYXMgVmVydGV4IEFJIHBhdGggZG9lcyBub3QgaGFuZGxlIElubGluZWRSZXF1ZXN0W11cbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uZmlnID0gdGhpcy5mb3JtYXREZXN0aW5hdGlvbihwYXJhbXMuc3JjLCBwYXJhbXMuY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUludGVybmFsKHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAqKkV4cGVyaW1lbnRhbCoqIENyZWF0ZXMgYW4gZW1iZWRkaW5nIGJhdGNoIGpvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjcmVhdGUgZW1iZWRkaW5nIGJhdGNoIGpvYiByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIGJhdGNoIGpvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5iYXRjaGVzLmNyZWF0ZUVtYmVkZGluZ3Moe1xuICAgICAgICAgKiAgIG1vZGVsOiAndGV4dC1lbWJlZGRpbmctMDA0JyxcbiAgICAgICAgICogICBzcmM6IHtmaWxlTmFtZTogJ2ZpbGVzL215X2VtYmVkZGluZ19pbnB1dCd9LFxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlRW1iZWRkaW5ncyA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYmF0Y2hlcy5jcmVhdGVFbWJlZGRpbmdzKCkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIHdpdGhvdXQgbm90aWNlLicpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmVydGV4IEFJIGRvZXMgbm90IHN1cHBvcnQgYmF0Y2hlcy5jcmVhdGVFbWJlZGRpbmdzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRW1iZWRkaW5nc0ludGVybmFsKHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBoYW5kbGUgaW5saW5lZCBnZW5lcmF0ZSBjb250ZW50IHJlcXVlc3RzXG4gICAgY3JlYXRlSW5saW5lZEdlbmVyYXRlQ29udGVudFJlcXVlc3QocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCAvLyBVc2UgaW5zdGFuY2UgYXBpQ2xpZW50XG4gICAgICAgIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IGJvZHlbJ191cmwnXTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpiYXRjaEdlbmVyYXRlQ29udGVudCcsIHVybFBhcmFtcyk7XG4gICAgICAgIGNvbnN0IGJhdGNoID0gYm9keVsnYmF0Y2gnXTtcbiAgICAgICAgY29uc3QgaW5wdXRDb25maWcgPSBiYXRjaFsnaW5wdXRDb25maWcnXTtcbiAgICAgICAgY29uc3QgcmVxdWVzdHNXcmFwcGVyID0gaW5wdXRDb25maWdbJ3JlcXVlc3RzJ107XG4gICAgICAgIGNvbnN0IHJlcXVlc3RzID0gcmVxdWVzdHNXcmFwcGVyWydyZXF1ZXN0cyddO1xuICAgICAgICBjb25zdCBuZXdSZXF1ZXN0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgcmVxdWVzdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3REaWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCk7IC8vIENsb25lXG4gICAgICAgICAgICBpZiAocmVxdWVzdERpY3RbJ3N5c3RlbUluc3RydWN0aW9uJ10pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeXN0ZW1JbnN0cnVjdGlvblZhbHVlID0gcmVxdWVzdERpY3RbJ3N5c3RlbUluc3RydWN0aW9uJ107XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0WydzeXN0ZW1JbnN0cnVjdGlvbiddO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RDb250ZW50ID0gcmVxdWVzdERpY3RbJ3JlcXVlc3QnXTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Q29udGVudFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSA9IHN5c3RlbUluc3RydWN0aW9uVmFsdWU7XG4gICAgICAgICAgICAgICAgcmVxdWVzdERpY3RbJ3JlcXVlc3QnXSA9IHJlcXVlc3RDb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3UmVxdWVzdHMucHVzaChyZXF1ZXN0RGljdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdHNXcmFwcGVyWydyZXF1ZXN0cyddID0gbmV3UmVxdWVzdHM7XG4gICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICByZXR1cm4geyBwYXRoLCBib2R5IH07XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGZpcnN0IEdDUyBVUklcbiAgICBnZXRHY3NVcmkoc3JjKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHNyYy5zdGFydHNXaXRoKCdnczovLycpID8gc3JjIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzcmMpICYmIHNyYy5nY3NVcmkgJiYgc3JjLmdjc1VyaS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjLmdjc1VyaVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBCaWdRdWVyeSBVUklcbiAgICBnZXRCaWdxdWVyeVVyaShzcmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjLnN0YXJ0c1dpdGgoJ2JxOi8vJykgPyBzcmMgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpIHtcbiAgICAgICAgICAgIHJldHVybiBzcmMuYmlncXVlcnlVcmk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gRnVuY3Rpb24gdG8gZm9ybWF0IHRoZSBkZXN0aW5hdGlvbiBjb25maWd1cmF0aW9uIGZvciBWZXJ0ZXggQUlcbiAgICBmb3JtYXREZXN0aW5hdGlvbihzcmMsIGNvbmZpZykge1xuICAgICAgICBjb25zdCBuZXdDb25maWcgPSBjb25maWcgPyBPYmplY3QuYXNzaWduKHt9LCBjb25maWcpIDoge307XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcFN0ciA9IERhdGUubm93KCkudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKCFuZXdDb25maWcuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgIG5ld0NvbmZpZy5kaXNwbGF5TmFtZSA9IGBnZW5haUJhdGNoSm9iXyR7dGltZXN0YW1wU3RyfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0NvbmZpZy5kZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGdjc1VyaSA9IHRoaXMuZ2V0R2NzVXJpKHNyYyk7XG4gICAgICAgICAgICBjb25zdCBiaWdxdWVyeVVyaSA9IHRoaXMuZ2V0QmlncXVlcnlVcmkoc3JjKTtcbiAgICAgICAgICAgIGlmIChnY3NVcmkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2NzVXJpLmVuZHNXaXRoKCcuanNvbmwnKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgLmpzb25sIGZpbGVzLCByZW1vdmUgc3VmZml4IGFuZCBhZGQgL2Rlc3RcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29uZmlnLmRlc3QgPSBgJHtnY3NVcmkuc2xpY2UoMCwgLTYpfS9kZXN0YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciBvdGhlciBHQ1MgVVJJc1xuICAgICAgICAgICAgICAgICAgICBuZXdDb25maWcuZGVzdCA9IGAke2djc1VyaX1fZGVzdF8ke3RpbWVzdGFtcFN0cn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpZ3F1ZXJ5VXJpKSB7XG4gICAgICAgICAgICAgICAgbmV3Q29uZmlnLmRlc3QgPSBgJHtiaWdxdWVyeVVyaX1fZGVzdF8ke3RpbWVzdGFtcFN0cn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzb3VyY2UgZm9yIFZlcnRleCBBSTogTm8gR0NTIG9yIEJpZ1F1ZXJ5IFVSSSBmb3VuZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3Q29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRlIGJhdGNoIGpvYiByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hQcmVkaWN0aW9uSm9icycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYmF0Y2hKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmJhdGNoR2VuZXJhdGVDb250ZW50JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBiYXRjaEpvYkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRlIGJhdGNoIGpvYiByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRW1iZWRkaW5nc0ludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVFbWJlZGRpbmdzQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06YXN5bmNCYXRjaEVtYmVkQ29udGVudCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYmF0Y2hKb2JGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBiYXRjaCBqb2IgY29uZmlndXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuYmF0Y2hlcy5nZXQoe25hbWU6ICcuLi4nfSk7IC8vIFRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHJlc291cmNlIG5hbWUuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoUHJlZGljdGlvbkpvYnMve25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hlcy97bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYmF0Y2hKb2JGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGNhbmNlbCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGVtcHR5IHJlc3BvbnNlIHJldHVybmVkIGJ5IHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuYmF0Y2hlcy5jYW5jZWwoe25hbWU6ICcuLi4nfSk7IC8vIFRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHJlc291cmNlIG5hbWUuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY2FuY2VsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaFByZWRpY3Rpb25Kb2JzL3tuYW1lfTpjYW5jZWwnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwaUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoZXMve25hbWV9OmNhbmNlbCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RCYXRjaEpvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoUHJlZGljdGlvbkpvYnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0QmF0Y2hKb2JzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RCYXRjaEpvYnNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hlcycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdEJhdGNoSm9ic1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdEJhdGNoSm9ic1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZGVsZXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgZW1wdHkgcmVzcG9uc2UgcmV0dXJuZWQgYnkgdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5iYXRjaGVzLmRlbGV0ZSh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hQcmVkaWN0aW9uSm9icy97bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZVJlc291cmNlSm9iRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hlcy97bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZVJlc291cmNlSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiBibG9iVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDMoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHRsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dGwnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHRsJ10sIGZyb21UdGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvTWxkZXYkMyhpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQzKHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Ub29scztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldiQzKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIHRvb2xDb25maWdUb01sZGV2JDEoZnJvbVRvb2xDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsna21zS2V5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna21zS2V5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHRsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dGwnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHRsJ10sIGZyb21UdGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCB0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Ub29scztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9WZXJ0ZXgkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCBmcm9tVG9vbENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21LbXNLZXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydrbXNLZXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tS21zS2V5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydlbmNyeXB0aW9uX3NwZWMnLCAna21zS2V5TmFtZSddLCBmcm9tS21zS2V5TmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIHRDYWNoZXNNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCB0Q2FjaGVzTW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YVRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRpYWxBcmdzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJ0aWFsQXJncyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd3aWxsQ29udGludWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dpbGxDb250aW51ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbGxvd2VkRnVuY3Rpb25OYW1lcyddLCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RyZWFtRnVuY3Rpb25DYWxsQXJndW1lbnRzJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJlYW1GdW5jdGlvbkNhbGxBcmd1bWVudHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJhbWV0ZXJzJ10pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSwgZnJvbVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwYXJhbWV0ZXJzSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnNKc29uU2NoZW1hJ10sIGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGZyb21SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiZWhhdmlvciddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmVoYXZpb3IgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVNYXBzVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dGhDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dGhDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZVdpZGdldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10pO1xuICAgIGlmIChmcm9tRW5hYmxlV2lkZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10sIGZyb21FbmFibGVXaWRnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4Y2x1ZGVEb21haW5zIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jsb2NraW5nQ29uZmlkZW5jZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmxvY2tpbmdDb25maWRlbmNlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGZyb21UaW1lUmFuZ2VGaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0Q2FjaGVkQ29udGVudHNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlZENvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYWNoZWRDb250ZW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVkQ29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZWRDb250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FjaGVkQ29udGVudHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFUb01sZGV2JDMoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmdW5jdGlvbkNhbGxUb01sZGV2JDMoZnJvbUZ1bmN0aW9uQ2FsbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb01sZGV2JDMoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgZnJvbVZpZGVvTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21SZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsQ29uZmlnJ10sIGZyb21SZXRyaWV2YWxDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZyddLCBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDEoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0cmlldmFsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tRmlsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSwgZnJvbUZpbGVTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRlcnByaXNlV2ViU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBnb29nbGVNYXBzVG9NbGRldiQzKGZyb21Hb29nbGVNYXBzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb01sZGV2JDMoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCBmcm9tVXJsQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21SZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbCddLCBmcm9tUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgZnJvbUNvbXB1dGVyVXNlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZVNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbnRlcnByaXNlV2ViU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW50ZXJwcmlzZVdlYlNlYXJjaCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbnRlcnByaXNlV2ViU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddLCBmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZnJvbUdvb2dsZU1hcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZnJvbUdvb2dsZVNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIGZyb21VcmxDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHRsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dGwnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHRsJ10sIGZyb21UdGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UdGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R0bCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR0bCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dGwnXSwgZnJvbVR0bCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBpcmVUaW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIENhY2hlcyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGNhY2hlZCBjb250ZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIC0gQSBwYWdlciBvZiBjYWNoZWQgY29udGVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGNhY2hlZENvbnRlbnRzID0gYXdhaXQgYWkuY2FjaGVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDJ9fSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgY2FjaGVkQ29udGVudCBvZiBjYWNoZWRDb250ZW50cykge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKGNhY2hlZENvbnRlbnQpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX0NBQ0hFRF9DT05URU5UUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2FjaGVkIGNvbnRlbnRzIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBDb250ZXh0IGNhY2hpbmcgaXMgb25seSBzdXBwb3J0ZWQgZm9yIHNwZWNpZmljIG1vZGVscy4gU2VlIFtHZW1pbmlcbiAgICAgKiBEZXZlbG9wZXIgQVBJIHJlZmVyZW5jZV0oaHR0cHM6Ly9haS5nb29nbGUuZGV2L2dlbWluaS1hcGkvZG9jcy9jYWNoaW5nP2xhbmc9bm9kZS9jb250ZXh0LWNhYylcbiAgICAgKiBhbmQgW1ZlcnRleCBBSSByZWZlcmVuY2VdKGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS92ZXJ0ZXgtYWkvZ2VuZXJhdGl2ZS1haS9kb2NzL2NvbnRleHQtY2FjaGUvY29udGV4dC1jYWNoZS1vdmVydmlldyNzdXBwb3J0ZWRfbW9kZWxzKVxuICAgICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgY3JlYXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjb250ZW50cyA9IC4uLjsgLy8gSW5pdGlhbGl6ZSB0aGUgY29udGVudCB0byBjYWNoZS5cbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLmNhY2hlcy5jcmVhdGUoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoLTAwMScsXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAnY29udGVudHMnOiBjb250ZW50cyxcbiAgICAgKiAgICAnZGlzcGxheU5hbWUnOiAndGVzdCBjYWNoZScsXG4gICAgICogICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ1doYXQgaXMgdGhlIHN1bSBvZiB0aGUgdHdvIHBkZnM/JyxcbiAgICAgKiAgICAndHRsJzogJzg2NDAwcycsXG4gICAgICogIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdjYWNoZWRDb250ZW50cycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnY2FjaGVkQ29udGVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgY2FjaGVkIGNvbnRlbnQgY29uZmlndXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5jYWNoZXMuZ2V0KHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGRlbGV0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGVtcHR5IHJlc3BvbnNlIHJldHVybmVkIGJ5IHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuY2FjaGVzLmRlbGV0ZSh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNhY2hlZCBjb250ZW50IGNvbmZpZ3VyYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgdXBkYXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgdXBkYXRlZCBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLmNhY2hlcy51cGRhdGUoe1xuICAgICAqICAgbmFtZTogJy4uLicsICAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqICAgY29uZmlnOiB7J3R0bCc6ICc3NjAwcyd9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB1cGRhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAoZ1tuXSkgeyBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyBpZiAoZikgaVtuXSA9IGYoaVtuXSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVzcG9uc2UgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChyZXNwb25zZS5jYW5kaWRhdGVzID09IHVuZGVmaW5lZCB8fCByZXNwb25zZS5jYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnQgPSAoX2EgPSByZXNwb25zZS5jYW5kaWRhdGVzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGVudDtcbiAgICBpZiAoY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzVmFsaWRDb250ZW50KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gaXNWYWxpZENvbnRlbnQoY29udGVudCkge1xuICAgIGlmIChjb250ZW50LnBhcnRzID09PSB1bmRlZmluZWQgfHwgY29udGVudC5wYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgY29udGVudC5wYXJ0cykge1xuICAgICAgICBpZiAocGFydCA9PT0gdW5kZWZpbmVkIHx8IE9iamVjdC5rZXlzKHBhcnQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGhpc3RvcnkgY29udGFpbnMgdGhlIGNvcnJlY3Qgcm9sZXMuXG4gKlxuICogQHRocm93cyBFcnJvciBpZiB0aGUgaGlzdG9yeSBkb2VzIG5vdCBzdGFydCB3aXRoIGEgdXNlciB0dXJuLlxuICogQHRocm93cyBFcnJvciBpZiB0aGUgaGlzdG9yeSBjb250YWlucyBhbiBpbnZhbGlkIHJvbGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSGlzdG9yeShoaXN0b3J5KSB7XG4gICAgLy8gRW1wdHkgaGlzdG9yeSBpcyB2YWxpZC5cbiAgICBpZiAoaGlzdG9yeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbnRlbnQgb2YgaGlzdG9yeSkge1xuICAgICAgICBpZiAoY29udGVudC5yb2xlICE9PSAndXNlcicgJiYgY29udGVudC5yb2xlICE9PSAnbW9kZWwnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJvbGUgbXVzdCBiZSB1c2VyIG9yIG1vZGVsLCBidXQgZ290ICR7Y29udGVudC5yb2xlfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogRXh0cmFjdHMgdGhlIGN1cmF0ZWQgKHZhbGlkKSBoaXN0b3J5IGZyb20gYSBjb21wcmVoZW5zaXZlIGhpc3RvcnkuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSBtb2RlbCBtYXkgc29tZXRpbWVzIGdlbmVyYXRlIGludmFsaWQgb3IgZW1wdHkgY29udGVudHMoZS5nLiwgZHVlIHRvIHNhZnR5XG4gKiBmaWx0ZXJzIG9yIHJlY2l0YXRpb24pLiBFeHRyYWN0aW5nIHZhbGlkIHR1cm5zIGZyb20gdGhlIGhpc3RvcnlcbiAqIGVuc3VyZXMgdGhhdCBzdWJzZXF1ZW50IHJlcXVlc3RzIGNvdWxkIGJlIGFjY3BldGVkIGJ5IHRoZSBtb2RlbC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEN1cmF0ZWRIaXN0b3J5KGNvbXByZWhlbnNpdmVIaXN0b3J5KSB7XG4gICAgaWYgKGNvbXByZWhlbnNpdmVIaXN0b3J5ID09PSB1bmRlZmluZWQgfHwgY29tcHJlaGVuc2l2ZUhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgY3VyYXRlZEhpc3RvcnkgPSBbXTtcbiAgICBjb25zdCBsZW5ndGggPSBjb21wcmVoZW5zaXZlSGlzdG9yeS5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChjb21wcmVoZW5zaXZlSGlzdG9yeVtpXS5yb2xlID09PSAndXNlcicpIHtcbiAgICAgICAgICAgIGN1cmF0ZWRIaXN0b3J5LnB1c2goY29tcHJlaGVuc2l2ZUhpc3RvcnlbaV0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxPdXRwdXQgPSBbXTtcbiAgICAgICAgICAgIGxldCBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuZ3RoICYmIGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldLnJvbGUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICAgICAgICBtb2RlbE91dHB1dC5wdXNoKGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZCAmJiAhaXNWYWxpZENvbnRlbnQoY29tcHJlaGVuc2l2ZUhpc3RvcnlbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBjdXJhdGVkSGlzdG9yeS5wdXNoKC4uLm1vZGVsT3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGFzdCB1c2VyIGlucHV0IHdoZW4gbW9kZWwgY29udGVudCBpcyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIGN1cmF0ZWRIaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJhdGVkSGlzdG9yeTtcbn1cbi8qKlxuICogQSB1dGlsaXR5IGNsYXNzIHRvIGNyZWF0ZSBhIGNoYXQgc2Vzc2lvbi5cbiAqL1xuY2xhc3MgQ2hhdHMge1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsc01vZHVsZSwgYXBpQ2xpZW50KSB7XG4gICAgICAgIHRoaXMubW9kZWxzTW9kdWxlID0gbW9kZWxzTW9kdWxlO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjaGF0IHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBjb25maWcgaW4gdGhlIHBhcmFtcyB3aWxsIGJlIHVzZWQgZm9yIGFsbCByZXF1ZXN0cyB3aXRoaW4gdGhlIGNoYXRcbiAgICAgKiBzZXNzaW9uIHVubGVzcyBvdmVycmlkZGVuIGJ5IGEgcGVyLXJlcXVlc3QgYGNvbmZpZ2AgaW5cbiAgICAgKiBAc2VlIHtAbGluayB0eXBlcy5TZW5kTWVzc2FnZVBhcmFtZXRlcnMjY29uZmlnfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciBjcmVhdGluZyBhIGNoYXQgc2Vzc2lvbi5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBjaGF0IHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY2hhdCA9IGFpLmNoYXRzLmNyZWF0ZSh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAgdGVtcGVyYXR1cmU6IDAuNSxcbiAgICAgKiAgICAgbWF4T3V0cHV0VG9rZW5zOiAxMDI0LFxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNyZWF0ZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGF0KHRoaXMuYXBpQ2xpZW50LCB0aGlzLm1vZGVsc01vZHVsZSwgcGFyYW1zLm1vZGVsLCBwYXJhbXMuY29uZmlnLCBcbiAgICAgICAgLy8gRGVlcCBjb3B5IHRoZSBoaXN0b3J5IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBoaXN0b3J5IG91dHNpZGUgb2YgdGhlXG4gICAgICAgIC8vIGNoYXQgc2Vzc2lvbi5cbiAgICAgICAgc3RydWN0dXJlZENsb25lKHBhcmFtcy5oaXN0b3J5KSk7XG4gICAgfVxufVxuLyoqXG4gKiBDaGF0IHNlc3Npb24gdGhhdCBlbmFibGVzIHNlbmRpbmcgbWVzc2FnZXMgdG8gdGhlIG1vZGVsIHdpdGggcHJldmlvdXNcbiAqIGNvbnZlcnNhdGlvbiBjb250ZXh0LlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgc2Vzc2lvbiBtYWludGFpbnMgYWxsIHRoZSB0dXJucyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsLlxuICovXG5jbGFzcyBDaGF0IHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQsIG1vZGVsc01vZHVsZSwgbW9kZWwsIGNvbmZpZyA9IHt9LCBoaXN0b3J5ID0gW10pIHtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIHRoaXMubW9kZWxzTW9kdWxlID0gbW9kZWxzTW9kdWxlO1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmhpc3RvcnkgPSBoaXN0b3J5O1xuICAgICAgICAvLyBBIHByb21pc2UgdG8gcmVwcmVzZW50IHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBtZXNzYWdlIGJlaW5nIHNlbnQgdG8gdGhlXG4gICAgICAgIC8vIG1vZGVsLlxuICAgICAgICB0aGlzLnNlbmRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHZhbGlkYXRlSGlzdG9yeShoaXN0b3J5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBtb2RlbCBhbmQgcmV0dXJucyB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgd2FpdCBmb3IgdGhlIHByZXZpb3VzIG1lc3NhZ2UgdG8gYmUgcHJvY2Vzc2VkIGJlZm9yZVxuICAgICAqIHNlbmRpbmcgdGhlIG5leHQgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIENoYXQjc2VuZE1lc3NhZ2VTdHJlYW19IGZvciBzdHJlYW1pbmcgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBwYXJhbWV0ZXJzIGZvciBzZW5kaW5nIG1lc3NhZ2VzIHdpdGhpbiBhIGNoYXQgc2Vzc2lvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgbW9kZWwncyByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjaGF0ID0gYWkuY2hhdHMuY3JlYXRlKHttb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnfSk7XG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjaGF0LnNlbmRNZXNzYWdlKHtcbiAgICAgKiAgIG1lc3NhZ2U6ICdXaHkgaXMgdGhlIHNreSBibHVlPydcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZS50ZXh0KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBzZW5kTWVzc2FnZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRQcm9taXNlO1xuICAgICAgICBjb25zdCBpbnB1dENvbnRlbnQgPSB0Q29udGVudChwYXJhbXMubWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHRoaXMubW9kZWxzTW9kdWxlLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIGNvbnRlbnRzOiB0aGlzLmdldEhpc3RvcnkodHJ1ZSkuY29uY2F0KGlucHV0Q29udGVudCksXG4gICAgICAgICAgICBjb25maWc6IChfYSA9IHBhcmFtcy5jb25maWcpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuY29uZmlnLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2VQcm9taXNlO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0Q29udGVudCA9IChfYiA9IChfYSA9IHJlc3BvbnNlLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQ7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIHRoZSBBRkMgaW5wdXQgY29udGFpbnMgdGhlIGVudGlyZSBjdXJhdGVkIGNoYXQgaGlzdG9yeSBpblxuICAgICAgICAgICAgLy8gYWRkaXRpb24gdG8gdGhlIG5ldyB1c2VyIGlucHV0LCB3ZSBuZWVkIHRvIHRydW5jYXRlIHRoZSBBRkMgaGlzdG9yeVxuICAgICAgICAgICAgLy8gdG8gZGVkdXBsaWNhdGUgdGhlIGV4aXN0aW5nIGNoYXQgaGlzdG9yeS5cbiAgICAgICAgICAgIGNvbnN0IGZ1bGxBdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID0gcmVzcG9uc2UuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRIaXN0b3J5KHRydWUpLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID0gW107XG4gICAgICAgICAgICBpZiAoZnVsbEF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkgPVxuICAgICAgICAgICAgICAgICAgICAoX2MgPSBmdWxsQXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeS5zbGljZShpbmRleCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW9kZWxPdXRwdXQgPSBvdXRwdXRDb250ZW50ID8gW291dHB1dENvbnRlbnRdIDogW107XG4gICAgICAgICAgICB0aGlzLnJlY29yZEhpc3RvcnkoaW5wdXRDb250ZW50LCBtb2RlbE91dHB1dCwgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZFByb21pc2UuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgLy8gUmVzZXRzIHNlbmRQcm9taXNlIHRvIGF2b2lkIHN1YnNlcXVlbnQgY2FsbHMgZmFpbGluZ1xuICAgICAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlUHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBtb2RlbCBhbmQgcmV0dXJucyB0aGUgcmVzcG9uc2UgaW4gY2h1bmtzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBtZXNzYWdlIHRvIGJlIHByb2Nlc3NlZCBiZWZvcmVcbiAgICAgKiBzZW5kaW5nIHRoZSBuZXh0IG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBDaGF0I3NlbmRNZXNzYWdlfSBmb3Igbm9uLXN0cmVhbWluZyBtZXRob2QuXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIHBhcmFtZXRlcnMgZm9yIHNlbmRpbmcgdGhlIG1lc3NhZ2UuXG4gICAgICogQHJldHVybiBUaGUgbW9kZWwncyByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjaGF0ID0gYWkuY2hhdHMuY3JlYXRlKHttb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnfSk7XG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjaGF0LnNlbmRNZXNzYWdlU3RyZWFtKHtcbiAgICAgKiAgIG1lc3NhZ2U6ICdXaHkgaXMgdGhlIHNreSBibHVlPydcbiAgICAgKiB9KTtcbiAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlc3BvbnNlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhjaHVuay50ZXh0KTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2VTdHJlYW0ocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kUHJvbWlzZTtcbiAgICAgICAgY29uc3QgaW5wdXRDb250ZW50ID0gdENvbnRlbnQocGFyYW1zLm1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBzdHJlYW1SZXNwb25zZSA9IHRoaXMubW9kZWxzTW9kdWxlLmdlbmVyYXRlQ29udGVudFN0cmVhbSh7XG4gICAgICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIGNvbnRlbnRzOiB0aGlzLmdldEhpc3RvcnkodHJ1ZSkuY29uY2F0KGlucHV0Q29udGVudCksXG4gICAgICAgICAgICBjb25maWc6IChfYSA9IHBhcmFtcy5jb25maWcpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuY29uZmlnLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgaW50ZXJuYWwgdHJhY2tpbmcgb2Ygc2VuZCBjb21wbGV0aW9uIHByb21pc2UgLSBgc2VuZFByb21pc2VgXG4gICAgICAgIC8vIGZvciBib3RoIHN1Y2Nlc3MgYW5kIGZhaWx1cmUgcmVzcG9uc2UuIFRoZSBhY3R1YWwgZmFpbHVyZSBpcyBzdGlsbFxuICAgICAgICAvLyBwcm9wYWdhdGVkIGJ5IHRoZSBgYXdhaXQgc3RyZWFtUmVzcG9uc2VgLlxuICAgICAgICB0aGlzLnNlbmRQcm9taXNlID0gc3RyZWFtUmVzcG9uc2VcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHVuZGVmaW5lZClcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHN0cmVhbVJlc3BvbnNlO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnByb2Nlc3NTdHJlYW1SZXNwb25zZShyZXNwb25zZSwgaW5wdXRDb250ZW50KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2hhdCBoaXN0b3J5LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgaGlzdG9yeSBpcyBhIGxpc3Qgb2YgY29udGVudHMgYWx0ZXJuYXRpbmcgYmV0d2VlbiB1c2VyIGFuZCBtb2RlbC5cbiAgICAgKlxuICAgICAqIFRoZXJlIGFyZSB0d28gdHlwZXMgb2YgaGlzdG9yeTpcbiAgICAgKiAtIFRoZSBgY3VyYXRlZCBoaXN0b3J5YCBjb250YWlucyBvbmx5IHRoZSB2YWxpZCB0dXJucyBiZXR3ZWVuIHVzZXIgYW5kXG4gICAgICogbW9kZWwsIHdoaWNoIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHN1YnNlcXVlbnQgcmVxdWVzdHMgc2VudCB0byB0aGUgbW9kZWwuXG4gICAgICogLSBUaGUgYGNvbXByZWhlbnNpdmUgaGlzdG9yeWAgY29udGFpbnMgYWxsIHR1cm5zLCBpbmNsdWRpbmcgaW52YWxpZCBvclxuICAgICAqICAgZW1wdHkgbW9kZWwgb3V0cHV0cywgcHJvdmlkaW5nIGEgY29tcGxldGUgcmVjb3JkIG9mIHRoZSBoaXN0b3J5LlxuICAgICAqXG4gICAgICogVGhlIGhpc3RvcnkgaXMgdXBkYXRlZCBhZnRlciByZWNlaXZpbmcgdGhlIHJlc3BvbnNlIGZyb20gdGhlIG1vZGVsLFxuICAgICAqIGZvciBzdHJlYW1pbmcgcmVzcG9uc2UsIGl0IG1lYW5zIHJlY2VpdmluZyB0aGUgbGFzdCBjaHVuayBvZiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBUaGUgYGNvbXByZWhlbnNpdmUgaGlzdG9yeWAgaXMgcmV0dXJuZWQgYnkgZGVmYXVsdC4gVG8gZ2V0IHRoZSBgY3VyYXRlZFxuICAgICAqIGhpc3RvcnlgLCBzZXQgdGhlIGBjdXJhdGVkYCBwYXJhbWV0ZXIgdG8gYHRydWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGN1cmF0ZWQgLSB3aGV0aGVyIHRvIHJldHVybiB0aGUgY3VyYXRlZCBoaXN0b3J5IG9yIHRoZSBjb21wcmVoZW5zaXZlXG4gICAgICogICAgIGhpc3RvcnkuXG4gICAgICogQHJldHVybiBIaXN0b3J5IGNvbnRlbnRzIGFsdGVybmF0aW5nIGJldHdlZW4gdXNlciBhbmQgbW9kZWwgZm9yIHRoZSBlbnRpcmVcbiAgICAgKiAgICAgY2hhdCBzZXNzaW9uLlxuICAgICAqL1xuICAgIGdldEhpc3RvcnkoY3VyYXRlZCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGhpc3RvcnkgPSBjdXJhdGVkXG4gICAgICAgICAgICA/IGV4dHJhY3RDdXJhdGVkSGlzdG9yeSh0aGlzLmhpc3RvcnkpXG4gICAgICAgICAgICA6IHRoaXMuaGlzdG9yeTtcbiAgICAgICAgLy8gRGVlcCBjb3B5IHRoZSBoaXN0b3J5IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBoaXN0b3J5IG91dHNpZGUgb2YgdGhlXG4gICAgICAgIC8vIGNoYXQgc2Vzc2lvbi5cbiAgICAgICAgcmV0dXJuIHN0cnVjdHVyZWRDbG9uZShoaXN0b3J5KTtcbiAgICB9XG4gICAgcHJvY2Vzc1N0cmVhbVJlc3BvbnNlKHN0cmVhbVJlc3BvbnNlLCBpbnB1dENvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogcHJvY2Vzc1N0cmVhbVJlc3BvbnNlXzEoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICAgICAgdmFyIF9kLCBfZTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dENvbnRlbnQgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBzdHJlYW1SZXNwb25zZV8xID0gX19hc3luY1ZhbHVlcyhzdHJlYW1SZXNwb25zZSksIHN0cmVhbVJlc3BvbnNlXzFfMTsgc3RyZWFtUmVzcG9uc2VfMV8xID0geWllbGQgX19hd2FpdChzdHJlYW1SZXNwb25zZV8xLm5leHQoKSksIF9hID0gc3RyZWFtUmVzcG9uc2VfMV8xLmRvbmUsICFfYTsgX2YgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gc3RyZWFtUmVzcG9uc2VfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZFJlc3BvbnNlKGNodW5rKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IChfZSA9IChfZCA9IGNodW5rLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZFswXSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Q29udGVudC5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9mICYmICFfYSAmJiAoX2IgPSBzdHJlYW1SZXNwb25zZV8xLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChzdHJlYW1SZXNwb25zZV8xKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVjb3JkSGlzdG9yeShpbnB1dENvbnRlbnQsIG91dHB1dENvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVjb3JkSGlzdG9yeSh1c2VySW5wdXQsIG1vZGVsT3V0cHV0LCBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5KSB7XG4gICAgICAgIGxldCBvdXRwdXRDb250ZW50cyA9IFtdO1xuICAgICAgICBpZiAobW9kZWxPdXRwdXQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgbW9kZWxPdXRwdXQuZXZlcnkoKGNvbnRlbnQpID0+IGNvbnRlbnQucm9sZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgb3V0cHV0Q29udGVudHMgPSBtb2RlbE91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFwcGVuZHMgYW4gZW1wdHkgY29udGVudCB3aGVuIG1vZGVsIHJldHVybnMgZW1wdHkgcmVzcG9uc2UsIHNvIHRoYXQgdGhlXG4gICAgICAgICAgICAvLyBoaXN0b3J5IGlzIGFsd2F5cyBhbHRlcm5hdGluZyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsLlxuICAgICAgICAgICAgb3V0cHV0Q29udGVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgcm9sZTogJ21vZGVsJyxcbiAgICAgICAgICAgICAgICBwYXJ0czogW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSAmJlxuICAgICAgICAgICAgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCguLi5leHRyYWN0Q3VyYXRlZEhpc3RvcnkoYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2godXNlcklucHV0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCguLi5vdXRwdXRDb250ZW50cyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIEFQSSBlcnJvcnMgcmFpc2VkIGJ5IHRoZSBHZW5BSSBBUEkuXG4gKi9cbmNsYXNzIEFwaUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0FwaUVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEFwaUVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgR29vZ2xlIEdlbiBBSSBTREsgZ2VuZXJhdG9yIERPIE5PVCBFRElULlxuZnVuY3Rpb24gY3JlYXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GaWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlJ10pO1xuICAgIGlmIChmcm9tRmlsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGUnXSwgZnJvbUZpbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUZpbGVQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ2ZpbGUnXSwgdEZpbGVOYW1lKGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUZpbGVSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0RmlsZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnZmlsZSddLCB0RmlsZU5hbWUoZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW50ZXJuYWxSZWdpc3RlckZpbGVzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VyaXMnXSk7XG4gICAgaWYgKGZyb21VcmlzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpcyddLCBmcm9tVXJpcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RGaWxlc0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RmlsZXNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0RmlsZXNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEZpbGVzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZXMnXSk7XG4gICAgaWYgKGZyb21GaWxlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRmlsZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRmlsZXNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlcyddKTtcbiAgICBpZiAoZnJvbUZpbGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GaWxlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBGaWxlcyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGZpbGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBsaXN0IHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIHBhZ2VyIG9mIGZpbGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCBmaWxlcyA9IGF3YWl0IGFpLmZpbGVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDJ9fSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKGZpbGUpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX0ZJTEVTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeCksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKHBhcmFtcyksIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYSBmaWxlIGFzeW5jaHJvbm91c2x5IHRvIHRoZSBHZW1pbmkgQVBJLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBhdmFpbGFibGUgaW4gVmVydGV4IEFJLlxuICAgICAqIFN1cHBvcnRlZCB1cGxvYWQgc291cmNlczpcbiAgICAgKiAtIE5vZGUuanM6IEZpbGUgcGF0aCAoc3RyaW5nKSBvciBCbG9iIG9iamVjdC5cbiAgICAgKiAtIEJyb3dzZXI6IEJsb2Igb2JqZWN0IChlLmcuLCBGaWxlKS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGBtaW1lVHlwZWAgY2FuIGJlIHNwZWNpZmllZCBpbiB0aGUgYGNvbmZpZ2AgcGFyYW1ldGVyLiBJZiBvbWl0dGVkOlxuICAgICAqICAtIEZvciBmaWxlIHBhdGggKHN0cmluZykgaW5wdXRzLCB0aGUgYG1pbWVUeXBlYCB3aWxsIGJlIGluZmVycmVkIGZyb20gdGhlXG4gICAgICogICAgIGZpbGUgZXh0ZW5zaW9uLlxuICAgICAqICAtIEZvciBCbG9iIG9iamVjdCBpbnB1dHMsIHRoZSBgbWltZVR5cGVgIHdpbGwgYmUgc2V0IHRvIHRoZSBCbG9iJ3MgYHR5cGVgXG4gICAgICogICAgIHByb3BlcnR5LlxuICAgICAqIFNvbWV4IGVhbXBsZXMgZm9yIGZpbGUgZXh0ZW5zaW9uIHRvIG1pbWVUeXBlIG1hcHBpbmc6XG4gICAgICogLnR4dCAtPiB0ZXh0L3BsYWluXG4gICAgICogLmpzb24gLT4gYXBwbGljYXRpb24vanNvblxuICAgICAqIC5qcGcgIC0+IGltYWdlL2pwZWdcbiAgICAgKiAucG5nIC0+IGltYWdlL3BuZ1xuICAgICAqIC5tcDMgLT4gYXVkaW8vbXBlZ1xuICAgICAqIC5tcDQgLT4gdmlkZW8vbXA0XG4gICAgICpcbiAgICAgKiBUaGlzIHNlY3Rpb24gY2FuIGNvbnRhaW4gbXVsdGlwbGUgcGFyYWdyYXBocyBhbmQgY29kZSBleGFtcGxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBPcHRpb25hbCBwYXJhbWV0ZXJzIHNwZWNpZmllZCBpbiB0aGVcbiAgICAgKiAgICAgICAgYHR5cGVzLlVwbG9hZEZpbGVQYXJhbWV0ZXJzYCBpbnRlcmZhY2UuXG4gICAgICogICAgICAgICBAc2VlIHtAbGluayB0eXBlcy5VcGxvYWRGaWxlUGFyYW1ldGVycyNjb25maWd9IGZvciB0aGUgb3B0aW9uYWxcbiAgICAgKiAgICAgICAgIGNvbmZpZyBpbiB0aGUgcGFyYW1ldGVycy5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYHR5cGVzLkZpbGVgIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIGNhbGxlZCBvbiBhIFZlcnRleCBBSSBjbGllbnQuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgYG1pbWVUeXBlYCBpcyBub3QgcHJvdmlkZWQgYW5kIGNhbiBub3QgYmUgaW5mZXJyZWQsXG4gICAgICogdGhlIGBtaW1lVHlwZWAgY2FuIGJlIHByb3ZpZGVkIGluIHRoZSBgcGFyYW1zLmNvbmZpZ2AgcGFyYW1ldGVyLlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3Igb2NjdXJzIGlmIGEgc3VpdGFibGUgdXBsb2FkIGxvY2F0aW9uIGNhbm5vdCBiZSBlc3RhYmxpc2hlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVGhlIGZvbGxvd2luZyBjb2RlIHVwbG9hZHMgYSBmaWxlIHRvIEdlbWluaSBBUEkuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGZpbGUgPSBhd2FpdCBhaS5maWxlcy51cGxvYWQoe2ZpbGU6ICdmaWxlLnR4dCcsIGNvbmZpZzoge1xuICAgICAqICAgbWltZVR5cGU6ICd0ZXh0L3BsYWluJyxcbiAgICAgKiB9fSk7XG4gICAgICogY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWQocGFyYW1zKSB7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmVydGV4IEFJIGRvZXMgbm90IHN1cHBvcnQgdXBsb2FkaW5nIGZpbGVzLiBZb3UgY2FuIHNoYXJlIGZpbGVzIHRocm91Z2ggYSBHQ1MgYnVja2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgLnVwbG9hZEZpbGUocGFyYW1zLmZpbGUsIHBhcmFtcy5jb25maWcpXG4gICAgICAgICAgICAudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZHMgYSByZW1vdGVseSBzdG9yZWQgZmlsZSBhc3luY2hyb25vdXNseSB0byBhIGxvY2F0aW9uIHNwZWNpZmllZCBpblxuICAgICAqIHRoZSBgcGFyYW1zYCBvYmplY3QuIFRoaXMgbWV0aG9kIG9ubHkgd29ya3Mgb24gTm9kZSBlbnZpcm9ubWVudCwgdG9cbiAgICAgKiBkb3dubG9hZCBmaWxlcyBpbiB0aGUgYnJvd3NlciwgdXNlIGEgYnJvd3NlciBjb21wbGlhbnQgbWV0aG9kIGxpa2UgYW4gPGE+XG4gICAgICogdGFnLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZG93bmxvYWQgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVGhlIGZvbGxvd2luZyBjb2RlIGRvd25sb2FkcyBhbiBleGFtcGxlIGZpbGUgbmFtZWQgXCJmaWxlcy9tZWhvenB4Zjg3N2RcIiBhc1xuICAgICAqIFwiZmlsZS50eHRcIi5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuZmlsZXMuZG93bmxvYWQoe2ZpbGU6IGZpbGUubmFtZSwgZG93bmxvYWRQYXRoOiAnZmlsZS50eHQnfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZG93bmxvYWQocGFyYW1zKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuYXBpQ2xpZW50LmRvd25sb2FkRmlsZShwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgR29vZ2xlIENsb3VkIFN0b3JhZ2UgZmlsZXMgZm9yIHVzZSB3aXRoIHRoZSBBUEkuXG4gICAgICogVGhpcyBtZXRob2QgaXMgb25seSBhdmFpbGFibGUgaW4gTm9kZS5qcyBlbnZpcm9ubWVudHMuXG4gICAgICovXG4gICAgYXN5bmMgcmVnaXN0ZXJGaWxlcyhwYXJhbXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWdpc3RlckZpbGVzIGlzIG9ubHkgc3VwcG9ydGVkIGluIE5vZGUuanMgZW52aXJvbm1lbnRzLicpO1xuICAgIH1cbiAgICBhc3luYyBfcmVnaXN0ZXJGaWxlcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJGaWxlc0ludGVybmFsKHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdEZpbGVzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2ZpbGVzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0RmlsZXNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RGaWxlc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjcmVhdGVJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd1cGxvYWQvdjFiZXRhL2ZpbGVzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjcmVhdGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBDcmVhdGVGaWxlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZmlsZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzZXJ2aWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIFRoZSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHR5cGVzLkZpbGUgb2JqZWN0IHJlcXVlc3RlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjb25maWc6IEdldEZpbGVQYXJhbWV0ZXJzID0ge1xuICAgICAqICAgbmFtZTogZmlsZU5hbWUsXG4gICAgICogfTtcbiAgICAgKiBmaWxlID0gYXdhaXQgYWkuZmlsZXMuZ2V0KGNvbmZpZyk7XG4gICAgICogY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldEZpbGVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZXMve2ZpbGV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSByZW1vdGVseSBzdG9yZWQgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGRlbGV0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIERlbGV0ZUZpbGVSZXNwb25zZSwgdGhlIHJlc3BvbnNlIGZvciB0aGUgZGVsZXRlIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVGhlIGZvbGxvd2luZyBjb2RlIGRlbGV0ZXMgYW4gZXhhbXBsZSBmaWxlIG5hbWVkIFwiZmlsZXMvbWVob3pweGY4NzdkXCIuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmZpbGVzLmRlbGV0ZSh7bmFtZTogZmlsZS5uYW1lfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVGaWxlUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2ZpbGVzL3tmaWxlfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlRmlsZVJlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlRmlsZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZWdpc3RlckZpbGVzSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGludGVybmFsUmVnaXN0ZXJGaWxlc1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdmaWxlczpyZWdpc3RlcicsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gcmVnaXN0ZXJGaWxlc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgUmVnaXN0ZXJGaWxlc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gYmxvYlRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9NbGRldiQyKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWQnXSk7XG4gICAgaWYgKGZyb21JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkJ10sIGZyb21JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydGlhbEFyZ3MnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRpYWxBcmdzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3dpbGxDb250aW51ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd2lsbENvbnRpbnVlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmVoYXZpb3InXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JlaGF2aW9yIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGlvbkNvbmZpZ1RvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbW9kZWxTZWxlY3Rpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbENvbmZpZyddLCBmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvVGltZXN0YW1wID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXVkaW9UaW1lc3RhbXAnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXVkaW9UaW1lc3RhbXAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb1RpbWVzdGFtcCddLCBmcm9tQXVkaW9UaW1lc3RhbXApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJ10sIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnJlcXVlbmN5UGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZyZXF1ZW5jeVBlbmFsdHknXSwgZnJvbUZyZXF1ZW5jeVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVzZW5jZVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVzZW5jZVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlc2VuY2VQZW5hbHR5J10sIGZyb21QcmVzZW5jZVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTWltZVR5cGUnXSwgZnJvbVJlc3BvbnNlTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VTY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VTY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVNjaGVtYSddLCBmcm9tUmVzcG9uc2VTY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm91dGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JvdXRpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUm91dGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSwgZnJvbVJvdXRpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAoZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10sIGZyb21TcGVlY2hDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQ29uZmlnJ10sIGZyb21UaGlua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAoZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5hYmxlRW5oYW5jZWRDaXZpY0Fuc3dlcnMnXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuYWJsZUVuaGFuY2VkQ2l2aWNBbnN3ZXJzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlTWFwc1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdXRoQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVXaWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddKTtcbiAgICBpZiAoZnJvbUVuYWJsZVdpZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddLCBmcm9tRW5hYmxlV2lkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGNsdWRlRG9tYWlucyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydibG9ja2luZ0NvbmZpZGVuY2UnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jsb2NraW5nQ29uZmlkZW5jZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBmcm9tVGltZVJhbmdlRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJ10sIGZyb21HZW5lcmF0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc3BlZWNoQ29uZmlnJ10sIHRMaXZlU3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0aGlua2luZ0NvbmZpZyddLCBmcm9tVGhpbmtpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZyddLCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvTWxkZXYkMih0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldiQyKHRUb29sKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2Vzc2lvblJlc3VtcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXNzaW9uUmVzdW1wdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZXNzaW9uUmVzdW1wdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdzZXNzaW9uUmVzdW1wdGlvbiddLCBzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYkMShmcm9tU2Vzc2lvblJlc3VtcHRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24nXSwgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlYWx0aW1lSW5wdXRDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdyZWFsdGltZUlucHV0Q29uZmlnJ10sIGZyb21SZWFsdGltZUlucHV0Q29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJ10sIGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvYWN0aXZpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb2FjdGl2aXR5J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvYWN0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncHJvYWN0aXZpdHknXSwgZnJvbVByb2FjdGl2aXR5KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwbGljaXRWYWRTaWduYWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGxpY2l0VmFkU2lnbmFsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0Q29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJ10sIGdlbmVyYXRpb25Db25maWdUb1ZlcnRleCQxKGZyb21HZW5lcmF0aW9uQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NwZWVjaENvbmZpZyddLCB0TGl2ZVNwZWVjaENvbmZpZyhmcm9tU3BlZWNoQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndGhpbmtpbmdDb25maWcnXSwgZnJvbVRoaW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnXSwgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3N5c3RlbUluc3RydWN0aW9uJ10sIHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdFRvb2xzKGZyb21Ub29scyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvVmVydGV4JDEodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlc3Npb25SZXN1bXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Nlc3Npb25SZXN1bXB0aW9uJ10sIGZyb21TZXNzaW9uUmVzdW1wdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWFsdGltZUlucHV0Q29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncmVhbHRpbWVJbnB1dENvbmZpZyddLCBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbiddLCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb2FjdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9hY3Rpdml0eSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb2FjdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Byb2FjdGl2aXR5J10sIGZyb21Qcm9hY3Rpdml0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBsaWNpdFZhZFNpZ25hbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4cGxpY2l0VmFkU2lnbmFsJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGxpY2l0VmFkU2lnbmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2V4cGxpY2l0VmFkU2lnbmFsJ10sIGZyb21FeHBsaWNpdFZhZFNpZ25hbCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGxpdmVDb25uZWN0Q29uZmlnVG9NbGRldiQxKGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXAnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXZlQ29ubmVjdENvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY1NldENvbmZpZ1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtdXNpY0dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTXVzaWNHZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVzaWNHZW5lcmF0aW9uQ29uZmlnJ10sIGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNTZXRXZWlnaHRlZFByb21wdHNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tV2VpZ2h0ZWRQcm9tcHRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnd2VpZ2h0ZWRQcm9tcHRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVdlaWdodGVkUHJvbXB0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tV2VpZ2h0ZWRQcm9tcHRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd3ZWlnaHRlZFByb21wdHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1lZGlhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZWRpYSddKTtcbiAgICBpZiAoZnJvbU1lZGlhICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRCbG9icyhmcm9tTWVkaWEpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2JUb01sZGV2JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYUNodW5rcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1ZGlvJ10pO1xuICAgIGlmIChmcm9tQXVkaW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpbyddLCBibG9iVG9NbGRldiQyKHRBdWRpb0Jsb2IoZnJvbUF1ZGlvKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW9TdHJlYW1FbmQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdWRpb1N0cmVhbUVuZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdWRpb1N0cmVhbUVuZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvU3RyZWFtRW5kJ10sIGZyb21BdWRpb1N0cmVhbUVuZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIGJsb2JUb01sZGV2JDIodEltYWdlQmxvYihmcm9tVmlkZW8pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlTdGFydCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FjdGl2aXR5U3RhcnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlTdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5U3RhcnQnXSwgZnJvbUFjdGl2aXR5U3RhcnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlFbmQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FjdGl2aXR5RW5kJ10pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlFbmQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eUVuZCddLCBmcm9tQWN0aXZpdHlFbmQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1lZGlhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZWRpYSddKTtcbiAgICBpZiAoZnJvbU1lZGlhICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRCbG9icyhmcm9tTWVkaWEpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYUNodW5rcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1ZGlvJ10pO1xuICAgIGlmIChmcm9tQXVkaW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpbyddLCB0QXVkaW9CbG9iKGZyb21BdWRpbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW9TdHJlYW1FbmQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdWRpb1N0cmVhbUVuZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdWRpb1N0cmVhbUVuZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvU3RyZWFtRW5kJ10sIGZyb21BdWRpb1N0cmVhbUVuZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHRJbWFnZUJsb2IoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlTdGFydCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FjdGl2aXR5U3RhcnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlTdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5U3RhcnQnXSwgZnJvbUFjdGl2aXR5U3RhcnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlFbmQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FjdGl2aXR5RW5kJ10pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlFbmQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eUVuZCddLCBmcm9tQWN0aXZpdHlFbmQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyTWVzc2FnZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNldHVwQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXR1cENvbXBsZXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNldHVwQ29tcGxldGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cENvbXBsZXRlJ10sIGZyb21TZXR1cENvbXBsZXRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlcnZlckNvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXJ2ZXJDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlcnZlckNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXJ2ZXJDb250ZW50J10sIGZyb21TZXJ2ZXJDb250ZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ2FsbCddKTtcbiAgICBpZiAoZnJvbVRvb2xDYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbENhbGwnXSwgZnJvbVRvb2xDYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDYWxsQ2FuY2VsbGF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbENhbGxDYW5jZWxsYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sQ2FsbENhbmNlbGxhdGlvbiddLCBmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNhZ2VNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VzYWdlTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXNhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VzYWdlTWV0YWRhdGEnXSwgdXNhZ2VNZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbVVzYWdlTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvQXdheSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29Bd2F5J10pO1xuICAgIGlmIChmcm9tR29Bd2F5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29Bd2F5J10sIGZyb21Hb0F3YXkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2Vzc2lvblJlc3VtcHRpb25VcGRhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXNzaW9uUmVzdW1wdGlvblVwZGF0ZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nlc3Npb25SZXN1bXB0aW9uVXBkYXRlJ10sIGZyb21TZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Wb2ljZUFjdGl2aXR5RGV0ZWN0aW9uU2lnbmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndm9pY2VBY3Rpdml0eURldGVjdGlvblNpZ25hbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Wb2ljZUFjdGl2aXR5RGV0ZWN0aW9uU2lnbmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VBY3Rpdml0eURldGVjdGlvblNpZ25hbCddLCBmcm9tVm9pY2VBY3Rpdml0eURldGVjdGlvblNpZ25hbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Wb2ljZUFjdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndm9pY2VBY3Rpdml0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Wb2ljZUFjdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VBY3Rpdml0eSddLCB2b2ljZUFjdGl2aXR5RnJvbVZlcnRleChmcm9tVm9pY2VBY3Rpdml0eSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0VG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9NbGRldiQyKGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnVuY3Rpb25DYWxsVG9NbGRldiQyKGZyb21GdW5jdGlvbkNhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9NbGRldiQyKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIGZyb21WaWRlb01ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2Vzc2lvblJlc3VtcHRpb25Db25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUhhbmRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaGFuZGxlJ10pO1xuICAgIGlmIChmcm9tSGFuZGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaGFuZGxlJ10sIGZyb21IYW5kbGUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0cmFuc3BhcmVudCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNwYXJlbnQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBmcm9tQ29tcHV0ZXJVc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUZpbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlU2VhcmNoJ10sIGZyb21GaWxlU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZ29vZ2xlTWFwc1RvTWxkZXYkMihmcm9tR29vZ2xlTWFwcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQyKGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWwnXSwgZnJvbVJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGVTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VudGVycHJpc2VXZWJTZWFyY2gnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSwgZnJvbUVudGVycHJpc2VXZWJTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGZyb21Hb29nbGVNYXBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGZyb21Hb29nbGVTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCBmcm9tVXJsQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVzYWdlTWV0YWRhdGFGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0VG9rZW5Db3VudCddLCBmcm9tUHJvbXB0VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVkQ29udGVudFRva2VuQ291bnQnXSwgZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZXNUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlVG9rZW5Db3VudCddLCBmcm9tUmVzcG9uc2VUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbFVzZVByb21wdFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbFVzZVByb21wdFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sVXNlUHJvbXB0VG9rZW5Db3VudCddLCBmcm9tVG9vbFVzZVByb21wdFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodHNUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodHNUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRzVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRzVG9rZW5Db3VudCddLCBmcm9tVGhvdWdodHNUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvdGFsVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RvdGFsVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Ub3RhbFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3RhbFRva2VuQ291bnQnXSwgZnJvbVRvdGFsVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0VG9rZW5zRGV0YWlscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZVRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZVRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYWNoZVRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlVG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FuZGlkYXRlc1Rva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21SZXNwb25zZVRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlVG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Ub29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UcmFmZmljVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHJhZmZpY1R5cGUnXSk7XG4gICAgaWYgKGZyb21UcmFmZmljVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RyYWZmaWNUeXBlJ10sIGZyb21UcmFmZmljVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZvaWNlQWN0aXZpdHlGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZUFjdGl2aXR5VHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHlwZSddKTtcbiAgICBpZiAoZnJvbVZvaWNlQWN0aXZpdHlUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VBY3Rpdml0eVR5cGUnXSwgZnJvbVZvaWNlQWN0aXZpdHlUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiBibG9iVG9NbGRldiQxKGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmRpZGF0ZUZyb21NbGRldihmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudCddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50J10sIGZyb21Db250ZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNpdGF0aW9uTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjaXRhdGlvbk1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNpdGF0aW9uTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaXRhdGlvbk1ldGFkYXRhJ10sIGNpdGF0aW9uTWV0YWRhdGFGcm9tTWxkZXYoZnJvbUNpdGF0aW9uTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSk7XG4gICAgaWYgKGZyb21Ub2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5Db3VudCddLCBmcm9tVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaW5pc2hSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbmlzaFJlYXNvbiddKTtcbiAgICBpZiAoZnJvbUZpbmlzaFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbmlzaFJlYXNvbiddLCBmcm9tRmluaXNoUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF2Z0xvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdmdMb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUF2Z0xvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSwgZnJvbUF2Z0xvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdyb3VuZGluZ01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3JvdW5kaW5nTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR3JvdW5kaW5nTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydncm91bmRpbmdNZXRhZGF0YSddLCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5kZXggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2luZGV4J10pO1xuICAgIGlmIChmcm9tSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmRleCddLCBmcm9tSW5kZXgpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnNSZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsb2dwcm9ic1Jlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9ic1Jlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzUmVzdWx0J10sIGZyb21Mb2dwcm9ic1Jlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlSYXRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5UmF0aW5ncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TYWZldHlSYXRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TYWZldHlSYXRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzYWZldHlSYXRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0TWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1cmxDb250ZXh0TWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dE1ldGFkYXRhJ10sIGZyb21VcmxDb250ZXh0TWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2l0YXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjaXRhdGlvblNvdXJjZXMnXSk7XG4gICAgaWYgKGZyb21DaXRhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNpdGF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlVG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRva2Vuc0luZm8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2Vuc0luZm8nXSk7XG4gICAgaWYgKGZyb21Ub2tlbnNJbmZvICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Ub2tlbnNJbmZvO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b2tlbnNJbmZvJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRFbWJlZGRpbmdGcm9tVmVydGV4KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WYWx1ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZhbHVlcyddKTtcbiAgICBpZiAoZnJvbVZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZhbHVlcyddLCBmcm9tVmFsdWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRpc3RpY3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRpc3RpY3MnXSk7XG4gICAgaWYgKGZyb21TdGF0aXN0aWNzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGlzdGljcyddLCBjb250ZW50RW1iZWRkaW5nU3RhdGlzdGljc0Zyb21WZXJ0ZXgoZnJvbVN0YXRpc3RpY3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEVtYmVkZGluZ1N0YXRpc3RpY3NGcm9tVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHJ1bmNhdGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0cnVuY2F0ZWQnXSk7XG4gICAgaWYgKGZyb21UcnVuY2F0ZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0cnVuY2F0ZWQnXSwgZnJvbVRydW5jYXRlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbl9jb3VudCddKTtcbiAgICBpZiAoZnJvbVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b2tlbkNvdW50J10sIGZyb21Ub2tlbkNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYkMShmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udHJvbFJlZmVyZW5jZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29udHJvbFR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRyb2xUeXBlJ10pO1xuICAgIGlmIChmcm9tQ29udHJvbFR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250cm9sVHlwZSddLCBmcm9tQ29udHJvbFR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlQ29udHJvbEltYWdlQ29tcHV0YXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVDb250cm9sJ10sIGZyb21FbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N5c3RlbUluc3RydWN0aW9uIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29scyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnZW5lcmF0aW9uQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZW5lcmF0aW9uQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCB0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Ub29scztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZ2VuZXJhdGlvbkNvbmZpZyddLCBnZW5lcmF0aW9uQ29uZmlnVG9WZXJ0ZXgoZnJvbUdlbmVyYXRpb25Db25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY291bnRUb2tlbnNDb25maWdUb01sZGV2KGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc1BhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY291bnRUb2tlbnNDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG90YWxUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvdGFsVG9rZW5zJ10pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3RhbFRva2VucyddLCBmcm9tVG90YWxUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50J10sIGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvdGFsVG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3RhbFRva2VucyddKTtcbiAgICBpZiAoZnJvbVRvdGFsVG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG90YWxUb2tlbnMnXSwgZnJvbVRvdGFsVG9rZW5zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlTW9kZWxQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZU1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlTW9kZWxSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZU1vZGVsUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZWRpdEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZVNjYWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3VpZGFuY2VTY2FsZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HdWlkYW5jZVNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZ3VpZGFuY2VTY2FsZSddLCBmcm9tR3VpZGFuY2VTY2FsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcyddLCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVJhaVJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVSYWlSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVJhaVJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVSYWlSZWFzb24nXSwgZnJvbUluY2x1ZGVSYWlSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFuZ3VhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdsYW5ndWFnZSddLCBmcm9tTGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFkZFdhdGVybWFyayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRkV2F0ZXJtYXJrJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRkV2F0ZXJtYXJrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYWRkV2F0ZXJtYXJrJ10sIGZyb21BZGRXYXRlcm1hcmspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRWRpdE1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VkaXRNb2RlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRWRpdE1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlZGl0TW9kZSddLCBmcm9tRWRpdE1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmFzZVN0ZXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlU3RlcHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CYXNlU3RlcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlZGl0Q29uZmlnJywgJ2Jhc2VTdGVwcyddLCBmcm9tQmFzZVN0ZXBzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZWRpdEltYWdlUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlZmVyZW5jZUltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUmVmZXJlbmNlSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWxUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdyZWZlcmVuY2VJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZWRpdEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlZGl0SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50Q29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGFza1R5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rhc2tUeXBlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGFza1R5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncmVxdWVzdHNbXScsICd0YXNrVHlwZSddLCBmcm9tVGFza1R5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGl0bGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RpdGxlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGl0bGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncmVxdWVzdHNbXScsICd0aXRsZSddLCBmcm9tVGl0bGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXREaW1lbnNpb25hbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ291dHB1dERpbWVuc2lvbmFsaXR5J10sIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaW1lVHlwZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRvVHJ1bmNhdGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dG9UcnVuY2F0ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGFza1R5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rhc2tUeXBlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGFza1R5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzW10nLCAndGFza190eXBlJ10sIGZyb21UYXNrVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaXRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGl0bGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UaXRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbXScsICd0aXRsZSddLCBmcm9tVGl0bGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXREaW1lbnNpb25hbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dERpbWVuc2lvbmFsaXR5J10sIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbXScsICdtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXV0b1RydW5jYXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRvVHJ1bmNhdGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21BdXRvVHJ1bmNhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhdXRvVHJ1bmNhdGUnXSwgZnJvbUF1dG9UcnVuY2F0ZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50c0ZvckVtYmVkKGFwaUNsaWVudCwgZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdHNbXScsICdjb250ZW50J10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGVtYmVkQ29udGVudENvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxGb3JFbWJlZENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWxGb3JFbWJlZENvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0c1tdJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbEZvckVtYmVkQ29udGVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzRm9yRW1iZWQoYXBpQ2xpZW50LCBmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbXScsICdjb250ZW50J10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGVtYmVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW1iZWRkaW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW1iZWRkaW5ncyddKTtcbiAgICBpZiAoZnJvbUVtYmVkZGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUVtYmVkZGluZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VtYmVkZGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW1iZWRkaW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWRpY3Rpb25zW10nLFxuICAgICAgICAnZW1iZWRkaW5ncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbWJlZGRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21FbWJlZGRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRFbWJlZGRpbmdGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW1iZWRkaW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbmRwb2ludEZyb21WZXJ0ZXgoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRwb2ludCddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlcGxveWVkTW9kZWxJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2RlcGxveWVkTW9kZWxJZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EZXBsb3llZE1vZGVsSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXBsb3llZE1vZGVsSWQnXSwgZnJvbURlcGxveWVkTW9kZWxJZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9NbGRldiQxKGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkMShmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZCddKTtcbiAgICBpZiAoZnJvbUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWQnXSwgZnJvbUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFyZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FyZ3MnXSk7XG4gICAgaWYgKGZyb21BcmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXJncyddLCBmcm9tQXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0aWFsQXJncyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFydGlhbEFyZ3MgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnd2lsbENvbnRpbnVlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3aWxsQ29udGludWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbGxvd2VkRnVuY3Rpb25OYW1lcyddLCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RyZWFtRnVuY3Rpb25DYWxsQXJndW1lbnRzJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJlYW1GdW5jdGlvbkNhbGxBcmd1bWVudHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BhcmFtZXRlcnNKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVyc0pzb25TY2hlbWEnXSwgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZnJvbVJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JlaGF2aW9yJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiZWhhdmlvciBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb01sZGV2JDEodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAoZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZUNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZUNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlQ291bnQnXSwgZnJvbUNhbmRpZGF0ZUNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdG9wU2VxdWVuY2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3RvcFNlcXVlbmNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdG9wU2VxdWVuY2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RvcFNlcXVlbmNlcyddLCBmcm9tU3RvcFNlcXVlbmNlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VMb2dwcm9icycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VMb2dwcm9icyddLCBmcm9tUmVzcG9uc2VMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzJ10sIGZyb21Mb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVzZW5jZVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVzZW5jZVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlc2VuY2VQZW5hbHR5J10sIGZyb21QcmVzZW5jZVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnJlcXVlbmN5UGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZyZXF1ZW5jeVBlbmFsdHknXSwgZnJvbUZyZXF1ZW5jeVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAoZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1pbWVUeXBlJ10sIGZyb21SZXNwb25zZU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VTY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VTY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVNjaGVtYSddLCB0U2NoZW1hKGZyb21SZXNwb25zZVNjaGVtYSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm91dGluZ0NvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncm91dGluZ0NvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFNlbGVjdGlvbkNvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbW9kZWxTZWxlY3Rpb25Db25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eVNldHRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5U2V0dGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5U2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNhZmV0eVNldHRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhZmV0eVNldHRpbmdUb01sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NhZmV0eVNldHRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldiQxKHRUb29sKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCB0b29sQ29uZmlnVG9NbGRldihmcm9tVG9vbENvbmZpZykpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhYmVscyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ2FjaGVkQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjYWNoZWRDb250ZW50J10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21DYWNoZWRDb250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10sIHRTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdWRpb1RpbWVzdGFtcCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXVkaW9UaW1lc3RhbXAgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aGlua2luZ0NvbmZpZyddLCBmcm9tVGhpbmtpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZUNvbmZpZyddLCBpbWFnZUNvbmZpZ1RvTWxkZXYoZnJvbUltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVFbmhhbmNlZENpdmljQW5zd2VycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUVuaGFuY2VkQ2l2aWNBbnN3ZXJzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuYWJsZUVuaGFuY2VkQ2l2aWNBbnN3ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5hYmxlRW5oYW5jZWRDaXZpY0Fuc3dlcnMnXSwgZnJvbUVuYWJsZUVuaGFuY2VkQ2l2aWNBbnN3ZXJzKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxBcm1vckNvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbW9kZWxBcm1vckNvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgdENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAoZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZUNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FuZGlkYXRlQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVDb3VudCddLCBmcm9tQ2FuZGlkYXRlQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0b3BTZXF1ZW5jZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdG9wU2VxdWVuY2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0b3BTZXF1ZW5jZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdG9wU2VxdWVuY2VzJ10sIGZyb21TdG9wU2VxdWVuY2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUxvZ3Byb2JzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUxvZ3Byb2JzJ10sIGZyb21SZXNwb25zZUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9ncHJvYnMnXSwgZnJvbUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZXNlbmNlUGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZXNlbmNlUGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVzZW5jZVBlbmFsdHknXSwgZnJvbVByZXNlbmNlUGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GcmVxdWVuY3lQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnJlcXVlbmN5UGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnJlcXVlbmN5UGVuYWx0eSddLCBmcm9tRnJlcXVlbmN5UGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTWltZVR5cGUnXSwgZnJvbVJlc3BvbnNlTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VTY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZVNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlU2NoZW1hJ10sIHRTY2hlbWEoZnJvbVJlc3BvbnNlU2NoZW1hKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm91dGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JvdXRpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUm91dGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSwgZnJvbVJvdXRpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtb2RlbFNlbGVjdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsQ29uZmlnJ10sIGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlTZXR0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVNldHRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eVNldHRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TYWZldHlTZXR0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NhZmV0eVNldHRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9WZXJ0ZXgodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIGZyb21Ub29sQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNhY2hlZENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY2FjaGVkQ29udGVudCddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tQ2FjaGVkQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAoZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddLCB0U3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvVGltZXN0YW1wID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXVkaW9UaW1lc3RhbXAnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXVkaW9UaW1lc3RhbXAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb1RpbWVzdGFtcCddLCBmcm9tQXVkaW9UaW1lc3RhbXApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQ29uZmlnJ10sIGZyb21UaGlua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21JbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlQ29uZmlnJ10sIGltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbUltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuYWJsZUVuaGFuY2VkQ2l2aWNBbnN3ZXJzJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmFibGVFbmhhbmNlZENpdmljQW5zd2VycyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbEFybW9yQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbW9kZWxBcm1vckNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Nb2RlbEFybW9yQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ21vZGVsQXJtb3JDb25maWcnXSwgZnJvbU1vZGVsQXJtb3JDb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGlvbkNvbmZpZyddLCBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0aW9uQ29uZmlnJ10sIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYW5kaWRhdGVzJ10pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FuZGlkYXRlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGVGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbFZlcnNpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddKTtcbiAgICBpZiAoZnJvbU1vZGVsVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddLCBmcm9tTW9kZWxWZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdEZlZWRiYWNrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0RmVlZGJhY2snLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0RmVlZGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRGZWVkYmFjayddLCBmcm9tUHJvbXB0RmVlZGJhY2spO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2VJZCddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUlkJ10sIGZyb21SZXNwb25zZUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIGZyb21Vc2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYW5kaWRhdGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxWZXJzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFZlcnNpb24nXSk7XG4gICAgaWYgKGZyb21Nb2RlbFZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbFZlcnNpb24nXSwgZnJvbU1vZGVsVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRGZWVkYmFjayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdEZlZWRiYWNrJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb21wdEZlZWRiYWNrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0RmVlZGJhY2snXSwgZnJvbVByb21wdEZlZWRiYWNrKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlSWQnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VJZCddLCBmcm9tUmVzcG9uc2VJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCBmcm9tVXNhZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dEdjc1VyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduZWdhdGl2ZVByb21wdCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbmVnYXRpdmVQcm9tcHQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU51bWJlck9mSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZJbWFnZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR3VpZGFuY2VTY2FsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2d1aWRhbmNlU2NhbGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR3VpZGFuY2VTY2FsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2d1aWRhbmNlU2NhbGUnXSwgZnJvbUd1aWRhbmNlU2NhbGUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWVkIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlGaWx0ZXJMZXZlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUZpbHRlckxldmVsJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eUZpbHRlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FmZXR5U2V0dGluZyddLCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVTYWZldHlBdHRyaWJ1dGVzJ10sIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlUmFpUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVJhaVJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlUmFpUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVJhaVJlYXNvbiddLCBmcm9tSW5jbHVkZVJhaVJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2xhbmd1YWdlJ10sIGZyb21MYW5ndWFnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGRXYXRlcm1hcmsnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZFdhdGVybWFyayBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhYmVscyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVJbWFnZVNpemUnXSwgZnJvbUltYWdlU2l6ZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuaGFuY2VQcm9tcHQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuaGFuY2VQcm9tcHQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZXNDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmVnYXRpdmVQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZWdhdGl2ZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZWdhdGl2ZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ25lZ2F0aXZlUHJvbXB0J10sIGZyb21OZWdhdGl2ZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdW1iZXJPZkltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mSW1hZ2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUd1aWRhbmNlU2NhbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdndWlkYW5jZVNjYWxlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUd1aWRhbmNlU2NhbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdndWlkYW5jZVNjYWxlJ10sIGZyb21HdWlkYW5jZVNjYWxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlGaWx0ZXJMZXZlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUZpbHRlckxldmVsJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eUZpbHRlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FmZXR5U2V0dGluZyddLCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVTYWZldHlBdHRyaWJ1dGVzJ10sIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlUmFpUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVJhaVJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlUmFpUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVJhaVJlYXNvbiddLCBmcm9tSW5jbHVkZVJhaVJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2xhbmd1YWdlJ10sIGZyb21MYW5ndWFnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWRkV2F0ZXJtYXJrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGRXYXRlcm1hcmsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21BZGRXYXRlcm1hcmsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhZGRXYXRlcm1hcmsnXSwgZnJvbUFkZFdhdGVybWFyayk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUltYWdlU2l6ZSddLCBmcm9tSW1hZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlbmhhbmNlUHJvbXB0J10sIGZyb21FbmhhbmNlUHJvbXB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZXNQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdGVJbWFnZXNDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZEltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Bvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyddLCBzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2KGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Bvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMnXSwgc2FmZXR5QXR0cmlidXRlc0Zyb21WZXJ0ZXgoZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZlZpZGVvcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZlZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZlZpZGVvcyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dEdjc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0R2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnBzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EdXJhdGlvblNlY29uZHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkdXJhdGlvblNlY29uZHMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRHVyYXRpb25TZWNvbmRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZHVyYXRpb25TZWNvbmRzJ10sIGZyb21EdXJhdGlvblNlY29uZHMpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWVkIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNvbHV0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Jlc29sdXRpb24nXSwgZnJvbVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwdWJzdWJUb3BpYyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHVic3ViVG9waWMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5oYW5jZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuaGFuY2VQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5oYW5jZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2VuaGFuY2VQcm9tcHQnXSwgZnJvbUVuaGFuY2VQcm9tcHQpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnZW5lcmF0ZUF1ZGlvJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZW5lcmF0ZUF1ZGlvIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYXN0RnJhbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhc3RGcmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhc3RGcmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnbGFzdEZyYW1lJ10sIGltYWdlVG9NbGRldihmcm9tTGFzdEZyYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVmZXJlbmNlSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21SZWZlcmVuY2VJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlSW1hZ2VUb01sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdyZWZlcmVuY2VJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWFzayddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFzayBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wcmVzc2lvblF1YWxpdHknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXByZXNzaW9uUXVhbGl0eSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU51bWJlck9mVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZWaWRlb3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZWaWRlb3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EdXJhdGlvblNlY29uZHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkdXJhdGlvblNlY29uZHMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRHVyYXRpb25TZWNvbmRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZHVyYXRpb25TZWNvbmRzJ10sIGZyb21EdXJhdGlvblNlY29uZHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc29sdXRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncmVzb2x1dGlvbiddLCBmcm9tUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QZXJzb25HZW5lcmF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGVyc29uR2VuZXJhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QZXJzb25HZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncGVyc29uR2VuZXJhdGlvbiddLCBmcm9tUGVyc29uR2VuZXJhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QdWJzdWJUb3BpYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHVic3ViVG9waWMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QdWJzdWJUb3BpYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3B1YnN1YlRvcGljJ10sIGZyb21QdWJzdWJUb3BpYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZWdhdGl2ZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25lZ2F0aXZlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU5lZ2F0aXZlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbmVnYXRpdmVQcm9tcHQnXSwgZnJvbU5lZ2F0aXZlUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlbmhhbmNlUHJvbXB0J10sIGZyb21FbmhhbmNlUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlQXVkaW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0ZUF1ZGlvJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdlbmVyYXRlQXVkaW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdnZW5lcmF0ZUF1ZGlvJ10sIGZyb21HZW5lcmF0ZUF1ZGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhc3RGcmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFzdEZyYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFzdEZyYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdsYXN0RnJhbWUnXSwgaW1hZ2VUb1ZlcnRleChmcm9tTGFzdEZyYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVmZXJlbmNlSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21SZWZlcmVuY2VJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlSW1hZ2VUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncmVmZXJlbmNlSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXNrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXNrJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWFzayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnbWFzayddLCB2aWRlb0dlbmVyYXRpb25NYXNrVG9WZXJ0ZXgoZnJvbU1hc2spKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdjb21wcmVzc2lvblF1YWxpdHknXSwgZnJvbUNvbXByZXNzaW9uUXVhbGl0eSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbU1sZGV2KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2UnLFxuICAgICAgICAnZ2VuZXJhdGVWaWRlb1Jlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21NbGRldihmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb01sZGV2KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAndmlkZW8nXSwgdmlkZW9Ub01sZGV2KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzb3VyY2UnXSk7XG4gICAgaWYgKGZyb21Tb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0ZVZpZGVvc1NvdXJjZVRvTWxkZXYoZnJvbVNvdXJjZSwgdG9PYmplY3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1BhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAndmlkZW8nXSwgdmlkZW9Ub1ZlcnRleChmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc291cmNlJ10pO1xuICAgIGlmIChmcm9tU291cmNlICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdGVWaWRlb3NTb3VyY2VUb1ZlcnRleChmcm9tU291cmNlLCB0b09iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRlVmlkZW9zQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0ZWRTYW1wbGVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZFZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkVmlkZW9zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZFZpZGVvRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkVmlkZW9zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZENvdW50J10sIGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkUmVhc29ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJ10sIGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvcyddKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZFZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkVmlkZW9zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZFZpZGVvcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZENvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkUmVhc29ucyddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1NvdXJjZVRvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvTWxkZXYoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAndmlkZW8nXSwgdmlkZW9Ub01sZGV2KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1NvdXJjZVRvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICd2aWRlbyddLCB2aWRlb1RvVmVydGV4KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRJbWFnZUZyb21NbGRldihmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZUZyb21NbGRldihmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaUZpbHRlcmVkUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpRmlsdGVyZWRSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpRmlsdGVyZWRSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlGaWx0ZXJlZFJlYXNvbiddLCBmcm9tUmFpRmlsdGVyZWRSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21TYWZldHlBdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5QXR0cmlidXRlcyddLCBzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2KGZyb21TYWZldHlBdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZEltYWdlRnJvbVZlcnRleChmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZUZyb21WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlGaWx0ZXJlZFJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaUZpbHRlcmVkUmVhc29uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaUZpbHRlcmVkUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpRmlsdGVyZWRSZWFzb24nXSwgZnJvbVJhaUZpbHRlcmVkUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NhZmV0eUF0dHJpYnV0ZXMnXSwgc2FmZXR5QXR0cmlidXRlc0Zyb21WZXJ0ZXgoZnJvbVNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VkUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21FbmhhbmNlZFByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuaGFuY2VkUHJvbXB0J10sIGZyb21FbmhhbmNlZFByb21wdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZEltYWdlTWFza0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1hc2sgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tTWFzayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21hc2snXSwgaW1hZ2VGcm9tVmVydGV4KGZyb21NYXNrKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAoZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tTGFiZWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYWJlbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkVmlkZW9Gcm9tTWxkZXYoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW8nXSwgdmlkZW9Gcm9tTWxkZXYoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleChmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB2aWRlb0Zyb21WZXJ0ZXgoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRpb25Db25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbW9kZWxTZWxlY3Rpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbENvbmZpZyddLCBmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvVGltZXN0YW1wID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXVkaW9UaW1lc3RhbXAnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXVkaW9UaW1lc3RhbXAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb1RpbWVzdGFtcCddLCBmcm9tQXVkaW9UaW1lc3RhbXApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJ10sIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnJlcXVlbmN5UGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZyZXF1ZW5jeVBlbmFsdHknXSwgZnJvbUZyZXF1ZW5jeVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVzZW5jZVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVzZW5jZVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlc2VuY2VQZW5hbHR5J10sIGZyb21QcmVzZW5jZVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTWltZVR5cGUnXSwgZnJvbVJlc3BvbnNlTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VTY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VTY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVNjaGVtYSddLCBmcm9tUmVzcG9uc2VTY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm91dGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JvdXRpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUm91dGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSwgZnJvbVJvdXRpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAoZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10sIGZyb21TcGVlY2hDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQ29uZmlnJ10sIGZyb21UaGlua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAoZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5hYmxlRW5oYW5jZWRDaXZpY0Fuc3dlcnMnXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuYWJsZUVuaGFuY2VkQ2l2aWNBbnN3ZXJzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldE1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlTWFwc1RvTWxkZXYkMShmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0aENvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXV0aENvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlV2lkZ2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmFibGVXaWRnZXQnXSk7XG4gICAgaWYgKGZyb21FbmFibGVXaWRnZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmFibGVXaWRnZXQnXSwgZnJvbUVuYWJsZVdpZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYkMShmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4Y2x1ZGVEb21haW5zIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jsb2NraW5nQ29uZmlkZW5jZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmxvY2tpbmdDb25maWRlbmNlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGZyb21UaW1lUmFuZ2VGaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZUNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlU2l6ZSddKTtcbiAgICBpZiAoZnJvbUltYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlU2l6ZSddLCBmcm9tSW1hZ2VTaXplKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGVyc29uR2VuZXJhdGlvbiddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGVyc29uR2VuZXJhdGlvbiBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRNaW1lVHlwZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0TWltZVR5cGUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5J10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAoZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VTaXplJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VTaXplJ10sIGZyb21JbWFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlT3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlT3V0cHV0T3B0aW9ucycsICdjb21wcmVzc2lvblF1YWxpdHknXSwgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlRnJvbU1sZGV2KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2VCeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2J5dGVzQmFzZTY0RW5jb2RlZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbWFnZUJ5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VCeXRlcyddLCB0Qnl0ZXMoZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VGcm9tVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYnl0ZXNCYXNlNjRFbmNvZGVkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUltYWdlQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZUJ5dGVzJ10sIHRCeXRlcyhmcm9tSW1hZ2VCeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZVRvTWxkZXYoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUJ5dGVzJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2J5dGVzQmFzZTY0RW5jb2RlZCddLCB0Qnl0ZXMoZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VUb1ZlcnRleChmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzVXJpJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VCeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VCeXRlcyddKTtcbiAgICBpZiAoZnJvbUltYWdlQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydieXRlc0Jhc2U2NEVuY29kZWQnXSwgdEJ5dGVzKGZyb21JbWFnZUJ5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21RdWVyeUJhc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3F1ZXJ5QmFzZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVF1ZXJ5QmFzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfdXJsJywgJ21vZGVsc191cmwnXSwgdE1vZGVsc1VybChhcGlDbGllbnQsIGZyb21RdWVyeUJhc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc0NvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21RdWVyeUJhc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3F1ZXJ5QmFzZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVF1ZXJ5QmFzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfdXJsJywgJ21vZGVsc191cmwnXSwgdE1vZGVsc1VybChhcGlDbGllbnQsIGZyb21RdWVyeUJhc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc1BhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdE1vZGVsc0NvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0TW9kZWxzQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21Nb2RlbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdEV4dHJhY3RNb2RlbHMoZnJvbU1vZGVscyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWxGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21Nb2RlbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdEV4dHJhY3RNb2RlbHMoZnJvbU1vZGVscyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWxGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1hc2tSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1hc2tNb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXNrTW9kZSddKTtcbiAgICBpZiAoZnJvbU1hc2tNb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWFza01vZGUnXSwgZnJvbU1hc2tNb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZ21lbnRhdGlvbkNsYXNzZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZWdtZW50YXRpb25DbGFzc2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlZ21lbnRhdGlvbkNsYXNzZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXNrQ2xhc3NlcyddLCBmcm9tU2VnbWVudGF0aW9uQ2xhc3Nlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXNrRGlsYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21hc2tEaWxhdGlvbiddKTtcbiAgICBpZiAoZnJvbU1hc2tEaWxhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RpbGF0aW9uJ10sIGZyb21NYXNrRGlsYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBtb2RlbEZyb21NbGRldihmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZlcnNpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZlcnNpb24nXSk7XG4gICAgaWYgKGZyb21WZXJzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmVyc2lvbiddLCBmcm9tVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsSW5mbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21UdW5lZE1vZGVsSW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWxJbmZvJ10sIHR1bmVkTW9kZWxJbmZvRnJvbU1sZGV2KGZyb21UdW5lZE1vZGVsSW5mbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5wdXRUb2tlbkxpbWl0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5wdXRUb2tlbkxpbWl0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUlucHV0VG9rZW5MaW1pdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lucHV0VG9rZW5MaW1pdCddLCBmcm9tSW5wdXRUb2tlbkxpbWl0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dFRva2VuTGltaXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRUb2tlbkxpbWl0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU91dHB1dFRva2VuTGltaXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvdXRwdXRUb2tlbkxpbWl0J10sIGZyb21PdXRwdXRUb2tlbkxpbWl0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN1cHBvcnRlZEFjdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdXBwb3J0ZWRHZW5lcmF0aW9uTWV0aG9kcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdXBwb3J0ZWRBY3Rpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3VwcG9ydGVkQWN0aW9ucyddLCBmcm9tU3VwcG9ydGVkQWN0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhUZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heFRlbXBlcmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heFRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4VGVtcGVyYXR1cmUnXSwgZnJvbU1heFRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RoaW5raW5nJ10pO1xuICAgIGlmIChmcm9tVGhpbmtpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aGlua2luZyddLCBmcm9tVGhpbmtpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBtb2RlbEZyb21WZXJ0ZXgoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WZXJzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2ZXJzaW9uSWQnXSk7XG4gICAgaWYgKGZyb21WZXJzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmVyc2lvbiddLCBmcm9tVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRwb2ludHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RlcGxveWVkTW9kZWxzJ10pO1xuICAgIGlmIChmcm9tRW5kcG9pbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21FbmRwb2ludHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kcG9pbnRGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kcG9pbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAoZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxJbmZvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWxJbmZvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbEluZm8nXSwgdHVuZWRNb2RlbEluZm9Gcm9tVmVydGV4KGZyb21UdW5lZE1vZGVsSW5mbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2RlZmF1bHRDaGVja3BvaW50SWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RlZmF1bHRDaGVja3BvaW50SWQnXSwgZnJvbURlZmF1bHRDaGVja3BvaW50SWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2hlY2twb2ludHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NoZWNrcG9pbnRzJ10pO1xuICAgIGlmIChmcm9tQ2hlY2twb2ludHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNoZWNrcG9pbnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaGVja3BvaW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0VG9NbGRldiQxKGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9NbGRldiQxKGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnVuY3Rpb25DYWxsVG9NbGRldiQxKGZyb21GdW5jdGlvbkNhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9NbGRldiQxKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIGZyb21WaWRlb01ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcHJvZHVjdEltYWdlVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb2R1Y3RJbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvZHVjdEltYWdlJ10pO1xuICAgIGlmIChmcm9tUHJvZHVjdEltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tUHJvZHVjdEltYWdlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlY29udGV4dEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU51bWJlck9mSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZJbWFnZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmFzZVN0ZXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlU3RlcHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CYXNlU3RlcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdiYXNlU3RlcHMnXSwgZnJvbUJhc2VTdGVwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRHY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dEdjc1VyaSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3N0b3JhZ2VVcmknXSwgZnJvbU91dHB1dEdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFkZFdhdGVybWFyayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRkV2F0ZXJtYXJrJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRkV2F0ZXJtYXJrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYWRkV2F0ZXJtYXJrJ10sIGZyb21BZGRXYXRlcm1hcmspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlbmhhbmNlUHJvbXB0J10sIGZyb21FbmhhbmNlUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVjb250ZXh0SW1hZ2VQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzb3VyY2UnXSk7XG4gICAgaWYgKGZyb21Tb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICByZWNvbnRleHRJbWFnZVNvdXJjZVRvVmVydGV4KGZyb21Tb3VyY2UsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgcmVjb250ZXh0SW1hZ2VDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlY29udGV4dEltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVjb250ZXh0SW1hZ2VTb3VyY2VUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BlcnNvbkltYWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3BlcnNvbkltYWdlJywgJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbVBlcnNvbkltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9kdWN0SW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvZHVjdEltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9kdWN0SW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Qcm9kdWN0SW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2R1Y3RJbWFnZVRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9kdWN0SW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWxUb1ZlcnRleChmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VJbWFnZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VJbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlZmVyZW5jZUltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbVJlZmVyZW5jZUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVmZXJlbmNlSWQnXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlZmVyZW5jZUlkJ10sIGZyb21SZWZlcmVuY2VJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVmZXJlbmNlVHlwZSddLCBmcm9tUmVmZXJlbmNlVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXNrSW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXNrSW1hZ2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWFza0ltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWFza0ltYWdlQ29uZmlnJ10sIG1hc2tSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tTWFza0ltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250cm9sSW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb250cm9sSW1hZ2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29udHJvbEltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udHJvbEltYWdlQ29uZmlnJ10sIGNvbnRyb2xSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tQ29udHJvbEltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdHlsZUltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3R5bGVJbWFnZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdHlsZUltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3R5bGVJbWFnZUNvbmZpZyddLCBmcm9tU3R5bGVJbWFnZUNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdWJqZWN0SW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdWJqZWN0SW1hZ2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3ViamVjdEltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3ViamVjdEltYWdlQ29uZmlnJ10sIGZyb21TdWJqZWN0SW1hZ2VDb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2F0ZWdvcmllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUF0dHJpYnV0ZXMnLFxuICAgICAgICAnY2F0ZWdvcmllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYXRlZ29yaWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcmllcyddLCBmcm9tQ2F0ZWdvcmllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TY29yZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ3Njb3JlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TY29yZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzY29yZXMnXSwgZnJvbVNjb3Jlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50VHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudFR5cGUnXSk7XG4gICAgaWYgKGZyb21Db250ZW50VHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRUeXBlJ10sIGZyb21Db250ZW50VHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eUF0dHJpYnV0ZXNGcm9tVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2F0ZWdvcmllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUF0dHJpYnV0ZXMnLFxuICAgICAgICAnY2F0ZWdvcmllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYXRlZ29yaWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcmllcyddLCBmcm9tQ2F0ZWdvcmllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TY29yZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ3Njb3JlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TY29yZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzY29yZXMnXSwgZnJvbVNjb3Jlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50VHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudFR5cGUnXSk7XG4gICAgaWYgKGZyb21Db250ZW50VHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRUeXBlJ10sIGZyb21Db250ZW50VHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eVNldHRpbmdUb01sZGV2KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2F0ZWdvcnkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NhdGVnb3J5J10pO1xuICAgIGlmIChmcm9tQ2F0ZWdvcnkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYXRlZ29yeSddLCBmcm9tQ2F0ZWdvcnkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRob2QnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aHJlc2hvbGQnXSk7XG4gICAgaWYgKGZyb21UaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aHJlc2hvbGQnXSwgZnJvbVRocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNjcmliYmxlSW1hZ2VUb1ZlcnRleChmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZWdtZW50SW1hZ2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heFByZWRpY3Rpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4UHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWF4UHJlZGljdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdtYXhQcmVkaWN0aW9ucyddLCBmcm9tTWF4UHJlZGljdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlkZW5jZVRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbmZpZGVuY2VUaHJlc2hvbGQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29uZmlkZW5jZVRocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2NvbmZpZGVuY2VUaHJlc2hvbGQnXSwgZnJvbUNvbmZpZGVuY2VUaHJlc2hvbGQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWFza0RpbGF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXNrRGlsYXRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXNrRGlsYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdtYXNrRGlsYXRpb24nXSwgZnJvbU1hc2tEaWxhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CaW5hcnlDb2xvclRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2JpbmFyeUNvbG9yVGhyZXNob2xkJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUJpbmFyeUNvbG9yVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYmluYXJ5Q29sb3JUaHJlc2hvbGQnXSwgZnJvbUJpbmFyeUNvbG9yVGhyZXNob2xkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2VnbWVudEltYWdlUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc291cmNlJ10pO1xuICAgIGlmIChmcm9tU291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc2VnbWVudEltYWdlU291cmNlVG9WZXJ0ZXgoZnJvbVNvdXJjZSwgdG9PYmplY3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZWdtZW50SW1hZ2VDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNlZ21lbnRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkTWFza3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ByZWRpY3Rpb25zJ10pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkTWFza3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZE1hc2tzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZEltYWdlTWFza0Zyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRNYXNrcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZWdtZW50SW1hZ2VTb3VyY2VUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TY3JpYmJsZUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2NyaWJibGVJbWFnZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TY3JpYmJsZUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdzY3JpYmJsZSddLCBzY3JpYmJsZUltYWdlVG9WZXJ0ZXgoZnJvbVNjcmliYmxlSW1hZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWxDb25maWcnXSwgZnJvbVJldHJpZXZhbENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkNhbGxpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJ10sIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9NbGRldiQxKGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0cmlldmFsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tRmlsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSwgZnJvbUZpbGVTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRlcnByaXNlV2ViU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBnb29nbGVNYXBzVG9NbGRldiQxKGZyb21Hb29nbGVNYXBzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb01sZGV2JDEoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCBmcm9tVXJsQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb1ZlcnRleChmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWwnXSwgZnJvbVJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGVTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VudGVycHJpc2VXZWJTZWFyY2gnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSwgZnJvbUVudGVycHJpc2VXZWJTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBmcm9tR29vZ2xlTWFwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBmcm9tR29vZ2xlU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5lZE1vZGVsSW5mb0Zyb21NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZU1vZGVsJ10pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmVkTW9kZWxJbmZvRnJvbVZlcnRleChmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xhYmVscycsXG4gICAgICAgICdnb29nbGUtdmVydGV4LWxsbS10dW5pbmctYmFzZS1tb2RlbC1pZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXNlTW9kZWwnXSwgZnJvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlTW9kZWxDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlZmF1bHRDaGVja3BvaW50SWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkZWZhdWx0Q2hlY2twb2ludElkJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlZmF1bHRDaGVja3BvaW50SWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGVmYXVsdENoZWNrcG9pbnRJZCddLCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2RlZmF1bHRDaGVja3BvaW50SWQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZWZhdWx0Q2hlY2twb2ludElkJ10sIGZyb21EZWZhdWx0Q2hlY2twb2ludElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlTW9kZWxDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVNb2RlbENvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBzY2FsZUltYWdlQVBJQ29uZmlnSW50ZXJuYWxUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVSYWlSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlUmFpUmVhc29uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUluY2x1ZGVSYWlSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlUmFpUmVhc29uJ10sIGZyb21JbmNsdWRlUmFpUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dE1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0TWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0TWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ21pbWVUeXBlJ10sIGZyb21PdXRwdXRNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRDb21wcmVzc2lvblF1YWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdjb21wcmVzc2lvblF1YWxpdHknXSwgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlSW5wdXRJbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuaGFuY2VJbnB1dEltYWdlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VJbnB1dEltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAndXBzY2FsZUNvbmZpZycsICdlbmhhbmNlSW5wdXRJbWFnZSddLCBmcm9tRW5oYW5jZUlucHV0SW1hZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VQcmVzZXJ2YXRpb25GYWN0b3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbWFnZVByZXNlcnZhdGlvbkZhY3RvcicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZVByZXNlcnZhdGlvbkZhY3RvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Vwc2NhbGVDb25maWcnLCAnaW1hZ2VQcmVzZXJ2YXRpb25GYWN0b3InXSwgZnJvbUltYWdlUHJlc2VydmF0aW9uRmFjdG9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU51bWJlck9mSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZJbWFnZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBzY2FsZUltYWdlQVBJUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwc2NhbGVGYWN0b3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1cHNjYWxlRmFjdG9yJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVwc2NhbGVGYWN0b3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Vwc2NhbGVDb25maWcnLCAndXBzY2FsZUZhY3RvciddLCBmcm9tVXBzY2FsZUZhY3Rvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHVwc2NhbGVJbWFnZUFQSUNvbmZpZ0ludGVybmFsVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cHNjYWxlSW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9Gcm9tTWxkZXYoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuY29kZWRWaWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb0J5dGVzJ10sIHRCeXRlcyhmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuY29kaW5nJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdieXRlc0Jhc2U2NEVuY29kZWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9CeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSwgdEJ5dGVzKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvR2VuZXJhdGlvbk1hc2tUb1ZlcnRleChmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfc2VsZiddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWFza01vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21hc2tNb2RlJ10pO1xuICAgIGlmIChmcm9tTWFza01vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXNrTW9kZSddLCBmcm9tTWFza01vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0dlbmVyYXRpb25SZWZlcmVuY2VJbWFnZVRvTWxkZXYoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2UnXSwgaW1hZ2VUb01sZGV2KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlZmVyZW5jZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVmZXJlbmNlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlZmVyZW5jZVR5cGUnXSwgZnJvbVJlZmVyZW5jZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0dlbmVyYXRpb25SZWZlcmVuY2VJbWFnZVRvVmVydGV4KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVmZXJlbmNlVHlwZSddLCBmcm9tUmVmZXJlbmNlVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvVG9NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW9CeXRlcyddKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmNvZGVkVmlkZW8nXSwgdEJ5dGVzKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuY29kaW5nJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvVG9WZXJ0ZXgoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSk7XG4gICAgaWYgKGZyb21WaWRlb0J5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYnl0ZXNCYXNlNjRFbmNvZGVkJ10sIHRCeXRlcyhmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBHb29nbGUgR2VuIEFJIFNESyBnZW5lcmF0b3IgRE8gTk9UIEVESVQuXG5mdW5jdGlvbiBjcmVhdGVGaWxlU2VhcmNoU3RvcmVDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZUZpbGVTZWFyY2hTdG9yZUNvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVGaWxlU2VhcmNoU3RvcmVDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZvcmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JjZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZvcmNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmb3JjZSddLCBmcm9tRm9yY2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBkZWxldGVGaWxlU2VhcmNoU3RvcmVDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0RmlsZVNlYXJjaFN0b3JlUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1wb3J0RmlsZUNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ3VzdG9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjdXN0b21NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21DdXN0b21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ3VzdG9tTWV0YWRhdGE7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjdXN0b21NZXRhZGF0YSddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2h1bmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjaHVua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21DaHVua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjaHVua2luZ0NvbmZpZyddLCBmcm9tQ2h1bmtpbmdDb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbXBvcnRGaWxlT3BlcmF0aW9uRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgaW1wb3J0RmlsZVJlc3BvbnNlRnJvbU1sZGV2KGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbXBvcnRGaWxlUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGVTZWFyY2hTdG9yZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmaWxlU2VhcmNoU3RvcmVOYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZpbGVTZWFyY2hTdG9yZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ2ZpbGVfc2VhcmNoX3N0b3JlX25hbWUnXSwgZnJvbUZpbGVTZWFyY2hTdG9yZU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVOYW1lJ10pO1xuICAgIGlmIChmcm9tRmlsZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlTmFtZSddLCBmcm9tRmlsZU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBpbXBvcnRGaWxlQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltcG9ydEZpbGVSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyZW50J10pO1xuICAgIGlmIChmcm9tUGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyZW50J10sIGZyb21QYXJlbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9jdW1lbnROYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb2N1bWVudE5hbWUnXSk7XG4gICAgaWYgKGZyb21Eb2N1bWVudE5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb2N1bWVudE5hbWUnXSwgZnJvbURvY3VtZW50TmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RGaWxlU2VhcmNoU3RvcmVzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RGaWxlU2VhcmNoU3RvcmVzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdEZpbGVTZWFyY2hTdG9yZXNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEZpbGVTZWFyY2hTdG9yZXNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVTZWFyY2hTdG9yZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmaWxlU2VhcmNoU3RvcmVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZpbGVTZWFyY2hTdG9yZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZpbGVTZWFyY2hTdG9yZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVTZWFyY2hTdG9yZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3VzdG9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjdXN0b21NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21DdXN0b21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ3VzdG9tTWV0YWRhdGE7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjdXN0b21NZXRhZGF0YSddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2h1bmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjaHVua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21DaHVua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjaHVua2luZ0NvbmZpZyddLCBmcm9tQ2h1bmtpbmdDb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GaWxlU2VhcmNoU3RvcmVOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZmlsZVNlYXJjaFN0b3JlTmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GaWxlU2VhcmNoU3RvcmVOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdmaWxlX3NlYXJjaF9zdG9yZV9uYW1lJ10sIGZyb21GaWxlU2VhcmNoU3RvcmVOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVSZXN1bWFibGVSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBDT05URU5UX1RZUEVfSEVBREVSID0gJ0NvbnRlbnQtVHlwZSc7XG5jb25zdCBTRVJWRVJfVElNRU9VVF9IRUFERVIgPSAnWC1TZXJ2ZXItVGltZW91dCc7XG5jb25zdCBVU0VSX0FHRU5UX0hFQURFUiA9ICdVc2VyLUFnZW50JztcbmNvbnN0IEdPT0dMRV9BUElfQ0xJRU5UX0hFQURFUiA9ICd4LWdvb2ctYXBpLWNsaWVudCc7XG5jb25zdCBTREtfVkVSU0lPTiA9ICcxLjQwLjAnOyAvLyB4LXJlbGVhc2UtcGxlYXNlLXZlcnNpb25cbmNvbnN0IExJQlJBUllfTEFCRUwgPSBgZ29vZ2xlLWdlbmFpLXNkay8ke1NES19WRVJTSU9OfWA7XG5jb25zdCBWRVJURVhfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTiA9ICd2MWJldGExJztcbmNvbnN0IEdPT0dMRV9BSV9BUElfREVGQVVMVF9WRVJTSU9OID0gJ3YxYmV0YSc7XG4vKipcbiAqIFRoZSBBcGlDbGllbnQgY2xhc3MgaXMgdXNlZCB0byBzZW5kIHJlcXVlc3RzIHRvIHRoZSBHZW1pbmkgQVBJIG9yIFZlcnRleCBBSVxuICogZW5kcG9pbnRzLlxuICovXG5jbGFzcyBBcGlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpO1xuICAgICAgICB0aGlzLmN1c3RvbUJhc2VVcmwgPSAoX2EgPSBvcHRzLmh0dHBPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmFzZVVybDtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy52ZXJ0ZXhhaSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5wcm9qZWN0ICYmIHRoaXMuY2xpZW50T3B0aW9ucy5sb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5hcGlLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNsaWVudE9wdGlvbnMuYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLnByb2plY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluaXRIdHRwT3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLnZlcnRleGFpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xpZW50T3B0aW9ucy5sb2NhdGlvbiAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmNsaWVudE9wdGlvbnMuYXBpS2V5ICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuY3VzdG9tQmFzZVVybCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5sb2NhdGlvbiA9ICdnbG9iYWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFzU3VmZmljaWVudEF1dGggPSAodGhpcy5jbGllbnRPcHRpb25zLnByb2plY3QgJiYgdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5hcGlLZXk7XG4gICAgICAgICAgICBpZiAoIWhhc1N1ZmZpY2llbnRBdXRoICYmICF0aGlzLmN1c3RvbUJhc2VVcmwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIGlzIG5vdCBzZXQgdXAuIFBsZWFzZSBwcm92aWRlIGVpdGhlciBhIHByb2plY3QgYW5kIGxvY2F0aW9uLCBvciBhbiBBUEkga2V5LCBvciBhIGN1c3RvbSBiYXNlIFVSTC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhc0NvbnN0cnVjdG9yQXV0aCA9IChvcHRzLnByb2plY3QgJiYgb3B0cy5sb2NhdGlvbikgfHwgISFvcHRzLmFwaUtleTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1c3RvbUJhc2VVcmwgJiYgIWhhc0NvbnN0cnVjdG9yQXV0aCkge1xuICAgICAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5iYXNlVXJsID0gdGhpcy5jdXN0b21CYXNlVXJsO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5wcm9qZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5sb2NhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5hcGlLZXkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb24gPT09ICdnbG9iYWwnKSB7XG4gICAgICAgICAgICAgICAgLy8gVmVydGV4IEV4cHJlc3Mgb3IgZ2xvYmFsIGVuZHBvaW50IGNhc2UuXG4gICAgICAgICAgICAgICAgaW5pdEh0dHBPcHRpb25zLmJhc2VVcmwgPSAnaHR0cHM6Ly9haXBsYXRmb3JtLmdvb2dsZWFwaXMuY29tLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdCAmJiB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpbml0SHR0cE9wdGlvbnMuYmFzZVVybCA9IGBodHRwczovLyR7dGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9ufS1haXBsYXRmb3JtLmdvb2dsZWFwaXMuY29tL2A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbml0SHR0cE9wdGlvbnMuYXBpVmVyc2lvbiA9XG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy5jbGllbnRPcHRpb25zLmFwaVZlcnNpb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFZFUlRFWF9BSV9BUElfREVGQVVMVF9WRVJTSU9OO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gR2VtaW5pIEFQSVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNsaWVudE9wdGlvbnMuYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0FQSSBrZXkgbXVzdCBiZSBzZXQgd2hlbiB1c2luZyB0aGUgR2VtaW5pIEFQSS4nLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDQwMyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5hcGlWZXJzaW9uID1cbiAgICAgICAgICAgICAgICAoX2MgPSB0aGlzLmNsaWVudE9wdGlvbnMuYXBpVmVyc2lvbikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogR09PR0xFX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT047XG4gICAgICAgICAgICBpbml0SHR0cE9wdGlvbnMuYmFzZVVybCA9IGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS9gO1xuICAgICAgICB9XG4gICAgICAgIGluaXRIdHRwT3B0aW9ucy5oZWFkZXJzID0gdGhpcy5nZXREZWZhdWx0SGVhZGVycygpO1xuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgPSBpbml0SHR0cE9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRzLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgPSB0aGlzLnBhdGNoSHR0cE9wdGlvbnMoaW5pdEh0dHBPcHRpb25zLCBvcHRzLmh0dHBPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1ZlcnRleEFJKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsaWVudE9wdGlvbnMudmVydGV4YWkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXRQcm9qZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLnByb2plY3Q7XG4gICAgfVxuICAgIGdldExvY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uO1xuICAgIH1cbiAgICBnZXRDdXN0b21CYXNlVXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21CYXNlVXJsO1xuICAgIH1cbiAgICBhc3luYyBnZXRBdXRoSGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50T3B0aW9ucy5hdXRoLmFkZEF1dGhIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgZ2V0QXBpVmVyc2lvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmFwaVZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5hcGlWZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQVBJIHZlcnNpb24gaXMgbm90IHNldC4nKTtcbiAgICB9XG4gICAgZ2V0QmFzZVVybCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmJhc2VVcmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5iYXNlVXJsO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQmFzZSBVUkwgaXMgbm90IHNldC4nKTtcbiAgICB9XG4gICAgZ2V0UmVxdWVzdFVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVxdWVzdFVybEludGVybmFsKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyk7XG4gICAgfVxuICAgIGdldEhlYWRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgJiZcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5oZWFkZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuaGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSGVhZGVycyBhcmUgbm90IHNldC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSZXF1ZXN0VXJsSW50ZXJuYWwoaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFodHRwT3B0aW9ucyB8fFxuICAgICAgICAgICAgaHR0cE9wdGlvbnMuYmFzZVVybCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBodHRwT3B0aW9ucy5hcGlWZXJzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSFRUUCBvcHRpb25zIGFyZSBub3QgY29ycmVjdGx5IHNldC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXNlVXJsID0gaHR0cE9wdGlvbnMuYmFzZVVybC5lbmRzV2l0aCgnLycpXG4gICAgICAgICAgICA/IGh0dHBPcHRpb25zLmJhc2VVcmwuc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICA6IGh0dHBPcHRpb25zLmJhc2VVcmw7XG4gICAgICAgIGNvbnN0IHVybEVsZW1lbnQgPSBbYmFzZVVybF07XG4gICAgICAgIGlmIChodHRwT3B0aW9ucy5hcGlWZXJzaW9uICYmIGh0dHBPcHRpb25zLmFwaVZlcnNpb24gIT09ICcnKSB7XG4gICAgICAgICAgICB1cmxFbGVtZW50LnB1c2goaHR0cE9wdGlvbnMuYXBpVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybEVsZW1lbnQuam9pbignLycpO1xuICAgIH1cbiAgICBnZXRCYXNlUmVzb3VyY2VQYXRoKCkge1xuICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7dGhpcy5jbGllbnRPcHRpb25zLnByb2plY3R9L2xvY2F0aW9ucy8ke3RoaXMuY2xpZW50T3B0aW9ucy5sb2NhdGlvbn1gO1xuICAgIH1cbiAgICBnZXRBcGlLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9wdGlvbnMuYXBpS2V5O1xuICAgIH1cbiAgICBnZXRXZWJzb2NrZXRCYXNlVXJsKCkge1xuICAgICAgICBjb25zdCBiYXNlVXJsID0gdGhpcy5nZXRCYXNlVXJsKCk7XG4gICAgICAgIGNvbnN0IHVybFBhcnRzID0gbmV3IFVSTChiYXNlVXJsKTtcbiAgICAgICAgdXJsUGFydHMucHJvdG9jb2wgPSB1cmxQYXJ0cy5wcm90b2NvbCA9PSAnaHR0cDonID8gJ3dzJyA6ICd3c3MnO1xuICAgICAgICByZXR1cm4gdXJsUGFydHMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgc2V0QmFzZVVybCh1cmwpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmJhc2VVcmwgPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hUVFAgb3B0aW9ucyBhcmUgbm90IGNvcnJlY3RseSBzZXQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0VXJsKHBhdGgsIGh0dHBPcHRpb25zLCBwcmVwZW5kUHJvamVjdExvY2F0aW9uKSB7XG4gICAgICAgIGNvbnN0IHVybEVsZW1lbnQgPSBbdGhpcy5nZXRSZXF1ZXN0VXJsSW50ZXJuYWwoaHR0cE9wdGlvbnMpXTtcbiAgICAgICAgaWYgKHByZXBlbmRQcm9qZWN0TG9jYXRpb24pIHtcbiAgICAgICAgICAgIHVybEVsZW1lbnQucHVzaCh0aGlzLmdldEJhc2VSZXNvdXJjZVBhdGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGggIT09ICcnKSB7XG4gICAgICAgICAgICB1cmxFbGVtZW50LnB1c2gocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHt1cmxFbGVtZW50LmpvaW4oJy8nKX1gKTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgc2hvdWxkUHJlcGVuZFZlcnRleFByb2plY3RQYXRoKHJlcXVlc3QsIGh0dHBPcHRpb25zKSB7XG4gICAgICAgIGlmIChodHRwT3B0aW9ucy5iYXNlVXJsICYmXG4gICAgICAgICAgICBodHRwT3B0aW9ucy5iYXNlVXJsUmVzb3VyY2VTY29wZSA9PT0gUmVzb3VyY2VTY29wZS5DT0xMRUNUSU9OKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5hcGlLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY2xpZW50T3B0aW9ucy52ZXJ0ZXhhaSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0LnBhdGguc3RhcnRzV2l0aCgncHJvamVjdHMvJykpIHtcbiAgICAgICAgICAgIC8vIEFzc3VtZSB0aGUgcGF0aCBhbHJlYWR5IHN0YXJ0cyB3aXRoXG4gICAgICAgICAgICAvLyBgcHJvamVjdHMvPHByb2plY3Q+L2xvY2F0aW9uLzxsb2NhdGlvbj5gLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0Lmh0dHBNZXRob2QgPT09ICdHRVQnICYmXG4gICAgICAgICAgICByZXF1ZXN0LnBhdGguc3RhcnRzV2l0aCgncHVibGlzaGVycy9nb29nbGUvbW9kZWxzJykpIHtcbiAgICAgICAgICAgIC8vIFRoZXNlIHBhdGhzIGFyZSB1c2VkIGJ5IFZlcnRleCdzIG1vZGVscy5nZXQgYW5kIG1vZGVscy5saXN0XG4gICAgICAgICAgICAvLyBjYWxscy4gRm9yIGJhc2UgbW9kZWxzIFZlcnRleCBkb2VzIG5vdCBhY2NlcHQgYSBwcm9qZWN0L2xvY2F0aW9uXG4gICAgICAgICAgICAvLyBwcmVmaXggKGZvciB0dW5lZCBtb2RlbCB0aGUgcHJlZml4IGlzIHJlcXVpcmVkKS5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIGxldCBwYXRjaGVkSHR0cE9wdGlvbnMgPSB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnM7XG4gICAgICAgIGlmIChyZXF1ZXN0Lmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICBwYXRjaGVkSHR0cE9wdGlvbnMgPSB0aGlzLnBhdGNoSHR0cE9wdGlvbnModGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLCByZXF1ZXN0Lmh0dHBPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVwZW5kUHJvamVjdExvY2F0aW9uID0gdGhpcy5zaG91bGRQcmVwZW5kVmVydGV4UHJvamVjdFBhdGgocmVxdWVzdCwgcGF0Y2hlZEh0dHBPcHRpb25zKTtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5jb25zdHJ1Y3RVcmwocmVxdWVzdC5wYXRoLCBwYXRjaGVkSHR0cE9wdGlvbnMsIHByZXBlbmRQcm9qZWN0TG9jYXRpb24pO1xuICAgICAgICBpZiAocmVxdWVzdC5xdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVxdWVzdC5xdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZXF1ZXN0SW5pdCA9IHt9O1xuICAgICAgICBpZiAocmVxdWVzdC5odHRwTWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QuYm9keSAmJiByZXF1ZXN0LmJvZHkgIT09ICd7fScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgYm9keSBzaG91bGQgYmUgZW1wdHkgZm9yIEdFVCByZXF1ZXN0LCBidXQgZ290IG5vbiBlbXB0eSByZXF1ZXN0IGJvZHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RJbml0LmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEluaXQgPSBhd2FpdCB0aGlzLmluY2x1ZGVFeHRyYUh0dHBPcHRpb25zVG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgcGF0Y2hlZEh0dHBPcHRpb25zLCB1cmwudG9TdHJpbmcoKSwgcmVxdWVzdC5hYm9ydFNpZ25hbCk7XG4gICAgICAgIHJldHVybiB0aGlzLnVuYXJ5QXBpQ2FsbCh1cmwsIHJlcXVlc3RJbml0LCByZXF1ZXN0Lmh0dHBNZXRob2QpO1xuICAgIH1cbiAgICBwYXRjaEh0dHBPcHRpb25zKGJhc2VIdHRwT3B0aW9ucywgcmVxdWVzdEh0dHBPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhdGNoZWRIdHRwT3B0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYmFzZUh0dHBPcHRpb25zKSk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlcXVlc3RIdHRwT3B0aW9ucykpIHtcbiAgICAgICAgICAgIC8vIFJlY29yZHMgY29tcGlsZSB0byBvYmplY3RzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTMjM0NVRTNzA1MzogRWxlbWVudCBpbXBsaWNpdGx5IGhhcyBhbiAnYW55JyB0eXBlXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBleHByZXNzaW9uIG9mIHR5cGUgJ3N0cmluZycgY2FuJ3QgYmUgdXNlZCB0byBpbmRleCB0eXBlXG4gICAgICAgICAgICAgICAgLy8gJ0h0dHBPcHRpb25zJy5cbiAgICAgICAgICAgICAgICBwYXRjaGVkSHR0cE9wdGlvbnNba2V5XSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGF0Y2hlZEh0dHBPcHRpb25zW2tleV0pLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUzIzNDVUUzcwNTM6IEVsZW1lbnQgaW1wbGljaXRseSBoYXMgYW4gJ2FueScgdHlwZVxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgZXhwcmVzc2lvbiBvZiB0eXBlICdzdHJpbmcnIGNhbid0IGJlIHVzZWQgdG8gaW5kZXggdHlwZVxuICAgICAgICAgICAgICAgIC8vICdIdHRwT3B0aW9ucycuXG4gICAgICAgICAgICAgICAgcGF0Y2hlZEh0dHBPcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0Y2hlZEh0dHBPcHRpb25zO1xuICAgIH1cbiAgICBhc3luYyByZXF1ZXN0U3RyZWFtKHJlcXVlc3QpIHtcbiAgICAgICAgbGV0IHBhdGNoZWRIdHRwT3B0aW9ucyA9IHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucztcbiAgICAgICAgaWYgKHJlcXVlc3QuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHBhdGNoZWRIdHRwT3B0aW9ucyA9IHRoaXMucGF0Y2hIdHRwT3B0aW9ucyh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMsIHJlcXVlc3QuaHR0cE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXBlbmRQcm9qZWN0TG9jYXRpb24gPSB0aGlzLnNob3VsZFByZXBlbmRWZXJ0ZXhQcm9qZWN0UGF0aChyZXF1ZXN0LCBwYXRjaGVkSHR0cE9wdGlvbnMpO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmNvbnN0cnVjdFVybChyZXF1ZXN0LnBhdGgsIHBhdGNoZWRIdHRwT3B0aW9ucywgcHJlcGVuZFByb2plY3RMb2NhdGlvbik7XG4gICAgICAgIGlmICghdXJsLnNlYXJjaFBhcmFtcy5oYXMoJ2FsdCcpIHx8IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCdhbHQnKSAhPT0gJ3NzZScpIHtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdhbHQnLCAnc3NlJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcXVlc3RJbml0ID0ge307XG4gICAgICAgIHJlcXVlc3RJbml0LmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIHJlcXVlc3RJbml0ID0gYXdhaXQgdGhpcy5pbmNsdWRlRXh0cmFIdHRwT3B0aW9uc1RvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIHBhdGNoZWRIdHRwT3B0aW9ucywgdXJsLnRvU3RyaW5nKCksIHJlcXVlc3QuYWJvcnRTaWduYWwpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1BcGlDYWxsKHVybCwgcmVxdWVzdEluaXQsIHJlcXVlc3QuaHR0cE1ldGhvZCk7XG4gICAgfVxuICAgIGFzeW5jIGluY2x1ZGVFeHRyYUh0dHBPcHRpb25zVG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgaHR0cE9wdGlvbnMsIHVybCwgYWJvcnRTaWduYWwpIHtcbiAgICAgICAgaWYgKChodHRwT3B0aW9ucyAmJiBodHRwT3B0aW9ucy50aW1lb3V0KSB8fCBhYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgICAgIGlmIChodHRwT3B0aW9ucy50aW1lb3V0ICYmIChodHRwT3B0aW9ucyA9PT0gbnVsbCB8fCBodHRwT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cE9wdGlvbnMudGltZW91dCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gYWJvcnRDb250cm9sbGVyLmFib3J0KCksIGh0dHBPcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0SGFuZGxlICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aW1lb3V0SGFuZGxlLnVucmVmID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHVucmVmIHRvIHByZXZlbnQgbm9kZWpzIHByb2Nlc3MgZnJvbSBoYW5naW5nLCBzZWVcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCN0aW1lb3V0dW5yZWZcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dEhhbmRsZS51bnJlZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3RJbml0LnNpZ25hbCA9IHNpZ25hbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaHR0cE9wdGlvbnMgJiYgaHR0cE9wdGlvbnMuZXh0cmFCb2R5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbmNsdWRlRXh0cmFCb2R5VG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgaHR0cE9wdGlvbnMuZXh0cmFCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0SW5pdC5oZWFkZXJzID0gYXdhaXQgdGhpcy5nZXRIZWFkZXJzSW50ZXJuYWwoaHR0cE9wdGlvbnMsIHVybCk7XG4gICAgICAgIHJldHVybiByZXF1ZXN0SW5pdDtcbiAgICB9XG4gICAgYXN5bmMgdW5hcnlBcGlDYWxsKHVybCwgcmVxdWVzdEluaXQsIGh0dHBNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2FsbCh1cmwudG9TdHJpbmcoKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0SW5pdCksIHsgbWV0aG9kOiBodHRwTWV0aG9kIH0pKVxuICAgICAgICAgICAgLnRoZW4oYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aHJvd0Vycm9ySWZOb3RPSyhyZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEh0dHBSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbUFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCwgaHR0cE1ldGhvZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcGlDYWxsKHVybC50b1N0cmluZygpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3RJbml0KSwgeyBtZXRob2Q6IGh0dHBNZXRob2QgfSkpXG4gICAgICAgICAgICAudGhlbihhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRocm93RXJyb3JJZk5vdE9LKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJlYW1SZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByb2Nlc3NTdHJlYW1SZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBwcm9jZXNzU3RyZWFtUmVzcG9uc2VfMSgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5ib2R5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuICAgICAgICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGJvZHkgaXMgZW1wdHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFQcmVmaXggPSAnZGF0YTonO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGltaXRlcnMgPSBbJ1xcblxcbicsICdcXHJcXHInLCAnXFxyXFxuXFxyXFxuJ107XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0geWllbGQgX19hd2FpdChyZWFkZXIucmVhZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGxldGUgSlNPTiBzZWdtZW50IGF0IHRoZSBlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rU3RyaW5nID0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbmQgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGNodW5rIGNvbnRhaW5zIGFuIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtKc29uID0gSlNPTi5wYXJzZShjaHVua1N0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiBjaHVua0pzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvckpzb24gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNodW5rSnNvblsnZXJyb3InXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGVycm9ySnNvblsnc3RhdHVzJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGVycm9ySnNvblsnY29kZSddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBnb3Qgc3RhdHVzOiAke3N0YXR1c30uICR7SlNPTi5zdHJpbmdpZnkoY2h1bmtKc29uKX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID49IDQwMCAmJiBjb2RlIDwgNjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFwaUVycm9yID0gbmV3IEFwaUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGFwaUVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBcGlFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBjaHVua1N0cmluZztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlbGltaXRlckluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWxpbWl0ZXJMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVySW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltaXRlckxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlbGltaXRlciBvZiBkZWxpbWl0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBidWZmZXIuaW5kZXhPZihkZWxpbWl0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRlbGltaXRlckluZGV4ID09PSAtMSB8fCBpbmRleCA8IGRlbGltaXRlckluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXJJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXJMZW5ndGggPSBkZWxpbWl0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxpbWl0ZXJJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gTm8gY29tcGxldGUgZXZlbnQgaW4gYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudFN0cmluZyA9IGJ1ZmZlci5zdWJzdHJpbmcoMCwgZGVsaW1pdGVySW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnN1YnN0cmluZyhkZWxpbWl0ZXJJbmRleCArIGRlbGltaXRlckxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkRXZlbnQgPSBldmVudFN0cmluZy50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJpbW1lZEV2ZW50LnN0YXJ0c1dpdGgoZGF0YVByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRDaHVua1N0cmluZyA9IHRyaW1tZWRFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3Vic3RyaW5nKGRhdGFQcmVmaXgubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpYWxSZXNwb25zZSA9IG5ldyBSZXNwb25zZShwcm9jZXNzZWRDaHVua1N0cmluZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQobmV3IEh0dHBSZXNwb25zZShwYXJ0aWFsUmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleGNlcHRpb24gcGFyc2luZyBzdHJlYW0gY2h1bmsgJHtwcm9jZXNzZWRDaHVua1N0cmluZ30uICR7ZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCkge1xuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCByZXF1ZXN0SW5pdCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhjZXB0aW9uICR7ZX0gc2VuZGluZyByZXF1ZXN0YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXREZWZhdWx0SGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBjb25zdCB2ZXJzaW9uSGVhZGVyVmFsdWUgPSBMSUJSQVJZX0xBQkVMICsgJyAnICsgdGhpcy5jbGllbnRPcHRpb25zLnVzZXJBZ2VudEV4dHJhO1xuICAgICAgICBoZWFkZXJzW1VTRVJfQUdFTlRfSEVBREVSXSA9IHZlcnNpb25IZWFkZXJWYWx1ZTtcbiAgICAgICAgaGVhZGVyc1tHT09HTEVfQVBJX0NMSUVOVF9IRUFERVJdID0gdmVyc2lvbkhlYWRlclZhbHVlO1xuICAgICAgICBoZWFkZXJzW0NPTlRFTlRfVFlQRV9IRUFERVJdID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgYXN5bmMgZ2V0SGVhZGVyc0ludGVybmFsKGh0dHBPcHRpb25zLCB1cmwpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICAgIGlmIChodHRwT3B0aW9ucyAmJiBodHRwT3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhodHRwT3B0aW9ucy5oZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXBwZW5kIGEgdGltZW91dCBoZWFkZXIgaWYgaXQgaXMgc2V0LCBub3RlIHRoYXQgdGhlIHRpbWVvdXQgb3B0aW9uIGlzXG4gICAgICAgICAgICAvLyBpbiBtaWxsaXNlY29uZHMgYnV0IHRoZSBoZWFkZXIgaXMgaW4gc2Vjb25kcy5cbiAgICAgICAgICAgIGlmIChodHRwT3B0aW9ucy50aW1lb3V0ICYmIGh0dHBPcHRpb25zLnRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoU0VSVkVSX1RJTUVPVVRfSEVBREVSLCBTdHJpbmcoTWF0aC5jZWlsKGh0dHBPcHRpb25zLnRpbWVvdXQgLyAxMDAwKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50T3B0aW9ucy5hdXRoLmFkZEF1dGhIZWFkZXJzKGhlYWRlcnMsIHVybCk7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICBnZXRGaWxlTmFtZShmaWxlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGZpbGVOYW1lID0gJyc7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZpbGVOYW1lID0gZmlsZS5yZXBsYWNlKC9bL1xcXFxdKyQvLCAnJyk7XG4gICAgICAgICAgICBmaWxlTmFtZSA9IChfYSA9IGZpbGVOYW1lLnNwbGl0KC9bL1xcXFxdLykucG9wKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxlTmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyBhIGZpbGUgYXN5bmNocm9ub3VzbHkgdXNpbmcgR2VtaW5pIEFQSSBvbmx5LCB0aGlzIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgKiBpbiBWZXJ0ZXggQUkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZSBUaGUgc3RyaW5nIHBhdGggdG8gdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWQgb3IgYSBCbG9iIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gY29uZmlnIE9wdGlvbmFsIHBhcmFtZXRlcnMgc3BlY2lmaWVkIGluIHRoZSBgVXBsb2FkRmlsZUNvbmZpZ2BcbiAgICAgKiAgICAgaW50ZXJmYWNlLiBAc2VlIHtAbGluayB0eXBlcy5VcGxvYWRGaWxlQ29uZmlnfVxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmlsZWAgb2JqZWN0LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgY2FsbGVkIG9uIGEgVmVydGV4IEFJIGNsaWVudC5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBgbWltZVR5cGVgIGlzIG5vdCBwcm92aWRlZCBhbmQgY2FuIG5vdCBiZSBpbmZlcnJlZCxcbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWRGaWxlKGZpbGUsIGNvbmZpZykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGZpbGVUb1VwbG9hZCA9IHt9O1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZpbGVUb1VwbG9hZC5taW1lVHlwZSA9IGNvbmZpZy5taW1lVHlwZTtcbiAgICAgICAgICAgIGZpbGVUb1VwbG9hZC5uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgICAgICAgICBmaWxlVG9VcGxvYWQuZGlzcGxheU5hbWUgPSBjb25maWcuZGlzcGxheU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGVUb1VwbG9hZC5uYW1lICYmICFmaWxlVG9VcGxvYWQubmFtZS5zdGFydHNXaXRoKCdmaWxlcy8nKSkge1xuICAgICAgICAgICAgZmlsZVRvVXBsb2FkLm5hbWUgPSBgZmlsZXMvJHtmaWxlVG9VcGxvYWQubmFtZX1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwbG9hZGVyID0gdGhpcy5jbGllbnRPcHRpb25zLnVwbG9hZGVyO1xuICAgICAgICBjb25zdCBmaWxlU3RhdCA9IGF3YWl0IHVwbG9hZGVyLnN0YXQoZmlsZSk7XG4gICAgICAgIGZpbGVUb1VwbG9hZC5zaXplQnl0ZXMgPSBTdHJpbmcoZmlsZVN0YXQuc2l6ZSk7XG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLm1pbWVUeXBlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaWxlU3RhdC50eXBlO1xuICAgICAgICBpZiAobWltZVR5cGUgPT09IHVuZGVmaW5lZCB8fCBtaW1lVHlwZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBkZXRlcm1pbmUgbWltZVR5cGUuIFBsZWFzZSBwcm92aWRlIG1pbWVUeXBlIGluIHRoZSBjb25maWcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZmlsZVRvVXBsb2FkLm1pbWVUeXBlID0gbWltZVR5cGU7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBmaWxlOiBmaWxlVG9VcGxvYWQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gdGhpcy5nZXRGaWxlTmFtZShmaWxlKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGZvcm1hdE1hcCgndXBsb2FkL3YxYmV0YS9maWxlcycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgIGNvbnN0IHVwbG9hZFVybCA9IGF3YWl0IHRoaXMuZmV0Y2hVcGxvYWRVcmwocGF0aCwgZmlsZVRvVXBsb2FkLnNpemVCeXRlcywgZmlsZVRvVXBsb2FkLm1pbWVUeXBlLCBmaWxlTmFtZSwgYm9keSwgY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmh0dHBPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHVwbG9hZGVyLnVwbG9hZChmaWxlLCB1cGxvYWRVcmwsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSB0byBhIGdpdmVuIGZpbGUgc2VhcmNoIHN0b3JlIGFzeW5jaHJvbm91c2x5IHVzaW5nIEdlbWluaSBBUEkgb25seSwgdGhpcyBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICogaW4gVmVydGV4IEFJLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGVTZWFyY2hTdG9yZU5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpbGUgc2VhcmNoIHN0b3JlIHRvIHVwbG9hZCB0aGUgZmlsZSB0by5cbiAgICAgKiBAcGFyYW0gZmlsZSBUaGUgc3RyaW5nIHBhdGggdG8gdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWQgb3IgYSBCbG9iIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gY29uZmlnIE9wdGlvbmFsIHBhcmFtZXRlcnMgc3BlY2lmaWVkIGluIHRoZSBgVXBsb2FkRmlsZUNvbmZpZ2BcbiAgICAgKiAgICAgaW50ZXJmYWNlLiBAc2VlIHtAbGluayBVcGxvYWRGaWxlQ29uZmlnfVxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmlsZWAgb2JqZWN0LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgY2FsbGVkIG9uIGEgVmVydGV4IEFJIGNsaWVudC5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBgbWltZVR5cGVgIGlzIG5vdCBwcm92aWRlZCBhbmQgY2FuIG5vdCBiZSBpbmZlcnJlZCxcbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWRGaWxlVG9GaWxlU2VhcmNoU3RvcmUoZmlsZVNlYXJjaFN0b3JlTmFtZSwgZmlsZSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgdXBsb2FkZXIgPSB0aGlzLmNsaWVudE9wdGlvbnMudXBsb2FkZXI7XG4gICAgICAgIGNvbnN0IGZpbGVTdGF0ID0gYXdhaXQgdXBsb2FkZXIuc3RhdChmaWxlKTtcbiAgICAgICAgY29uc3Qgc2l6ZUJ5dGVzID0gU3RyaW5nKGZpbGVTdGF0LnNpemUpO1xuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IChfYSA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5taW1lVHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmlsZVN0YXQudHlwZTtcbiAgICAgICAgaWYgKG1pbWVUeXBlID09PSB1bmRlZmluZWQgfHwgbWltZVR5cGUgPT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgZGV0ZXJtaW5lIG1pbWVUeXBlLiBQbGVhc2UgcHJvdmlkZSBtaW1lVHlwZSBpbiB0aGUgY29uZmlnLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBgdXBsb2FkL3YxYmV0YS8ke2ZpbGVTZWFyY2hTdG9yZU5hbWV9OnVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlYDtcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSB0aGlzLmdldEZpbGVOYW1lKGZpbGUpO1xuICAgICAgICBjb25zdCBib2R5ID0ge307XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVDb25maWdUb01sZGV2KGNvbmZpZywgYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBsb2FkVXJsID0gYXdhaXQgdGhpcy5mZXRjaFVwbG9hZFVybChwYXRoLCBzaXplQnl0ZXMsIG1pbWVUeXBlLCBmaWxlTmFtZSwgYm9keSwgY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmh0dHBPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHVwbG9hZGVyLnVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlKGZpbGUsIHVwbG9hZFVybCwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBhIGZpbGUgYXN5bmNocm9ub3VzbHkgdG8gdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtcyBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGRvd25sb2FkIHJlcXVlc3QsIHNlZSB7QGxpbmtcbiAgICAgKiB0eXBlcy5Eb3dubG9hZEZpbGVQYXJhbWV0ZXJzfVxuICAgICAqL1xuICAgIGFzeW5jIGRvd25sb2FkRmlsZShwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgZG93bmxvYWRlciA9IHRoaXMuY2xpZW50T3B0aW9ucy5kb3dubG9hZGVyO1xuICAgICAgICBhd2FpdCBkb3dubG9hZGVyLmRvd25sb2FkKHBhcmFtcywgdGhpcyk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoVXBsb2FkVXJsKHBhdGgsIHNpemVCeXRlcywgbWltZVR5cGUsIGZpbGVOYW1lLCBib2R5LCBjb25maWdIdHRwT3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBodHRwT3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAoY29uZmlnSHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGh0dHBPcHRpb25zID0gY29uZmlnSHR0cE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBodHRwT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBhcGlWZXJzaW9uOiAnJywgLy8gYXBpLXZlcnNpb24gaXMgc2V0IGluIHRoZSBwYXRoLlxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLCAnWC1Hb29nLVVwbG9hZC1Qcm90b2NvbCc6ICdyZXN1bWFibGUnLCAnWC1Hb29nLVVwbG9hZC1Db21tYW5kJzogJ3N0YXJ0JywgJ1gtR29vZy1VcGxvYWQtSGVhZGVyLUNvbnRlbnQtTGVuZ3RoJzogYCR7c2l6ZUJ5dGVzfWAsICdYLUdvb2ctVXBsb2FkLUhlYWRlci1Db250ZW50LVR5cGUnOiBgJHttaW1lVHlwZX1gIH0sIChmaWxlTmFtZSA/IHsgJ1gtR29vZy1VcGxvYWQtRmlsZS1OYW1lJzogZmlsZU5hbWUgfSA6IHt9KSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGh0dHBSZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBodHRwT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaHR0cFJlc3BvbnNlIHx8ICEoaHR0cFJlc3BvbnNlID09PSBudWxsIHx8IGh0dHBSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cFJlc3BvbnNlLmhlYWRlcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciBkaWQgbm90IHJldHVybiBhbiBIdHRwUmVzcG9uc2Ugb3IgdGhlIHJldHVybmVkIEh0dHBSZXNwb25zZSBkaWQgbm90IGhhdmUgaGVhZGVycy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGxvYWRVcmwgPSAoX2EgPSBodHRwUmVzcG9uc2UgPT09IG51bGwgfHwgaHR0cFJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBodHRwUmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWyd4LWdvb2ctdXBsb2FkLXVybCddO1xuICAgICAgICBpZiAodXBsb2FkVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCB1cGxvYWQgdXJsLiBTZXJ2ZXIgZGlkIG5vdCByZXR1cm4gdGhlIHgtZ29vZ2xlLXVwbG9hZC11cmwgaW4gdGhlIGhlYWRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBsb2FkVXJsO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHRocm93RXJyb3JJZk5vdE9LKHJlc3BvbnNlKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzcG9uc2UgaXMgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICBsZXQgZXJyb3JCb2R5O1xuICAgICAgICBpZiAoKF9hID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JCb2R5ID0ge1xuICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGF3YWl0IHJlc3BvbnNlLnRleHQoKSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZXJyb3JCb2R5KTtcbiAgICAgICAgaWYgKHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBBcGlFcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBhcGlFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICB9XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHVwZGF0ZXMgdGhlIGByZXF1ZXN0SW5pdC5ib2R5YCB3aXRoIHZhbHVlcyBmcm9tIGFuIGBleHRyYUJvZHlgIG9iamVjdC5cbiAqXG4gKiBJZiBgcmVxdWVzdEluaXQuYm9keWAgaXMgYSBzdHJpbmcsIGl0J3MgYXNzdW1lZCB0byBiZSBKU09OIGFuZCB3aWxsIGJlIHBhcnNlZC5cbiAqIFRoZSBgZXh0cmFCb2R5YCBpcyB0aGVuIGRlZXBseSBtZXJnZWQgaW50byB0aGlzIHBhcnNlZCBvYmplY3QuXG4gKiBJZiBgcmVxdWVzdEluaXQuYm9keWAgaXMgYSBCbG9iLCBgZXh0cmFCb2R5YCB3aWxsIGJlIGlnbm9yZWQsIGFuZCBhIHdhcm5pbmcgbG9nZ2VkLFxuICogYXMgbWVyZ2luZyBzdHJ1Y3R1cmVkIGRhdGEgaW50byBhbiBvcGFxdWUgQmxvYiBpcyBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBkb2VzIG5vdCBlbmZvcmNlIHRoYXQgdXBkYXRlZCB2YWx1ZXMgZnJvbSBgZXh0cmFCb2R5YCBoYXZlIHRoZVxuICogc2FtZSB0eXBlIGFzIGV4aXN0aW5nIHZhbHVlcyBpbiBgcmVxdWVzdEluaXQuYm9keWAuIFR5cGUgbWlzbWF0Y2hlcyBkdXJpbmdcbiAqIHRoZSBtZXJnZSB3aWxsIHJlc3VsdCBpbiBhIHdhcm5pbmcsIGJ1dCB0aGUgdmFsdWUgZnJvbSBgZXh0cmFCb2R5YCB3aWxsIG92ZXJ3cml0ZVxuICogdGhlIG9yaWdpbmFsLiBgZXh0cmFCb2R5YCB1c2VycyBhcmUgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIGBleHRyYUJvZHlgIGhhcyB0aGUgY29ycmVjdCBzdHJ1Y3R1cmUuXG4gKlxuICogQHBhcmFtIHJlcXVlc3RJbml0IFRoZSBSZXF1ZXN0SW5pdCBvYmplY3Qgd2hvc2UgYm9keSB3aWxsIGJlIHVwZGF0ZWQuXG4gKiBAcGFyYW0gZXh0cmFCb2R5IFRoZSBvYmplY3QgY29udGFpbmluZyB1cGRhdGVzIHRvIGJlIG1lcmdlZCBpbnRvIGByZXF1ZXN0SW5pdC5ib2R5YC5cbiAqL1xuZnVuY3Rpb24gaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIGV4dHJhQm9keSkge1xuICAgIGlmICghZXh0cmFCb2R5IHx8IE9iamVjdC5rZXlzKGV4dHJhQm9keSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3RJbml0LmJvZHkgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IGV4dHJhQm9keSBwcm92aWRlZCBidXQgY3VycmVudCByZXF1ZXN0IGJvZHkgaXMgYSBCbG9iLiBleHRyYUJvZHkgd2lsbCBiZSBpZ25vcmVkIGFzIG1lcmdpbmcgaXMgbm90IHN1cHBvcnRlZCBmb3IgQmxvYiBib2RpZXMuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRCb2R5T2JqZWN0ID0ge307XG4gICAgLy8gSWYgYWRkaW5nIG5ldyB0eXBlIHRvIEh0dHBSZXF1ZXN0LmJvZHksIHBsZWFzZSBjaGVjayB0aGUgY29kZSBiZWxvdyB0b1xuICAgIC8vIHNlZSBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgbG9naWMuXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0SW5pdC5ib2R5ID09PSAnc3RyaW5nJyAmJiByZXF1ZXN0SW5pdC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEJvZHkgPSBKU09OLnBhcnNlKHJlcXVlc3RJbml0LmJvZHkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWRCb2R5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHBhcnNlZEJvZHkgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShwYXJzZWRCb2R5KSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCb2R5T2JqZWN0ID0gcGFyc2VkQm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IE9yaWdpbmFsIHJlcXVlc3QgYm9keSBpcyB2YWxpZCBKU09OIGJ1dCBub3QgYSBub24tYXJyYXkgb2JqZWN0LiBTa2lwIGFwcGx5aW5nIGV4dHJhQm9keSB0byB0aGUgcmVxdWVzdCBib2R5LicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qICBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IE9yaWdpbmFsIHJlcXVlc3QgYm9keSBpcyBub3QgdmFsaWQgSlNPTi4gU2tpcCBhcHBseWluZyBleHRyYUJvZHkgdG8gdGhlIHJlcXVlc3QgYm9keS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZWVwTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0KTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSBvdXRwdXRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHNvdXJjZVZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShzb3VyY2VWYWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldFZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh0YXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBkZWVwTWVyZ2UodGFyZ2V0VmFsdWUsIHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRWYWx1ZSAhPT0gdHlwZW9mIHNvdXJjZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYGluY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0OmRlZXBNZXJnZTogVHlwZSBtaXNtYXRjaCBmb3Iga2V5IFwiJHtrZXl9XCIuIE9yaWdpbmFsIHR5cGU6ICR7dHlwZW9mIHRhcmdldFZhbHVlfSwgTmV3IHR5cGU6ICR7dHlwZW9mIHNvdXJjZVZhbHVlfS4gT3ZlcndyaXRpbmcuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBzb3VyY2VWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkQm9keSA9IGRlZXBNZXJnZShjdXJyZW50Qm9keU9iamVjdCwgZXh0cmFCb2R5KTtcbiAgICByZXF1ZXN0SW5pdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkobWVyZ2VkQm9keSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIFRPRE86IGIvNDE2MDQxMjI5IC0gRGV0ZXJtaW5lIGhvdyB0byByZXRyaWV2ZSB0aGUgTUNQIHBhY2thZ2UgdmVyc2lvbi5cbmNvbnN0IE1DUF9MQUJFTCA9ICdtY3BfdXNlZC91bmtub3duJztcbi8vIFdoZXRoZXIgTUNQIHRvb2wgdXNhZ2UgaXMgZGV0ZWN0ZWQgZnJvbSBtY3BUb1Rvb2wuIFRoaXMgaXMgdXNlZCBmb3Jcbi8vIHRlbGVtZXRyeS5cbmxldCBoYXNNY3BUb29sVXNhZ2VGcm9tTWNwVG9Ub29sID0gZmFsc2U7XG4vLyBDaGVja3Mgd2hldGhlciB0aGUgbGlzdCBvZiB0b29scyBjb250YWlucyBhbnkgTUNQIHRvb2xzLlxuZnVuY3Rpb24gaGFzTWNwVG9vbFVzYWdlKHRvb2xzKSB7XG4gICAgZm9yIChjb25zdCB0b29sIG9mIHRvb2xzKSB7XG4gICAgICAgIGlmIChpc01jcENhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b29sID09PSAnb2JqZWN0JyAmJiAnaW5wdXRTY2hlbWEnIGluIHRvb2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXNNY3BUb29sVXNhZ2VGcm9tTWNwVG9Ub29sO1xufVxuLy8gU2V0cyB0aGUgTUNQIHZlcnNpb24gbGFiZWwgaW4gdGhlIEdvb2dsZSBBUEkgY2xpZW50IGhlYWRlci5cbmZ1bmN0aW9uIHNldE1jcFVzYWdlSGVhZGVyKGhlYWRlcnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZXhpc3RpbmdIZWFkZXIgPSAoX2EgPSBoZWFkZXJzW0dPT0dMRV9BUElfQ0xJRU5UX0hFQURFUl0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgIGhlYWRlcnNbR09PR0xFX0FQSV9DTElFTlRfSEVBREVSXSA9IChleGlzdGluZ0hlYWRlciArIGAgJHtNQ1BfTEFCRUx9YCkudHJpbVN0YXJ0KCk7XG59XG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIE1DUCBDYWxsYWJsZVRvb2wsIG90aGVyd2lzZSBmYWxzZS5cbmZ1bmN0aW9uIGlzTWNwQ2FsbGFibGVUb29sKG9iamVjdCkge1xuICAgIHJldHVybiAob2JqZWN0ICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgIG9iamVjdCBpbnN0YW5jZW9mIE1jcENhbGxhYmxlVG9vbCk7XG59XG4vLyBMaXN0IGFsbCB0b29scyBmcm9tIHRoZSBNQ1AgY2xpZW50LlxuZnVuY3Rpb24gbGlzdEFsbFRvb2xzKG1jcENsaWVudF8xKSB7XG4gICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogbGlzdEFsbFRvb2xzXzEobWNwQ2xpZW50LCBtYXhUb29scyA9IDEwMCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgbnVtVG9vbHMgPSAwO1xuICAgICAgICB3aGlsZSAobnVtVG9vbHMgPCBtYXhUb29scykge1xuICAgICAgICAgICAgY29uc3QgdCA9IHlpZWxkIF9fYXdhaXQobWNwQ2xpZW50Lmxpc3RUb29scyh7IGN1cnNvciB9KSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdC50b29scykge1xuICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQodG9vbCk7XG4gICAgICAgICAgICAgICAgbnVtVG9vbHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdC5uZXh0Q3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJzb3IgPSB0Lm5leHRDdXJzb3I7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogTWNwQ2FsbGFibGVUb29sIGNhbiBiZSB1c2VkIGZvciBtb2RlbCBpbmZlcmVuY2UgYW5kIGludm9raW5nIE1DUCBjbGllbnRzIHdpdGhcbiAqIGdpdmVuIGZ1bmN0aW9uIGNhbGwgYXJndW1lbnRzLlxuICpcbiAqIEBleHBlcmltZW50YWwgQnVpbHQtaW4gTUNQIHN1cHBvcnQgaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUsIG1heSBjaGFuZ2UgaW4gZnV0dXJlXG4gKiB2ZXJzaW9ucy5cbiAqL1xuY2xhc3MgTWNwQ2FsbGFibGVUb29sIHtcbiAgICBjb25zdHJ1Y3RvcihtY3BDbGllbnRzID0gW10sIGNvbmZpZykge1xuICAgICAgICB0aGlzLm1jcFRvb2xzID0gW107XG4gICAgICAgIHRoaXMuZnVuY3Rpb25OYW1lVG9NY3BDbGllbnQgPSB7fTtcbiAgICAgICAgdGhpcy5tY3BDbGllbnRzID0gbWNwQ2xpZW50cztcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBNY3BDYWxsYWJsZVRvb2wuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShtY3BDbGllbnRzLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNY3BDYWxsYWJsZVRvb2wobWNwQ2xpZW50cywgY29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSBmdW5jdGlvbiBuYW1lcyBhcmUgbm90IGR1cGxpY2F0ZSBhbmQgaW5pdGlhbGl6ZSB0aGUgZnVuY3Rpb25cbiAgICAgKiBuYW1lIHRvIE1DUCBjbGllbnQgbWFwcGluZy5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgTUNQIHRvb2xzIGZyb20gdGhlIE1DUCBjbGllbnRzIGhhdmUgZHVwbGljYXRlIHRvb2xcbiAgICAgKiAgICAgbmFtZXMuXG4gICAgICovXG4gICAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICAgICAgaWYgKHRoaXMubWNwVG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uTWFwID0ge307XG4gICAgICAgIGNvbnN0IG1jcFRvb2xzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbWNwQ2xpZW50IG9mIHRoaXMubWNwQ2xpZW50cykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIF9lID0gKGVfMSA9IHZvaWQgMCwgX19hc3luY1ZhbHVlcyhsaXN0QWxsVG9vbHMobWNwQ2xpZW50KSkpLCBfZjsgX2YgPSBhd2FpdCBfZS5uZXh0KCksIF9hID0gX2YuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2MgPSBfZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWNwVG9vbCA9IF9jO1xuICAgICAgICAgICAgICAgICAgICBtY3BUb29scy5wdXNoKG1jcFRvb2wpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtY3BUb29sTmFtZSA9IG1jcFRvb2wubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uTWFwW21jcFRvb2xOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgZnVuY3Rpb24gbmFtZSAke21jcFRvb2xOYW1lfSBmb3VuZCBpbiBNQ1AgdG9vbHMuIFBsZWFzZSBlbnN1cmUgZnVuY3Rpb24gbmFtZXMgYXJlIHVuaXF1ZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk1hcFttY3BUb29sTmFtZV0gPSBtY3BDbGllbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IF9lLnJldHVybikpIGF3YWl0IF9iLmNhbGwoX2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tY3BUb29scyA9IG1jcFRvb2xzO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTmFtZVRvTWNwQ2xpZW50ID0gZnVuY3Rpb25NYXA7XG4gICAgfVxuICAgIGFzeW5jIHRvb2woKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICByZXR1cm4gbWNwVG9vbHNUb0dlbWluaVRvb2wodGhpcy5tY3BUb29scywgdGhpcy5jb25maWcpO1xuICAgIH1cbiAgICBhc3luYyBjYWxsVG9vbChmdW5jdGlvbkNhbGxzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGxSZXNwb25zZVBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZnVuY3Rpb25DYWxsIG9mIGZ1bmN0aW9uQ2FsbHMpIHtcbiAgICAgICAgICAgIGlmIChmdW5jdGlvbkNhbGwubmFtZSBpbiB0aGlzLmZ1bmN0aW9uTmFtZVRvTWNwQ2xpZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWNwQ2xpZW50ID0gdGhpcy5mdW5jdGlvbk5hbWVUb01jcENsaWVudFtmdW5jdGlvbkNhbGwubmFtZV07XG4gICAgICAgICAgICAgICAgbGV0IHJlcXVlc3RPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGIvNDI0MjM4NjU0IC0gQWRkIHN1cHBvcnQgZm9yIGZpbmVyIGdyYWluZWQgdGltZW91dCBjb250cm9sLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy50aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy5jb25maWcudGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbFRvb2xSZXNwb25zZSA9IGF3YWl0IG1jcENsaWVudC5jYWxsVG9vbCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uQ2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGZ1bmN0aW9uQ2FsbC5hcmdzLFxuICAgICAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgcmVzdWx0IHNjaGVtYSB0byB1bmRlZmluZWQgdG8gYWxsb3cgTUNQIHRvIHJlbHkgb24gdGhlXG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBzY2hlbWEuXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsUmVzcG9uc2VQYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25DYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogY2FsbFRvb2xSZXNwb25zZS5pc0Vycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7IGVycm9yOiBjYWxsVG9vbFJlc3BvbnNlIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNhbGxUb29sUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uQ2FsbFJlc3BvbnNlUGFydHM7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNNY3BDbGllbnQoY2xpZW50KSB7XG4gICAgcmV0dXJuIChjbGllbnQgIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIGNsaWVudCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ2xpc3RUb29scycgaW4gY2xpZW50ICYmXG4gICAgICAgIHR5cGVvZiBjbGllbnQubGlzdFRvb2xzID09PSAnZnVuY3Rpb24nKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIE1jcENhbGxhYmxlVG9vbCBmcm9tIE1DUCBjbGllbnRzIGFuZCBhbiBvcHRpb25hbCBjb25maWcuXG4gKlxuICogVGhlIGNhbGxhYmxlIHRvb2wgY2FuIGludm9rZSB0aGUgTUNQIGNsaWVudHMgd2l0aCBnaXZlbiBmdW5jdGlvbiBjYWxsXG4gKiBhcmd1bWVudHMuIChvZnRlbiBmb3IgYXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcpLlxuICogVXNlIHRoZSBjb25maWcgdG8gbW9kaWZ5IHRvb2wgcGFyYW1ldGVycyBzdWNoIGFzIGJlaGF2aW9yLlxuICpcbiAqIEBleHBlcmltZW50YWwgQnVpbHQtaW4gTUNQIHN1cHBvcnQgaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUsIG1heSBjaGFuZ2UgaW4gZnV0dXJlXG4gKiB2ZXJzaW9ucy5cbiAqL1xuZnVuY3Rpb24gbWNwVG9Ub29sKC4uLmFyZ3MpIHtcbiAgICAvLyBTZXQgTUNQIHVzYWdlIGZvciB0ZWxlbWV0cnkuXG4gICAgaGFzTWNwVG9vbFVzYWdlRnJvbU1jcFRvVG9vbCA9IHRydWU7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gTUNQIGNsaWVudHMgcHJvdmlkZWQnKTtcbiAgICB9XG4gICAgY29uc3QgbWF5YmVDb25maWcgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgaWYgKGlzTWNwQ2xpZW50KG1heWJlQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gTWNwQ2FsbGFibGVUb29sLmNyZWF0ZShhcmdzLCB7fSk7XG4gICAgfVxuICAgIHJldHVybiBNY3BDYWxsYWJsZVRvb2wuY3JlYXRlKGFyZ3Muc2xpY2UoMCwgYXJncy5sZW5ndGggLSAxKSwgbWF5YmVDb25maWcpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIEhhbmRsZXMgaW5jb21pbmcgbWVzc2FnZXMgZnJvbSB0aGUgV2ViU29ja2V0LlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBwYXJzaW5nIGluY29taW5nIG1lc3NhZ2VzLCB0cmFuc2Zvcm1pbmcgdGhlbVxuICogaW50byBMaXZlTXVzaWNTZXJ2ZXJNZXNzYWdlLCBhbmQgdGhlbiBjYWxsaW5nIHRoZSBvbm1lc3NhZ2UgY2FsbGJhY2suXG4gKiBOb3RlIHRoYXQgdGhlIGZpcnN0IG1lc3NhZ2Ugd2hpY2ggaXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIGlzIGFcbiAqIHNldHVwQ29tcGxldGUgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gYXBpQ2xpZW50IFRoZSBBcGlDbGllbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0gb25tZXNzYWdlIFRoZSB1c2VyLXByb3ZpZGVkIG9ubWVzc2FnZSBjYWxsYmFjayAoaWYgYW55KS5cbiAqIEBwYXJhbSBldmVudCBUaGUgTWVzc2FnZUV2ZW50IGZyb20gdGhlIFdlYlNvY2tldC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaGFuZGxlV2ViU29ja2V0TWVzc2FnZSQxKGFwaUNsaWVudCwgb25tZXNzYWdlLCBldmVudCkge1xuICAgIGNvbnN0IHNlcnZlck1lc3NhZ2UgPSBuZXcgTGl2ZU11c2ljU2VydmVyTWVzc2FnZSgpO1xuICAgIGxldCBkYXRhO1xuICAgIGlmIChldmVudC5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShhd2FpdCBldmVudC5kYXRhLnRleHQoKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihzZXJ2ZXJNZXNzYWdlLCBkYXRhKTtcbiAgICBvbm1lc3NhZ2Uoc2VydmVyTWVzc2FnZSk7XG59XG4vKipcbiAgIExpdmVNdXNpYyBjbGFzcyBlbmNhcHN1bGF0ZXMgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIGxpdmUgbXVzaWNcbiAgIGdlbmVyYXRpb24gdmlhIEx5cmlhIExpdmUgbW9kZWxzLlxuXG4gICBAZXhwZXJpbWVudGFsXG4gICovXG5jbGFzcyBMaXZlTXVzaWMge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCwgYXV0aCwgd2ViU29ja2V0RmFjdG9yeSkge1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXRGYWN0b3J5ID0gd2ViU29ja2V0RmFjdG9yeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgRXN0YWJsaXNoZXMgYSBjb25uZWN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgbW9kZWwgYW5kIHJldHVybnMgYVxuICAgICAgIExpdmVNdXNpY1Nlc3Npb24gb2JqZWN0IHJlcHJlc2VudGluZyB0aGF0IGNvbm5lY3Rpb24uXG4gIFxuICAgICAgIEBleHBlcmltZW50YWxcbiAgXG4gICAgICAgQHJlbWFya3NcbiAgXG4gICAgICAgQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBlc3RhYmxpc2hpbmcgYSBjb25uZWN0aW9uIHRvIHRoZSBtb2RlbC5cbiAgICAgICBAcmV0dXJuIEEgbGl2ZSBzZXNzaW9uLlxuICBcbiAgICAgICBAZXhhbXBsZVxuICAgICAgIGBgYHRzXG4gICAgICAgbGV0IG1vZGVsID0gJ21vZGVscy9seXJpYS1yZWFsdGltZS1leHAnO1xuICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBhaS5saXZlLm11c2ljLmNvbm5lY3Qoe1xuICAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgIG9ubWVzc2FnZTogKGU6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZCBtZXNzYWdlIGZyb20gdGhlIHNlcnZlcjogJXNcXG4nLCBkZWJ1ZyhlLmRhdGEpKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25lcnJvcjogKGU6IEVycm9yRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3Igb2NjdXJyZWQ6ICVzXFxuJywgZGVidWcoZS5lcnJvcikpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBvbmNsb3NlOiAoZTogQ2xvc2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0aW9uIGNsb3NlZC4nKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgIH0sXG4gICAgICAgfSk7XG4gICAgICAgYGBgXG4gICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3QocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGl2ZSBtdXNpYyBpcyBub3Qgc3VwcG9ydGVkIGZvciBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS53YXJuKCdMaXZlIG11c2ljIGdlbmVyYXRpb24gaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSB2ZXJzaW9ucy4nKTtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0QmFzZVVybCA9IHRoaXMuYXBpQ2xpZW50LmdldFdlYnNvY2tldEJhc2VVcmwoKTtcbiAgICAgICAgY29uc3QgYXBpVmVyc2lvbiA9IHRoaXMuYXBpQ2xpZW50LmdldEFwaVZlcnNpb24oKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG1hcFRvSGVhZGVycyQxKHRoaXMuYXBpQ2xpZW50LmdldERlZmF1bHRIZWFkZXJzKCkpO1xuICAgICAgICBjb25zdCBhcGlLZXkgPSB0aGlzLmFwaUNsaWVudC5nZXRBcGlLZXkoKTtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7d2Vic29ja2V0QmFzZVVybH0vd3MvZ29vZ2xlLmFpLmdlbmVyYXRpdmVsYW5ndWFnZS4ke2FwaVZlcnNpb259LkdlbmVyYXRpdmVTZXJ2aWNlLkJpZGlHZW5lcmF0ZU11c2ljP2tleT0ke2FwaUtleX1gO1xuICAgICAgICBsZXQgb25vcGVuUmVzb2x2ZSA9ICgpID0+IHsgfTtcbiAgICAgICAgY29uc3Qgb25vcGVuUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHBhcmFtcy5jYWxsYmFja3M7XG4gICAgICAgIGNvbnN0IG9ub3BlbkF3YWl0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9ub3BlblJlc29sdmUoe30pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhcGlDbGllbnQgPSB0aGlzLmFwaUNsaWVudDtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0Q2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgb25vcGVuOiBvbm9wZW5Bd2FpdGVkQ2FsbGJhY2ssXG4gICAgICAgICAgICBvbm1lc3NhZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZvaWQgaGFuZGxlV2ViU29ja2V0TWVzc2FnZSQxKGFwaUNsaWVudCwgY2FsbGJhY2tzLm9ubWVzc2FnZSwgZXZlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uZXJyb3I6IChfYSA9IGNhbGxiYWNrcyA9PT0gbnVsbCB8fCBjYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbmVycm9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uY2xvc2U6IChfYiA9IGNhbGxiYWNrcyA9PT0gbnVsbCB8fCBjYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbmNsb3NlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29ubiA9IHRoaXMud2ViU29ja2V0RmFjdG9yeS5jcmVhdGUodXJsLCBoZWFkZXJzVG9NYXAkMShoZWFkZXJzKSwgd2Vic29ja2V0Q2FsbGJhY2tzKTtcbiAgICAgICAgY29ubi5jb25uZWN0KCk7XG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSB3ZWJzb2NrZXQgdG8gb3BlbiBiZWZvcmUgc2VuZGluZyByZXF1ZXN0cy5cbiAgICAgICAgYXdhaXQgb25vcGVuUHJvbWlzZTtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0TW9kZWwodGhpcy5hcGlDbGllbnQsIHBhcmFtcy5tb2RlbCk7XG4gICAgICAgIGNvbnN0IHNldHVwID0geyBtb2RlbCB9O1xuICAgICAgICBjb25zdCBjbGllbnRNZXNzYWdlID0geyBzZXR1cCB9O1xuICAgICAgICBjb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgICAgICByZXR1cm4gbmV3IExpdmVNdXNpY1Nlc3Npb24oY29ubiwgdGhpcy5hcGlDbGllbnQpO1xuICAgIH1cbn1cbi8qKlxuICAgUmVwcmVzZW50cyBhIGNvbm5lY3Rpb24gdG8gdGhlIEFQSS5cblxuICAgQGV4cGVyaW1lbnRhbFxuICAqL1xuY2xhc3MgTGl2ZU11c2ljU2Vzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoY29ubiwgYXBpQ2xpZW50KSB7XG4gICAgICAgIHRoaXMuY29ubiA9IGNvbm47XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgIFNldHMgaW5wdXRzIHRvIHN0ZWVyIG11c2ljIGdlbmVyYXRpb24uIFVwZGF0ZXMgdGhlIHNlc3Npb24ncyBjdXJyZW50XG4gICAgICB3ZWlnaHRlZCBwcm9tcHRzLlxuICBcbiAgICAgIEBwYXJhbSBwYXJhbXMgLSBDb250YWlucyBvbmUgcHJvcGVydHksIGB3ZWlnaHRlZFByb21wdHNgLlxuICBcbiAgICAgICAgLSBgd2VpZ2h0ZWRQcm9tcHRzYCB0byBzZW5kIHRvIHRoZSBtb2RlbDsgd2VpZ2h0cyBhcmUgbm9ybWFsaXplZCB0b1xuICAgICAgICAgIHN1bSB0byAxLjAuXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGFzeW5jIHNldFdlaWdodGVkUHJvbXB0cyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMud2VpZ2h0ZWRQcm9tcHRzIHx8XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMud2VpZ2h0ZWRQcm9tcHRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2VpZ2h0ZWQgcHJvbXB0cyBtdXN0IGJlIHNldCBhbmQgY29udGFpbiBhdCBsZWFzdCBvbmUgZW50cnkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50Q29udGVudCA9IGxpdmVNdXNpY1NldFdlaWdodGVkUHJvbXB0c1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgIHRoaXMuY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KHsgY2xpZW50Q29udGVudCB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2V0cyBhIGNvbmZpZ3VyYXRpb24gdG8gdGhlIG1vZGVsLiBVcGRhdGVzIHRoZSBzZXNzaW9uJ3MgY3VycmVudFxuICAgICAgbXVzaWMgZ2VuZXJhdGlvbiBjb25maWcuXG4gIFxuICAgICAgQHBhcmFtIHBhcmFtcyAtIENvbnRhaW5zIG9uZSBwcm9wZXJ0eSwgYG11c2ljR2VuZXJhdGlvbkNvbmZpZ2AuXG4gIFxuICAgICAgICAtIGBtdXNpY0dlbmVyYXRpb25Db25maWdgIHRvIHNldCBpbiB0aGUgbW9kZWwuIFBhc3NpbmcgYW4gZW1wdHkgb3JcbiAgICAgIHVuZGVmaW5lZCBjb25maWcgdG8gdGhlIG1vZGVsIHdpbGwgcmVzZXQgdGhlIGNvbmZpZyB0byBkZWZhdWx0cy5cbiAgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgYXN5bmMgc2V0TXVzaWNHZW5lcmF0aW9uQ29uZmlnKHBhcmFtcykge1xuICAgICAgICBpZiAoIXBhcmFtcy5tdXNpY0dlbmVyYXRpb25Db25maWcpIHtcbiAgICAgICAgICAgIHBhcmFtcy5tdXNpY0dlbmVyYXRpb25Db25maWcgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXRDb25maWdQYXJhbWV0ZXJzID0gbGl2ZU11c2ljU2V0Q29uZmlnUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoc2V0Q29uZmlnUGFyYW1ldGVycykpO1xuICAgIH1cbiAgICBzZW5kUGxheWJhY2tDb250cm9sKHBsYXliYWNrQ29udHJvbCkge1xuICAgICAgICBjb25zdCBjbGllbnRNZXNzYWdlID0geyBwbGF5YmFja0NvbnRyb2wgfTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCB0aGUgbXVzaWMgc3RyZWFtLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHBsYXkoKSB7XG4gICAgICAgIHRoaXMuc2VuZFBsYXliYWNrQ29udHJvbChMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wuUExBWSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlbXBvcmFyaWx5IGhhbHQgdGhlIG11c2ljIHN0cmVhbS4gVXNlIGBwbGF5YCB0byByZXN1bWUgZnJvbSB0aGUgY3VycmVudFxuICAgICAqIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLnNlbmRQbGF5YmFja0NvbnRyb2woTGl2ZU11c2ljUGxheWJhY2tDb250cm9sLlBBVVNFKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgbXVzaWMgc3RyZWFtIGFuZCByZXNldCB0aGUgc3RhdGUuIFJldGFpbnMgdGhlIGN1cnJlbnQgcHJvbXB0c1xuICAgICAqIGFuZCBjb25maWcuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5zZW5kUGxheWJhY2tDb250cm9sKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbC5TVE9QKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBjb250ZXh0IG9mIHRoZSBtdXNpYyBnZW5lcmF0aW9uIHdpdGhvdXQgc3RvcHBpbmcgaXQuXG4gICAgICogUmV0YWlucyB0aGUgY3VycmVudCBwcm9tcHRzIGFuZCBjb25maWcuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgcmVzZXRDb250ZXh0KCkge1xuICAgICAgICB0aGlzLnNlbmRQbGF5YmFja0NvbnRyb2woTGl2ZU11c2ljUGxheWJhY2tDb250cm9sLlJFU0VUX0NPTlRFWFQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgICBUZXJtaW5hdGVzIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgXG4gICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmNvbm4uY2xvc2UoKTtcbiAgICB9XG59XG4vLyBDb252ZXJ0cyBhbiBoZWFkZXJzIG9iamVjdCB0byBhIFwibWFwXCIgb2JqZWN0IGFzIGV4cGVjdGVkIGJ5IHRoZSBXZWJTb2NrZXRcbi8vIGNvbnN0cnVjdG9yLiBXZSB1c2UgdGhpcyBhcyB0aGUgQXV0aCBpbnRlcmZhY2Ugd29ya3Mgd2l0aCBIZWFkZXJzIG9iamVjdHNcbi8vIHdoaWxlIHRoZSBXZWJTb2NrZXQgY29uc3RydWN0b3IgdGFrZXMgYSBtYXAuXG5mdW5jdGlvbiBoZWFkZXJzVG9NYXAkMShoZWFkZXJzKSB7XG4gICAgY29uc3QgaGVhZGVyTWFwID0ge307XG4gICAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGhlYWRlck1hcFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlck1hcDtcbn1cbi8vIENvbnZlcnRzIGEgXCJtYXBcIiBvYmplY3QgdG8gYSBoZWFkZXJzIG9iamVjdC4gV2UgdXNlIHRoaXMgYXMgdGhlIEF1dGhcbi8vIGludGVyZmFjZSB3b3JrcyB3aXRoIEhlYWRlcnMgb2JqZWN0cyB3aGlsZSB0aGUgQVBJIGNsaWVudCBkZWZhdWx0IGhlYWRlcnNcbi8vIHJldHVybnMgYSBtYXAuXG5mdW5jdGlvbiBtYXBUb0hlYWRlcnMkMShtYXApIHtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtYXApKSB7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgRlVOQ1RJT05fUkVTUE9OU0VfUkVRVUlSRVNfSUQgPSAnRnVuY3Rpb25SZXNwb25zZSByZXF1ZXN0IG11c3QgaGF2ZSBhbiBgaWRgIGZpZWxkIGZyb20gdGhlIHJlc3BvbnNlIG9mIGEgVG9vbENhbGwuRnVuY3Rpb25hbENhbGxzIGluIEdvb2dsZSBBSS4nO1xuLyoqXG4gKiBIYW5kbGVzIGluY29taW5nIG1lc3NhZ2VzIGZyb20gdGhlIFdlYlNvY2tldC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgcGFyc2luZyBpbmNvbWluZyBtZXNzYWdlcywgdHJhbnNmb3JtaW5nIHRoZW1cbiAqIGludG8gTGl2ZVNlcnZlck1lc3NhZ2VzLCBhbmQgdGhlbiBjYWxsaW5nIHRoZSBvbm1lc3NhZ2UgY2FsbGJhY2suIE5vdGUgdGhhdFxuICogdGhlIGZpcnN0IG1lc3NhZ2Ugd2hpY2ggaXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIGlzIGEgc2V0dXBDb21wbGV0ZVxuICogbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gYXBpQ2xpZW50IFRoZSBBcGlDbGllbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0gb25tZXNzYWdlIFRoZSB1c2VyLXByb3ZpZGVkIG9ubWVzc2FnZSBjYWxsYmFjayAoaWYgYW55KS5cbiAqIEBwYXJhbSBldmVudCBUaGUgTWVzc2FnZUV2ZW50IGZyb20gdGhlIFdlYlNvY2tldC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaGFuZGxlV2ViU29ja2V0TWVzc2FnZShhcGlDbGllbnQsIG9ubWVzc2FnZSwgZXZlbnQpIHtcbiAgICBjb25zdCBzZXJ2ZXJNZXNzYWdlID0gbmV3IExpdmVTZXJ2ZXJNZXNzYWdlKCk7XG4gICAgbGV0IGpzb25EYXRhO1xuICAgIGlmIChldmVudC5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBqc29uRGF0YSA9IGF3YWl0IGV2ZW50LmRhdGEudGV4dCgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudC5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAganNvbkRhdGEgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZXZlbnQuZGF0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBqc29uRGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb25EYXRhKTtcbiAgICBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICBjb25zdCByZXNwID0gbGl2ZVNlcnZlck1lc3NhZ2VGcm9tVmVydGV4KGRhdGEpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHNlcnZlck1lc3NhZ2UsIHJlc3ApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzcCA9IGRhdGE7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc2VydmVyTWVzc2FnZSwgcmVzcCk7XG4gICAgfVxuICAgIG9ubWVzc2FnZShzZXJ2ZXJNZXNzYWdlKTtcbn1cbi8qKlxuICAgTGl2ZSBjbGFzcyBlbmNhcHN1bGF0ZXMgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIGxpdmUgaW50ZXJhY3Rpb24gd2l0aCB0aGVcbiAgIEdlbmVyYXRpdmUgTGFuZ3VhZ2UgQVBJLiBJdCBlbWJlZHMgQXBpQ2xpZW50IGZvciBnZW5lcmFsIEFQSSBzZXR0aW5ncy5cblxuICAgQGV4cGVyaW1lbnRhbFxuICAqL1xuY2xhc3MgTGl2ZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50LCBhdXRoLCB3ZWJTb2NrZXRGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICB0aGlzLndlYlNvY2tldEZhY3RvcnkgPSB3ZWJTb2NrZXRGYWN0b3J5O1xuICAgICAgICB0aGlzLm11c2ljID0gbmV3IExpdmVNdXNpYyh0aGlzLmFwaUNsaWVudCwgdGhpcy5hdXRoLCB0aGlzLndlYlNvY2tldEZhY3RvcnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgICBFc3RhYmxpc2hlcyBhIGNvbm5lY3Rpb24gdG8gdGhlIHNwZWNpZmllZCBtb2RlbCB3aXRoIHRoZSBnaXZlblxuICAgICAgIGNvbmZpZ3VyYXRpb24gYW5kIHJldHVybnMgYSBTZXNzaW9uIG9iamVjdCByZXByZXNlbnRpbmcgdGhhdCBjb25uZWN0aW9uLlxuICBcbiAgICAgICBAZXhwZXJpbWVudGFsIEJ1aWx0LWluIE1DUCBzdXBwb3J0IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlLCBtYXkgY2hhbmdlIGluXG4gICAgICAgZnV0dXJlIHZlcnNpb25zLlxuICBcbiAgICAgICBAcmVtYXJrc1xuICBcbiAgICAgICBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGVzdGFibGlzaGluZyBhIGNvbm5lY3Rpb24gdG8gdGhlIG1vZGVsLlxuICAgICAgIEByZXR1cm4gQSBsaXZlIHNlc3Npb24uXG4gIFxuICAgICAgIEBleGFtcGxlXG4gICAgICAgYGBgdHNcbiAgICAgICBsZXQgbW9kZWw6IHN0cmluZztcbiAgICAgICBpZiAoR09PR0xFX0dFTkFJX1VTRV9WRVJURVhBSSkge1xuICAgICAgICAgbW9kZWwgPSAnZ2VtaW5pLTIuMC1mbGFzaC1saXZlLXByZXZpZXctMDQtMDknO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICBtb2RlbCA9ICdnZW1pbmktbGl2ZS0yLjUtZmxhc2gtcHJldmlldyc7XG4gICAgICAgfVxuICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBhaS5saXZlLmNvbm5lY3Qoe1xuICAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgIHJlc3BvbnNlTW9kYWxpdGllczogW01vZGFsaXR5LkFVRElPXSxcbiAgICAgICAgIH0sXG4gICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgb25vcGVuOiAoKSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3RlZCB0byB0aGUgc29ja2V0LicpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBvbm1lc3NhZ2U6IChlOiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVjZWl2ZWQgbWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXI6ICVzXFxuJywgZGVidWcoZS5kYXRhKSk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIG9uZXJyb3I6IChlOiBFcnJvckV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIG9jY3VycmVkOiAlc1xcbicsIGRlYnVnKGUuZXJyb3IpKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25jbG9zZTogKGU6IENsb3NlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGlvbiBjbG9zZWQuJyk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICB9LFxuICAgICAgIH0pO1xuICAgICAgIGBgYFxuICAgICAgKi9cbiAgICBhc3luYyBjb25uZWN0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgLy8gVE9ETzogYi80MDQ5NDY3NDYgLSBTdXBwb3J0IHBlciByZXF1ZXN0IEhUVFAgb3B0aW9ucy5cbiAgICAgICAgaWYgKHBhcmFtcy5jb25maWcgJiYgcGFyYW1zLmNvbmZpZy5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgTGl2ZSBtb2R1bGUgZG9lcyBub3Qgc3VwcG9ydCBodHRwT3B0aW9ucyBhdCByZXF1ZXN0LWxldmVsIGluJyArXG4gICAgICAgICAgICAgICAgJyBMaXZlQ29ubmVjdENvbmZpZyB5ZXQuIFBsZWFzZSB1c2UgdGhlIGNsaWVudC1sZXZlbCBodHRwT3B0aW9ucycgK1xuICAgICAgICAgICAgICAgICcgY29uZmlndXJhdGlvbiBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdlYnNvY2tldEJhc2VVcmwgPSB0aGlzLmFwaUNsaWVudC5nZXRXZWJzb2NrZXRCYXNlVXJsKCk7XG4gICAgICAgIGNvbnN0IGFwaVZlcnNpb24gPSB0aGlzLmFwaUNsaWVudC5nZXRBcGlWZXJzaW9uKCk7XG4gICAgICAgIGxldCB1cmw7XG4gICAgICAgIGNvbnN0IGNsaWVudEhlYWRlcnMgPSB0aGlzLmFwaUNsaWVudC5nZXRIZWFkZXJzKCk7XG4gICAgICAgIGlmIChwYXJhbXMuY29uZmlnICYmXG4gICAgICAgICAgICBwYXJhbXMuY29uZmlnLnRvb2xzICYmXG4gICAgICAgICAgICBoYXNNY3BUb29sVXNhZ2UocGFyYW1zLmNvbmZpZy50b29scykpIHtcbiAgICAgICAgICAgIHNldE1jcFVzYWdlSGVhZGVyKGNsaWVudEhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBtYXBUb0hlYWRlcnMoY2xpZW50SGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3QgPSB0aGlzLmFwaUNsaWVudC5nZXRQcm9qZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuYXBpQ2xpZW50LmdldExvY2F0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBhcGlLZXkgPSB0aGlzLmFwaUNsaWVudC5nZXRBcGlLZXkoKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc1N0YW5kYXJkQXV0aCA9ICghIXByb2plY3QgJiYgISFsb2NhdGlvbikgfHwgISFhcGlLZXk7XG4gICAgICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuZ2V0Q3VzdG9tQmFzZVVybCgpICYmICFoYXNTdGFuZGFyZEF1dGgpIHtcbiAgICAgICAgICAgICAgICAvLyBDdXN0b20gYmFzZSBVUkwgd2l0aG91dCBzdGFuZGFyZCBhdXRoIChlLmcuLCBwcm94eSkuXG4gICAgICAgICAgICAgICAgdXJsID0gd2Vic29ja2V0QmFzZVVybDtcbiAgICAgICAgICAgICAgICAvLyBBdXRoIGhlYWRlcnMgYXJlIGFzc3VtZWQgdG8gYmUgaW4gYGNsaWVudEhlYWRlcnNgIGZyb20gaHR0cE9wdGlvbnMuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmwgPSBgJHt3ZWJzb2NrZXRCYXNlVXJsfS93cy9nb29nbGUuY2xvdWQuYWlwbGF0Zm9ybS4ke2FwaVZlcnNpb259LkxsbUJpZGlTZXJ2aWNlL0JpZGlHZW5lcmF0ZUNvbnRlbnRgO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXV0aC5hZGRBdXRoSGVhZGVycyhoZWFkZXJzLCB1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYXBpS2V5ID0gdGhpcy5hcGlDbGllbnQuZ2V0QXBpS2V5KCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kID0gJ0JpZGlHZW5lcmF0ZUNvbnRlbnQnO1xuICAgICAgICAgICAgbGV0IGtleU5hbWUgPSAna2V5JztcbiAgICAgICAgICAgIGlmIChhcGlLZXkgPT09IG51bGwgfHwgYXBpS2V5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcGlLZXkuc3RhcnRzV2l0aCgnYXV0aF90b2tlbnMvJykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IEVwaGVtZXJhbCB0b2tlbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuJyk7XG4gICAgICAgICAgICAgICAgaWYgKGFwaVZlcnNpb24gIT09ICd2MWFscGhhJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBUaGUgU0RLJ3MgZXBoZW1lcmFsIHRva2VuIHN1cHBvcnQgaXMgaW4gdjFhbHBoYSBvbmx5LiBQbGVhc2UgdXNlIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHthcGlLZXk6IHRva2VuLm5hbWUsIGh0dHBPcHRpb25zOiB7IGFwaVZlcnNpb246ICd2MWFscGhhJyB9fSk7IGJlZm9yZSBzZXNzaW9uIGNvbm5lY3Rpb24uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRob2QgPSAnQmlkaUdlbmVyYXRlQ29udGVudENvbnN0cmFpbmVkJztcbiAgICAgICAgICAgICAgICBrZXlOYW1lID0gJ2FjY2Vzc190b2tlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cmwgPSBgJHt3ZWJzb2NrZXRCYXNlVXJsfS93cy9nb29nbGUuYWkuZ2VuZXJhdGl2ZWxhbmd1YWdlLiR7YXBpVmVyc2lvbn0uR2VuZXJhdGl2ZVNlcnZpY2UuJHttZXRob2R9PyR7a2V5TmFtZX09JHthcGlLZXl9YDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb25vcGVuUmVzb2x2ZSA9ICgpID0+IHsgfTtcbiAgICAgICAgY29uc3Qgb25vcGVuUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHBhcmFtcy5jYWxsYmFja3M7XG4gICAgICAgIGNvbnN0IG9ub3BlbkF3YWl0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IGNhbGxiYWNrcyA9PT0gbnVsbCB8fCBjYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbm9wZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNhbGxiYWNrcyk7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlKHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gdGhpcy5hcGlDbGllbnQ7XG4gICAgICAgIGNvbnN0IHdlYnNvY2tldENhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIG9ub3Blbjogb25vcGVuQXdhaXRlZENhbGxiYWNrLFxuICAgICAgICAgICAgb25tZXNzYWdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2b2lkIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UoYXBpQ2xpZW50LCBjYWxsYmFja3Mub25tZXNzYWdlLCBldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25lcnJvcjogKF9hID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uZXJyb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25jbG9zZTogKF9iID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uY2xvc2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb25uID0gdGhpcy53ZWJTb2NrZXRGYWN0b3J5LmNyZWF0ZSh1cmwsIGhlYWRlcnNUb01hcChoZWFkZXJzKSwgd2Vic29ja2V0Q2FsbGJhY2tzKTtcbiAgICAgICAgY29ubi5jb25uZWN0KCk7XG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSB3ZWJzb2NrZXQgdG8gb3BlbiBiZWZvcmUgc2VuZGluZyByZXF1ZXN0cy5cbiAgICAgICAgYXdhaXQgb25vcGVuUHJvbWlzZTtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTW9kZWwgPSB0TW9kZWwodGhpcy5hcGlDbGllbnQsIHBhcmFtcy5tb2RlbCk7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiZcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTW9kZWwuc3RhcnRzV2l0aCgncHVibGlzaGVycy8nKSkge1xuICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9IHRoaXMuYXBpQ2xpZW50LmdldFByb2plY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5hcGlDbGllbnQuZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIGlmIChwcm9qZWN0ICYmIGxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRNb2RlbCA9XG4gICAgICAgICAgICAgICAgICAgIGBwcm9qZWN0cy8ke3Byb2plY3R9L2xvY2F0aW9ucy8ke2xvY2F0aW9ufS9gICsgdHJhbnNmb3JtZWRNb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2xpZW50TWVzc2FnZSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpICYmXG4gICAgICAgICAgICAoKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlc3BvbnNlTW9kYWxpdGllcykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gU2V0IGRlZmF1bHQgdG8gQVVESU8gdG8gYWxpZ24gd2l0aCBNTERldiBBUEkuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbmZpZyA9IHsgcmVzcG9uc2VNb2RhbGl0aWVzOiBbTW9kYWxpdHkuQVVESU9dIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uZmlnLnJlc3BvbnNlTW9kYWxpdGllcyA9IFtNb2RhbGl0eS5BVURJT107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5nZW5lcmF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgICAvLyBSYWlzZSBkZXByZWNhdGlvbiB3YXJuaW5nIGZvciBnZW5lcmF0aW9uQ29uZmlnLlxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdTZXR0aW5nIGBMaXZlQ29ubmVjdENvbmZpZy5nZW5lcmF0aW9uX2NvbmZpZ2AgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHNldCB0aGUgZmllbGRzIG9uIGBMaXZlQ29ubmVjdENvbmZpZ2AgZGlyZWN0bHkuIFRoaXMgd2lsbCBiZWNvbWUgYW4gZXJyb3IgaW4gYSBmdXR1cmUgdmVyc2lvbiAobm90IGJlZm9yZSBRMyAyMDI1KS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dFRvb2xzID0gKF9mID0gKF9lID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnRvb2xzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBbXTtcbiAgICAgICAgY29uc3QgY29udmVydGVkVG9vbHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIGlucHV0VG9vbHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGFibGVUb29sID0gdG9vbDtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRUb29scy5wdXNoKGF3YWl0IGNhbGxhYmxlVG9vbC50b29sKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udmVydGVkVG9vbHMucHVzaCh0b29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udmVydGVkVG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy50b29scyA9IGNvbnZlcnRlZFRvb2xzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpdmVDb25uZWN0UGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIG1vZGVsOiB0cmFuc2Zvcm1lZE1vZGVsLFxuICAgICAgICAgICAgY29uZmlnOiBwYXJhbXMuY29uZmlnLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBwYXJhbXMuY2FsbGJhY2tzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjbGllbnRNZXNzYWdlID0gbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIGxpdmVDb25uZWN0UGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGllbnRNZXNzYWdlID0gbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgY2xpZW50TWVzc2FnZVsnY29uZmlnJ107XG4gICAgICAgIGNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiBuZXcgU2Vzc2lvbihjb25uLCB0aGlzLmFwaUNsaWVudCk7XG4gICAgfVxuICAgIC8vIFRPRE86IGIvNDE2MDQxMjI5IC0gQWJzdHJhY3QgdGhpcyBtZXRob2QgdG8gYSBjb21tb24gcGxhY2UuXG4gICAgaXNDYWxsYWJsZVRvb2wodG9vbCkge1xuICAgICAgICByZXR1cm4gJ2NhbGxUb29sJyBpbiB0b29sICYmIHR5cGVvZiB0b29sLmNhbGxUb29sID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbn1cbmNvbnN0IGRlZmF1bHRMaXZlU2VuZENsaWVudENvbnRlbnRQYXJhbWVydGVycyA9IHtcbiAgICB0dXJuQ29tcGxldGU6IHRydWUsXG59O1xuLyoqXG4gICBSZXByZXNlbnRzIGEgY29ubmVjdGlvbiB0byB0aGUgQVBJLlxuXG4gICBAZXhwZXJpbWVudGFsXG4gICovXG5jbGFzcyBTZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uLCBhcGlDbGllbnQpIHtcbiAgICAgICAgdGhpcy5jb25uID0gY29ubjtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIHRMaXZlQ2xpZW50Q29udGVudChhcGlDbGllbnQsIHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLnR1cm5zICE9PSBudWxsICYmIHBhcmFtcy50dXJucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgY29udGVudHMgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29udGVudHMgPSB0Q29udGVudHMocGFyYW1zLnR1cm5zKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMgPSBjb250ZW50cy5tYXAoKGl0ZW0pID0+IGNvbnRlbnRUb01sZGV2JDEoaXRlbSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIGNsaWVudCBjb250ZW50IFwidHVybnNcIiwgdHlwZTogJyR7dHlwZW9mIHBhcmFtcy50dXJuc30nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNsaWVudENvbnRlbnQ6IHsgdHVybnM6IGNvbnRlbnRzLCB0dXJuQ29tcGxldGU6IHBhcmFtcy50dXJuQ29tcGxldGUgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsaWVudENvbnRlbnQ6IHsgdHVybkNvbXBsZXRlOiBwYXJhbXMudHVybkNvbXBsZXRlIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRMaXZlQ2xpZW50dFRvb2xSZXNwb25zZShhcGlDbGllbnQsIHBhcmFtcykge1xuICAgICAgICBsZXQgZnVuY3Rpb25SZXNwb25zZXMgPSBbXTtcbiAgICAgICAgaWYgKHBhcmFtcy5mdW5jdGlvblJlc3BvbnNlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Z1bmN0aW9uUmVzcG9uc2VzIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXMpKSB7XG4gICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlcyA9IFtwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZXMgPSBwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bmN0aW9uUmVzcG9uc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdW5jdGlvblJlc3BvbnNlcyBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZ1bmN0aW9uUmVzcG9uc2Ugb2YgZnVuY3Rpb25SZXNwb25zZXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25SZXNwb25zZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgISgnbmFtZScgaW4gZnVuY3Rpb25SZXNwb25zZSkgfHxcbiAgICAgICAgICAgICAgICAhKCdyZXNwb25zZScgaW4gZnVuY3Rpb25SZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSBmdW5jdGlvbiByZXNwb25zZSwgdHlwZSAnJHt0eXBlb2YgZnVuY3Rpb25SZXNwb25zZX0nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpICYmICEoJ2lkJyBpbiBmdW5jdGlvblJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihGVU5DVElPTl9SRVNQT05TRV9SRVFVSVJFU19JRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHRvb2xSZXNwb25zZTogeyBmdW5jdGlvblJlc3BvbnNlczogZnVuY3Rpb25SZXNwb25zZXMgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNsaWVudE1lc3NhZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2VuZCBhIG1lc3NhZ2Ugb3ZlciB0aGUgZXN0YWJsaXNoZWQgY29ubmVjdGlvbi5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgdHdvICoqb3B0aW9uYWwqKiBwcm9wZXJ0aWVzLCBgdHVybnNgIGFuZFxuICAgICAgICAgIGB0dXJuQ29tcGxldGVgLlxuICBcbiAgICAgICAgLSBgdHVybnNgIHdpbGwgYmUgY29udmVydGVkIHRvIGEgYENvbnRlbnRbXWBcbiAgICAgICAgLSBgdHVybkNvbXBsZXRlOiB0cnVlYCBbZGVmYXVsdF0gaW5kaWNhdGVzIHRoYXQgeW91IGFyZSBkb25lIHNlbmRpbmdcbiAgICAgICAgICBjb250ZW50IGFuZCBleHBlY3QgYSByZXNwb25zZS4gSWYgYHR1cm5Db21wbGV0ZTogZmFsc2VgLCB0aGUgc2VydmVyXG4gICAgICAgICAgd2lsbCB3YWl0IGZvciBhZGRpdGlvbmFsIG1lc3NhZ2VzIGJlZm9yZSBzdGFydGluZyBnZW5lcmF0aW9uLlxuICBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgXG4gICAgICBAcmVtYXJrc1xuICAgICAgVGhlcmUgYXJlIHR3byB3YXlzIHRvIHNlbmQgbWVzc2FnZXMgdG8gdGhlIGxpdmUgQVBJOlxuICAgICAgYHNlbmRDbGllbnRDb250ZW50YCBhbmQgYHNlbmRSZWFsdGltZUlucHV0YC5cbiAgXG4gICAgICBgc2VuZENsaWVudENvbnRlbnRgIG1lc3NhZ2VzIGFyZSBhZGRlZCB0byB0aGUgbW9kZWwgY29udGV4dCAqKmluIG9yZGVyKiouXG4gICAgICBIYXZpbmcgYSBjb252ZXJzYXRpb24gdXNpbmcgYHNlbmRDbGllbnRDb250ZW50YCBtZXNzYWdlcyBpcyByb3VnaGx5XG4gICAgICBlcXVpdmFsZW50IHRvIHVzaW5nIHRoZSBgQ2hhdC5zZW5kTWVzc2FnZVN0cmVhbWAsIGV4Y2VwdCB0aGF0IHRoZSBzdGF0ZSBvZlxuICAgICAgdGhlIGBjaGF0YCBoaXN0b3J5IGlzIHN0b3JlZCBvbiB0aGUgQVBJIHNlcnZlciBpbnN0ZWFkIG9mIGxvY2FsbHkuXG4gIFxuICAgICAgQmVjYXVzZSBvZiBgc2VuZENsaWVudENvbnRlbnRgJ3Mgb3JkZXIgZ3VhcmFudGVlLCB0aGUgbW9kZWwgY2Fubm90IHJlc3BvbnNcbiAgICAgIGFzIHF1aWNrbHkgdG8gYHNlbmRDbGllbnRDb250ZW50YCBtZXNzYWdlcyBhcyB0byBgc2VuZFJlYWx0aW1lSW5wdXRgXG4gICAgICBtZXNzYWdlcy4gVGhpcyBtYWtlcyB0aGUgYmlnZ2VzdCBkaWZmZXJlbmNlIHdoZW4gc2VuZGluZyBvYmplY3RzIHRoYXQgaGF2ZVxuICAgICAgc2lnbmlmaWNhbnQgcHJlcHJvY2Vzc2luZyB0aW1lICh0eXBpY2FsbHkgaW1hZ2VzKS5cbiAgXG4gICAgICBUaGUgYHNlbmRDbGllbnRDb250ZW50YCBtZXNzYWdlIHNlbmRzIGEgYENvbnRlbnRbXWBcbiAgICAgIHdoaWNoIGhhcyBtb3JlIG9wdGlvbnMgdGhhbiB0aGUgYEJsb2JgIHNlbnQgYnkgYHNlbmRSZWFsdGltZUlucHV0YC5cbiAgXG4gICAgICBTbyB0aGUgbWFpbiB1c2UtY2FzZXMgZm9yIGBzZW5kQ2xpZW50Q29udGVudGAgb3ZlciBgc2VuZFJlYWx0aW1lSW5wdXRgIGFyZTpcbiAgXG4gICAgICAtIFNlbmRpbmcgYW55dGhpbmcgdGhhdCBjYW4ndCBiZSByZXByZXNlbnRlZCBhcyBhIGBCbG9iYCAodGV4dCxcbiAgICAgIGBzZW5kQ2xpZW50Q29udGVudCh7dHVybnM9XCJIZWxsbz9cIn1gKSkuXG4gICAgICAtIE1hbmFnaW5nIHR1cm5zIHdoZW4gbm90IHVzaW5nIGF1ZGlvIGlucHV0IGFuZCB2b2ljZSBhY3Rpdml0eSBkZXRlY3Rpb24uXG4gICAgICAgIChgc2VuZENsaWVudENvbnRlbnQoe3R1cm5Db21wbGV0ZTp0cnVlfSlgIG9yIHRoZSBzaG9ydCBmb3JtXG4gICAgICBgc2VuZENsaWVudENvbnRlbnQoKWApXG4gICAgICAtIFByZWZpbGxpbmcgYSBjb252ZXJzYXRpb24gY29udGV4dFxuICAgICAgICBgYGBcbiAgICAgICAgc2VuZENsaWVudENvbnRlbnQoe1xuICAgICAgICAgICAgdHVybnM6IFtcbiAgICAgICAgICAgICAgQ29udGVudCh7cm9sZTp1c2VyLCBwYXJ0czouLi59KSxcbiAgICAgICAgICAgICAgQ29udGVudCh7cm9sZTp1c2VyLCBwYXJ0czouLi59KSxcbiAgICAgICAgICAgICAgLi4uXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgICAgIGBgYFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHNlbmRDbGllbnRDb250ZW50KHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRMaXZlU2VuZENsaWVudENvbnRlbnRQYXJhbWVydGVycyksIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSB0aGlzLnRMaXZlQ2xpZW50Q29udGVudCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgIFNlbmQgYSByZWFsdGltZSBtZXNzYWdlIG92ZXIgdGhlIGVzdGFibGlzaGVkIGNvbm5lY3Rpb24uXG4gIFxuICAgICAgQHBhcmFtIHBhcmFtcyAtIENvbnRhaW5zIG9uZSBwcm9wZXJ0eSwgYG1lZGlhYC5cbiAgXG4gICAgICAgIC0gYG1lZGlhYCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIGBCbG9iYFxuICBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgXG4gICAgICBAcmVtYXJrc1xuICAgICAgVXNlIGBzZW5kUmVhbHRpbWVJbnB1dGAgZm9yIHJlYWx0aW1lIGF1ZGlvIGNodW5rcyBhbmQgdmlkZW8gZnJhbWVzIChpbWFnZXMpLlxuICBcbiAgICAgIFdpdGggYHNlbmRSZWFsdGltZUlucHV0YCB0aGUgYXBpIHdpbGwgcmVzcG9uZCB0byBhdWRpbyBhdXRvbWF0aWNhbGx5XG4gICAgICBiYXNlZCBvbiB2b2ljZSBhY3Rpdml0eSBkZXRlY3Rpb24gKFZBRCkuXG4gIFxuICAgICAgYHNlbmRSZWFsdGltZUlucHV0YCBpcyBvcHRpbWl6ZWQgZm9yIHJlc3BvbnNpdm5lc3MgYXQgdGhlIGV4cGVuc2Ugb2ZcbiAgICAgIGRldGVybWluaXN0aWMgb3JkZXJpbmcgZ3VhcmFudGVlcy4gQXVkaW8gYW5kIHZpZGVvIHRva2VucyBhcmUgdG8gdGhlXG4gICAgICBjb250ZXh0IHdoZW4gdGhleSBiZWNvbWUgYXZhaWxhYmxlLlxuICBcbiAgICAgIE5vdGU6IFRoZSBDYWxsIHNpZ25hdHVyZSBleHBlY3RzIGEgYEJsb2JgIG9iamVjdCwgYnV0IG9ubHkgYSBzdWJzZXRcbiAgICAgIG9mIGF1ZGlvIGFuZCBpbWFnZSBtaW1ldHlwZXMgYXJlIGFsbG93ZWQuXG4gICAgICovXG4gICAgc2VuZFJlYWx0aW1lSW5wdXQocGFyYW1zKSB7XG4gICAgICAgIGxldCBjbGllbnRNZXNzYWdlID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNsaWVudE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgJ3JlYWx0aW1lSW5wdXQnOiBsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGllbnRNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICdyZWFsdGltZUlucHV0JzogbGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgIFNlbmQgYSBmdW5jdGlvbiByZXNwb25zZSBtZXNzYWdlIG92ZXIgdGhlIGVzdGFibGlzaGVkIGNvbm5lY3Rpb24uXG4gIFxuICAgICAgQHBhcmFtIHBhcmFtcyAtIENvbnRhaW5zIHByb3BlcnR5IGBmdW5jdGlvblJlc3BvbnNlc2AuXG4gIFxuICAgICAgICAtIGBmdW5jdGlvblJlc3BvbnNlc2Agd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBgZnVuY3Rpb25SZXNwb25zZXNbXWBcbiAgXG4gICAgICBAcmVtYXJrc1xuICAgICAgVXNlIGBzZW5kRnVuY3Rpb25SZXNwb25zZWAgdG8gcmVwbHkgdG8gYExpdmVTZXJ2ZXJUb29sQ2FsbGAgZnJvbSB0aGUgc2VydmVyLlxuICBcbiAgICAgIFVzZSB7QGxpbmsgdHlwZXMuTGl2ZUNvbm5lY3RDb25maWcjdG9vbHN9IHRvIGNvbmZpZ3VyZSB0aGUgY2FsbGFibGUgZnVuY3Rpb25zLlxuICBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBzZW5kVG9vbFJlc3BvbnNlKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmZ1bmN0aW9uUmVzcG9uc2VzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9vbCByZXNwb25zZSBwYXJhbWV0ZXJzIGFyZSByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnRNZXNzYWdlID0gdGhpcy50TGl2ZUNsaWVudHRUb29sUmVzcG9uc2UodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgIHRoaXMuY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgVGVybWluYXRlcyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gIFxuICAgICAgIEBleHBlcmltZW50YWxcbiAgXG4gICAgICAgQGV4YW1wbGVcbiAgICAgICBgYGB0c1xuICAgICAgIGxldCBtb2RlbDogc3RyaW5nO1xuICAgICAgIGlmIChHT09HTEVfR0VOQUlfVVNFX1ZFUlRFWEFJKSB7XG4gICAgICAgICBtb2RlbCA9ICdnZW1pbmktMi4wLWZsYXNoLWxpdmUtcHJldmlldy0wNC0wOSc7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgIG1vZGVsID0gJ2dlbWluaS1saXZlLTIuNS1mbGFzaC1wcmV2aWV3JztcbiAgICAgICB9XG4gICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGFpLmxpdmUuY29ubmVjdCh7XG4gICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgcmVzcG9uc2VNb2RhbGl0aWVzOiBbTW9kYWxpdHkuQVVESU9dLFxuICAgICAgICAgfVxuICAgICAgIH0pO1xuICBcbiAgICAgICBzZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgYGBgXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgIH1cbn1cbi8vIENvbnZlcnRzIGFuIGhlYWRlcnMgb2JqZWN0IHRvIGEgXCJtYXBcIiBvYmplY3QgYXMgZXhwZWN0ZWQgYnkgdGhlIFdlYlNvY2tldFxuLy8gY29uc3RydWN0b3IuIFdlIHVzZSB0aGlzIGFzIHRoZSBBdXRoIGludGVyZmFjZSB3b3JrcyB3aXRoIEhlYWRlcnMgb2JqZWN0c1xuLy8gd2hpbGUgdGhlIFdlYlNvY2tldCBjb25zdHJ1Y3RvciB0YWtlcyBhIG1hcC5cbmZ1bmN0aW9uIGhlYWRlcnNUb01hcChoZWFkZXJzKSB7XG4gICAgY29uc3QgaGVhZGVyTWFwID0ge307XG4gICAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGhlYWRlck1hcFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlck1hcDtcbn1cbi8vIENvbnZlcnRzIGEgXCJtYXBcIiBvYmplY3QgdG8gYSBoZWFkZXJzIG9iamVjdC4gV2UgdXNlIHRoaXMgYXMgdGhlIEF1dGhcbi8vIGludGVyZmFjZSB3b3JrcyB3aXRoIEhlYWRlcnMgb2JqZWN0cyB3aGlsZSB0aGUgQVBJIGNsaWVudCBkZWZhdWx0IGhlYWRlcnNcbi8vIHJldHVybnMgYSBtYXAuXG5mdW5jdGlvbiBtYXBUb0hlYWRlcnMobWFwKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWFwKSkge1xuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IERFRkFVTFRfTUFYX1JFTU9URV9DQUxMUyA9IDEwO1xuLyoqIFJldHVybnMgd2hldGhlciBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZyBpcyBkaXNhYmxlZC4gKi9cbmZ1bmN0aW9uIHNob3VsZERpc2FibGVBZmMoY29uZmlnKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKChfYSA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNhYmxlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgY2FsbGFibGVUb29sc1ByZXNlbnQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHRvb2wgb2YgKF9iID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLnRvb2xzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSkge1xuICAgICAgICBpZiAoaXNDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgIGNhbGxhYmxlVG9vbHNQcmVzZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2FsbGFibGVUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IG1heENhbGxzID0gKF9jID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1heGltdW1SZW1vdGVDYWxscztcbiAgICBpZiAoKG1heENhbGxzICYmIChtYXhDYWxscyA8IDAgfHwgIU51bWJlci5pc0ludGVnZXIobWF4Q2FsbHMpKSkgfHxcbiAgICAgICAgbWF4Q2FsbHMgPT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgbWF4aW11bVJlbW90ZUNhbGxzIHZhbHVlIHByb3ZpZGVkIGZvciBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZy4gRGlzYWJsZWQgYXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcuIFBsZWFzZSBwcm92aWRlIGEgdmFsaWQgaW50ZWdlciB2YWx1ZSBncmVhdGVyIHRoYW4gMC4gbWF4aW11bVJlbW90ZUNhbGxzIHByb3ZpZGVkOicsIG1heENhbGxzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQ2FsbGFibGVUb29sKHRvb2wpIHtcbiAgICByZXR1cm4gJ2NhbGxUb29sJyBpbiB0b29sICYmIHR5cGVvZiB0b29sLmNhbGxUb29sID09PSAnZnVuY3Rpb24nO1xufVxuLy8gQ2hlY2tzIHdoZXRoZXIgdGhlIGxpc3Qgb2YgdG9vbHMgY29udGFpbnMgYW55IENhbGxhYmxlVG9vbHMuIFdpbGwgcmV0dXJuIHRydWVcbi8vIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBDYWxsYWJsZVRvb2wuXG5mdW5jdGlvbiBoYXNDYWxsYWJsZVRvb2xzKHBhcmFtcykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9vbHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zb21lKCh0b29sKSA9PiBpc0NhbGxhYmxlVG9vbCh0b29sKSkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZhbHNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmRleGVzIG9mIHRoZSB0b29scyB0aGF0IGFyZSBub3QgY29tcGF0aWJsZSB3aXRoIEFGQy5cbiAqL1xuZnVuY3Rpb24gZmluZEFmY0luY29tcGF0aWJsZVRvb2xJbmRleGVzKHBhcmFtcykge1xuICAgIHZhciBfYTtcbiAgICAvLyBVc2UgbnVtYmVyW10gZm9yIGFuIGFycmF5IG9mIG51bWJlcnMgaW4gVHlwZVNjcmlwdFxuICAgIGNvbnN0IGFmY0luY29tcGF0aWJsZVRvb2xJbmRleGVzID0gW107XG4gICAgaWYgKCEoKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvb2xzKSkge1xuICAgICAgICByZXR1cm4gYWZjSW5jb21wYXRpYmxlVG9vbEluZGV4ZXM7XG4gICAgfVxuICAgIHBhcmFtcy5jb25maWcudG9vbHMuZm9yRWFjaCgodG9vbCwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2VtaW5pVG9vbCA9IHRvb2w7XG4gICAgICAgIGlmIChnZW1pbmlUb29sLmZ1bmN0aW9uRGVjbGFyYXRpb25zICYmXG4gICAgICAgICAgICBnZW1pbmlUb29sLmZ1bmN0aW9uRGVjbGFyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGFmY0luY29tcGF0aWJsZVRvb2xJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFmY0luY29tcGF0aWJsZVRvb2xJbmRleGVzO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdG8gYXBwZW5kIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIGhpc3RvcnkgdG8gdGhlXG4gKiByZXNwb25zZS5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkQXBwZW5kQWZjSGlzdG9yeShjb25maWcpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICEoKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlnbm9yZUNhbGxIaXN0b3J5KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgTW9kZWxzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFrZXMgYW4gQVBJIHJlcXVlc3QgdG8gZ2VuZXJhdGUgY29udGVudCB3aXRoIGEgZ2l2ZW4gbW9kZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBWZXJ0ZXggQUkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBmdWxsIHJlc291cmNlIG5hbWUgc3RhcnRzIHdpdGggJ3Byb2plY3RzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3Byb2plY3RzL215LXByb2plY3QtaWQvbG9jYXRpb25zL3VzLWNlbnRyYWwxL3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy9nZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBwYXJ0aWFsIHJlc291cmNlIG5hbWUgd2l0aCAncHVibGlzaGVycy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCcgb3JcbiAgICAgICAgICogICdwdWJsaXNoZXJzL21ldGEvbW9kZWxzL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqIC0gYC9gIHNlcGFyYXRlZCBwdWJsaXNoZXIgYW5kIG1vZGVsIG5hbWUsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAnZ29vZ2xlL2dlbWluaS0yLjAtZmxhc2gnIG9yICdtZXRhL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBHZW1pbmkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBtb2RlbCBuYW1lIHN0YXJ0cyB3aXRoICdtb2RlbHMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAnbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gRm9yIHR1bmVkIG1vZGVscywgdGhlIG1vZGVsIG5hbWUgc3RhcnRzIHdpdGggJ3R1bmVkTW9kZWxzLycsXG4gICAgICAgICAqIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAndHVuZWRNb2RlbHMvMTIzNDU2Nzg5MDEyMzQ1Njc4OSdcbiAgICAgICAgICpcbiAgICAgICAgICogU29tZSBtb2RlbHMgc3VwcG9ydCBtdWx0aW1vZGFsIGlucHV0IGFuZCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2VuZXJhdGluZyBjb250ZW50LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIGdlbmVyYXRpbmcgY29udGVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50KHtcbiAgICAgICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAgICAgKiAgIGNvbnRlbnRzOiAnd2h5IGlzIHRoZSBza3kgYmx1ZT8nLFxuICAgICAgICAgKiAgIGNvbmZpZzoge1xuICAgICAgICAgKiAgICAgY2FuZGlkYXRlQ291bnQ6IDIsXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDb250ZW50ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgdGhpcy5wcm9jZXNzUGFyYW1zTWF5YmVBZGRNY3BVc2FnZShwYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5tYXliZU1vdmVUb1Jlc3BvbnNlSnNvblNjaGVtKHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoIWhhc0NhbGxhYmxlVG9vbHMocGFyYW1zKSB8fCBzaG91bGREaXNhYmxlQWZjKHBhcmFtcy5jb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVDb250ZW50SW50ZXJuYWwodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5jb21wYXRpYmxlVG9vbEluZGV4ZXMgPSBmaW5kQWZjSW5jb21wYXRpYmxlVG9vbEluZGV4ZXMocGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChpbmNvbXBhdGlibGVUb29sSW5kZXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkSW5kZXhlcyA9IGluY29tcGF0aWJsZVRvb2xJbmRleGVzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGluZGV4KSA9PiBgdG9vbHNbJHtpbmRleH1dYClcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZyB3aXRoIENhbGxhYmxlVG9vbHMgKG9yIE1DUCBvYmplY3RzKSBhbmQgYmFzaWMgRnVuY3Rpb25EZWNsYXJhdGlvbnMgaXMgbm90IHlldCBzdXBwb3J0ZWQuIEluY29tcGF0aWJsZSB0b29scyBmb3VuZCBhdCAke2Zvcm1hdHRlZEluZGV4ZXN9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgbGV0IGZ1bmN0aW9uUmVzcG9uc2VDb250ZW50O1xuICAgICAgICAgICAgY29uc3QgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9IHRDb250ZW50cyh0cmFuc2Zvcm1lZFBhcmFtcy5jb250ZW50cyk7XG4gICAgICAgICAgICBjb25zdCBtYXhSZW1vdGVDYWxscyA9IChfYyA9IChfYiA9IChfYSA9IHRyYW5zZm9ybWVkUGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1heGltdW1SZW1vdGVDYWxscykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogREVGQVVMVF9NQVhfUkVNT1RFX0NBTExTO1xuICAgICAgICAgICAgbGV0IHJlbW90ZUNhbGxzID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChyZW1vdGVDYWxscyA8IG1heFJlbW90ZUNhbGxzKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdlbmVyYXRlQ29udGVudEludGVybmFsKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMgfHwgcmVzcG9uc2UuZnVuY3Rpb25DYWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudCA9IHJlc3BvbnNlLmNhbmRpZGF0ZXNbMF0uY29udGVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBmdW5jdGlvblJlc3BvbnNlUGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgKF9lID0gKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnRvb2xzKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBbXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxhYmxlVG9vbCA9IHRvb2w7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGF3YWl0IGNhbGxhYmxlVG9vbC5jYWxsVG9vbChyZXNwb25zZS5mdW5jdGlvbkNhbGxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2VQYXJ0cy5wdXNoKC4uLnBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW1vdGVDYWxscysrO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2VDb250ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzOiBmdW5jdGlvblJlc3BvbnNlUGFydHMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBhcmFtcy5jb250ZW50cyA9IHRDb250ZW50cyh0cmFuc2Zvcm1lZFBhcmFtcy5jb250ZW50cyk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRQYXJhbXMuY29udGVudHMucHVzaChyZXNwb25zZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzLnB1c2goZnVuY3Rpb25SZXNwb25zZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRBcHBlbmRBZmNIaXN0b3J5KHRyYW5zZm9ybWVkUGFyYW1zLmNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeS5wdXNoKHJlc3BvbnNlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkucHVzaChmdW5jdGlvblJlc3BvbnNlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZEFwcGVuZEFmY0hpc3RvcnkodHJhbnNmb3JtZWRQYXJhbXMuY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkgPVxuICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFrZXMgYW4gQVBJIHJlcXVlc3QgdG8gZ2VuZXJhdGUgY29udGVudCB3aXRoIGEgZ2l2ZW4gbW9kZWwgYW5kIHlpZWxkcyB0aGVcbiAgICAgICAgICogcmVzcG9uc2UgaW4gY2h1bmtzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgdGhlIGBtb2RlbGAgcGFyYW1ldGVyLCBzdXBwb3J0ZWQgZm9ybWF0cyBmb3IgVmVydGV4IEFJIEFQSSBpbmNsdWRlOlxuICAgICAgICAgKiAtIFRoZSBHZW1pbmkgbW9kZWwgSUQsIGZvciBleGFtcGxlOiAnZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBUaGUgZnVsbCByZXNvdXJjZSBuYW1lIHN0YXJ0cyB3aXRoICdwcm9qZWN0cy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdwcm9qZWN0cy9teS1wcm9qZWN0LWlkL2xvY2F0aW9ucy91cy1jZW50cmFsMS9wdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBUaGUgcGFydGlhbCByZXNvdXJjZSBuYW1lIHdpdGggJ3B1Ymxpc2hlcnMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAncHVibGlzaGVycy9nb29nbGUvbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnIG9yXG4gICAgICAgICAqICAncHVibGlzaGVycy9tZXRhL21vZGVscy9sbGFtYS0zLjEtNDA1Yi1pbnN0cnVjdC1tYWFzJ1xuICAgICAgICAgKiAtIGAvYCBzZXBhcmF0ZWQgcHVibGlzaGVyIGFuZCBtb2RlbCBuYW1lLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogJ2dvb2dsZS9nZW1pbmktMi4wLWZsYXNoJyBvciAnbWV0YS9sbGFtYS0zLjEtNDA1Yi1pbnN0cnVjdC1tYWFzJ1xuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgdGhlIGBtb2RlbGAgcGFyYW1ldGVyLCBzdXBwb3J0ZWQgZm9ybWF0cyBmb3IgR2VtaW5pIEFQSSBpbmNsdWRlOlxuICAgICAgICAgKiAtIFRoZSBHZW1pbmkgbW9kZWwgSUQsIGZvciBleGFtcGxlOiAnZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBUaGUgbW9kZWwgbmFtZSBzdGFydHMgd2l0aCAnbW9kZWxzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ21vZGVscy9nZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIEZvciB0dW5lZCBtb2RlbHMsIHRoZSBtb2RlbCBuYW1lIHN0YXJ0cyB3aXRoICd0dW5lZE1vZGVscy8nLFxuICAgICAgICAgKiBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICd0dW5lZE1vZGVscy8xMjM0NTY3ODkwMTIzNDU2Nzg5J1xuICAgICAgICAgKlxuICAgICAgICAgKiBTb21lIG1vZGVscyBzdXBwb3J0IG11bHRpbW9kYWwgaW5wdXQgYW5kIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZW5lcmF0aW5nIGNvbnRlbnQgd2l0aCBzdHJlYW1pbmcgcmVzcG9uc2UuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gZ2VuZXJhdGluZyBjb250ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnRTdHJlYW0oe1xuICAgICAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICAgICAqICAgY29udGVudHM6ICd3aHkgaXMgdGhlIHNreSBibHVlPycsXG4gICAgICAgICAqICAgY29uZmlnOiB7XG4gICAgICAgICAqICAgICBtYXhPdXRwdXRUb2tlbnM6IDIwMCxcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlc3BvbnNlKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coY2h1bmspO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNvbnRlbnRTdHJlYW0gPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAgICAgdGhpcy5tYXliZU1vdmVUb1Jlc3BvbnNlSnNvblNjaGVtKHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkRGlzYWJsZUFmYyhwYXJhbXMuY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgdGhpcy5wcm9jZXNzUGFyYW1zTWF5YmVBZGRNY3BVc2FnZShwYXJhbXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdlbmVyYXRlQ29udGVudFN0cmVhbUludGVybmFsKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluY29tcGF0aWJsZVRvb2xJbmRleGVzID0gZmluZEFmY0luY29tcGF0aWJsZVRvb2xJbmRleGVzKHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoaW5jb21wYXRpYmxlVG9vbEluZGV4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZEluZGV4ZXMgPSBpbmNvbXBhdGlibGVUb29sSW5kZXhlc1xuICAgICAgICAgICAgICAgICAgICAubWFwKChpbmRleCkgPT4gYHRvb2xzWyR7aW5kZXh9XWApXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5jb21wYXRpYmxlIHRvb2xzIGZvdW5kIGF0ICR7Zm9ybWF0dGVkSW5kZXhlc30uIEF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIHdpdGggQ2FsbGFibGVUb29scyAob3IgTUNQIG9iamVjdHMpIGFuZCBiYXNpYyBGdW5jdGlvbkRlY2xhcmF0aW9uc1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2l0aCB0b29sIGNvbXBhdGliaWxpdHkgY29uZmlybWVkLCB2YWxpZGF0ZSB0aGF0IHRoZSBjb25maWd1cmF0aW9uIGFyZVxuICAgICAgICAgICAgLy8gY29tcGF0aWJsZSB3aXRoIGVhY2ggb3RoZXIgYW5kIHJhaXNlIGFuIGVycm9yIGlmIGludmFsaWQuXG4gICAgICAgICAgICBjb25zdCBzdHJlYW1GdW5jdGlvbkNhbGwgPSAoX2MgPSAoX2IgPSAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9vbENvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZ1bmN0aW9uQ2FsbGluZ0NvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN0cmVhbUZ1bmN0aW9uQ2FsbEFyZ3VtZW50cztcbiAgICAgICAgICAgIGNvbnN0IGRpc2FibGVBZmMgPSAoX2UgPSAoX2QgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuZGlzYWJsZTtcbiAgICAgICAgICAgIGlmIChzdHJlYW1GdW5jdGlvbkNhbGwgJiYgIWRpc2FibGVBZmMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW5uaW5nIGluIHN0cmVhbWluZyBtb2RlIHdpdGggJ3N0cmVhbUZ1bmN0aW9uQ2FsbEFyZ3VtZW50cycgZW5hYmxlZCwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAndGhpcyBmZWF0dXJlIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcgKEFGQykuICcgK1xuICAgICAgICAgICAgICAgICAgICBcIlBsZWFzZSBzZXQgJ2NvbmZpZy5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmcuZGlzYWJsZScgdG8gdHJ1ZSB0byBkaXNhYmxlIEFGQyBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwib3IgbGVhdmUgJ2NvbmZpZy50b29sQ29uZmlnLmZ1bmN0aW9uQ2FsbGluZ0NvbmZpZy5zdHJlYW1GdW5jdGlvbkNhbGxBcmd1bWVudHMnIFwiICtcbiAgICAgICAgICAgICAgICAgICAgJ3RvIGJlIHVuZGVmaW5lZCBvciBzZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBzdHJlYW1pbmcgZnVuY3Rpb24gY2FsbCBhcmd1bWVudHMgZmVhdHVyZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb2Nlc3NBZmNTdHJlYW0ocGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYXRlcyBhbiBpbWFnZSBiYXNlZCBvbiBhIHRleHQgZGVzY3JpcHRpb24gYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2VuZXJhdGluZyBpbWFnZXMuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQubW9kZWxzLmdlbmVyYXRlSW1hZ2VzKHtcbiAgICAgICAgICogIG1vZGVsOiAnaW1hZ2VuLTQuMC1nZW5lcmF0ZS0wMDEnLFxuICAgICAgICAgKiAgcHJvbXB0OiAnUm9ib3QgaG9sZGluZyBhIHJlZCBza2F0ZWJvYXJkJyxcbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgICAgICogICAgaW5jbHVkZVJhaVJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlbmVyYXRlSW1hZ2VzID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVJbWFnZXNJbnRlcm5hbChwYXJhbXMpLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGxldCBwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkSW1hZ2VzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGFwaVJlc3BvbnNlID09PSBudWxsIHx8IGFwaVJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcGlSZXNwb25zZS5nZW5lcmF0ZWRJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBnZW5lcmF0ZWRJbWFnZSBvZiBhcGlSZXNwb25zZS5nZW5lcmF0ZWRJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRJbWFnZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnZW5lcmF0ZWRJbWFnZSA9PT0gbnVsbCB8fCBnZW5lcmF0ZWRJbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VuZXJhdGVkSW1hZ2Uuc2FmZXR5QXR0cmlidXRlcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9hID0gZ2VuZXJhdGVkSW1hZ2UgPT09IG51bGwgfHwgZ2VuZXJhdGVkSW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRlZEltYWdlLnNhZmV0eUF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50VHlwZSkgPT09ICdQb3NpdGl2ZSBQcm9tcHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzID0gZ2VuZXJhdGVkSW1hZ2UgPT09IG51bGwgfHwgZ2VuZXJhdGVkSW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRlZEltYWdlLnNhZmV0eUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRJbWFnZXMucHVzaChnZW5lcmF0ZWRJbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRJbWFnZXM6IGdlbmVyYXRlZEltYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlczogcG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2RrSHR0cFJlc3BvbnNlOiBhcGlSZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZEltYWdlczogZ2VuZXJhdGVkSW1hZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2RrSHR0cFJlc3BvbnNlOiBhcGlSZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3QgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgIHF1ZXJ5QmFzZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxDb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDb25maWcpLCBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb25maWc6IGFjdHVhbENvbmZpZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY3R1YWxQYXJhbXMuY29uZmlnLnF1ZXJ5QmFzZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKF9hID0gYWN0dWFsUGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWx0ZXJpbmcgdHVuZWQgbW9kZWxzIGxpc3QgZm9yIFZlcnRleCBBSSBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsUGFyYW1zLmNvbmZpZy5maWx0ZXIgPSAnbGFiZWxzLnR1bmUtdHlwZToqJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fTU9ERUxTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeCksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKGFjdHVhbFBhcmFtcyksIGFjdHVhbFBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZGl0cyBhbiBpbWFnZSBiYXNlZCBvbiBhIHByb21wdCwgbGlzdCBvZiByZWZlcmVuY2UgaW1hZ2VzLCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBlZGl0aW5nIGFuIGltYWdlLlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50Lm1vZGVscy5lZGl0SW1hZ2Uoe1xuICAgICAgICAgKiAgbW9kZWw6ICdpbWFnZW4tMy4wLWNhcGFiaWxpdHktMDAxJyxcbiAgICAgICAgICogIHByb21wdDogJ0dlbmVyYXRlIGFuIGltYWdlIGNvbnRhaW5pbmcgYSBtdWcgd2l0aCB0aGUgcHJvZHVjdCBsb2dvIFsxXSB2aXNpYmxlIG9uIHRoZSBzaWRlIG9mIHRoZSBtdWcuJyxcbiAgICAgICAgICogIHJlZmVyZW5jZUltYWdlczogW3N1YmplY3RSZWZlcmVuY2VJbWFnZV1cbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgICAgICogICAgaW5jbHVkZVJhaVJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVkaXRJbWFnZSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtc0ludGVybmFsID0ge1xuICAgICAgICAgICAgICAgIG1vZGVsOiBwYXJhbXMubW9kZWwsXG4gICAgICAgICAgICAgICAgcHJvbXB0OiBwYXJhbXMucHJvbXB0LFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlczogW10sXG4gICAgICAgICAgICAgICAgY29uZmlnOiBwYXJhbXMuY29uZmlnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMucmVmZXJlbmNlSW1hZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5yZWZlcmVuY2VJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zSW50ZXJuYWwucmVmZXJlbmNlSW1hZ2VzID0gcGFyYW1zLnJlZmVyZW5jZUltYWdlcy5tYXAoKGltZykgPT4gaW1nLnRvUmVmZXJlbmNlSW1hZ2VBUEkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZWRpdEltYWdlSW50ZXJuYWwocGFyYW1zSW50ZXJuYWwpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBzY2FsZXMgYW4gaW1hZ2UgYmFzZWQgb24gYW4gaW1hZ2UsIHVwc2NhbGUgZmFjdG9yLCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogT25seSBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJIGN1cnJlbnRseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB1cHNjYWxpbmcgYW4gaW1hZ2UuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQubW9kZWxzLnVwc2NhbGVJbWFnZSh7XG4gICAgICAgICAqICBtb2RlbDogJ2ltYWdlbi00LjAtdXBzY2FsZS1wcmV2aWV3JyxcbiAgICAgICAgICogIGltYWdlOiBpbWFnZSxcbiAgICAgICAgICogIHVwc2NhbGVGYWN0b3I6ICd4MicsXG4gICAgICAgICAqICBjb25maWc6IHtcbiAgICAgICAgICogICAgaW5jbHVkZVJhaVJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwc2NhbGVJbWFnZSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGxldCBhcGlDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZJbWFnZXM6IDEsXG4gICAgICAgICAgICAgICAgbW9kZTogJ3Vwc2NhbGUnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgYXBpQ29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhcGlDb25maWcpLCBwYXJhbXMuY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBtb2RlbDogcGFyYW1zLm1vZGVsLFxuICAgICAgICAgICAgICAgIGltYWdlOiBwYXJhbXMuaW1hZ2UsXG4gICAgICAgICAgICAgICAgdXBzY2FsZUZhY3RvcjogcGFyYW1zLnVwc2NhbGVGYWN0b3IsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBhcGlDb25maWcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudXBzY2FsZUltYWdlSW50ZXJuYWwoYXBpUGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBHZW5lcmF0ZXMgdmlkZW9zIGJhc2VkIG9uIGEgdGV4dCBkZXNjcmlwdGlvbiBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZW5lcmF0aW5nIHZpZGVvcy5cbiAgICAgICAgICogQHJldHVybiBBIFByb21pc2U8R2VuZXJhdGVWaWRlb3NPcGVyYXRpb24+IHdoaWNoIGFsbG93cyB5b3UgdG8gdHJhY2sgdGhlIHByb2dyZXNzIGFuZCBldmVudHVhbGx5IHJldHJpZXZlIHRoZSBnZW5lcmF0ZWQgdmlkZW9zIHVzaW5nIHRoZSBvcGVyYXRpb25zLmdldCBtZXRob2QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IG9wZXJhdGlvbiA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZVZpZGVvcyh7XG4gICAgICAgICAqICBtb2RlbDogJ3Zlby0yLjAtZ2VuZXJhdGUtMDAxJyxcbiAgICAgICAgICogIHNvdXJjZToge1xuICAgICAgICAgKiAgICBwcm9tcHQ6ICdBIG5lb24gaG9sb2dyYW0gb2YgYSBjYXQgZHJpdmluZyBhdCB0b3Agc3BlZWQnLFxuICAgICAgICAgKiAgfSxcbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBudW1iZXJPZlZpZGVvczogMVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogd2hpbGUgKCFvcGVyYXRpb24uZG9uZSkge1xuICAgICAgICAgKiAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwMCkpO1xuICAgICAgICAgKiAgIG9wZXJhdGlvbiA9IGF3YWl0IGFpLm9wZXJhdGlvbnMuZ2V0VmlkZW9zT3BlcmF0aW9uKHtvcGVyYXRpb246IG9wZXJhdGlvbn0pO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKG9wZXJhdGlvbi5yZXNwb25zZT8uZ2VuZXJhdGVkVmlkZW9zPy5bMF0/LnZpZGVvPy51cmkpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVWaWRlb3MgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgIGlmICgocGFyYW1zLnByb21wdCB8fCBwYXJhbXMuaW1hZ2UgfHwgcGFyYW1zLnZpZGVvKSAmJiBwYXJhbXMuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgYW5kIHByb21wdC9pbWFnZS92aWRlbyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLiBQbGVhc2Ugb25seSB1c2Ugc291cmNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2VtaW5pIEFQSSBkb2VzIG5vdCBzdXBwb3J0IHZpZGVvIGJ5dGVzLlxuICAgICAgICAgICAgaWYgKCF0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHBhcmFtcy52aWRlbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVyaSkgJiYgKChfYiA9IHBhcmFtcy52aWRlbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnZpZGVvQnl0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy52aWRlbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVyaTogcGFyYW1zLnZpZGVvLnVyaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJhbXMudmlkZW8ubWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCgoX2QgPSAoX2MgPSBwYXJhbXMuc291cmNlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudmlkZW8pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC51cmkpICYmXG4gICAgICAgICAgICAgICAgICAgICgoX2YgPSAoX2UgPSBwYXJhbXMuc291cmNlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UudmlkZW8pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi52aWRlb0J5dGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuc291cmNlLnZpZGVvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJpOiBwYXJhbXMuc291cmNlLnZpZGVvLnVyaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJhbXMuc291cmNlLnZpZGVvLm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdlbmVyYXRlVmlkZW9zSW50ZXJuYWwocGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBsb2dpYyBpcyBuZWVkZWQgZm9yIEdlbmVyYXRlQ29udGVudENvbmZpZyBvbmx5LlxuICAgICAqIFByZXZpb3VzbHkgd2UgbWFkZSBHZW5lcmF0ZUNvbnRlbnRDb25maWcucmVzcG9uc2VTY2hlbWEgZmllbGQgdG8gYWNjZXB0XG4gICAgICogdW5rbm93bi4gU2luY2UgdjEuOS4wLCB3ZSBzd2l0Y2ggdG8gdXNlIGJhY2tlbmQgSlNPTiBzY2hlbWEgc3VwcG9ydC5cbiAgICAgKiBUbyBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB3ZSBtb3ZlIHRoZSBkYXRhIHRoYXQgd2FzIHRyZWF0ZWQgYXNcbiAgICAgKiBKU09OIHNjaGVtYSBmcm9tIHRoZSByZXNwb25zZVNjaGVtYSBmaWVsZCB0byB0aGUgcmVzcG9uc2VKc29uU2NoZW1hIGZpZWxkLlxuICAgICAqL1xuICAgIG1heWJlTW92ZVRvUmVzcG9uc2VKc29uU2NoZW0ocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuY29uZmlnICYmIHBhcmFtcy5jb25maWcucmVzcG9uc2VTY2hlbWEpIHtcbiAgICAgICAgICAgIGlmICghcGFyYW1zLmNvbmZpZy5yZXNwb25zZUpzb25TY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMocGFyYW1zLmNvbmZpZy5yZXNwb25zZVNjaGVtYSkuaW5jbHVkZXMoJyRzY2hlbWEnKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY29uZmlnLnJlc3BvbnNlSnNvblNjaGVtYSA9IHBhcmFtcy5jb25maWcucmVzcG9uc2VTY2hlbWE7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMuY29uZmlnLnJlc3BvbnNlU2NoZW1hO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIENhbGxhYmxlVG9vbHMgaW4gdGhlIHBhcmFtZXRlcnMgdG8gYmUgc2ltcGx5IFRvb2xzLCBpdFxuICAgICAqIGNvcGllcyB0aGUgcGFyYW1zIGludG8gYSBuZXcgb2JqZWN0IGFuZCByZXBsYWNlcyB0aGUgdG9vbHMsIGl0IGRvZXMgbm90XG4gICAgICogbW9kaWZ5IHRoZSBvcmlnaW5hbCBwYXJhbXMuIEFsc28gc2V0cyB0aGUgTUNQIHVzYWdlIGhlYWRlciBpZiB0aGVyZSBhcmVcbiAgICAgKiBNQ1AgdG9vbHMgaW4gdGhlIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgYXN5bmMgcHJvY2Vzc1BhcmFtc01heWJlQWRkTWNwVXNhZ2UocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCB0b29scyA9IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29scztcbiAgICAgICAgaWYgKCF0b29scykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFRvb2xzID0gYXdhaXQgUHJvbWlzZS5hbGwodG9vbHMubWFwKGFzeW5jICh0b29sKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYWJsZVRvb2wgPSB0b29sO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBjYWxsYWJsZVRvb2wudG9vbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvb2w7XG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0ge1xuICAgICAgICAgICAgbW9kZWw6IHBhcmFtcy5tb2RlbCxcbiAgICAgICAgICAgIGNvbnRlbnRzOiBwYXJhbXMuY29udGVudHMsXG4gICAgICAgICAgICBjb25maWc6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLmNvbmZpZyksIHsgdG9vbHM6IHRyYW5zZm9ybWVkVG9vbHMgfSksXG4gICAgICAgIH07XG4gICAgICAgIG5ld1BhcmFtcy5jb25maWcudG9vbHMgPSB0cmFuc2Zvcm1lZFRvb2xzO1xuICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyAmJlxuICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy50b29scyAmJlxuICAgICAgICAgICAgaGFzTWNwVG9vbFVzYWdlKHBhcmFtcy5jb25maWcudG9vbHMpKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gKF9jID0gKF9iID0gcGFyYW1zLmNvbmZpZy5odHRwT3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlYWRlcnMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9O1xuICAgICAgICAgICAgbGV0IG5ld0hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBoZWFkZXJzKTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdIZWFkZXJzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBuZXdIZWFkZXJzID0gdGhpcy5hcGlDbGllbnQuZ2V0RGVmYXVsdEhlYWRlcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1jcFVzYWdlSGVhZGVyKG5ld0hlYWRlcnMpO1xuICAgICAgICAgICAgbmV3UGFyYW1zLmNvbmZpZy5odHRwT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLmNvbmZpZy5odHRwT3B0aW9ucyksIHsgaGVhZGVyczogbmV3SGVhZGVycyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UGFyYW1zO1xuICAgIH1cbiAgICBhc3luYyBpbml0QWZjVG9vbHNNYXAocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBhZmNUb29scyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIChfYiA9IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29scykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pIHtcbiAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxhYmxlVG9vbCA9IHRvb2w7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vbERlY2xhcmF0aW9uID0gYXdhaXQgY2FsbGFibGVUb29sLnRvb2woKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY2xhcmF0aW9uIG9mIChfYyA9IHRvb2xEZWNsYXJhdGlvbi5mdW5jdGlvbkRlY2xhcmF0aW9ucykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWNsYXJhdGlvbi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGRlY2xhcmF0aW9uIG5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFmY1Rvb2xzLmhhcyhkZWNsYXJhdGlvbi5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgdG9vbCBkZWNsYXJhdGlvbiBuYW1lOiAke2RlY2xhcmF0aW9uLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWZjVG9vbHMuc2V0KGRlY2xhcmF0aW9uLm5hbWUsIGNhbGxhYmxlVG9vbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZmNUb29scztcbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc0FmY1N0cmVhbShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1heFJlbW90ZUNhbGxzID0gKF9jID0gKF9iID0gKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1heGltdW1SZW1vdGVDYWxscykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogREVGQVVMVF9NQVhfUkVNT1RFX0NBTExTO1xuICAgICAgICBsZXQgd2VyZUZ1bmN0aW9uc0NhbGxlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVtb3RlQ2FsbENvdW50ID0gMDtcbiAgICAgICAgY29uc3QgYWZjVG9vbHNNYXAgPSBhd2FpdCB0aGlzLmluaXRBZmNUb29sc01hcChwYXJhbXMpO1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChtb2RlbHMsIGFmY1Rvb2xzLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIHZhciBfZCwgX2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlbW90ZUNhbGxDb3VudCA8IG1heFJlbW90ZUNhbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3ZXJlRnVuY3Rpb25zQ2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVDYWxsQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlcmVGdW5jdGlvbnNDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IHlpZWxkIF9fYXdhaXQobW9kZWxzLnByb2Nlc3NQYXJhbXNNYXliZUFkZE1jcFVzYWdlKHBhcmFtcykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIF9fYXdhaXQobW9kZWxzLmdlbmVyYXRlQ29udGVudFN0cmVhbUludGVybmFsKHRyYW5zZm9ybWVkUGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUmVzcG9uc2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9mID0gdHJ1ZSwgcmVzcG9uc2VfMSA9IChlXzEgPSB2b2lkIDAsIF9fYXN5bmNWYWx1ZXMocmVzcG9uc2UpKSwgcmVzcG9uc2VfMV8xOyByZXNwb25zZV8xXzEgPSB5aWVsZCBfX2F3YWl0KHJlc3BvbnNlXzEubmV4dCgpKSwgX2EgPSByZXNwb25zZV8xXzEuZG9uZSwgIV9hOyBfZiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyA9IHJlc3BvbnNlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLmNhbmRpZGF0ZXMgJiYgKChfZCA9IGNodW5rLmNhbmRpZGF0ZXNbMF0pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jb250ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUNvbnRlbnRzLnB1c2goY2h1bmsuY2FuZGlkYXRlc1swXS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIChfZSA9IGNodW5rLmNhbmRpZGF0ZXNbMF0uY29udGVudC5wYXJ0cykgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogW10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdGVDYWxsQ291bnQgPCBtYXhSZW1vdGVDYWxscyAmJiBwYXJ0LmZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFydC5mdW5jdGlvbkNhbGwubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGNhbGwgbmFtZSB3YXMgbm90IHJldHVybmVkIGJ5IHRoZSBtb2RlbC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhZmNUb29scy5oYXMocGFydC5mdW5jdGlvbkNhbGwubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZyB3YXMgcmVxdWVzdGVkLCBidXQgbm90IGFsbCB0aGUgdG9vbHMgdGhlIG1vZGVsIHVzZWQgaW1wbGVtZW50IHRoZSBDYWxsYWJsZVRvb2wgaW50ZXJmYWNlLiBBdmFpbGFibGUgdG9vbHM6ICR7YWZjVG9vbHMua2V5cygpfSwgbWlzaW5nIHRvb2w6ICR7cGFydC5mdW5jdGlvbkNhbGwubmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUGFydHMgPSB5aWVsZCBfX2F3YWl0KGFmY1Rvb2xzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0KHBhcnQuZnVuY3Rpb25DYWxsLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2FsbFRvb2woW3BhcnQuZnVuY3Rpb25DYWxsXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlcy5wdXNoKC4uLnJlc3BvbnNlUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZiAmJiAhX2EgJiYgKF9iID0gcmVzcG9uc2VfMS5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwocmVzcG9uc2VfMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvblJlc3BvbnNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZXJlRnVuY3Rpb25zQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcG9uc2VDaHVuayA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWRSZXNwb25zZUNodW5rLmNhbmRpZGF0ZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czogZnVuY3Rpb25SZXNwb25zZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHR5cGVkUmVzcG9uc2VDaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdDb250ZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udGVudHMucHVzaCguLi5yZXNwb25zZUNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czogZnVuY3Rpb25SZXNwb25zZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRDb250ZW50cyA9IHRDb250ZW50cyhwYXJhbXMuY29udGVudHMpLmNvbmNhdChuZXdDb250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY29udGVudHMgPSB1cGRhdGVkQ29udGVudHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSh0aGlzLCBhZmNUb29sc01hcCwgcGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2VuZXJhdGVDb250ZW50SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Z2VuZXJhdGVDb250ZW50JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpnZW5lcmF0ZUNvbnRlbnQnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZUNvbnRlbnRTdHJlYW1JbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpzdHJlYW1HZW5lcmF0ZUNvbnRlbnQ/YWx0PXNzZScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGNvbnN0IGFwaUNsaWVudCA9IHRoaXMuYXBpQ2xpZW50O1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhcGlDbGllbnQucmVxdWVzdFN0cmVhbSh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oZnVuY3Rpb24gKGFwaVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIGVfMiwgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBhcGlSZXNwb25zZV8xID0gX19hc3luY1ZhbHVlcyhhcGlSZXNwb25zZSksIGFwaVJlc3BvbnNlXzFfMTsgYXBpUmVzcG9uc2VfMV8xID0geWllbGQgX19hd2FpdChhcGlSZXNwb25zZV8xLm5leHQoKSksIF9hID0gYXBpUmVzcG9uc2VfMV8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBhcGlSZXNwb25zZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoKHlpZWxkIF9fYXdhaXQoY2h1bmsuanNvbigpKSksIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcFsnc2RrSHR0cFJlc3BvbnNlJ10gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGNodW5rLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh0eXBlZFJlc3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBhcGlSZXNwb25zZV8xLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChhcGlSZXNwb25zZV8xKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpzdHJlYW1HZW5lcmF0ZUNvbnRlbnQ/YWx0PXNzZScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGNvbnN0IGFwaUNsaWVudCA9IHRoaXMuYXBpQ2xpZW50O1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhcGlDbGllbnQucmVxdWVzdFN0cmVhbSh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oZnVuY3Rpb24gKGFwaVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIGVfMywgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBhcGlSZXNwb25zZV8yID0gX19hc3luY1ZhbHVlcyhhcGlSZXNwb25zZSksIGFwaVJlc3BvbnNlXzJfMTsgYXBpUmVzcG9uc2VfMl8xID0geWllbGQgX19hd2FpdChhcGlSZXNwb25zZV8yLm5leHQoKSksIF9hID0gYXBpUmVzcG9uc2VfMl8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBhcGlSZXNwb25zZV8yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldigoeWllbGQgX19hd2FpdChjaHVuay5qc29uKCkpKSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwWydzZGtIdHRwUmVzcG9uc2UnXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogY2h1bmsuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHR5cGVkUmVzcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGFwaVJlc3BvbnNlXzIucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGFwaVJlc3BvbnNlXzIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBlbWJlZGRpbmdzIGZvciB0aGUgZ2l2ZW4gY29udGVudHMuIE9ubHkgdGV4dCBpcyBzdXBwb3J0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGVtYmVkZGluZyBjb250ZW50cy5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZW1iZWRDb250ZW50KHtcbiAgICAgKiAgbW9kZWw6ICd0ZXh0LWVtYmVkZGluZy0wMDQnLFxuICAgICAqICBjb250ZW50czogW1xuICAgICAqICAgICdXaGF0IGlzIHlvdXIgbmFtZT8nLFxuICAgICAqICAgICdXaGF0IGlzIHlvdXIgZmF2b3JpdGUgY29sb3I/JyxcbiAgICAgKiAgXSxcbiAgICAgKiAgY29uZmlnOiB7XG4gICAgICogICAgb3V0cHV0RGltZW5zaW9uYWxpdHk6IDY0LFxuICAgICAqICB9LFxuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBlbWJlZENvbnRlbnQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGVtYmVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGVtYmVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEVtYmVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06YmF0Y2hFbWJlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBFbWJlZENvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgZm9yIGdlbmVyYXRpbmcgaW1hZ2VzLlxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlSW1hZ2VzSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUltYWdlc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUltYWdlc1BhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlSW1hZ2VzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgbWV0aG9kIGZvciBlZGl0aW5nIGFuIGltYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIGVkaXRJbWFnZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZWRpdEltYWdlUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBlZGl0SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBFZGl0SW1hZ2VSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgZm9yIHVwc2NhbGluZyBhbiBpbWFnZS5cbiAgICAgKi9cbiAgICBhc3luYyB1cHNjYWxlSW1hZ2VJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHVwc2NhbGVJbWFnZUFQSVBhcmFtZXRlcnNJbnRlcm5hbFRvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdXBzY2FsZUltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgVXBzY2FsZUltYWdlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29udGV4dHVhbGl6ZXMgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdHdvIHR5cGVzIG9mIHJlY29udGV4dHVhbGl6YXRpb24gY3VycmVudGx5IHN1cHBvcnRlZDpcbiAgICAgKiAxKSBJbWFnZW4gUHJvZHVjdCBSZWNvbnRleHQgLSBHZW5lcmF0ZSBpbWFnZXMgb2YgcHJvZHVjdHMgaW4gbmV3IHNjZW5lc1xuICAgICAqICAgIGFuZCBjb250ZXh0cy5cbiAgICAgKiAyKSBWaXJ0dWFsIFRyeS1PbjogR2VuZXJhdGUgaW1hZ2VzIG9mIHBlcnNvbnMgbW9kZWxpbmcgZmFzaGlvbiBwcm9kdWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgcmVjb250ZXh0dWFsaXppbmcgYW4gaW1hZ2UuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlMSA9IGF3YWl0IGFpLm1vZGVscy5yZWNvbnRleHRJbWFnZSh7XG4gICAgICogIG1vZGVsOiAnaW1hZ2VuLXByb2R1Y3QtcmVjb250ZXh0LXByZXZpZXctMDYtMzAnLFxuICAgICAqICBzb3VyY2U6IHtcbiAgICAgKiAgICBwcm9tcHQ6ICdJbiBhIG1vZGVybiBraXRjaGVuIHNldHRpbmcuJyxcbiAgICAgKiAgICBwcm9kdWN0SW1hZ2VzOiBbcHJvZHVjdEltYWdlXSxcbiAgICAgKiAgfSxcbiAgICAgKiAgY29uZmlnOiB7XG4gICAgICogICAgbnVtYmVyT2ZJbWFnZXM6IDEsXG4gICAgICogIH0sXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UxPy5nZW5lcmF0ZWRJbWFnZXM/LlswXT8uaW1hZ2U/LmltYWdlQnl0ZXMpO1xuICAgICAqXG4gICAgICogY29uc3QgcmVzcG9uc2UyID0gYXdhaXQgYWkubW9kZWxzLnJlY29udGV4dEltYWdlKHtcbiAgICAgKiAgbW9kZWw6ICd2aXJ0dWFsLXRyeS1vbi0wMDEnLFxuICAgICAqICBzb3VyY2U6IHtcbiAgICAgKiAgICBwZXJzb25JbWFnZTogcGVyc29uSW1hZ2UsXG4gICAgICogICAgcHJvZHVjdEltYWdlczogW3Byb2R1Y3RJbWFnZV0sXG4gICAgICogIH0sXG4gICAgICogIGNvbmZpZzoge1xuICAgICAqICAgIG51bWJlck9mSW1hZ2VzOiAxLFxuICAgICAqICB9LFxuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlMj8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyByZWNvbnRleHRJbWFnZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHJlY29udGV4dEltYWdlUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSByZWNvbnRleHRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IFJlY29udGV4dEltYWdlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlZ21lbnRzIGFuIGltYWdlLCBjcmVhdGluZyBhIG1hc2sgb2YgYSBzcGVjaWZpZWQgYXJlYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3Igc2VnbWVudGluZyBhbiBpbWFnZS5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuc2VnbWVudEltYWdlKHtcbiAgICAgKiAgbW9kZWw6ICdpbWFnZS1zZWdtZW50YXRpb24tMDAxJyxcbiAgICAgKiAgc291cmNlOiB7XG4gICAgICogICAgaW1hZ2U6IGltYWdlLFxuICAgICAqICB9LFxuICAgICAqICBjb25maWc6IHtcbiAgICAgKiAgICBtb2RlOiAnZm9yZWdyb3VuZCcsXG4gICAgICogIH0sXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2U/LmdlbmVyYXRlZE1hc2tzPy5bMF0/Lm1hc2s/LmltYWdlQnl0ZXMpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHNlZ21lbnRJbWFnZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHNlZ21lbnRJbWFnZVBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gc2VnbWVudEltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgU2VnbWVudEltYWdlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgaW5mb3JtYXRpb24gYWJvdXQgYSBtb2RlbCBieSBuYW1lLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IG1vZGVsSW5mbyA9IGF3YWl0IGFpLm1vZGVscy5nZXQoe21vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCd9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldE1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IG1vZGVsRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRNb2RlbFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IG1vZGVsRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdE1vZGVsc1BhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbHNfdXJsfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdE1vZGVsc1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RNb2RlbHNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdE1vZGVsc1BhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsc191cmx9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0TW9kZWxzUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0TW9kZWxzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSB0dW5lZCBtb2RlbCBieSBpdHMgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdXBkYXRpbmcgdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy51cGRhdGUoe1xuICAgICAqICAgbW9kZWw6ICd0dW5lZC1tb2RlbC1uYW1lJyxcbiAgICAgKiAgIGNvbmZpZzoge1xuICAgICAqICAgICBkaXNwbGF5TmFtZTogJ05ldyBkaXNwbGF5IG5hbWUnLFxuICAgICAqICAgICBkZXNjcmlwdGlvbjogJ05ldyBkZXNjcmlwdGlvbicsXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbW9kZWxGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHVwZGF0ZU1vZGVsUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBtb2RlbEZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgdHVuZWQgbW9kZWwgYnkgaXRzIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGRlbGV0aW5nIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZGVsZXRlKHttb2RlbDogJ3R1bmVkLW1vZGVsLW5hbWUnfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlTW9kZWxSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVNb2RlbFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVNb2RlbFJlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlTW9kZWxSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ291bnRzIHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBnaXZlbiBjb250ZW50cy4gTXVsdGltb2RhbCBpbnB1dCBpc1xuICAgICAqIHN1cHBvcnRlZCBmb3IgR2VtaW5pIG1vZGVscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY291bnRpbmcgdG9rZW5zLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5jb3VudFRva2Vucyh7XG4gICAgICogIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogIGNvbnRlbnRzOiAnVGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4nXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNvdW50VG9rZW5zKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjb3VudFRva2Vuc1BhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Y291bnRUb2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENvdW50VG9rZW5zUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNvdW50VG9rZW5zUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmNvdW50VG9rZW5zJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY291bnRUb2tlbnNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENvdW50VG9rZW5zUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgbGlzdCBvZiBjb250ZW50cywgcmV0dXJucyBhIGNvcnJlc3BvbmRpbmcgVG9rZW5zSW5mbyBjb250YWluaW5nXG4gICAgICogdGhlIGxpc3Qgb2YgdG9rZW5zIGFuZCBsaXN0IG9mIHRva2VuIGlkcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjb21wdXRpbmcgdG9rZW5zLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5jb21wdXRlVG9rZW5zKHtcbiAgICAgKiAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgY29udGVudHM6ICdXaGF0IGlzIHlvdXIgbmFtZT8nXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNvbXB1dGVUb2tlbnMocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjb21wdXRlVG9rZW5zUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpjb21wdXRlVG9rZW5zJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY29tcHV0ZVRva2Vuc1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENvbXB1dGVUb2tlbnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgZm9yIGdlbmVyYXRpbmcgdmlkZW9zLlxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlVmlkZW9zSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0TG9uZ1J1bm5pbmcnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZVZpZGVvc1BhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0TG9uZ1J1bm5pbmcnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVWaWRlb3NPcGVyYXRpb24oKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBPcGVyYXRpb25zIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0dXMgb2YgYSBsb25nLXJ1bm5pbmcgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgb3BlcmF0aW9uIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgdXBkYXRlZCBPcGVyYXRpb24gb2JqZWN0LCB3aXRoIHRoZSBsYXRlc3Qgc3RhdHVzIG9yIHJlc3VsdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRWaWRlb3NPcGVyYXRpb24ocGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBwYXJhbWV0ZXJzLm9wZXJhdGlvbjtcbiAgICAgICAgY29uc3QgY29uZmlnID0gcGFyYW1ldGVycy5jb25maWc7XG4gICAgICAgIGlmIChvcGVyYXRpb24ubmFtZSA9PT0gdW5kZWZpbmVkIHx8IG9wZXJhdGlvbi5uYW1lID09PSAnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpb24gbmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvdXJjZU5hbWUgPSBvcGVyYXRpb24ubmFtZS5zcGxpdCgnL29wZXJhdGlvbnMvJylbMF07XG4gICAgICAgICAgICBsZXQgaHR0cE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY29uZmlnICYmICdodHRwT3B0aW9ucycgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnMgPSBjb25maWcuaHR0cE9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByYXdPcGVyYXRpb24gPSBhd2FpdCB0aGlzLmZldGNoUHJlZGljdFZpZGVvc09wZXJhdGlvbkludGVybmFsKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb24ubmFtZSxcbiAgICAgICAgICAgICAgICByZXNvdXJjZU5hbWU6IHJlc291cmNlTmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWc6IHsgaHR0cE9wdGlvbnM6IGh0dHBPcHRpb25zIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24uX2Zyb21BUElSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgYXBpUmVzcG9uc2U6IHJhd09wZXJhdGlvbixcbiAgICAgICAgICAgICAgICBfaXNWZXJ0ZXhBSTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmF3T3BlcmF0aW9uID0gYXdhaXQgdGhpcy5nZXRWaWRlb3NPcGVyYXRpb25JbnRlcm5hbCh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24uX2Zyb21BUElSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgYXBpUmVzcG9uc2U6IHJhd09wZXJhdGlvbixcbiAgICAgICAgICAgICAgICBfaXNWZXJ0ZXhBSTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0dXMgb2YgYSBsb25nLXJ1bm5pbmcgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgb3BlcmF0aW9uIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgdXBkYXRlZCBPcGVyYXRpb24gb2JqZWN0LCB3aXRoIHRoZSBsYXRlc3Qgc3RhdHVzIG9yIHJlc3VsdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBwYXJhbWV0ZXJzLm9wZXJhdGlvbjtcbiAgICAgICAgY29uc3QgY29uZmlnID0gcGFyYW1ldGVycy5jb25maWc7XG4gICAgICAgIGlmIChvcGVyYXRpb24ubmFtZSA9PT0gdW5kZWZpbmVkIHx8IG9wZXJhdGlvbi5uYW1lID09PSAnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpb24gbmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvdXJjZU5hbWUgPSBvcGVyYXRpb24ubmFtZS5zcGxpdCgnL29wZXJhdGlvbnMvJylbMF07XG4gICAgICAgICAgICBsZXQgaHR0cE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY29uZmlnICYmICdodHRwT3B0aW9ucycgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnMgPSBjb25maWcuaHR0cE9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByYXdPcGVyYXRpb24gPSBhd2FpdCB0aGlzLmZldGNoUHJlZGljdFZpZGVvc09wZXJhdGlvbkludGVybmFsKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb24ubmFtZSxcbiAgICAgICAgICAgICAgICByZXNvdXJjZU5hbWU6IHJlc291cmNlTmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWc6IHsgaHR0cE9wdGlvbnM6IGh0dHBPcHRpb25zIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24uX2Zyb21BUElSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgYXBpUmVzcG9uc2U6IHJhd09wZXJhdGlvbixcbiAgICAgICAgICAgICAgICBfaXNWZXJ0ZXhBSTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmF3T3BlcmF0aW9uID0gYXdhaXQgdGhpcy5nZXRWaWRlb3NPcGVyYXRpb25JbnRlcm5hbCh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24uX2Zyb21BUElSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgYXBpUmVzcG9uc2U6IHJhd09wZXJhdGlvbixcbiAgICAgICAgICAgICAgICBfaXNWZXJ0ZXhBSTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRWaWRlb3NPcGVyYXRpb25JbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0T3BlcmF0aW9uUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7b3BlcmF0aW9uTmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0T3BlcmF0aW9uUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tvcGVyYXRpb25OYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmZXRjaFByZWRpY3RWaWRlb3NPcGVyYXRpb25JbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGZldGNoUHJlZGljdE9wZXJhdGlvblBhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne3Jlc291cmNlTmFtZX06ZmV0Y2hQcmVkaWN0T3BlcmF0aW9uJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gYmxvYlRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUF1dGhUb2tlbkNvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBpcmVUaW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5ld1Nlc3Npb25FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV3U2Vzc2lvbkV4cGlyZVRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmV3U2Vzc2lvbkV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbmV3U2Vzc2lvbkV4cGlyZVRpbWUnXSwgZnJvbU5ld1Nlc3Npb25FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VzZXMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Vc2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3VzZXMnXSwgZnJvbVVzZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGl2ZUNvbm5lY3RDb25zdHJhaW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xpdmVDb25uZWN0Q29uc3RyYWludHMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGl2ZUNvbm5lY3RDb25zdHJhaW50cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAnXSwgbGl2ZUNvbm5lY3RDb25zdHJhaW50c1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tTGl2ZUNvbm5lY3RDb25zdHJhaW50cykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ja0FkZGl0aW9uYWxGaWVsZHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsb2NrQWRkaXRpb25hbEZpZWxkcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Mb2NrQWRkaXRpb25hbEZpZWxkcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydmaWVsZE1hc2snXSwgZnJvbUxvY2tBZGRpdGlvbmFsRmllbGRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQXV0aFRva2VuUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgY3JlYXRlQXV0aFRva2VuQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZCddKTtcbiAgICBpZiAoZnJvbUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWQnXSwgZnJvbUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFyZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FyZ3MnXSk7XG4gICAgaWYgKGZyb21BcmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXJncyddLCBmcm9tQXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0aWFsQXJncyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFydGlhbEFyZ3MgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnd2lsbENvbnRpbnVlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3aWxsQ29udGludWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlTWFwc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0aENvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXV0aENvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlV2lkZ2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmFibGVXaWRnZXQnXSk7XG4gICAgaWYgKGZyb21FbmFibGVXaWRnZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmFibGVXaWRnZXQnXSwgZnJvbUVuYWJsZVdpZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4Y2x1ZGVEb21haW5zIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jsb2NraW5nQ29uZmlkZW5jZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmxvY2tpbmdDb25maWRlbmNlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGZyb21UaW1lUmFuZ2VGaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJ10sIGZyb21HZW5lcmF0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc3BlZWNoQ29uZmlnJ10sIHRMaXZlU3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0aGlua2luZ0NvbmZpZyddLCBmcm9tVGhpbmtpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZyddLCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvTWxkZXYodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdFRvb2xzKGZyb21Ub29scyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvTWxkZXYodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlc3Npb25SZXN1bXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Nlc3Npb25SZXN1bXB0aW9uJ10sIHNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldihmcm9tU2Vzc2lvblJlc3VtcHRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24nXSwgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlYWx0aW1lSW5wdXRDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdyZWFsdGltZUlucHV0Q29uZmlnJ10sIGZyb21SZWFsdGltZUlucHV0Q29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJ10sIGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvYWN0aXZpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb2FjdGl2aXR5J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvYWN0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncHJvYWN0aXZpdHknXSwgZnJvbVByb2FjdGl2aXR5KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwbGljaXRWYWRTaWduYWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGxpY2l0VmFkU2lnbmFsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0Q29uc3RyYWludHNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXAnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFUb01sZGV2KGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnVuY3Rpb25DYWxsVG9NbGRldihmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgZnJvbVZpZGVvTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUhhbmRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaGFuZGxlJ10pO1xuICAgIGlmIChmcm9tSGFuZGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaGFuZGxlJ10sIGZyb21IYW5kbGUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0cmFuc3BhcmVudCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNwYXJlbnQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXRyaWV2YWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgZnJvbUNvbXB1dGVyVXNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21GaWxlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVNlYXJjaCddLCBmcm9tRmlsZVNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VudGVycHJpc2VXZWJTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGdvb2dsZU1hcHNUb01sZGV2KGZyb21Hb29nbGVNYXBzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb01sZGV2KGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGZpZWxkIG1hc2tzIGZyb20gYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHNldHVwIFRoZSBvYmplY3QgdG8gZXh0cmFjdCBmaWVsZCBtYXNrcyBmcm9tLlxuICogQHJldHVybiBBIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGZpZWxkIG1hc2tzLlxuICovXG5mdW5jdGlvbiBnZXRGaWVsZE1hc2tzKHNldHVwKSB7XG4gICAgY29uc3QgZmllbGRzID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2V0dXApIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR1cCwga2V5KSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzZXR1cFtrZXldO1xuICAgICAgICAgICAgLy8gMm5kIGxheWVyLCByZWN1cnNpdmVseSBnZXQgZmllbGQgbWFza3Mgc2VlIFRPRE8oYi80MTgyOTAxMDApXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gT2JqZWN0LmtleXModmFsdWUpLm1hcCgoa2spID0+IGAke2tleX0uJHtra31gKTtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaCguLi5maWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChrZXkpOyAvLyAxc3QgbGF5ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmllbGRzLmpvaW4oJywnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwLlxuICogQHBhcmFtIHJlcXVlc3REaWN0IC0gVGhlIHJlcXVlc3QgZGljdGlvbmFyeS5cbiAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJuIC0gVGhlIG1vZGlmaWVkIHJlcXVlc3QgZGljdGlvbmFyeS5cbiAqL1xuZnVuY3Rpb24gY29udmVydEJpZGlTZXR1cFRvVG9rZW5TZXR1cChyZXF1ZXN0RGljdCwgY29uZmlnKSB7XG4gICAgLy8gQ29udmVydCBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAgZnJvbSBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAuc2V0dXAuXG4gICAgbGV0IHNldHVwRm9yTWFza0dlbmVyYXRpb24gPSBudWxsO1xuICAgIGNvbnN0IGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlID0gcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddO1xuICAgIGlmICh0eXBlb2YgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICdzZXR1cCcgaW4gYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUpIHtcbiAgICAgICAgLy8gTm93IHdlIGtub3cgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUgaXMgYW4gb2JqZWN0IGFuZCBoYXMgYSAnc2V0dXAnXG4gICAgICAgIC8vIHByb3BlcnR5LlxuICAgICAgICBjb25zdCBpbm5lclNldHVwID0gYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWVcbiAgICAgICAgICAgIC5zZXR1cDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbm5lclNldHVwID09PSAnb2JqZWN0JyAmJiBpbm5lclNldHVwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBWYWxpZCBpbm5lciBzZXR1cCBmb3VuZC5cbiAgICAgICAgICAgIHJlcXVlc3REaWN0WydiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAnXSA9IGlubmVyU2V0dXA7XG4gICAgICAgICAgICBzZXR1cEZvck1hc2tHZW5lcmF0aW9uID0gaW5uZXJTZXR1cDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZS5zZXR1cGAgaXMgbm90IGEgdmFsaWQgb2JqZWN0OyB0cmVhdCBhc1xuICAgICAgICAgICAgLy8gaWYgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwIGlzIGludmFsaWQuXG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gYGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cGAgZXhpc3RzIGJ1dCBub3QgaW4gdGhlIGV4cGVjdGVkXG4gICAgICAgIC8vIHNoYXBlIHtzZXR1cDogey4uLn19OyB0cmVhdCBhcyBpbnZhbGlkLlxuICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddO1xuICAgIH1cbiAgICBjb25zdCBwcmVFeGlzdGluZ0ZpZWxkTWFzayA9IHJlcXVlc3REaWN0WydmaWVsZE1hc2snXTtcbiAgICAvLyBIYW5kbGUgbWFzayBnZW5lcmF0aW9uIHNldHVwLlxuICAgIGlmIChzZXR1cEZvck1hc2tHZW5lcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZE1hc2tGcm9tQmlkaSA9IGdldEZpZWxkTWFza3Moc2V0dXBGb3JNYXNrR2VuZXJhdGlvbik7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5sb2NrQWRkaXRpb25hbEZpZWxkcykgJiZcbiAgICAgICAgICAgIChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHMubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQ2FzZSAxOiBsb2NrQWRkaXRpb25hbEZpZWxkcyBpcyBhbiBlbXB0eSBhcnJheS4gTG9jayBvbmx5IGZpZWxkcyBmcm9tXG4gICAgICAgICAgICAvLyBiaWRpIHNldHVwLlxuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZE1hc2tGcm9tQmlkaSkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYXNzaWduIGlmIG1hc2sgaXMgbm90IGVtcHR5XG4gICAgICAgICAgICAgICAgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddID0gZ2VuZXJhdGVkTWFza0Zyb21CaWRpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXTsgLy8gSWYgbWFzayBpcyBlbXB0eSwgZWZmZWN0aXZlbHkgbm9cbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBmaWVsZHMgbG9ja2VkIGJ5IGJpZGlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzKSAmJlxuICAgICAgICAgICAgY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHByZUV4aXN0aW5nRmllbGRNYXNrICE9PSBudWxsICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHByZUV4aXN0aW5nRmllbGRNYXNrKSAmJlxuICAgICAgICAgICAgcHJlRXhpc3RpbmdGaWVsZE1hc2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gQ2FzZSAyOiBMb2NrIGZpZWxkcyBmcm9tIGJpZGkgc2V0dXAgKyBhZGRpdGlvbmFsIGZpZWxkc1xuICAgICAgICAgICAgLy8gKHByZUV4aXN0aW5nRmllbGRNYXNrKS5cbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRpb25Db25maWdGaWVsZHMgPSBbXG4gICAgICAgICAgICAgICAgJ3RlbXBlcmF0dXJlJyxcbiAgICAgICAgICAgICAgICAndG9wSycsXG4gICAgICAgICAgICAgICAgJ3RvcFAnLFxuICAgICAgICAgICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgICAgICAgICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgICAgICAgICAgICAgICdzZWVkJyxcbiAgICAgICAgICAgICAgICAnc3BlZWNoQ29uZmlnJyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBsZXQgbWFwcGVkRmllbGRzRnJvbVByZUV4aXN0aW5nID0gW107XG4gICAgICAgICAgICBpZiAocHJlRXhpc3RpbmdGaWVsZE1hc2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG1hcHBlZEZpZWxkc0Zyb21QcmVFeGlzdGluZyA9IHByZUV4aXN0aW5nRmllbGRNYXNrLm1hcCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRpb25Db25maWdGaWVsZHMuaW5jbHVkZXMoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYGdlbmVyYXRpb25Db25maWcuJHtmaWVsZH1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZDsgLy8gS2VlcCBvcmlnaW5hbCBmaWVsZCBuYW1lIGlmIG5vdCBpblxuICAgICAgICAgICAgICAgICAgICAvLyBnZW5lcmF0aW9uQ29uZmlnRmllbGRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hc2tQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZE1hc2tGcm9tQmlkaSkge1xuICAgICAgICAgICAgICAgIGZpbmFsTWFza1BhcnRzLnB1c2goZ2VuZXJhdGVkTWFza0Zyb21CaWRpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXBwZWRGaWVsZHNGcm9tUHJlRXhpc3RpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpbmFsTWFza1BhcnRzLnB1c2goLi4ubWFwcGVkRmllbGRzRnJvbVByZUV4aXN0aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaW5hbE1hc2tQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddID0gZmluYWxNYXNrUGFydHMuam9pbignLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gZmllbGRzIGZyb20gYmlkaSBhbmQgbm8gdmFsaWQgYWRkaXRpb25hbCBmaWVsZHMgZnJvbVxuICAgICAgICAgICAgICAgIC8vIHByZS1leGlzdGluZyBtYXNrLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXNlIDM6IFwiTG9jayBhbGwgZmllbGRzXCIgKG1lYW5pbmcsIGRvbid0IHNlbmQgYSBmaWVsZF9tYXNrLCBsZXQgc2VydmVyXG4gICAgICAgICAgICAvLyBkZWZhdWx0cyBhcHBseSBvciBhbGwgYXJlIG11dGFibGUpLiBUaGlzIGlzIGhpdCBpZjpcbiAgICAgICAgICAgIC8vICAtIGBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHNgIGlzIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIC8vICAtIGBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHNgIGlzIG5vbi1lbXB0eSwgQlVUXG4gICAgICAgICAgICAvLyAgYHByZUV4aXN0aW5nRmllbGRNYXNrYCBpcyBudWxsLCBub3QgYSBzdHJpbmcsIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE5vIHZhbGlkIGBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBgIHdhcyBmb3VuZCBvciBleHRyYWN0ZWQuXG4gICAgICAgIC8vIFwiTG9jayBhZGRpdGlvbmFsIG51bGwgZmllbGRzIGlmIGFueVwiLlxuICAgICAgICBpZiAocHJlRXhpc3RpbmdGaWVsZE1hc2sgIT09IG51bGwgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocHJlRXhpc3RpbmdGaWVsZE1hc2spICYmXG4gICAgICAgICAgICBwcmVFeGlzdGluZ0ZpZWxkTWFzay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgcHJlLWV4aXN0aW5nIGZpZWxkIG1hc2ssIGl0J3MgYSBzdHJpbmcsIGFuZCBpdCdzIG5vdFxuICAgICAgICAgICAgLy8gZW1wdHksIHRoZW4gd2Ugc2hvdWxkIGxvY2sgYWxsIGZpZWxkcy5cbiAgICAgICAgICAgIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXSA9IHByZUV4aXN0aW5nRmllbGRNYXNrLmpvaW4oJywnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3REaWN0O1xufVxuY2xhc3MgVG9rZW5zIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVwaGVtZXJhbCBhdXRoIHRva2VuIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBFcGhlbWVyYWwgYXV0aCB0b2tlbnMgaXMgb25seSBzdXBwb3J0ZWQgaW4gdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLlxuICAgICAqIEl0IGNhbiBiZSB1c2VkIGZvciB0aGUgc2Vzc2lvbiBjb25uZWN0aW9uIHRvIHRoZSBMaXZlIGNvbnN0cmFpbmVkIEFQSS5cbiAgICAgKiBTdXBwb3J0IGluIHYxYWxwaGEgb25seS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGNyZWF0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgYXV0aCB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBhaSA9IG5ldyBHb29nbGVHZW5BSSh7XG4gICAgICogICAgIGFwaUtleTogdG9rZW4ubmFtZSxcbiAgICAgKiAgICAgaHR0cE9wdGlvbnM6IHsgYXBpVmVyc2lvbjogJ3YxYWxwaGEnIH0gIC8vIFN1cHBvcnQgaW4gdjFhbHBoYSBvbmx5LlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gQ2FzZSAxOiBJZiBMaXZlRXBoZW1lcmFsUGFyYW1ldGVycyBpcyB1bnNldCwgdW5sb2NrIExpdmVDb25uZWN0Q29uZmlnXG4gICAgICogLy8gd2hlbiB1c2luZyB0aGUgdG9rZW4gaW4gTGl2ZSBBUEkgc2Vzc2lvbnMuIEVhY2ggc2Vzc2lvbiBjb25uZWN0aW9uIGNhblxuICAgICAqIC8vIHVzZSBhIGRpZmZlcmVudCBjb25maWd1cmF0aW9uLlxuICAgICAqIGNvbnN0IGNvbmZpZzogQ3JlYXRlQXV0aFRva2VuQ29uZmlnID0ge1xuICAgICAqICAgICB1c2VzOiAzLFxuICAgICAqICAgICBleHBpcmVUaW1lOiAnMjAyNS0wNS0wMVQwMDowMDowMFonLFxuICAgICAqIH1cbiAgICAgKiBjb25zdCB0b2tlbiA9IGF3YWl0IGFpLnRva2Vucy5jcmVhdGUoY29uZmlnKTtcbiAgICAgKlxuICAgICAqIC8vIENhc2UgMjogSWYgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnMgaXMgc2V0LCBsb2NrIGFsbCBmaWVsZHMgaW5cbiAgICAgKiAvLyBMaXZlQ29ubmVjdENvbmZpZyB3aGVuIHVzaW5nIHRoZSB0b2tlbiBpbiBMaXZlIEFQSSBzZXNzaW9ucy4gRm9yXG4gICAgICogLy8gZXhhbXBsZSwgY2hhbmdpbmcgYG91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbmAgaW4gdGhlIExpdmUgQVBJXG4gICAgICogLy8gY29ubmVjdGlvbiB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIEFQSS5cbiAgICAgKiBjb25zdCBjb25maWc6IENyZWF0ZUF1dGhUb2tlbkNvbmZpZyA9XG4gICAgICogICAgIHVzZXM6IDMsXG4gICAgICogICAgIGV4cGlyZVRpbWU6ICcyMDI1LTA1LTAxVDAwOjAwOjAwWicsXG4gICAgICogICAgIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzOiB7XG4gICAgICogICAgICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaC0wMDEnLFxuICAgICAqICAgICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcyc6IFsnQVVESU8nXSxcbiAgICAgKiAgICAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ0Fsd2F5cyBhbnN3ZXIgaW4gRW5nbGlzaC4nLFxuICAgICAqICAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICpcbiAgICAgKiAvLyBDYXNlIDM6IElmIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzIGlzIHNldCBhbmQgbG9ja0FkZGl0aW9uYWxGaWVsZHMgaXNcbiAgICAgKiAvLyBzZXQsIGxvY2sgTGl2ZUNvbm5lY3RDb25maWcgd2l0aCBzZXQgYW5kIGFkZGl0aW9uYWwgZmllbGRzIChlLmcuXG4gICAgICogLy8gcmVzcG9uc2VNb2RhbGl0aWVzLCBzeXN0ZW1JbnN0cnVjdGlvbiwgdGVtcGVyYXR1cmUgaW4gdGhpcyBleGFtcGxlKSB3aGVuXG4gICAgICogLy8gdXNpbmcgdGhlIHRva2VuIGluIExpdmUgQVBJIHNlc3Npb25zLlxuICAgICAqIGNvbnN0IGNvbmZpZzogQ3JlYXRlQXV0aFRva2VuQ29uZmlnID1cbiAgICAgKiAgICAgdXNlczogMyxcbiAgICAgKiAgICAgZXhwaXJlVGltZTogJzIwMjUtMDUtMDFUMDA6MDA6MDBaJyxcbiAgICAgKiAgICAgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnM6IHtcbiAgICAgKiAgICAgICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoLTAwMScsXG4gICAgICogICAgICAgIGNvbmZpZzoge1xuICAgICAqICAgICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJzogWydBVURJTyddLFxuICAgICAqICAgICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nOiAnQWx3YXlzIGFuc3dlciBpbiBFbmdsaXNoLicsXG4gICAgICogICAgICAgIH1cbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgbG9ja0FkZGl0aW9uYWxGaWVsZHM6IFsndGVtcGVyYXR1cmUnXSxcbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICpcbiAgICAgKiAvLyBDYXNlIDQ6IElmIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzIGlzIHNldCBhbmQgbG9ja0FkZGl0aW9uYWxGaWVsZHMgaXNcbiAgICAgKiAvLyBlbXB0eSBhcnJheSwgbG9jayBMaXZlQ29ubmVjdENvbmZpZyB3aXRoIHNldCBmaWVsZHMgKGUuZy5cbiAgICAgKiAvLyByZXNwb25zZU1vZGFsaXRpZXMsIHN5c3RlbUluc3RydWN0aW9uIGluIHRoaXMgZXhhbXBsZSkgd2hlbiB1c2luZyB0aGVcbiAgICAgKiAvLyB0b2tlbiBpbiBMaXZlIEFQSSBzZXNzaW9ucy5cbiAgICAgKiBjb25zdCBjb25maWc6IENyZWF0ZUF1dGhUb2tlbkNvbmZpZyA9XG4gICAgICogICAgIHVzZXM6IDMsXG4gICAgICogICAgIGV4cGlyZVRpbWU6ICcyMDI1LTA1LTAxVDAwOjAwOjAwWicsXG4gICAgICogICAgIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzOiB7XG4gICAgICogICAgICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaC0wMDEnLFxuICAgICAqICAgICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcyc6IFsnQVVESU8nXSxcbiAgICAgKiAgICAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ0Fsd2F5cyBhbnN3ZXIgaW4gRW5nbGlzaC4nLFxuICAgICAqICAgICAgICB9XG4gICAgICogICAgIH0sXG4gICAgICogICAgIGxvY2tBZGRpdGlvbmFsRmllbGRzOiBbXSxcbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjbGllbnQudG9rZW5zLmNyZWF0ZSBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUF1dGhUb2tlblBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYXV0aF90b2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEJvZHkgPSBjb252ZXJ0QmlkaVNldHVwVG9Ub2tlblNldHVwKGJvZHksIHBhcmFtcy5jb25maWcpO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm1lZEJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgR29vZ2xlIEdlbiBBSSBTREsgZ2VuZXJhdG9yIERPIE5PVCBFRElULlxuZnVuY3Rpb24gZGVsZXRlRG9jdW1lbnRDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZvcmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JjZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZvcmNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmb3JjZSddLCBmcm9tRm9yY2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVEb2N1bWVudFBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZURvY3VtZW50Q29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50UGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdERvY3VtZW50c0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RG9jdW1lbnRzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcmVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyZW50J10pO1xuICAgIGlmIChmcm9tUGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdwYXJlbnQnXSwgZnJvbVBhcmVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3REb2N1bWVudHNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdERvY3VtZW50c1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9jdW1lbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb2N1bWVudHMnXSk7XG4gICAgaWYgKGZyb21Eb2N1bWVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbURvY3VtZW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9jdW1lbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgRG9jdW1lbnRzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdHMgZG9jdW1lbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBsaXN0IHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIHBhZ2VyIG9mIGRvY3VtZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgZG9jdW1lbnRzID0gYXdhaXQgYWkuZG9jdW1lbnRzLmxpc3Qoe3BhcmVudDoncmFnX3N0b3JlX25hbWUnLCBjb25maWc6IHsncGFnZVNpemUnOiAyfX0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGRvY3VtZW50IG9mIGRvY3VtZW50cykge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKGRvY3VtZW50KTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fRE9DVU1FTlRTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeyBwYXJlbnQ6IHBhcmFtcy5wYXJlbnQsIGNvbmZpZzogeC5jb25maWcgfSksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKHBhcmFtcyksIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBEb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2V0dGluZyBhIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm4gRG9jdW1lbnQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXREb2N1bWVudFBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIERvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBkZWxldGluZyBhIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZURvY3VtZW50UGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdERvY3VtZW50c1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7cGFyZW50fS9kb2N1bWVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdERvY3VtZW50c1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdERvY3VtZW50c1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgRmlsZVNlYXJjaFN0b3JlcyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCwgZG9jdW1lbnRzID0gbmV3IERvY3VtZW50cyhhcGlDbGllbnQpKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICB0aGlzLmRvY3VtZW50cyA9IGRvY3VtZW50cztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGZpbGUgc2VhcmNoIHN0b3Jlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIC0gQSBwYWdlciBvZiBmaWxlIHNlYXJjaCBzdG9yZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGZpbGVTZWFyY2hTdG9yZXMgPSBhd2FpdCBhaS5maWxlU2VhcmNoU3RvcmVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDJ9fSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgZmlsZVNlYXJjaFN0b3JlIG9mIGZpbGVTZWFyY2hTdG9yZXMpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhmaWxlU2VhcmNoU3RvcmUpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX0ZJTEVfU0VBUkNIX1NUT1JFUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSBhc3luY2hyb25vdXNseSB0byBhIGdpdmVuIEZpbGUgU2VhcmNoIFN0b3JlLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBhdmFpbGFibGUgaW4gVmVydGV4IEFJLlxuICAgICAqIFN1cHBvcnRlZCB1cGxvYWQgc291cmNlczpcbiAgICAgKiAtIE5vZGUuanM6IEZpbGUgcGF0aCAoc3RyaW5nKSBvciBCbG9iIG9iamVjdC5cbiAgICAgKiAtIEJyb3dzZXI6IEJsb2Igb2JqZWN0IChlLmcuLCBGaWxlKS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGBtaW1lVHlwZWAgY2FuIGJlIHNwZWNpZmllZCBpbiB0aGUgYGNvbmZpZ2AgcGFyYW1ldGVyLiBJZiBvbWl0dGVkOlxuICAgICAqICAtIEZvciBmaWxlIHBhdGggKHN0cmluZykgaW5wdXRzLCB0aGUgYG1pbWVUeXBlYCB3aWxsIGJlIGluZmVycmVkIGZyb20gdGhlXG4gICAgICogICAgIGZpbGUgZXh0ZW5zaW9uLlxuICAgICAqICAtIEZvciBCbG9iIG9iamVjdCBpbnB1dHMsIHRoZSBgbWltZVR5cGVgIHdpbGwgYmUgc2V0IHRvIHRoZSBCbG9iJ3MgYHR5cGVgXG4gICAgICogICAgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhpcyBzZWN0aW9uIGNhbiBjb250YWluIG11bHRpcGxlIHBhcmFncmFwaHMgYW5kIGNvZGUgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gdGhlXG4gICAgICogICAgICAgIGB0eXBlcy5VcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnNgIGludGVyZmFjZS5cbiAgICAgKiAgICAgICAgIEBzZWUge0BsaW5rIHR5cGVzLlVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUGFyYW1ldGVycyNjb25maWd9IGZvciB0aGUgb3B0aW9uYWxcbiAgICAgKiAgICAgICAgIGNvbmZpZyBpbiB0aGUgcGFyYW1ldGVycy5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbG9uZyBydW5uaW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIGNhbGxlZCBvbiBhIFZlcnRleCBBSSBjbGllbnQuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgYG1pbWVUeXBlYCBpcyBub3QgcHJvdmlkZWQgYW5kIGNhbiBub3QgYmUgaW5mZXJyZWQsXG4gICAgICogdGhlIGBtaW1lVHlwZWAgY2FuIGJlIHByb3ZpZGVkIGluIHRoZSBgcGFyYW1zLmNvbmZpZ2AgcGFyYW1ldGVyLlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3Igb2NjdXJzIGlmIGEgc3VpdGFibGUgdXBsb2FkIGxvY2F0aW9uIGNhbm5vdCBiZSBlc3RhYmxpc2hlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVGhlIGZvbGxvd2luZyBjb2RlIHVwbG9hZHMgYSBmaWxlIHRvIGEgZ2l2ZW4gZmlsZSBzZWFyY2ggc3RvcmUuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IG9wZXJhdGlvbiA9IGF3YWl0IGFpLmZpbGVTZWFyY2hTdG9yZXMudXBsb2FkKHtmaWxlU2VhcmNoU3RvcmVOYW1lOiAnZmlsZVNlYXJjaFN0b3Jlcy9mb28tYmFyJywgZmlsZTogJ2ZpbGUudHh0JywgY29uZmlnOiB7XG4gICAgICogICBtaW1lVHlwZTogJ3RleHQvcGxhaW4nLFxuICAgICAqIH19KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvcGVyYXRpb24ubmFtZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmUocGFyYW1zKSB7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmVydGV4IEFJIGRvZXMgbm90IHN1cHBvcnQgdXBsb2FkaW5nIGZpbGVzIHRvIGEgZmlsZSBzZWFyY2ggc3RvcmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnVwbG9hZEZpbGVUb0ZpbGVTZWFyY2hTdG9yZShwYXJhbXMuZmlsZVNlYXJjaFN0b3JlTmFtZSwgcGFyYW1zLmZpbGUsIHBhcmFtcy5jb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgRmlsZSBTZWFyY2ggU3RvcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIGEgRmlsZSBTZWFyY2ggU3RvcmUuXG4gICAgICogQHJldHVybiBGaWxlU2VhcmNoU3RvcmUuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZVNlYXJjaFN0b3JlcycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIEZpbGUgU2VhcmNoIFN0b3JlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZXR0aW5nIGEgRmlsZSBTZWFyY2ggU3RvcmUuXG4gICAgICogQHJldHVybiBGaWxlU2VhcmNoU3RvcmUuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBGaWxlIFNlYXJjaCBTdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZGVsZXRpbmcgYSBGaWxlIFNlYXJjaCBTdG9yZS5cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0RmlsZVNlYXJjaFN0b3Jlc1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdmaWxlU2VhcmNoU3RvcmVzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RGaWxlU2VhcmNoU3RvcmVzUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0RmlsZVNlYXJjaFN0b3Jlc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd1cGxvYWQvdjFiZXRhL3tmaWxlX3NlYXJjaF9zdG9yZV9uYW1lfTp1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVSZXN1bWFibGVSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzdW1hYmxlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcG9ydHMgYSBGaWxlIGZyb20gRmlsZSBTZXJ2aWNlIHRvIGEgRmlsZVNlYXJjaFN0b3JlLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGxvbmctcnVubmluZyBvcGVyYXRpb24sIHNlZSBhaXAuZGV2LzE1MVxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBpbXBvcnRpbmcgYSBmaWxlIHRvIGEgZmlsZSBzZWFyY2ggc3RvcmUuXG4gICAgICogQHJldHVybiBJbXBvcnRGaWxlT3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIGltcG9ydEZpbGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGltcG9ydEZpbGVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne2ZpbGVfc2VhcmNoX3N0b3JlX25hbWV9OmltcG9ydEZpbGUnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGltcG9ydEZpbGVPcGVyYXRpb25Gcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBJbXBvcnRGaWxlT3BlcmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbi8qKlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxMTc1MjNcbiAqL1xubGV0IHV1aWQ0SW50ZXJuYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgeyBjcnlwdG8gfSA9IGdsb2JhbFRoaXM7XG4gICAgaWYgKGNyeXB0byA9PT0gbnVsbCB8fCBjcnlwdG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyeXB0by5yYW5kb21VVUlEKSB7XG4gICAgICAgIHV1aWQ0SW50ZXJuYWwgPSBjcnlwdG8ucmFuZG9tVVVJRC5iaW5kKGNyeXB0byk7XG4gICAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgIH1cbiAgICBjb25zdCB1OCA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgIGNvbnN0IHJhbmRvbUJ5dGUgPSBjcnlwdG8gPyAoKSA9PiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHU4KVswXSA6ICgpID0+IChNYXRoLnJhbmRvbSgpICogMHhmZikgJiAweGZmO1xuICAgIHJldHVybiAnMTAwMDAwMDAtMTAwMC00MDAwLTgwMDAtMTAwMDAwMDAwMDAwJy5yZXBsYWNlKC9bMDE4XS9nLCAoYykgPT4gKCtjIF4gKHJhbmRvbUJ5dGUoKSAmICgxNSA+PiAoK2MgLyA0KSkpKS50b1N0cmluZygxNikpO1xufTtcbmNvbnN0IHV1aWQ0ID0gKCkgPT4gdXVpZDRJbnRlcm5hbCgpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuZnVuY3Rpb24gaXNBYm9ydEVycm9yKGVycikge1xuICAgIHJldHVybiAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgZXJyICE9PSBudWxsICYmXG4gICAgICAgIC8vIFNwZWMtY29tcGxpYW50IGZldGNoIGltcGxlbWVudGF0aW9uc1xuICAgICAgICAoKCduYW1lJyBpbiBlcnIgJiYgZXJyLm5hbWUgPT09ICdBYm9ydEVycm9yJykgfHxcbiAgICAgICAgICAgIC8vIEV4cG8gZmV0Y2hcbiAgICAgICAgICAgICgnbWVzc2FnZScgaW4gZXJyICYmIFN0cmluZyhlcnIubWVzc2FnZSkuaW5jbHVkZXMoJ0ZldGNoUmVxdWVzdENhbmNlbGVkRXhjZXB0aW9uJykpKSk7XG59XG5jb25zdCBjYXN0VG9FcnJvciA9IChlcnIpID0+IHtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpXG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICdvYmplY3QnICYmIGVyciAhPT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpID09PSAnW29iamVjdCBFcnJvcl0nKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIG5vdCBhbGwgZW52cyBoYXZlIG5hdGl2ZSBzdXBwb3J0IGZvciBjYXVzZSB5ZXRcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihlcnIubWVzc2FnZSwgZXJyLmNhdXNlID8geyBjYXVzZTogZXJyLmNhdXNlIH0gOiB7fSk7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5zdGFjaylcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIG5vdCBhbGwgZW52cyBoYXZlIG5hdGl2ZSBzdXBwb3J0IGZvciBjYXVzZSB5ZXRcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmNhdXNlICYmICFlcnJvci5jYXVzZSlcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuY2F1c2UgPSBlcnIuY2F1c2U7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5uYW1lKVxuICAgICAgICAgICAgICAgICAgICBlcnJvci5uYW1lID0gZXJyLm5hbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KGVycikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYikgeyB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoZXJyKTtcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5jbGFzcyBHZW1pbmlOZXh0R2VuQVBJQ2xpZW50RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5jbGFzcyBBUElFcnJvciBleHRlbmRzIEdlbWluaU5leHRHZW5BUElDbGllbnRFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycykge1xuICAgICAgICBzdXBlcihgJHtBUElFcnJvci5tYWtlTWVzc2FnZShzdGF0dXMsIGVycm9yLCBtZXNzYWdlKX1gKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgc3RhdGljIG1ha2VNZXNzYWdlKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbXNnID0gKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlKSA/XG4gICAgICAgICAgICB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICA6IGVycm9yID8gSlNPTi5zdHJpbmdpZnkoZXJyb3IpXG4gICAgICAgICAgICAgICAgOiBtZXNzYWdlO1xuICAgICAgICBpZiAoc3RhdHVzICYmIG1zZykge1xuICAgICAgICAgICAgcmV0dXJuIGAke3N0YXR1c30gJHttc2d9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7c3RhdHVzfSBzdGF0dXMgY29kZSAobm8gYm9keSlgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtc2cpIHtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcobm8gc3RhdHVzIGNvZGUgb3IgYm9keSknO1xuICAgIH1cbiAgICBzdGF0aWMgZ2VuZXJhdGUoc3RhdHVzLCBlcnJvclJlc3BvbnNlLCBtZXNzYWdlLCBoZWFkZXJzKSB7XG4gICAgICAgIGlmICghc3RhdHVzIHx8ICFoZWFkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFQSUNvbm5lY3Rpb25FcnJvcih7IG1lc3NhZ2UsIGNhdXNlOiBjYXN0VG9FcnJvcihlcnJvclJlc3BvbnNlKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvciA9IGVycm9yUmVzcG9uc2U7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDQwMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCYWRSZXF1ZXN0RXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBlcm1pc3Npb25EZW5pZWRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm90Rm91bmRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uZmxpY3RFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSA0MjIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDQyOSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYXRlTGltaXRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID49IDUwMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcm5hbFNlcnZlckVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQVBJRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxufVxuY2xhc3MgQVBJVXNlckFib3J0RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBtZXNzYWdlIH0gPSB7fSkge1xuICAgICAgICBzdXBlcih1bmRlZmluZWQsIHVuZGVmaW5lZCwgbWVzc2FnZSB8fCAnUmVxdWVzdCB3YXMgYWJvcnRlZC4nLCB1bmRlZmluZWQpO1xuICAgIH1cbn1cbmNsYXNzIEFQSUNvbm5lY3Rpb25FcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UsIGNhdXNlIH0pIHtcbiAgICAgICAgc3VwZXIodW5kZWZpbmVkLCB1bmRlZmluZWQsIG1lc3NhZ2UgfHwgJ0Nvbm5lY3Rpb24gZXJyb3IuJywgdW5kZWZpbmVkKTtcbiAgICAgICAgLy8gaW4gc29tZSBlbnZpcm9ubWVudHMgdGhlICdjYXVzZScgcHJvcGVydHkgaXMgYWxyZWFkeSBkZWNsYXJlZFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChjYXVzZSlcbiAgICAgICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB9XG59XG5jbGFzcyBBUElDb25uZWN0aW9uVGltZW91dEVycm9yIGV4dGVuZHMgQVBJQ29ubmVjdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHsgbWVzc2FnZTogbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ1JlcXVlc3QgdGltZWQgb3V0LicgfSk7XG4gICAgfVxufVxuY2xhc3MgQmFkUmVxdWVzdEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuY2xhc3MgQXV0aGVudGljYXRpb25FcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmNsYXNzIFBlcm1pc3Npb25EZW5pZWRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmNsYXNzIE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5jbGFzcyBDb25mbGljdEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuY2xhc3MgVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuY2xhc3MgUmF0ZUxpbWl0RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5jbGFzcyBJbnRlcm5hbFNlcnZlckVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtc2NoZW1lLXN0cmluZ1xuY29uc3Qgc3RhcnRzV2l0aFNjaGVtZVJlZ2V4cCA9IC9eW2Etel1bYS16MC05Ky4tXSo6L2k7XG5jb25zdCBpc0Fic29sdXRlVVJMID0gKHVybCkgPT4ge1xuICAgIHJldHVybiBzdGFydHNXaXRoU2NoZW1lUmVnZXhwLnRlc3QodXJsKTtcbn07XG5sZXQgaXNBcnJheUludGVybmFsID0gKHZhbCkgPT4gKChpc0FycmF5SW50ZXJuYWwgPSBBcnJheS5pc0FycmF5KSwgaXNBcnJheUludGVybmFsKHZhbCkpO1xuY29uc3QgaXNBcnJheSA9IGlzQXJyYXlJbnRlcm5hbDtcbmxldCBpc1JlYWRvbmx5QXJyYXlJbnRlcm5hbCA9IGlzQXJyYXk7XG5jb25zdCBpc1JlYWRvbmx5QXJyYXkgPSBpc1JlYWRvbmx5QXJyYXlJbnRlcm5hbDtcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNDQ5MTI4N1xuZnVuY3Rpb24gaXNFbXB0eU9iaihvYmopIHtcbiAgICBpZiAoIW9iailcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZm9yIChjb25zdCBfayBpbiBvYmopXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIGh0dHBzOi8vZXNsaW50Lm9yZy9kb2NzL2xhdGVzdC9ydWxlcy9uby1wcm90b3R5cGUtYnVpbHRpbnNcbmZ1bmN0aW9uIGhhc093bihvYmosIGtleSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuY29uc3QgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIgPSAobmFtZSwgbikgPT4ge1xuICAgIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIobikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEdlbWluaU5leHRHZW5BUElDbGllbnRFcnJvcihgJHtuYW1lfSBtdXN0IGJlIGFuIGludGVnZXJgKTtcbiAgICB9XG4gICAgaWYgKG4gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBHZW1pbmlOZXh0R2VuQVBJQ2xpZW50RXJyb3IoYCR7bmFtZX0gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJgKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG59O1xuY29uc3Qgc2FmZUpTT04gPSAodGV4dCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmNvbnN0IHNsZWVwJDEgPSAobXMpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IFZFUlNJT04gPSAnMC4wLjEnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuLyoqXG4gKiBOb3RlIHRoaXMgZG9lcyBub3QgZGV0ZWN0ICdicm93c2VyJzsgZm9yIHRoYXQsIHVzZSBnZXRCcm93c2VySW5mbygpLlxuICovXG5mdW5jdGlvbiBnZXREZXRlY3RlZFBsYXRmb3JtKCkge1xuICAgIGlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcgJiYgRGVuby5idWlsZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnZGVubyc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgRWRnZVJ1bnRpbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAnZWRnZSc7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodHlwZW9mIGdsb2JhbFRoaXMucHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzLnByb2Nlc3MgOiAwKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgICAgIHJldHVybiAnbm9kZSc7XG4gICAgfVxuICAgIHJldHVybiAndW5rbm93bic7XG59XG5jb25zdCBnZXRQbGF0Zm9ybVByb3BlcnRpZXMgPSAoKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCBkZXRlY3RlZFBsYXRmb3JtID0gZ2V0RGV0ZWN0ZWRQbGF0Zm9ybSgpO1xuICAgIGlmIChkZXRlY3RlZFBsYXRmb3JtID09PSAnZGVubycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1MYW5nJzogJ2pzJyxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBWRVJTSU9OLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLU9TJzogbm9ybWFsaXplUGxhdGZvcm0oRGVuby5idWlsZC5vcyksXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6IG5vcm1hbGl6ZUFyY2goRGVuby5idWlsZC5hcmNoKSxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogJ2Rlbm8nLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6IHR5cGVvZiBEZW5vLnZlcnNpb24gPT09ICdzdHJpbmcnID8gRGVuby52ZXJzaW9uIDogKF9iID0gKF9hID0gRGVuby52ZXJzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVubykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIEVkZ2VSdW50aW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IFZFUlNJT04sXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtT1MnOiAnVW5rbm93bicsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6IGBvdGhlcjoke0VkZ2VSdW50aW1lfWAsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICdlZGdlJyxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiBnbG9iYWxUaGlzLnByb2Nlc3MudmVyc2lvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgTm9kZS5qc1xuICAgIGlmIChkZXRlY3RlZFBsYXRmb3JtID09PSAnbm9kZScpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1MYW5nJzogJ2pzJyxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBWRVJTSU9OLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLU9TJzogbm9ybWFsaXplUGxhdGZvcm0oKF9jID0gZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAndW5rbm93bicpLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLUFyY2gnOiBub3JtYWxpemVBcmNoKChfZCA9IGdsb2JhbFRoaXMucHJvY2Vzcy5hcmNoKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAndW5rbm93bicpLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiAnbm9kZScsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzogKF9lID0gZ2xvYmFsVGhpcy5wcm9jZXNzLnZlcnNpb24pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6ICd1bmtub3duJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgYnJvd3NlckluZm8gPSBnZXRCcm93c2VySW5mbygpO1xuICAgIGlmIChicm93c2VySW5mbykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IFZFUlNJT04sXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtT1MnOiAnVW5rbm93bicsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6ICd1bmtub3duJyxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogYGJyb3dzZXI6JHticm93c2VySW5mby5icm93c2VyfWAsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzogYnJvd3NlckluZm8udmVyc2lvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gVE9ETyBhZGQgc3VwcG9ydCBmb3IgQ2xvdWRmbGFyZSB3b3JrZXJzLCBldGMuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICAgJ1gtU3RhaW5sZXNzLU9TJzogJ1Vua25vd24nLFxuICAgICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6ICd1bmtub3duJyxcbiAgICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiAndW5rbm93bicsXG4gICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiAndW5rbm93bicsXG4gICAgfTtcbn07XG4vLyBOb3RlOiBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9KUy1EZXZUb29scy9ob3N0LWVudmlyb25tZW50L2Jsb2IvYjFhYjc5ZWNkZTM3ZGI1ZDZlMTYzYzA1MGU1NGZlN2QyODdkN2M5Mi9zcmMvaXNvbW9ycGhpYy5icm93c2VyLnRzXG5mdW5jdGlvbiBnZXRCcm93c2VySW5mbygpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gTk9URTogVGhlIG9yZGVyIG1hdHRlcnMgaGVyZSFcbiAgICBjb25zdCBicm93c2VyUGF0dGVybnMgPSBbXG4gICAgICAgIHsga2V5OiAnZWRnZScsIHBhdHRlcm46IC9FZGdlKD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgICAgIHsga2V5OiAnaWUnLCBwYXR0ZXJuOiAvTVNJRSg/OlxcVysoXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/LyB9LFxuICAgICAgICB7IGtleTogJ2llJywgcGF0dGVybjogL1RyaWRlbnQoPzouKnJ2XFw6KFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICAgICAgeyBrZXk6ICdjaHJvbWUnLCBwYXR0ZXJuOiAvQ2hyb21lKD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgICAgIHsga2V5OiAnZmlyZWZveCcsIHBhdHRlcm46IC9GaXJlZm94KD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgICAgIHsga2V5OiAnc2FmYXJpJywgcGF0dGVybjogLyg/OlZlcnNpb25cXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPyg/OlxcVytNb2JpbGVcXFMqKT9cXFcrU2FmYXJpLyB9LFxuICAgIF07XG4gICAgLy8gRmluZCB0aGUgRklSU1QgbWF0Y2hpbmcgYnJvd3NlclxuICAgIGZvciAoY29uc3QgeyBrZXksIHBhdHRlcm4gfSBvZiBicm93c2VyUGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgbWFqb3IgPSBtYXRjaFsxXSB8fCAwO1xuICAgICAgICAgICAgY29uc3QgbWlub3IgPSBtYXRjaFsyXSB8fCAwO1xuICAgICAgICAgICAgY29uc3QgcGF0Y2ggPSBtYXRjaFszXSB8fCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgYnJvd3Nlcjoga2V5LCB2ZXJzaW9uOiBgJHttYWpvcn0uJHttaW5vcn0uJHtwYXRjaH1gIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBub3JtYWxpemVBcmNoID0gKGFyY2gpID0+IHtcbiAgICAvLyBOb2RlIGRvY3M6XG4gICAgLy8gLSBodHRwczovL25vZGVqcy5vcmcvYXBpL3Byb2Nlc3MuaHRtbCNwcm9jZXNzYXJjaFxuICAgIC8vIERlbm8gZG9jczpcbiAgICAvLyAtIGh0dHBzOi8vZG9jLmRlbm8ubGFuZC9kZW5vL3N0YWJsZS9+L0Rlbm8uYnVpbGRcbiAgICBpZiAoYXJjaCA9PT0gJ3gzMicpXG4gICAgICAgIHJldHVybiAneDMyJztcbiAgICBpZiAoYXJjaCA9PT0gJ3g4Nl82NCcgfHwgYXJjaCA9PT0gJ3g2NCcpXG4gICAgICAgIHJldHVybiAneDY0JztcbiAgICBpZiAoYXJjaCA9PT0gJ2FybScpXG4gICAgICAgIHJldHVybiAnYXJtJztcbiAgICBpZiAoYXJjaCA9PT0gJ2FhcmNoNjQnIHx8IGFyY2ggPT09ICdhcm02NCcpXG4gICAgICAgIHJldHVybiAnYXJtNjQnO1xuICAgIGlmIChhcmNoKVxuICAgICAgICByZXR1cm4gYG90aGVyOiR7YXJjaH1gO1xuICAgIHJldHVybiAndW5rbm93bic7XG59O1xuY29uc3Qgbm9ybWFsaXplUGxhdGZvcm0gPSAocGxhdGZvcm0pID0+IHtcbiAgICAvLyBOb2RlIHBsYXRmb3JtczpcbiAgICAvLyAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NwbGF0Zm9ybVxuICAgIC8vIERlbm8gcGxhdGZvcm1zOlxuICAgIC8vIC0gaHR0cHM6Ly9kb2MuZGVuby5sYW5kL2Rlbm8vc3RhYmxlL34vRGVuby5idWlsZFxuICAgIC8vIC0gaHR0cHM6Ly9naXRodWIuY29tL2Rlbm9sYW5kL2Rlbm8vaXNzdWVzLzE0Nzk5XG4gICAgcGxhdGZvcm0gPSBwbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIE5PVEU6IHRoaXMgaU9TIGNoZWNrIGlzIHVudGVzdGVkIGFuZCBtYXkgbm90IHdvcmtcbiAgICAvLyBOb2RlIGRvZXMgbm90IHdvcmsgbmF0aXZlbHkgb24gSU9TLCB0aGVyZSBpcyBhIGZvcmsgYXRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzLW1vYmlsZS9ub2RlanMtbW9iaWxlXG4gICAgLy8gaG93ZXZlciBpdCBpcyB1bmtub3duIGF0IHRoZSB0aW1lIG9mIHdyaXRpbmcgaG93IHRvIGRldGVjdCBpZiBpdCBpcyBydW5uaW5nXG4gICAgaWYgKHBsYXRmb3JtLmluY2x1ZGVzKCdpb3MnKSlcbiAgICAgICAgcmV0dXJuICdpT1MnO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKVxuICAgICAgICByZXR1cm4gJ0FuZHJvaWQnO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ2RhcndpbicpXG4gICAgICAgIHJldHVybiAnTWFjT1MnO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ3dpbjMyJylcbiAgICAgICAgcmV0dXJuICdXaW5kb3dzJztcbiAgICBpZiAocGxhdGZvcm0gPT09ICdmcmVlYnNkJylcbiAgICAgICAgcmV0dXJuICdGcmVlQlNEJztcbiAgICBpZiAocGxhdGZvcm0gPT09ICdvcGVuYnNkJylcbiAgICAgICAgcmV0dXJuICdPcGVuQlNEJztcbiAgICBpZiAocGxhdGZvcm0gPT09ICdsaW51eCcpXG4gICAgICAgIHJldHVybiAnTGludXgnO1xuICAgIGlmIChwbGF0Zm9ybSlcbiAgICAgICAgcmV0dXJuIGBPdGhlcjoke3BsYXRmb3JtfWA7XG4gICAgcmV0dXJuICdVbmtub3duJztcbn07XG5sZXQgX3BsYXRmb3JtSGVhZGVycztcbmNvbnN0IGdldFBsYXRmb3JtSGVhZGVycyA9ICgpID0+IHtcbiAgICByZXR1cm4gKF9wbGF0Zm9ybUhlYWRlcnMgIT09IG51bGwgJiYgX3BsYXRmb3JtSGVhZGVycyAhPT0gdm9pZCAwID8gX3BsYXRmb3JtSGVhZGVycyA6IChfcGxhdGZvcm1IZWFkZXJzID0gZ2V0UGxhdGZvcm1Qcm9wZXJ0aWVzKCkpKTtcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRGZXRjaCgpIHtcbiAgICBpZiAodHlwZW9mIGZldGNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmV0Y2g7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignYGZldGNoYCBpcyBub3QgZGVmaW5lZCBhcyBhIGdsb2JhbDsgRWl0aGVyIHBhc3MgYGZldGNoYCB0byB0aGUgY2xpZW50LCBgbmV3IEdlbWluaU5leHRHZW5BUElDbGllbnQoeyBmZXRjaCB9KWAgb3IgcG9seWZpbGwgdGhlIGdsb2JhbCwgYGdsb2JhbFRoaXMuZmV0Y2ggPSBmZXRjaGAnKTtcbn1cbmZ1bmN0aW9uIG1ha2VSZWFkYWJsZVN0cmVhbSguLi5hcmdzKSB7XG4gICAgY29uc3QgUmVhZGFibGVTdHJlYW0gPSBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtO1xuICAgIGlmICh0eXBlb2YgUmVhZGFibGVTdHJlYW0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIE5vdGU6IEFsbCBvZiB0aGUgcGxhdGZvcm1zIC8gcnVudGltZXMgd2Ugb2ZmaWNpYWxseSBzdXBwb3J0IGFscmVhZHkgZGVmaW5lXG4gICAgICAgIC8vIGBSZWFkYWJsZVN0cmVhbWAgYXMgYSBnbG9iYWwsIHNvIHRoaXMgc2hvdWxkIG9ubHkgZXZlciBiZSBoaXQgb24gdW5zdXBwb3J0ZWQgcnVudGltZXMuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYFJlYWRhYmxlU3RyZWFtYCBpcyBub3QgZGVmaW5lZCBhcyBhIGdsb2JhbDsgWW91IHdpbGwgbmVlZCB0byBwb2x5ZmlsbCBpdCwgYGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0gPSBSZWFkYWJsZVN0cmVhbWAnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSguLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRnJvbShpdGVyYWJsZSkge1xuICAgIGxldCBpdGVyID0gU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gaXRlcmFibGUgPyBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSA6IGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICByZXR1cm4gbWFrZVJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoKSB7IH0sXG4gICAgICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXRlci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGNhbmNlbCgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGF3YWl0ICgoX2EgPSBpdGVyLnJldHVybikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaXRlcikpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBNb3N0IGJyb3dzZXJzIGRvbid0IHlldCBoYXZlIGFzeW5jIGl0ZXJhYmxlIHN1cHBvcnQgZm9yIFJlYWRhYmxlU3RyZWFtLFxuICogYW5kIE5vZGUgaGFzIGEgdmVyeSBkaWZmZXJlbnQgd2F5IG9mIHJlYWRpbmcgYnl0ZXMgZnJvbSBpdHMgXCJSZWFkYWJsZVN0cmVhbVwiLlxuICpcbiAqIFRoaXMgcG9seWZpbGwgd2FzIHB1bGxlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9NYXR0aWFzQnVlbGVucy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9wdWxsLzEyMiNpc3N1ZWNvbW1lbnQtMTYyNzM1NDQ5MFxuICovXG5mdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVRvQXN5bmNJdGVyYWJsZShzdHJlYW0pIHtcbiAgICBpZiAoc3RyZWFtW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSlcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0LmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgd2hlbiBzdHJlYW0gYmVjb21lcyBjbG9zZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgZXJyb3JlZFxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHJldHVybigpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIGF3YWl0IGNhbmNlbFByb21pc2U7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgIH0sXG4gICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDYW5jZWxzIGEgUmVhZGFibGVTdHJlYW0gd2UgZG9uJ3QgbmVlZCB0byBjb25zdW1lLlxuICogU2VlIGh0dHBzOi8vdW5kaWNpLm5vZGVqcy5vcmcvIy8/aWQ9Z2FyYmFnZS1jb2xsZWN0aW9uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIENhbmNlbFJlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKHN0cmVhbSA9PT0gbnVsbCB8fCB0eXBlb2Ygc3RyZWFtICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChzdHJlYW1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgICAgIGF3YWl0ICgoX2IgPSAoX2EgPSBzdHJlYW1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkpLnJldHVybikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IHJlYWRlci5jYW5jZWwoKTtcbiAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICBhd2FpdCBjYW5jZWxQcm9taXNlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBGYWxsYmFja0VuY29kZXIgPSAoeyBoZWFkZXJzLCBib2R5IH0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBib2R5SGVhZGVyczoge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgfTtcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IGNoZWNrRmlsZVN1cHBvcnQgPSAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0eXBlb2YgRmlsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgeyBwcm9jZXNzIH0gPSBnbG9iYWxUaGlzO1xuICAgICAgICBjb25zdCBpc09sZE5vZGUgPSB0eXBlb2YgKChfYSA9IHByb2Nlc3MgPT09IG51bGwgfHwgcHJvY2VzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvY2Vzcy52ZXJzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGUpID09PSAnc3RyaW5nJyAmJiBwYXJzZUludChwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoJy4nKSkgPCAyMDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgRmlsZWAgaXMgbm90IGRlZmluZWQgYXMgYSBnbG9iYWwsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciBmaWxlIHVwbG9hZHMuJyArXG4gICAgICAgICAgICAoaXNPbGROb2RlID9cbiAgICAgICAgICAgICAgICBcIiBVcGRhdGUgdG8gTm9kZSAyMCBMVFMgb3IgbmV3ZXIsIG9yIHNldCBgZ2xvYmFsVGhpcy5GaWxlYCB0byBgaW1wb3J0KCdub2RlOmJ1ZmZlcicpLkZpbGVgLlwiXG4gICAgICAgICAgICAgICAgOiAnJykpO1xuICAgIH1cbn07XG4vKipcbiAqIENvbnN0cnVjdCBhIGBGaWxlYCBpbnN0YW5jZS4gVGhpcyBpcyB1c2VkIHRvIGVuc3VyZSBhIGhlbHBmdWwgZXJyb3IgaXMgdGhyb3duXG4gKiBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG9uJ3QgZGVmaW5lIGEgZ2xvYmFsIGBGaWxlYCB5ZXQuXG4gKi9cbmZ1bmN0aW9uIG1ha2VGaWxlKGZpbGVCaXRzLCBmaWxlTmFtZSwgb3B0aW9ucykge1xuICAgIGNoZWNrRmlsZVN1cHBvcnQoKTtcbiAgICByZXR1cm4gbmV3IEZpbGUoZmlsZUJpdHMsIGZpbGVOYW1lICE9PSBudWxsICYmIGZpbGVOYW1lICE9PSB2b2lkIDAgPyBmaWxlTmFtZSA6ICd1bmtub3duX2ZpbGUnLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGdldE5hbWUodmFsdWUpIHtcbiAgICByZXR1cm4gKCgodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAoKCduYW1lJyBpbiB2YWx1ZSAmJiB2YWx1ZS5uYW1lICYmIFN0cmluZyh2YWx1ZS5uYW1lKSkgfHxcbiAgICAgICAgICAgICgndXJsJyBpbiB2YWx1ZSAmJiB2YWx1ZS51cmwgJiYgU3RyaW5nKHZhbHVlLnVybCkpIHx8XG4gICAgICAgICAgICAoJ2ZpbGVuYW1lJyBpbiB2YWx1ZSAmJiB2YWx1ZS5maWxlbmFtZSAmJiBTdHJpbmcodmFsdWUuZmlsZW5hbWUpKSB8fFxuICAgICAgICAgICAgKCdwYXRoJyBpbiB2YWx1ZSAmJiB2YWx1ZS5wYXRoICYmIFN0cmluZyh2YWx1ZS5wYXRoKSkpKSB8fFxuICAgICAgICAnJylcbiAgICAgICAgLnNwbGl0KC9bXFxcXC9dLylcbiAgICAgICAgLnBvcCgpIHx8IHVuZGVmaW5lZCk7XG59XG5jb25zdCBpc0FzeW5jSXRlcmFibGUgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIFRoaXMgY2hlY2sgYWRkcyB0aGUgYXJyYXlCdWZmZXIoKSBtZXRob2QgdHlwZSBiZWNhdXNlIGl0IGlzIGF2YWlsYWJsZSBhbmQgdXNlZCBhdCBydW50aW1lXG4gKi9cbmNvbnN0IGlzQmxvYkxpa2UgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGwgJiZcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHZhbHVlLnNpemUgPT09ICdudW1iZXInICYmXG4gICAgdHlwZW9mIHZhbHVlLnR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmFsdWUuc2xpY2UgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmFsdWUuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbic7XG4vKipcbiAqIFRoaXMgY2hlY2sgYWRkcyB0aGUgYXJyYXlCdWZmZXIoKSBtZXRob2QgdHlwZSBiZWNhdXNlIGl0IGlzIGF2YWlsYWJsZSBhbmQgdXNlZCBhdCBydW50aW1lXG4gKi9cbmNvbnN0IGlzRmlsZUxpa2UgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGwgJiZcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHZhbHVlLm5hbWUgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIHZhbHVlLmxhc3RNb2RpZmllZCA9PT0gJ251bWJlcicgJiZcbiAgICBpc0Jsb2JMaWtlKHZhbHVlKTtcbmNvbnN0IGlzUmVzcG9uc2VMaWtlID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsICYmXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB2YWx1ZS51cmwgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIHZhbHVlLmJsb2IgPT09ICdmdW5jdGlvbic7XG4vKipcbiAqIEhlbHBlciBmb3IgY3JlYXRpbmcgYSB7QGxpbmsgRmlsZX0gdG8gcGFzcyB0byBhbiBTREsgdXBsb2FkIG1ldGhvZCBmcm9tIGEgdmFyaWV0eSBvZiBkaWZmZXJlbnQgZGF0YSBmb3JtYXRzXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHJhdyBjb250ZW50IG9mIHRoZSBmaWxlLiBDYW4gYmUgYW4ge0BsaW5rIFVwbG9hZGFibGV9LCBCbG9iTGlrZVBhcnQsIG9yIEFzeW5jSXRlcmFibGUgb2YgQmxvYkxpa2VQYXJ0c1xuICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlLiBJZiBvbWl0dGVkLCB0b0ZpbGUgd2lsbCB0cnkgdG8gZGV0ZXJtaW5lIGEgZmlsZSBuYW1lIGZyb20gYml0cyBpZiBwb3NzaWJsZVxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLnR5cGUgdGhlIE1JTUUgdHlwZSBvZiB0aGUgY29udGVudFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRpb25zLmxhc3RNb2RpZmllZCB0aGUgbGFzdCBtb2RpZmllZCB0aW1lc3RhbXBcbiAqIEByZXR1cm5zIGEge0BsaW5rIEZpbGV9IHdpdGggdGhlIGdpdmVuIHByb3BlcnRpZXNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdG9GaWxlKHZhbHVlLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgY2hlY2tGaWxlU3VwcG9ydCgpO1xuICAgIC8vIElmIGl0J3MgYSBwcm9taXNlLCByZXNvbHZlIGl0LlxuICAgIHZhbHVlID0gYXdhaXQgdmFsdWU7XG4gICAgLy8gSWYgd2UndmUgYmVlbiBnaXZlbiBhIGBGaWxlYCB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgaWYgKGlzRmlsZUxpa2UodmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZUZpbGUoW2F3YWl0IHZhbHVlLmFycmF5QnVmZmVyKCldLCB2YWx1ZS5uYW1lKTtcbiAgICB9XG4gICAgaWYgKGlzUmVzcG9uc2VMaWtlKHZhbHVlKSkge1xuICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgdmFsdWUuYmxvYigpO1xuICAgICAgICBuYW1lIHx8IChuYW1lID0gbmV3IFVSTCh2YWx1ZS51cmwpLnBhdGhuYW1lLnNwbGl0KC9bXFxcXC9dLykucG9wKCkpO1xuICAgICAgICByZXR1cm4gbWFrZUZpbGUoYXdhaXQgZ2V0Qnl0ZXMoYmxvYiksIG5hbWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0cyA9IGF3YWl0IGdldEJ5dGVzKHZhbHVlKTtcbiAgICBuYW1lIHx8IChuYW1lID0gZ2V0TmFtZSh2YWx1ZSkpO1xuICAgIGlmICghKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50eXBlKSkge1xuICAgICAgICBjb25zdCB0eXBlID0gcGFydHMuZmluZCgocGFydCkgPT4gdHlwZW9mIHBhcnQgPT09ICdvYmplY3QnICYmICd0eXBlJyBpbiBwYXJ0ICYmIHBhcnQudHlwZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHR5cGUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1ha2VGaWxlKHBhcnRzLCBuYW1lLCBvcHRpb25zKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEJ5dGVzKHZhbHVlKSB7XG4gICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICB2YXIgX2Q7XG4gICAgbGV0IHBhcnRzID0gW107XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSB8fCAvLyBpbmNsdWRlcyBVaW50OEFycmF5LCBCdWZmZXIsIGV0Yy5cbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBwYXJ0cy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCbG9iTGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcGFydHMucHVzaCh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IgPyB2YWx1ZSA6IGF3YWl0IHZhbHVlLmFycmF5QnVmZmVyKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FzeW5jSXRlcmFibGUodmFsdWUpIC8vIGluY2x1ZGVzIFJlYWRhYmxlLCBSZWFkYWJsZVN0cmVhbSwgZXRjLlxuICAgICkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2UgPSB0cnVlLCB2YWx1ZV8xID0gX19hc3luY1ZhbHVlcyh2YWx1ZSksIHZhbHVlXzFfMTsgdmFsdWVfMV8xID0gYXdhaXQgdmFsdWVfMS5uZXh0KCksIF9hID0gdmFsdWVfMV8xLmRvbmUsICFfYTsgX2UgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgX2MgPSB2YWx1ZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgX2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goLi4uKGF3YWl0IGdldEJ5dGVzKGNodW5rKSkpOyAvLyBUT0RPLCBjb25zaWRlciB2YWxpZGF0aW5nP1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9lICYmICFfYSAmJiAoX2IgPSB2YWx1ZV8xLnJldHVybikpIGF3YWl0IF9iLmNhbGwodmFsdWVfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gKF9kID0gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubmFtZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGRhdGEgdHlwZTogJHt0eXBlb2YgdmFsdWV9JHtjb25zdHJ1Y3RvciA/IGA7IGNvbnN0cnVjdG9yOiAke2NvbnN0cnVjdG9yfWAgOiAnJ30ke3Byb3BzRm9yRXJyb3IodmFsdWUpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHM7XG59XG5mdW5jdGlvbiBwcm9wc0ZvckVycm9yKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgICByZXR1cm4gYDsgcHJvcHM6IFske3Byb3BzLm1hcCgocCkgPT4gYFwiJHtwfVwiYCkuam9pbignLCAnKX1dYDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgQVBJUmVzb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUga2V5IHBhdGggZnJvbSB0aGUgY2xpZW50LiBGb3IgZXhhbXBsZSwgYSByZXNvdXJjZSBhY2Nlc3NpYmxlIGFzIGBjbGllbnQucmVzb3VyY2Uuc3VicmVzb3VyY2VgIHdvdWxkXG4gKiBoYXZlIGEgcHJvcGVydHkgYHN0YXRpYyBvdmVycmlkZSByZWFkb25seSBfa2V5ID0gT2JqZWN0LmZyZWV6ZShbJ3Jlc291cmNlJywgJ3N1YnJlc291cmNlJ10gYXMgY29uc3QpO2AuXG4gKi9cbkFQSVJlc291cmNlLl9rZXkgPSBbXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBQZXJjZW50LWVuY29kZSBldmVyeXRoaW5nIHRoYXQgaXNuJ3Qgc2FmZSB0byBoYXZlIGluIGEgcGF0aCB3aXRob3V0IGVuY29kaW5nIHNhZmUgY2hhcnMuXG4gKlxuICogVGFrZW4gZnJvbSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjM6XG4gKiA+IHVucmVzZXJ2ZWQgID0gQUxQSEEgLyBESUdJVCAvIFwiLVwiIC8gXCIuXCIgLyBcIl9cIiAvIFwiflwiXG4gKiA+IHN1Yi1kZWxpbXMgID0gXCIhXCIgLyBcIiRcIiAvIFwiJlwiIC8gXCInXCIgLyBcIihcIiAvIFwiKVwiIC8gXCIqXCIgLyBcIitcIiAvIFwiLFwiIC8gXCI7XCIgLyBcIj1cIlxuICogPiBwY2hhciAgICAgICA9IHVucmVzZXJ2ZWQgLyBwY3QtZW5jb2RlZCAvIHN1Yi1kZWxpbXMgLyBcIjpcIiAvIFwiQFwiXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVVSSVBhdGgoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXkEtWmEtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdKy9nLCBlbmNvZGVVUklDb21wb25lbnQpO1xufVxuY29uc3QgRU1QVFkgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5jb25zdCBjcmVhdGVQYXRoVGFnRnVuY3Rpb24gPSAocGF0aEVuY29kZXIgPSBlbmNvZGVVUklQYXRoKSA9PiAoZnVuY3Rpb24gcGF0aChzdGF0aWNzLCAuLi5wYXJhbXMpIHtcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gcGFyYW1zLCBubyBwcm9jZXNzaW5nIGlzIG5lZWRlZC5cbiAgICBpZiAoc3RhdGljcy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBzdGF0aWNzWzBdO1xuICAgIGxldCBwb3N0UGF0aCA9IGZhbHNlO1xuICAgIGNvbnN0IGludmFsaWRTZWdtZW50cyA9IFtdO1xuICAgIGNvbnN0IHBhdGggPSBzdGF0aWNzLnJlZHVjZSgocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKC9bPyNdLy50ZXN0KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHBvc3RQYXRoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtc1tpbmRleF07XG4gICAgICAgIGxldCBlbmNvZGVkID0gKHBvc3RQYXRoID8gZW5jb2RlVVJJQ29tcG9uZW50IDogcGF0aEVuY29kZXIpKCcnICsgdmFsdWUpO1xuICAgICAgICBpZiAoaW5kZXggIT09IHBhcmFtcy5sZW5ndGggJiZcbiAgICAgICAgICAgICh2YWx1ZSA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHZhbHVlcyBmcm9tIG90aGVyIHJlYWxtc1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS50b1N0cmluZyA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICgoX2MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoKF9iID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKChfYSA9IHZhbHVlLmhhc093blByb3BlcnR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBFTVBUWSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IEVNUFRZKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvU3RyaW5nKSkpKSB7XG4gICAgICAgICAgICBlbmNvZGVkID0gdmFsdWUgKyAnJztcbiAgICAgICAgICAgIGludmFsaWRTZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydDogcHJldmlvdXNWYWx1ZS5sZW5ndGggKyBjdXJyZW50VmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZW5jb2RlZC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGBWYWx1ZSBvZiB0eXBlICR7T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAgICAgICAgICAgICAgICAgICAuY2FsbCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDgsIC0xKX0gaXMgbm90IGEgdmFsaWQgcGF0aCBwYXJhbWV0ZXJgLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWUgKyBjdXJyZW50VmFsdWUgKyAoaW5kZXggPT09IHBhcmFtcy5sZW5ndGggPyAnJyA6IGVuY29kZWQpO1xuICAgIH0sICcnKTtcbiAgICBjb25zdCBwYXRoT25seSA9IHBhdGguc3BsaXQoL1s/I10vLCAxKVswXTtcbiAgICBjb25zdCBpbnZhbGlkU2VnbWVudFBhdHRlcm4gPSAvKD88PV58XFwvKSg/OlxcLnwlMmUpezEsMn0oPz1cXC98JCkvZ2k7XG4gICAgbGV0IG1hdGNoO1xuICAgIC8vIEZpbmQgYWxsIGludmFsaWQgc2VnbWVudHNcbiAgICB3aGlsZSAoKG1hdGNoID0gaW52YWxpZFNlZ21lbnRQYXR0ZXJuLmV4ZWMocGF0aE9ubHkpKSAhPT0gbnVsbCkge1xuICAgICAgICBpbnZhbGlkU2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgICBzdGFydDogbWF0Y2guaW5kZXgsXG4gICAgICAgICAgICBsZW5ndGg6IG1hdGNoWzBdLmxlbmd0aCxcbiAgICAgICAgICAgIGVycm9yOiBgVmFsdWUgXCIke21hdGNoWzBdfVwiIGNhblxcJ3QgYmUgc2FmZWx5IHBhc3NlZCBhcyBhIHBhdGggcGFyYW1ldGVyYCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGludmFsaWRTZWdtZW50cy5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0IC0gYi5zdGFydCk7XG4gICAgaWYgKGludmFsaWRTZWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBsYXN0RW5kID0gMDtcbiAgICAgICAgY29uc3QgdW5kZXJsaW5lID0gaW52YWxpZFNlZ21lbnRzLnJlZHVjZSgoYWNjLCBzZWdtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzcGFjZXMgPSAnICcucmVwZWF0KHNlZ21lbnQuc3RhcnQgLSBsYXN0RW5kKTtcbiAgICAgICAgICAgIGNvbnN0IGFycm93cyA9ICdeJy5yZXBlYXQoc2VnbWVudC5sZW5ndGgpO1xuICAgICAgICAgICAgbGFzdEVuZCA9IHNlZ21lbnQuc3RhcnQgKyBzZWdtZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBhY2MgKyBzcGFjZXMgKyBhcnJvd3M7XG4gICAgICAgIH0sICcnKTtcbiAgICAgICAgdGhyb3cgbmV3IEdlbWluaU5leHRHZW5BUElDbGllbnRFcnJvcihgUGF0aCBwYXJhbWV0ZXJzIHJlc3VsdCBpbiBwYXRoIHdpdGggaW52YWxpZCBzZWdtZW50czpcXG4ke2ludmFsaWRTZWdtZW50c1xuICAgICAgICAgICAgLm1hcCgoZSkgPT4gZS5lcnJvcilcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKX1cXG4ke3BhdGh9XFxuJHt1bmRlcmxpbmV9YCk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufSk7XG4vKipcbiAqIFVSSS1lbmNvZGVzIHBhdGggcGFyYW1zIGFuZCBlbnN1cmVzIG5vIHVuc2FmZSAvLi8gb3IgLy4uLyBwYXRoIHNlZ21lbnRzIGFyZSBpbnRyb2R1Y2VkLlxuICovXG5jb25zdCBwYXRoID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVBhdGhUYWdGdW5jdGlvbihlbmNvZGVVUklQYXRoKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgQmFzZUludGVyYWN0aW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICBjcmVhdGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBhcGlfdmVyc2lvbiA9IHRoaXMuX2NsaWVudC5hcGlWZXJzaW9uIH0gPSBwYXJhbXMsIGJvZHkgPSBfX3Jlc3QocGFyYW1zLCBbXCJhcGlfdmVyc2lvblwiXSk7XG4gICAgICAgIGlmICgnbW9kZWwnIGluIGJvZHkgJiYgJ2FnZW50X2NvbmZpZycgaW4gYm9keSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdlbWluaU5leHRHZW5BUElDbGllbnRFcnJvcihgSW52YWxpZCByZXF1ZXN0OiBzcGVjaWZpZWQgXFxgbW9kZWxcXGAgYW5kIFxcYGFnZW50X2NvbmZpZ1xcYC4gSWYgc3BlY2lmeWluZyBcXGBtb2RlbFxcYCwgdXNlIFxcYGdlbmVyYXRpb25fY29uZmlnXFxgLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnYWdlbnQnIGluIGJvZHkgJiYgJ2dlbmVyYXRpb25fY29uZmlnJyBpbiBib2R5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR2VtaW5pTmV4dEdlbkFQSUNsaWVudEVycm9yKGBJbnZhbGlkIHJlcXVlc3Q6IHNwZWNpZmllZCBcXGBhZ2VudFxcYCBhbmQgXFxgZ2VuZXJhdGlvbl9jb25maWdcXGAuIElmIHNwZWNpZnlpbmcgXFxgYWdlbnRcXGAsIHVzZSBcXGBhZ2VudF9jb25maWdcXGAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KHBhdGggYC8ke2FwaV92ZXJzaW9ufS9pbnRlcmFjdGlvbnNgLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBib2R5IH0sIG9wdGlvbnMpLCB7IHN0cmVhbTogKF9hID0gcGFyYW1zLnN0cmVhbSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBpbnRlcmFjdGlvbiBieSBpZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBpbnRlcmFjdGlvbiA9IGF3YWl0IGNsaWVudC5pbnRlcmFjdGlvbnMuZGVsZXRlKCdpZCcsIHtcbiAgICAgKiAgIGFwaV92ZXJzaW9uOiAnYXBpX3ZlcnNpb24nLFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGRlbGV0ZShpZCwgcGFyYW1zID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBhcGlfdmVyc2lvbiA9IHRoaXMuX2NsaWVudC5hcGlWZXJzaW9uIH0gPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5kZWxldGUocGF0aCBgLyR7YXBpX3ZlcnNpb259L2ludGVyYWN0aW9ucy8ke2lkfWAsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGFuIGludGVyYWN0aW9uIGJ5IGlkLiBUaGlzIG9ubHkgYXBwbGllcyB0byBiYWNrZ3JvdW5kIGludGVyYWN0aW9ucyB0aGF0IGFyZSBzdGlsbCBydW5uaW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGludGVyYWN0aW9uID0gYXdhaXQgY2xpZW50LmludGVyYWN0aW9ucy5jYW5jZWwoJ2lkJywge1xuICAgICAqICAgYXBpX3ZlcnNpb246ICdhcGlfdmVyc2lvbicsXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgY2FuY2VsKGlkLCBwYXJhbXMgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGFwaV92ZXJzaW9uID0gdGhpcy5fY2xpZW50LmFwaVZlcnNpb24gfSA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QocGF0aCBgLyR7YXBpX3ZlcnNpb259L2ludGVyYWN0aW9ucy8ke2lkfS9jYW5jZWxgLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0KGlkLCBwYXJhbXMgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IF9iID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge30sIHsgYXBpX3ZlcnNpb24gPSB0aGlzLl9jbGllbnQuYXBpVmVyc2lvbiB9ID0gX2IsIHF1ZXJ5ID0gX19yZXN0KF9iLCBbXCJhcGlfdmVyc2lvblwiXSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KHBhdGggYC8ke2FwaV92ZXJzaW9ufS9pbnRlcmFjdGlvbnMvJHtpZH1gLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBxdWVyeSB9LCBvcHRpb25zKSwgeyBzdHJlYW06IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5zdHJlYW0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlIH0pKTtcbiAgICB9XG59XG5CYXNlSW50ZXJhY3Rpb25zLl9rZXkgPSBPYmplY3QuZnJlZXplKFsnaW50ZXJhY3Rpb25zJ10pO1xuY2xhc3MgSW50ZXJhY3Rpb25zIGV4dGVuZHMgQmFzZUludGVyYWN0aW9ucyB7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKGJ1ZmZlcnMpIHtcbiAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiBidWZmZXJzKSB7XG4gICAgICAgIGxlbmd0aCArPSBidWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVycykge1xuICAgICAgICBvdXRwdXQuc2V0KGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICBpbmRleCArPSBidWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxubGV0IGVuY29kZVVURjhfO1xuZnVuY3Rpb24gZW5jb2RlVVRGOChzdHIpIHtcbiAgICBsZXQgZW5jb2RlcjtcbiAgICByZXR1cm4gKGVuY29kZVVURjhfICE9PSBudWxsICYmIGVuY29kZVVURjhfICE9PSB2b2lkIDAgPyBlbmNvZGVVVEY4XyA6ICgoZW5jb2RlciA9IG5ldyBnbG9iYWxUaGlzLlRleHRFbmNvZGVyKCkpLCAoZW5jb2RlVVRGOF8gPSBlbmNvZGVyLmVuY29kZS5iaW5kKGVuY29kZXIpKSkpKHN0cik7XG59XG5sZXQgZGVjb2RlVVRGOF87XG5mdW5jdGlvbiBkZWNvZGVVVEY4KGJ5dGVzKSB7XG4gICAgbGV0IGRlY29kZXI7XG4gICAgcmV0dXJuIChkZWNvZGVVVEY4XyAhPT0gbnVsbCAmJiBkZWNvZGVVVEY4XyAhPT0gdm9pZCAwID8gZGVjb2RlVVRGOF8gOiAoKGRlY29kZXIgPSBuZXcgZ2xvYmFsVGhpcy5UZXh0RGVjb2RlcigpKSwgKGRlY29kZVVURjhfID0gZGVjb2Rlci5kZWNvZGUuYmluZChkZWNvZGVyKSkpKShieXRlcyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8qKlxuICogQSByZS1pbXBsZW1lbnRhdGlvbiBvZiBodHRweCdzIGBMaW5lRGVjb2RlcmAgaW4gUHl0aG9uIHRoYXQgaGFuZGxlcyBpbmNyZW1lbnRhbGx5XG4gKiByZWFkaW5nIGxpbmVzIGZyb20gdGV4dC5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZW5jb2RlL2h0dHB4L2Jsb2IvOTIwMzMzZWE5ODExOGU5Y2Y2MTdmMjQ2OTA1ZDdiMjAyNTEwOTQxYy9odHRweC9fZGVjb2RlcnMucHkjTDI1OFxuICovXG5jbGFzcyBMaW5lRGVjb2RlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgdGhpcy5jYXJyaWFnZVJldHVybkluZGV4ID0gbnVsbDtcbiAgICB9XG4gICAgZGVjb2RlKGNodW5rKSB7XG4gICAgICAgIGlmIChjaHVuayA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmluYXJ5Q2h1bmsgPSBjaHVuayBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkoY2h1bmspXG4gICAgICAgICAgICA6IHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgPyBlbmNvZGVVVEY4KGNodW5rKVxuICAgICAgICAgICAgICAgIDogY2h1bms7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gY29uY2F0Qnl0ZXMoW3RoaXMuYnVmZmVyLCBiaW5hcnlDaHVua10pO1xuICAgICAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgICAgICBsZXQgcGF0dGVybkluZGV4O1xuICAgICAgICB3aGlsZSAoKHBhdHRlcm5JbmRleCA9IGZpbmROZXdsaW5lSW5kZXgodGhpcy5idWZmZXIsIHRoaXMuY2FycmlhZ2VSZXR1cm5JbmRleCkpICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuSW5kZXguY2FycmlhZ2UgJiYgdGhpcy5jYXJyaWFnZVJldHVybkluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIHVudGlsIHdlIGVpdGhlciBnZXQgYSBjb3JyZXNwb25kaW5nIGBcXG5gLCBhIG5ldyBgXFxyYCBvciBub3RoaW5nXG4gICAgICAgICAgICAgICAgdGhpcy5jYXJyaWFnZVJldHVybkluZGV4ID0gcGF0dGVybkluZGV4LmluZGV4O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UgZ290IGRvdWJsZSBcXHIgb3IgXFxydGV4dFxcblxuICAgICAgICAgICAgaWYgKHRoaXMuY2FycmlhZ2VSZXR1cm5JbmRleCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgKHBhdHRlcm5JbmRleC5pbmRleCAhPT0gdGhpcy5jYXJyaWFnZVJldHVybkluZGV4ICsgMSB8fCBwYXR0ZXJuSW5kZXguY2FycmlhZ2UpKSB7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChkZWNvZGVVVEY4KHRoaXMuYnVmZmVyLnN1YmFycmF5KDAsIHRoaXMuY2FycmlhZ2VSZXR1cm5JbmRleCAtIDEpKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zdWJhcnJheSh0aGlzLmNhcnJpYWdlUmV0dXJuSW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FycmlhZ2VSZXR1cm5JbmRleCA9IG51bGw7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbmRJbmRleCA9IHRoaXMuY2FycmlhZ2VSZXR1cm5JbmRleCAhPT0gbnVsbCA/IHBhdHRlcm5JbmRleC5wcmVjZWRpbmcgLSAxIDogcGF0dGVybkluZGV4LnByZWNlZGluZztcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBkZWNvZGVVVEY4KHRoaXMuYnVmZmVyLnN1YmFycmF5KDAsIGVuZEluZGV4KSk7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zdWJhcnJheShwYXR0ZXJuSW5kZXguaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5jYXJyaWFnZVJldHVybkluZGV4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuICAgIGZsdXNoKCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZSgnXFxuJyk7XG4gICAgfVxufVxuLy8gcHJldHRpZXItaWdub3JlXG5MaW5lRGVjb2Rlci5ORVdMSU5FX0NIQVJTID0gbmV3IFNldChbJ1xcbicsICdcXHInXSk7XG5MaW5lRGVjb2Rlci5ORVdMSU5FX1JFR0VYUCA9IC9cXHJcXG58W1xcblxccl0vZztcbi8qKlxuICogVGhpcyBmdW5jdGlvbiBzZWFyY2hlcyB0aGUgYnVmZmVyIGZvciB0aGUgZW5kIHBhdHRlcm5zLCAoXFxyIG9yIFxcbilcbiAqIGFuZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBpbmRleCBwcmVjZWRpbmcgdGhlIG1hdGNoZWQgbmV3bGluZSBhbmQgdGhlXG4gKiBpbmRleCBhZnRlciB0aGUgbmV3bGluZSBjaGFyLiBgbnVsbGAgaXMgcmV0dXJuZWQgaWYgbm8gbmV3IGxpbmUgaXMgZm91bmQuXG4gKlxuICogYGBgdHNcbiAqIGZpbmROZXdMaW5lSW5kZXgoJ2FiY1xcbmRlZicpIC0+IHsgcHJlY2VkaW5nOiAyLCBpbmRleDogMyB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZmluZE5ld2xpbmVJbmRleChidWZmZXIsIHN0YXJ0SW5kZXgpIHtcbiAgICBjb25zdCBuZXdsaW5lID0gMHgwYTsgLy8gXFxuXG4gICAgY29uc3QgY2FycmlhZ2UgPSAweDBkOyAvLyBcXHJcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleCAhPT0gbnVsbCAmJiBzdGFydEluZGV4ICE9PSB2b2lkIDAgPyBzdGFydEluZGV4IDogMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYnVmZmVyW2ldID09PSBuZXdsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwcmVjZWRpbmc6IGksIGluZGV4OiBpICsgMSwgY2FycmlhZ2U6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gY2FycmlhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHByZWNlZGluZzogaSwgaW5kZXg6IGkgKyAxLCBjYXJyaWFnZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZERvdWJsZU5ld2xpbmVJbmRleChidWZmZXIpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHNlYXJjaGVzIHRoZSBidWZmZXIgZm9yIHRoZSBlbmQgcGF0dGVybnMgKFxcclxcciwgXFxuXFxuLCBcXHJcXG5cXHJcXG4pXG4gICAgLy8gYW5kIHJldHVybnMgdGhlIGluZGV4IHJpZ2h0IGFmdGVyIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFueSBwYXR0ZXJuLFxuICAgIC8vIG9yIC0xIGlmIG5vbmUgb2YgdGhlIHBhdHRlcm5zIGFyZSBmb3VuZC5cbiAgICBjb25zdCBuZXdsaW5lID0gMHgwYTsgLy8gXFxuXG4gICAgY29uc3QgY2FycmlhZ2UgPSAweDBkOyAvLyBcXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gbmV3bGluZSAmJiBidWZmZXJbaSArIDFdID09PSBuZXdsaW5lKSB7XG4gICAgICAgICAgICAvLyBcXG5cXG5cbiAgICAgICAgICAgIHJldHVybiBpICsgMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZmVyW2ldID09PSBjYXJyaWFnZSAmJiBidWZmZXJbaSArIDFdID09PSBjYXJyaWFnZSkge1xuICAgICAgICAgICAgLy8gXFxyXFxyXG4gICAgICAgICAgICByZXR1cm4gaSArIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gY2FycmlhZ2UgJiZcbiAgICAgICAgICAgIGJ1ZmZlcltpICsgMV0gPT09IG5ld2xpbmUgJiZcbiAgICAgICAgICAgIGkgKyAzIDwgYnVmZmVyLmxlbmd0aCAmJlxuICAgICAgICAgICAgYnVmZmVyW2kgKyAyXSA9PT0gY2FycmlhZ2UgJiZcbiAgICAgICAgICAgIGJ1ZmZlcltpICsgM10gPT09IG5ld2xpbmUpIHtcbiAgICAgICAgICAgIC8vIFxcclxcblxcclxcblxuICAgICAgICAgICAgcmV0dXJuIGkgKyA0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmNvbnN0IGxldmVsTnVtYmVycyA9IHtcbiAgICBvZmY6IDAsXG4gICAgZXJyb3I6IDIwMCxcbiAgICB3YXJuOiAzMDAsXG4gICAgaW5mbzogNDAwLFxuICAgIGRlYnVnOiA1MDAsXG59O1xuY29uc3QgcGFyc2VMb2dMZXZlbCA9IChtYXliZUxldmVsLCBzb3VyY2VOYW1lLCBjbGllbnQpID0+IHtcbiAgICBpZiAoIW1heWJlTGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGhhc093bihsZXZlbE51bWJlcnMsIG1heWJlTGV2ZWwpKSB7XG4gICAgICAgIHJldHVybiBtYXliZUxldmVsO1xuICAgIH1cbiAgICBsb2dnZXJGb3IoY2xpZW50KS53YXJuKGAke3NvdXJjZU5hbWV9IHdhcyBzZXQgdG8gJHtKU09OLnN0cmluZ2lmeShtYXliZUxldmVsKX0sIGV4cGVjdGVkIG9uZSBvZiAke0pTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKGxldmVsTnVtYmVycykpfWApO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxuZnVuY3Rpb24gbWFrZUxvZ0ZuKGZuTGV2ZWwsIGxvZ2dlciwgbG9nTGV2ZWwpIHtcbiAgICBpZiAoIWxvZ2dlciB8fCBsZXZlbE51bWJlcnNbZm5MZXZlbF0gPiBsZXZlbE51bWJlcnNbbG9nTGV2ZWxdKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gRG9uJ3Qgd3JhcCBsb2dnZXIgZnVuY3Rpb25zLCB3ZSB3YW50IHRoZSBzdGFja3RyYWNlIGludGFjdCFcbiAgICAgICAgcmV0dXJuIGxvZ2dlcltmbkxldmVsXS5iaW5kKGxvZ2dlcik7XG4gICAgfVxufVxuY29uc3Qgbm9vcExvZ2dlciA9IHtcbiAgICBlcnJvcjogbm9vcCxcbiAgICB3YXJuOiBub29wLFxuICAgIGluZm86IG5vb3AsXG4gICAgZGVidWc6IG5vb3AsXG59O1xubGV0IGNhY2hlZExvZ2dlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGxvZ2dlckZvcihjbGllbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbG9nZ2VyID0gY2xpZW50LmxvZ2dlcjtcbiAgICBjb25zdCBsb2dMZXZlbCA9IChfYSA9IGNsaWVudC5sb2dMZXZlbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ29mZic7XG4gICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgcmV0dXJuIG5vb3BMb2dnZXI7XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlZExvZ2dlciA9IGNhY2hlZExvZ2dlcnMuZ2V0KGxvZ2dlcik7XG4gICAgaWYgKGNhY2hlZExvZ2dlciAmJiBjYWNoZWRMb2dnZXJbMF0gPT09IGxvZ0xldmVsKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRMb2dnZXJbMV07XG4gICAgfVxuICAgIGNvbnN0IGxldmVsTG9nZ2VyID0ge1xuICAgICAgICBlcnJvcjogbWFrZUxvZ0ZuKCdlcnJvcicsIGxvZ2dlciwgbG9nTGV2ZWwpLFxuICAgICAgICB3YXJuOiBtYWtlTG9nRm4oJ3dhcm4nLCBsb2dnZXIsIGxvZ0xldmVsKSxcbiAgICAgICAgaW5mbzogbWFrZUxvZ0ZuKCdpbmZvJywgbG9nZ2VyLCBsb2dMZXZlbCksXG4gICAgICAgIGRlYnVnOiBtYWtlTG9nRm4oJ2RlYnVnJywgbG9nZ2VyLCBsb2dMZXZlbCksXG4gICAgfTtcbiAgICBjYWNoZWRMb2dnZXJzLnNldChsb2dnZXIsIFtsb2dMZXZlbCwgbGV2ZWxMb2dnZXJdKTtcbiAgICByZXR1cm4gbGV2ZWxMb2dnZXI7XG59XG5jb25zdCBmb3JtYXRSZXF1ZXN0RGV0YWlscyA9IChkZXRhaWxzKSA9PiB7XG4gICAgaWYgKGRldGFpbHMub3B0aW9ucykge1xuICAgICAgICBkZXRhaWxzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZXRhaWxzLm9wdGlvbnMpO1xuICAgICAgICBkZWxldGUgZGV0YWlscy5vcHRpb25zWydoZWFkZXJzJ107IC8vIHJlZHVuZGFudCArIGxlYWtzIGludGVybmFsc1xuICAgIH1cbiAgICBpZiAoZGV0YWlscy5oZWFkZXJzKSB7XG4gICAgICAgIGRldGFpbHMuaGVhZGVycyA9IE9iamVjdC5mcm9tRW50cmllcygoZGV0YWlscy5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycyA/IFsuLi5kZXRhaWxzLmhlYWRlcnNdIDogT2JqZWN0LmVudHJpZXMoZGV0YWlscy5oZWFkZXJzKSkubWFwKChbbmFtZSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgKG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3gtZ29vZy1hcGkta2V5JyB8fFxuICAgICAgICAgICAgICAgIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2F1dGhvcml6YXRpb24nIHx8XG4gICAgICAgICAgICAgICAgbmFtZS50b0xvd2VyQ2FzZSgpID09PSAnY29va2llJyB8fFxuICAgICAgICAgICAgICAgIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NldC1jb29raWUnKSA/XG4gICAgICAgICAgICAgICAgJyoqKidcbiAgICAgICAgICAgICAgICA6IHZhbHVlLFxuICAgICAgICBdKSk7XG4gICAgfVxuICAgIGlmICgncmV0cnlPZlJlcXVlc3RMb2dJRCcgaW4gZGV0YWlscykge1xuICAgICAgICBpZiAoZGV0YWlscy5yZXRyeU9mUmVxdWVzdExvZ0lEKSB7XG4gICAgICAgICAgICBkZXRhaWxzLnJldHJ5T2YgPSBkZXRhaWxzLnJldHJ5T2ZSZXF1ZXN0TG9nSUQ7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGRldGFpbHMucmV0cnlPZlJlcXVlc3RMb2dJRDtcbiAgICB9XG4gICAgcmV0dXJuIGRldGFpbHM7XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKGl0ZXJhdG9yLCBjb250cm9sbGVyLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5pdGVyYXRvciA9IGl0ZXJhdG9yO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TU0VSZXNwb25zZShyZXNwb25zZSwgY29udHJvbGxlciwgY2xpZW50KSB7XG4gICAgICAgIGxldCBjb25zdW1lZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBsb2dnZXIgPSBjbGllbnQgPyBsb2dnZXJGb3IoY2xpZW50KSA6IGNvbnNvbGU7XG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogaXRlcmF0b3JfMSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIGlmIChjb25zdW1lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR2VtaW5pTmV4dEdlbkFQSUNsaWVudEVycm9yKCdDYW5ub3QgaXRlcmF0ZSBvdmVyIGEgY29uc3VtZWQgc3RyZWFtLCB1c2UgYC50ZWUoKWAgdG8gc3BsaXQgdGhlIHN0cmVhbS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3VtZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgX2UgPSBfX2FzeW5jVmFsdWVzKF9pdGVyU1NFTWVzc2FnZXMocmVzcG9uc2UsIGNvbnRyb2xsZXIpKSwgX2Y7IF9mID0geWllbGQgX19hd2FpdChfZS5uZXh0KCkpLCBfYSA9IF9mLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBfZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNzZSA9IF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3NlLmRhdGEuc3RhcnRzV2l0aCgnW0RPTkVdJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoSlNPTi5wYXJzZShzc2UuZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYENvdWxkIG5vdCBwYXJzZSBtZXNzYWdlIGludG8gSlNPTjpgLCBzc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEZyb20gY2h1bms6YCwgc3NlLnJhdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBfZS5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoX2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgY2FsbHMgYHN0cmVhbS5jb250cm9sbGVyLmFib3J0KClgLCB3ZSBzaG91bGQgZXhpdCB3aXRob3V0IHRocm93aW5nLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBYm9ydEVycm9yKGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIF9fYXdhaXQodm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGBicmVha2BzLCBhYm9ydCB0aGUgb25nb2luZyByZXF1ZXN0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oaXRlcmF0b3IsIGNvbnRyb2xsZXIsIGNsaWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFN0cmVhbSBmcm9tIGEgbmV3bGluZS1zZXBhcmF0ZWQgUmVhZGFibGVTdHJlYW1cbiAgICAgKiB3aGVyZSBlYWNoIGl0ZW0gaXMgYSBKU09OIHZhbHVlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0sIGNvbnRyb2xsZXIsIGNsaWVudCkge1xuICAgICAgICBsZXQgY29uc3VtZWQgPSBmYWxzZTtcbiAgICAgICAgZnVuY3Rpb24gaXRlckxpbmVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogaXRlckxpbmVzXzEoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBlXzIsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lRGVjb2RlciA9IG5ldyBMaW5lRGVjb2RlcigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZXIgPSBSZWFkYWJsZVN0cmVhbVRvQXN5bmNJdGVyYWJsZShyZWFkYWJsZVN0cmVhbSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyXzEgPSBfX2FzeW5jVmFsdWVzKGl0ZXIpLCBpdGVyXzFfMTsgaXRlcl8xXzEgPSB5aWVsZCBfX2F3YWl0KGl0ZXJfMS5uZXh0KCkpLCBfYSA9IGl0ZXJfMV8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYyA9IGl0ZXJfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZURlY29kZXIuZGVjb2RlKGNodW5rKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQobGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJfMS5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoaXRlcl8xKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZURlY29kZXIuZmx1c2goKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KGxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogaXRlcmF0b3JfMigpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIGVfMywgX2IsIF9jO1xuICAgICAgICAgICAgICAgIGlmIChjb25zdW1lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR2VtaW5pTmV4dEdlbkFQSUNsaWVudEVycm9yKCdDYW5ub3QgaXRlcmF0ZSBvdmVyIGEgY29uc3VtZWQgc3RyZWFtLCB1c2UgYC50ZWUoKWAgdG8gc3BsaXQgdGhlIHN0cmVhbS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3VtZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgX2UgPSBfX2FzeW5jVmFsdWVzKGl0ZXJMaW5lcygpKSwgX2Y7IF9mID0geWllbGQgX19hd2FpdChfZS5uZXh0KCkpLCBfYSA9IF9mLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBfZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KEpTT04ucGFyc2UobGluZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBfZS5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoX2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgY2FsbHMgYHN0cmVhbS5jb250cm9sbGVyLmFib3J0KClgLCB3ZSBzaG91bGQgZXhpdCB3aXRob3V0IHRocm93aW5nLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBYm9ydEVycm9yKGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIF9fYXdhaXQodm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGBicmVha2BzLCBhYm9ydCB0aGUgb25nb2luZyByZXF1ZXN0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oaXRlcmF0b3IsIGNvbnRyb2xsZXIsIGNsaWVudCk7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwbGl0cyB0aGUgc3RyZWFtIGludG8gdHdvIHN0cmVhbXMgd2hpY2ggY2FuIGJlXG4gICAgICogaW5kZXBlbmRlbnRseSByZWFkIGZyb20gYXQgZGlmZmVyZW50IHNwZWVkcy5cbiAgICAgKi9cbiAgICB0ZWUoKSB7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBbXTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBbXTtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgICAgIGNvbnN0IHRlZUl0ZXJhdG9yID0gKHF1ZXVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdC5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodC5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgU3RyZWFtKCgpID0+IHRlZUl0ZXJhdG9yKGxlZnQpLCB0aGlzLmNvbnRyb2xsZXIsIHRoaXMuY2xpZW50KSxcbiAgICAgICAgICAgIG5ldyBTdHJlYW0oKCkgPT4gdGVlSXRlcmF0b3IocmlnaHQpLCB0aGlzLmNvbnRyb2xsZXIsIHRoaXMuY2xpZW50KSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBzdHJlYW0gdG8gYSBuZXdsaW5lLXNlcGFyYXRlZCBSZWFkYWJsZVN0cmVhbSBvZlxuICAgICAqIEpTT04gc3RyaW5naWZpZWQgdmFsdWVzIGluIHRoZSBzdHJlYW1cbiAgICAgKiB3aGljaCBjYW4gYmUgdHVybmVkIGJhY2sgaW50byBhIFN0cmVhbSB3aXRoIGBTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtKClgLlxuICAgICAqL1xuICAgIHRvUmVhZGFibGVTdHJlYW0oKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgaXRlcjtcbiAgICAgICAgcmV0dXJuIG1ha2VSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgICAgICAgICBpdGVyID0gc2VsZltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyBwdWxsKGN0cmwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBpdGVyLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3RybC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IGVuY29kZVVURjgoSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmVucXVldWUoYnl0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgY2FuY2VsKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBhd2FpdCAoKF9hID0gaXRlci5yZXR1cm4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGl0ZXIpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9pdGVyU1NFTWVzc2FnZXMocmVzcG9uc2UsIGNvbnRyb2xsZXIpIHtcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBfaXRlclNTRU1lc3NhZ2VzXzEoKSB7XG4gICAgICAgIHZhciBfYSwgZV80LCBfYiwgX2M7XG4gICAgICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLm5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLm5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEdlbWluaU5leHRHZW5BUElDbGllbnRFcnJvcihgVGhlIGRlZmF1bHQgcmVhY3QtbmF0aXZlIGZldGNoIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IHN1cHBvcnQgc3RyZWFtaW5nLiBQbGVhc2UgdXNlIGV4cG8vZmV0Y2g6IGh0dHBzOi8vZG9jcy5leHBvLmRldi92ZXJzaW9ucy9sYXRlc3Qvc2RrL2V4cG8vI2V4cG9mZXRjaC1hcGlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBHZW1pbmlOZXh0R2VuQVBJQ2xpZW50RXJyb3IoYEF0dGVtcHRlZCB0byBpdGVyYXRlIG92ZXIgYSByZXNwb25zZSB3aXRoIG5vIGJvZHlgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzc2VEZWNvZGVyID0gbmV3IFNTRURlY29kZXIoKTtcbiAgICAgICAgY29uc3QgbGluZURlY29kZXIgPSBuZXcgTGluZURlY29kZXIoKTtcbiAgICAgICAgY29uc3QgaXRlciA9IFJlYWRhYmxlU3RyZWFtVG9Bc3luY0l0ZXJhYmxlKHJlc3BvbnNlLmJvZHkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBfZSA9IF9fYXN5bmNWYWx1ZXMoaXRlclNTRUNodW5rcyhpdGVyKSksIF9mOyBfZiA9IHlpZWxkIF9fYXdhaXQoX2UubmV4dCgpKSwgX2EgPSBfZi5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF9jID0gX2YudmFsdWU7XG4gICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzc2VDaHVuayA9IF9jO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lRGVjb2Rlci5kZWNvZGUoc3NlQ2h1bmspKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNzZSA9IHNzZURlY29kZXIuZGVjb2RlKGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3NlKVxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChzc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV80XzEpIHsgZV80ID0geyBlcnJvcjogZV80XzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gX2UucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKF9lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVEZWNvZGVyLmZsdXNoKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNzZSA9IHNzZURlY29kZXIuZGVjb2RlKGxpbmUpO1xuICAgICAgICAgICAgaWYgKHNzZSlcbiAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHNzZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogR2l2ZW4gYW4gYXN5bmMgaXRlcmFibGUgaXRlcmF0b3IsIGl0ZXJhdGVzIG92ZXIgaXQgYW5kIHlpZWxkcyBmdWxsXG4gKiBTU0UgY2h1bmtzLCBpLmUuIHlpZWxkcyB3aGVuIGEgZG91YmxlIG5ldy1saW5lIGlzIGVuY291bnRlcmVkLlxuICovXG5mdW5jdGlvbiBpdGVyU1NFQ2h1bmtzKGl0ZXJhdG9yKSB7XG4gICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogaXRlclNTRUNodW5rc18xKCkge1xuICAgICAgICB2YXIgX2EsIGVfNSwgX2IsIF9jO1xuICAgICAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGl0ZXJhdG9yXzMgPSBfX2FzeW5jVmFsdWVzKGl0ZXJhdG9yKSwgaXRlcmF0b3JfM18xOyBpdGVyYXRvcl8zXzEgPSB5aWVsZCBfX2F3YWl0KGl0ZXJhdG9yXzMubmV4dCgpKSwgX2EgPSBpdGVyYXRvcl8zXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhdG9yXzNfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJpbmFyeUNodW5rID0gY2h1bmsgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IG5ldyBVaW50OEFycmF5KGNodW5rKVxuICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgPyBlbmNvZGVVVEY4KGNodW5rKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjaHVuaztcbiAgICAgICAgICAgICAgICBsZXQgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgYmluYXJ5Q2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBuZXdEYXRhLnNldChkYXRhKTtcbiAgICAgICAgICAgICAgICBuZXdEYXRhLnNldChiaW5hcnlDaHVuaywgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBuZXdEYXRhO1xuICAgICAgICAgICAgICAgIGxldCBwYXR0ZXJuSW5kZXg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChwYXR0ZXJuSW5kZXggPSBmaW5kRG91YmxlTmV3bGluZUluZGV4KGRhdGEpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChkYXRhLnNsaWNlKDAsIHBhdHRlcm5JbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zbGljZShwYXR0ZXJuSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV81XzEpIHsgZV81ID0geyBlcnJvcjogZV81XzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gaXRlcmF0b3JfMy5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoaXRlcmF0b3JfMykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNsYXNzIFNTRURlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmV2ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgfVxuICAgIGRlY29kZShsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLmVuZHNXaXRoKCdcXHInKSkge1xuICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyaW5nKDAsIGxpbmUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSBsaW5lIGFuZCB3ZSBkaWRuJ3QgcHJldmlvdXNseSBlbmNvdW50ZXIgYW55IG1lc3NhZ2VzXG4gICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnQgJiYgIXRoaXMuZGF0YS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCBzc2UgPSB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgICAgIHJhdzogdGhpcy5jaHVua3MsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5ldmVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgICAgICByZXR1cm4gc3NlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2gobGluZSk7XG4gICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJzonKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFtmaWVsZG5hbWUsIF8sIHZhbHVlXSA9IHBhcnRpdGlvbihsaW5lLCAnOicpO1xuICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnICcpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRuYW1lID09PSAnZXZlbnQnKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGRuYW1lID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJ0aXRpb24oc3RyLCBkZWxpbWl0ZXIpIHtcbiAgICBjb25zdCBpbmRleCA9IHN0ci5pbmRleE9mKGRlbGltaXRlcik7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gW3N0ci5zdWJzdHJpbmcoMCwgaW5kZXgpLCBkZWxpbWl0ZXIsIHN0ci5zdWJzdHJpbmcoaW5kZXggKyBkZWxpbWl0ZXIubGVuZ3RoKV07XG4gICAgfVxuICAgIHJldHVybiBbc3RyLCAnJywgJyddO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5hc3luYyBmdW5jdGlvbiBkZWZhdWx0UGFyc2VSZXNwb25zZShjbGllbnQsIHByb3BzKSB7XG4gICAgY29uc3QgeyByZXNwb25zZSwgcmVxdWVzdExvZ0lELCByZXRyeU9mUmVxdWVzdExvZ0lELCBzdGFydFRpbWUgfSA9IHByb3BzO1xuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChwcm9wcy5vcHRpb25zLnN0cmVhbSkge1xuICAgICAgICAgICAgbG9nZ2VyRm9yKGNsaWVudCkuZGVidWcoJ3Jlc3BvbnNlJywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS51cmwsIHJlc3BvbnNlLmhlYWRlcnMsIHJlc3BvbnNlLmJvZHkpO1xuICAgICAgICAgICAgLy8gTm90ZTogdGhlcmUgaXMgYW4gaW52YXJpYW50IGhlcmUgdGhhdCBpc24ndCByZXByZXNlbnRlZCBpbiB0aGUgdHlwZSBzeXN0ZW1cbiAgICAgICAgICAgIC8vIHRoYXQgaWYgeW91IHNldCBgc3RyZWFtOiB0cnVlYCB0aGUgcmVzcG9uc2UgdHlwZSBtdXN0IGFsc28gYmUgYFN0cmVhbTxUPmBcbiAgICAgICAgICAgIGlmIChwcm9wcy5vcHRpb25zLl9fc3RyZWFtQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMub3B0aW9ucy5fX3N0cmVhbUNsYXNzLmZyb21TU0VSZXNwb25zZShyZXNwb25zZSwgcHJvcHMuY29udHJvbGxlciwgY2xpZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTdHJlYW0uZnJvbVNTRVJlc3BvbnNlKHJlc3BvbnNlLCBwcm9wcy5jb250cm9sbGVyLCBjbGllbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZldGNoIHJlZnVzZXMgdG8gcmVhZCB0aGUgYm9keSB3aGVuIHRoZSBzdGF0dXMgY29kZSBpcyAyMDQuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLm9wdGlvbnMuX19iaW5hcnlSZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuICAgICAgICBjb25zdCBtZWRpYVR5cGUgPSAoX2EgPSBjb250ZW50VHlwZSA9PT0gbnVsbCB8fCBjb250ZW50VHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGVudFR5cGUuc3BsaXQoJzsnKVswXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRyaW0oKTtcbiAgICAgICAgY29uc3QgaXNKU09OID0gKG1lZGlhVHlwZSA9PT0gbnVsbCB8fCBtZWRpYVR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lZGlhVHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB8fCAobWVkaWFUeXBlID09PSBudWxsIHx8IG1lZGlhVHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVkaWFUeXBlLmVuZHNXaXRoKCcranNvbicpKTtcbiAgICAgICAgaWYgKGlzSlNPTikge1xuICAgICAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LWxlbmd0aCcpO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPT09ICcwJykge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGNvbnRlbnQgd2UgY2FuJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH0pKCk7XG4gICAgbG9nZ2VyRm9yKGNsaWVudCkuZGVidWcoYFske3JlcXVlc3RMb2dJRH1dIHJlc3BvbnNlIHBhcnNlZGAsIGZvcm1hdFJlcXVlc3REZXRhaWxzKHtcbiAgICAgICAgcmV0cnlPZlJlcXVlc3RMb2dJRCxcbiAgICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBib2R5LFxuICAgICAgICBkdXJhdGlvbk1zOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgIH0pKTtcbiAgICByZXR1cm4gYm9keTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBBIHN1YmNsYXNzIG9mIGBQcm9taXNlYCBwcm92aWRpbmcgYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kc1xuICogZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIFNESy5cbiAqL1xuY2xhc3MgQVBJUHJvbWlzZSBleHRlbmRzIFByb21pc2Uge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCwgcmVzcG9uc2VQcm9taXNlLCBwYXJzZVJlc3BvbnNlID0gZGVmYXVsdFBhcnNlUmVzcG9uc2UpIHtcbiAgICAgICAgc3VwZXIoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbWF5YmUgYSBiaXQgd2VpcmQgYnV0IHRoaXMgaGFzIHRvIGJlIGEgbm8tb3AgdG8gbm90IGltcGxpY2l0bHlcbiAgICAgICAgICAgIC8vIHBhcnNlIHRoZSByZXNwb25zZSBib2R5OyBpbnN0ZWFkIC50aGVuLCAuY2F0Y2gsIC5maW5hbGx5IGFyZSBvdmVycmlkZGVuXG4gICAgICAgICAgICAvLyB0byBwYXJzZSB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlc3BvbnNlUHJvbWlzZSA9IHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgdGhpcy5wYXJzZVJlc3BvbnNlID0gcGFyc2VSZXNwb25zZTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIF90aGVuVW53cmFwKHRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gbmV3IEFQSVByb21pc2UodGhpcy5jbGllbnQsIHRoaXMucmVzcG9uc2VQcm9taXNlLCBhc3luYyAoY2xpZW50LCBwcm9wcykgPT4gdHJhbnNmb3JtKGF3YWl0IHRoaXMucGFyc2VSZXNwb25zZShjbGllbnQsIHByb3BzKSwgcHJvcHMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcmF3IGBSZXNwb25zZWAgaW5zdGFuY2UgaW5zdGVhZCBvZiBwYXJzaW5nIHRoZSByZXNwb25zZVxuICAgICAqIGRhdGEuXG4gICAgICpcbiAgICAgKiBJZiB5b3Ugd2FudCB0byBwYXJzZSB0aGUgcmVzcG9uc2UgYm9keSBidXQgc3RpbGwgZ2V0IHRoZSBgUmVzcG9uc2VgXG4gICAgICogaW5zdGFuY2UsIHlvdSBjYW4gdXNlIHtAbGluayB3aXRoUmVzcG9uc2UoKX0uXG4gICAgICpcbiAgICAgKiDwn5GLIEdldHRpbmcgdGhlIHdyb25nIFR5cGVTY3JpcHQgdHlwZSBmb3IgYFJlc3BvbnNlYD9cbiAgICAgKiBUcnkgc2V0dGluZyBgXCJtb2R1bGVSZXNvbHV0aW9uXCI6IFwiTm9kZU5leHRcImAgb3IgYWRkIGBcImxpYlwiOiBbXCJET01cIl1gXG4gICAgICogdG8geW91ciBgdHNjb25maWcuanNvbmAuXG4gICAgICovXG4gICAgYXNSZXNwb25zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VQcm9taXNlLnRoZW4oKHApID0+IHAucmVzcG9uc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwYXJzZWQgcmVzcG9uc2UgZGF0YSBhbmQgdGhlIHJhdyBgUmVzcG9uc2VgIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogSWYgeW91IGp1c3Qgd2FudCB0byBnZXQgdGhlIHJhdyBgUmVzcG9uc2VgIGluc3RhbmNlIHdpdGhvdXQgcGFyc2luZyBpdCxcbiAgICAgKiB5b3UgY2FuIHVzZSB7QGxpbmsgYXNSZXNwb25zZSgpfS5cbiAgICAgKlxuICAgICAqIPCfkYsgR2V0dGluZyB0aGUgd3JvbmcgVHlwZVNjcmlwdCB0eXBlIGZvciBgUmVzcG9uc2VgP1xuICAgICAqIFRyeSBzZXR0aW5nIGBcIm1vZHVsZVJlc29sdXRpb25cIjogXCJOb2RlTmV4dFwiYCBvciBhZGQgYFwibGliXCI6IFtcIkRPTVwiXWBcbiAgICAgKiB0byB5b3VyIGB0c2NvbmZpZy5qc29uYC5cbiAgICAgKi9cbiAgICBhc3luYyB3aXRoUmVzcG9uc2UoKSB7XG4gICAgICAgIGNvbnN0IFtkYXRhLCByZXNwb25zZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5wYXJzZSgpLCB0aGlzLmFzUmVzcG9uc2UoKV0pO1xuICAgICAgICByZXR1cm4geyBkYXRhLCByZXNwb25zZSB9O1xuICAgIH1cbiAgICBwYXJzZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcnNlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VkUHJvbWlzZSA9IHRoaXMucmVzcG9uc2VQcm9taXNlLnRoZW4oKGRhdGEpID0+IHRoaXMucGFyc2VSZXNwb25zZSh0aGlzLmNsaWVudCwgZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlZFByb21pc2U7XG4gICAgfVxuICAgIHRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcbiAgICB9XG4gICAgY2F0Y2gob25yZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZSgpLmNhdGNoKG9ucmVqZWN0ZWQpO1xuICAgIH1cbiAgICBmaW5hbGx5KG9uZmluYWxseSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZSgpLmZpbmFsbHkob25maW5hbGx5KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5jb25zdCBicmFuZF9wcml2YXRlTnVsbGFibGVIZWFkZXJzID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCgnYnJhbmQucHJpdmF0ZU51bGxhYmxlSGVhZGVycycpO1xuZnVuY3Rpb24qIGl0ZXJhdGVIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICBpZiAoIWhlYWRlcnMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoYnJhbmRfcHJpdmF0ZU51bGxhYmxlSGVhZGVycyBpbiBoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWVzLCBudWxscyB9ID0gaGVhZGVycztcbiAgICAgICAgeWllbGQqIHZhbHVlcy5lbnRyaWVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBudWxscykge1xuICAgICAgICAgICAgeWllbGQgW25hbWUsIG51bGxdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHNob3VsZENsZWFyID0gZmFsc2U7XG4gICAgbGV0IGl0ZXI7XG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICAgIGl0ZXIgPSBoZWFkZXJzLmVudHJpZXMoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNSZWFkb25seUFycmF5KGhlYWRlcnMpKSB7XG4gICAgICAgIGl0ZXIgPSBoZWFkZXJzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2hvdWxkQ2xlYXIgPSB0cnVlO1xuICAgICAgICBpdGVyID0gT2JqZWN0LmVudHJpZXMoaGVhZGVycyAhPT0gbnVsbCAmJiBoZWFkZXJzICE9PSB2b2lkIDAgPyBoZWFkZXJzIDoge30pO1xuICAgIH1cbiAgICBmb3IgKGxldCByb3cgb2YgaXRlcikge1xuICAgICAgICBjb25zdCBuYW1lID0gcm93WzBdO1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgaGVhZGVyIG5hbWUgdG8gYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gaXNSZWFkb25seUFycmF5KHJvd1sxXSkgPyByb3dbMV0gOiBbcm93WzFdXTtcbiAgICAgICAgbGV0IGRpZENsZWFyID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIE9iamVjdHMga2V5cyBhbHdheXMgb3ZlcndyaXRlIG9sZGVyIGhlYWRlcnMsIHRoZXkgbmV2ZXIgYXBwZW5kLlxuICAgICAgICAgICAgLy8gWWllbGQgYSBudWxsIHRvIGNsZWFyIHRoZSBoZWFkZXIgYmVmb3JlIGFkZGluZyB0aGUgbmV3IHZhbHVlcy5cbiAgICAgICAgICAgIGlmIChzaG91bGRDbGVhciAmJiAhZGlkQ2xlYXIpIHtcbiAgICAgICAgICAgICAgICBkaWRDbGVhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgeWllbGQgW25hbWUsIG51bGxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgW25hbWUsIHZhbHVlXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGJ1aWxkSGVhZGVycyA9IChuZXdIZWFkZXJzKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0SGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgY29uc3QgbnVsbEhlYWRlcnMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBoZWFkZXJzIG9mIG5ld0hlYWRlcnMpIHtcbiAgICAgICAgY29uc3Qgc2VlbkhlYWRlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBpdGVyYXRlSGVhZGVycyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgY29uc3QgbG93ZXJOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKCFzZWVuSGVhZGVycy5oYXMobG93ZXJOYW1lKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldEhlYWRlcnMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgICAgIHNlZW5IZWFkZXJzLmFkZChsb3dlck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SGVhZGVycy5kZWxldGUobmFtZSk7XG4gICAgICAgICAgICAgICAgbnVsbEhlYWRlcnMuYWRkKGxvd2VyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRIZWFkZXJzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgbnVsbEhlYWRlcnMuZGVsZXRlKGxvd2VyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgW2JyYW5kX3ByaXZhdGVOdWxsYWJsZUhlYWRlcnNdOiB0cnVlLCB2YWx1ZXM6IHRhcmdldEhlYWRlcnMsIG51bGxzOiBudWxsSGVhZGVycyB9O1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbi8qKlxuICogUmVhZCBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAqXG4gKiBUcmltcyBiZWdpbm5pbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuXG4gKlxuICogV2lsbCByZXR1cm4gdW5kZWZpbmVkIGlmIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBkb2Vzbid0IGV4aXN0IG9yIGNhbm5vdCBiZSBhY2Nlc3NlZC5cbiAqL1xuY29uc3QgcmVhZEVudiA9IChlbnYpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMucHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIChfYyA9IChfYiA9IChfYSA9IGdsb2JhbFRoaXMucHJvY2Vzcy5lbnYpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtlbnZdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudHJpbSgpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5EZW5vICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gKF9mID0gKF9lID0gKF9kID0gZ2xvYmFsVGhpcy5EZW5vLmVudikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmdldCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwoX2QsIGVudikpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi50cmltKCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG52YXIgX2E7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIEdlbWluaSBOZXh0IEdlbiBBUEkgQVBJIGNsaWVudHMuXG4gKi9cbmNsYXNzIEJhc2VHZW1pbmlOZXh0R2VuQVBJQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBBUEkgQ2xpZW50IGZvciBpbnRlcmZhY2luZyB3aXRoIHRoZSBHZW1pbmkgTmV4dCBHZW4gQVBJIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdHMuYXBpS2V5PXByb2Nlc3MuZW52WydHRU1JTklfQVBJX0tFWSddID8/IG51bGxdXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtvcHRzLmFwaVZlcnNpb249djFiZXRhXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYXNlVVJMPXByb2Nlc3MuZW52WydHRU1JTklfTkVYVF9HRU5fQVBJX0JBU0VfVVJMJ10gPz8gaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb21dIC0gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmFzZSBVUkwgZm9yIHRoZSBBUEkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVvdXQ9MSBtaW51dGVdIC0gVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdGhlIGNsaWVudCB3aWxsIHdhaXQgZm9yIGEgcmVzcG9uc2UgYmVmb3JlIHRpbWluZyBvdXQuXG4gICAgICogQHBhcmFtIHtNZXJnZWRSZXF1ZXN0SW5pdH0gW29wdHMuZmV0Y2hPcHRpb25zXSAtIEFkZGl0aW9uYWwgYFJlcXVlc3RJbml0YCBvcHRpb25zIHRvIGJlIHBhc3NlZCB0byBgZmV0Y2hgIGNhbGxzLlxuICAgICAqIEBwYXJhbSB7RmV0Y2h9IFtvcHRzLmZldGNoXSAtIFNwZWNpZnkgYSBjdXN0b20gYGZldGNoYCBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMubWF4UmV0cmllcz0yXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyB0aGUgY2xpZW50IHdpbGwgcmV0cnkgYSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7SGVhZGVyc0xpa2V9IG9wdHMuZGVmYXVsdEhlYWRlcnMgLSBEZWZhdWx0IGhlYWRlcnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IHJlcXVlc3QgdG8gdGhlIEFQSS5cbiAgICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD59IG9wdHMuZGVmYXVsdFF1ZXJ5IC0gRGVmYXVsdCBxdWVyeSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgd2l0aCBldmVyeSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX2IpIHtcbiAgICAgICAgdmFyIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuICAgICAgICB2YXIgeyBiYXNlVVJMID0gcmVhZEVudignR0VNSU5JX05FWFRfR0VOX0FQSV9CQVNFX1VSTCcpLCBhcGlLZXkgPSAoX2MgPSByZWFkRW52KCdHRU1JTklfQVBJX0tFWScpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsLCBhcGlWZXJzaW9uID0gJ3YxYmV0YScgfSA9IF9iLCBvcHRzID0gX19yZXN0KF9iLCBbXCJiYXNlVVJMXCIsIFwiYXBpS2V5XCIsIFwiYXBpVmVyc2lvblwiXSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBhcGlLZXksXG4gICAgICAgICAgICBhcGlWZXJzaW9uIH0sIG9wdHMpLCB7IGJhc2VVUkw6IGJhc2VVUkwgfHwgYGh0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tYCB9KTtcbiAgICAgICAgdGhpcy5iYXNlVVJMID0gb3B0aW9ucy5iYXNlVVJMO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSAoX2QgPSBvcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IEJhc2VHZW1pbmlOZXh0R2VuQVBJQ2xpZW50LkRFRkFVTFRfVElNRU9VVCAvKiAxIG1pbnV0ZSAqLztcbiAgICAgICAgdGhpcy5sb2dnZXIgPSAoX2UgPSBvcHRpb25zLmxvZ2dlcikgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogY29uc29sZTtcbiAgICAgICAgY29uc3QgZGVmYXVsdExvZ0xldmVsID0gJ3dhcm4nO1xuICAgICAgICAvLyBTZXQgZGVmYXVsdCBsb2dMZXZlbCBlYXJseSBzbyB0aGF0IHdlIGNhbiBsb2cgYSB3YXJuaW5nIGluIHBhcnNlTG9nTGV2ZWwuXG4gICAgICAgIHRoaXMubG9nTGV2ZWwgPSBkZWZhdWx0TG9nTGV2ZWw7XG4gICAgICAgIHRoaXMubG9nTGV2ZWwgPVxuICAgICAgICAgICAgKF9nID0gKF9mID0gcGFyc2VMb2dMZXZlbChvcHRpb25zLmxvZ0xldmVsLCAnQ2xpZW50T3B0aW9ucy5sb2dMZXZlbCcsIHRoaXMpKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBwYXJzZUxvZ0xldmVsKHJlYWRFbnYoJ0dFTUlOSV9ORVhUX0dFTl9BUElfTE9HJyksIFwicHJvY2Vzcy5lbnZbJ0dFTUlOSV9ORVhUX0dFTl9BUElfTE9HJ11cIiwgdGhpcykpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IGRlZmF1bHRMb2dMZXZlbDtcbiAgICAgICAgdGhpcy5mZXRjaE9wdGlvbnMgPSBvcHRpb25zLmZldGNoT3B0aW9ucztcbiAgICAgICAgdGhpcy5tYXhSZXRyaWVzID0gKF9oID0gb3B0aW9ucy5tYXhSZXRyaWVzKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiAyO1xuICAgICAgICB0aGlzLmZldGNoID0gKF9qID0gb3B0aW9ucy5mZXRjaCkgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogZ2V0RGVmYXVsdEZldGNoKCk7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IEZhbGxiYWNrRW5jb2RlcjtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuICAgICAgICB0aGlzLmFwaVZlcnNpb24gPSBhcGlWZXJzaW9uO1xuICAgICAgICB0aGlzLmNsaWVudEFkYXB0ZXIgPSBvcHRpb25zLmNsaWVudEFkYXB0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBjbGllbnQgaW5zdGFuY2UgcmUtdXNpbmcgdGhlIHNhbWUgb3B0aW9ucyBnaXZlbiB0byB0aGUgY3VycmVudCBjbGllbnQgd2l0aCBvcHRpb25hbCBvdmVycmlkaW5nLlxuICAgICAqL1xuICAgIHdpdGhPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX29wdGlvbnMpLCB7IGJhc2VVUkw6IHRoaXMuYmFzZVVSTCwgbWF4UmV0cmllczogdGhpcy5tYXhSZXRyaWVzLCB0aW1lb3V0OiB0aGlzLnRpbWVvdXQsIGxvZ2dlcjogdGhpcy5sb2dnZXIsIGxvZ0xldmVsOiB0aGlzLmxvZ0xldmVsLCBmZXRjaDogdGhpcy5mZXRjaCwgZmV0Y2hPcHRpb25zOiB0aGlzLmZldGNoT3B0aW9ucywgYXBpS2V5OiB0aGlzLmFwaUtleSwgYXBpVmVyc2lvbjogdGhpcy5hcGlWZXJzaW9uIH0pLCBvcHRpb25zKSk7XG4gICAgICAgIHJldHVybiBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGJhc2UgVVJMIGlzIHNldCB0byBpdHMgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBiYXNlVVJMT3ZlcnJpZGRlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVVSTCAhPT0gJ2h0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tJztcbiAgICB9XG4gICAgZGVmYXVsdFF1ZXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5kZWZhdWx0UXVlcnk7XG4gICAgfVxuICAgIHZhbGlkYXRlSGVhZGVycyh7IHZhbHVlcywgbnVsbHMgfSkge1xuICAgICAgICAvLyBUaGUgaGVhZGVycyBvYmplY3QgaGFuZGxlcyBjYXNlIGluc2Vuc2l0aXZpdHkuXG4gICAgICAgIGlmICh2YWx1ZXMuaGFzKCdhdXRob3JpemF0aW9uJykgfHwgdmFsdWVzLmhhcygneC1nb29nLWFwaS1rZXknKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFwaUtleSAmJiB2YWx1ZXMuZ2V0KCd4LWdvb2ctYXBpLWtleScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bGxzLmhhcygneC1nb29nLWFwaS1rZXknKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJlc29sdmUgYXV0aGVudGljYXRpb24gbWV0aG9kLiBFeHBlY3RlZCB0aGUgYXBpS2V5IHRvIGJlIHNldC4gT3IgZm9yIHRoZSBcIngtZ29vZy1hcGkta2V5XCIgaGVhZGVycyB0byBiZSBleHBsaWNpdGx5IG9taXR0ZWQnKTtcbiAgICB9XG4gICAgYXN5bmMgYXV0aEhlYWRlcnMob3B0cykge1xuICAgICAgICBjb25zdCBleGlzdGluZ0hlYWRlcnMgPSBidWlsZEhlYWRlcnMoW29wdHMuaGVhZGVyc10pO1xuICAgICAgICBpZiAoZXhpc3RpbmdIZWFkZXJzLnZhbHVlcy5oYXMoJ2F1dGhvcml6YXRpb24nKSB8fCBleGlzdGluZ0hlYWRlcnMudmFsdWVzLmhhcygneC1nb29nLWFwaS1rZXknKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hcGlLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBidWlsZEhlYWRlcnMoW3sgJ3gtZ29vZy1hcGkta2V5JzogdGhpcy5hcGlLZXkgfV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNsaWVudEFkYXB0ZXIuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRIZWFkZXJzKFthd2FpdCB0aGlzLmNsaWVudEFkYXB0ZXIuZ2V0QXV0aEhlYWRlcnMoKV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhc2ljIHJlLWltcGxlbWVudGF0aW9uIG9mIGBxcy5zdHJpbmdpZnlgIGZvciBwcmltaXRpdmUgdHlwZXMuXG4gICAgICovXG4gICAgc3RyaW5naWZ5UXVlcnkocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHF1ZXJ5KVxuICAgICAgICAgICAgLmZpbHRlcigoW18sIHZhbHVlXSkgPT4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQodmFsdWUpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgR2VtaW5pTmV4dEdlbkFQSUNsaWVudEVycm9yKGBDYW5ub3Qgc3RyaW5naWZ5IHR5cGUgJHt0eXBlb2YgdmFsdWV9OyBFeHBlY3RlZCBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgbnVsbC4gSWYgeW91IG5lZWQgdG8gcGFzcyBuZXN0ZWQgcXVlcnkgcGFyYW1ldGVycywgeW91IGNhbiBtYW51YWxseSBlbmNvZGUgdGhlbSwgZS5nLiB7IHF1ZXJ5OiB7ICdmb29ba2V5MV0nOiB2YWx1ZTEsICdmb29ba2V5Ml0nOiB2YWx1ZTIgfSB9LCBhbmQgcGxlYXNlIG9wZW4gYSBHaXRIdWIgaXNzdWUgcmVxdWVzdGluZyBiZXR0ZXIgc3VwcG9ydCBmb3IgeW91ciB1c2UgY2FzZS5gKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcmJyk7XG4gICAgfVxuICAgIGdldFVzZXJBZ2VudCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0vSlMgJHtWRVJTSU9OfWA7XG4gICAgfVxuICAgIGRlZmF1bHRJZGVtcG90ZW5jeUtleSgpIHtcbiAgICAgICAgcmV0dXJuIGBzdGFpbmxlc3Mtbm9kZS1yZXRyeS0ke3V1aWQ0KCl9YDtcbiAgICB9XG4gICAgbWFrZVN0YXR1c0Vycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIEFQSUVycm9yLmdlbmVyYXRlKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgIH1cbiAgICBidWlsZFVSTChwYXRoLCBxdWVyeSwgZGVmYXVsdEJhc2VVUkwpIHtcbiAgICAgICAgY29uc3QgYmFzZVVSTCA9ICghdGhpcy5iYXNlVVJMT3ZlcnJpZGRlbigpICYmIGRlZmF1bHRCYXNlVVJMKSB8fCB0aGlzLmJhc2VVUkw7XG4gICAgICAgIGNvbnN0IHVybCA9IGlzQWJzb2x1dGVVUkwocGF0aCkgP1xuICAgICAgICAgICAgbmV3IFVSTChwYXRoKVxuICAgICAgICAgICAgOiBuZXcgVVJMKGJhc2VVUkwgKyAoYmFzZVVSTC5lbmRzV2l0aCgnLycpICYmIHBhdGguc3RhcnRzV2l0aCgnLycpID8gcGF0aC5zbGljZSgxKSA6IHBhdGgpKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdFF1ZXJ5ID0gdGhpcy5kZWZhdWx0UXVlcnkoKTtcbiAgICAgICAgaWYgKCFpc0VtcHR5T2JqKGRlZmF1bHRRdWVyeSkpIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UXVlcnkpLCBxdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcgJiYgcXVlcnkgJiYgIUFycmF5LmlzQXJyYXkocXVlcnkpKSB7XG4gICAgICAgICAgICB1cmwuc2VhcmNoID0gdGhpcy5zdHJpbmdpZnlRdWVyeShxdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIGFzIGEgY2FsbGJhY2sgZm9yIG11dGF0aW5nIHRoZSBnaXZlbiBgRmluYWxSZXF1ZXN0T3B0aW9uc2Agb2JqZWN0LlxuICBcbiAgICAgKi9cbiAgICBhc3luYyBwcmVwYXJlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudEFkYXB0ZXIgJiZcbiAgICAgICAgICAgIHRoaXMuY2xpZW50QWRhcHRlci5pc1ZlcnRleEFJKCkgJiZcbiAgICAgICAgICAgICFvcHRpb25zLnBhdGguc3RhcnRzV2l0aChgLyR7dGhpcy5hcGlWZXJzaW9ufS9wcm9qZWN0cy9gKSkge1xuICAgICAgICAgICAgY29uc3Qgb2xkUGF0aCA9IG9wdGlvbnMucGF0aC5zbGljZSh0aGlzLmFwaVZlcnNpb24ubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICBvcHRpb25zLnBhdGggPSBgLyR7dGhpcy5hcGlWZXJzaW9ufS9wcm9qZWN0cy8ke3RoaXMuY2xpZW50QWRhcHRlci5nZXRQcm9qZWN0KCl9L2xvY2F0aW9ucy8ke3RoaXMuY2xpZW50QWRhcHRlci5nZXRMb2NhdGlvbigpfSR7b2xkUGF0aH1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgYXMgYSBjYWxsYmFjayBmb3IgbXV0YXRpbmcgdGhlIGdpdmVuIGBSZXF1ZXN0SW5pdGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1c2VmdWwgZm9yIGNhc2VzIHdoZXJlIHlvdSB3YW50IHRvIGFkZCBjZXJ0YWluIGhlYWRlcnMgYmFzZWQgb2ZmIG9mXG4gICAgICogdGhlIHJlcXVlc3QgcHJvcGVydGllcywgZS5nLiBgbWV0aG9kYCBvciBgdXJsYC5cbiAgICAgKi9cbiAgICBhc3luYyBwcmVwYXJlUmVxdWVzdChyZXF1ZXN0LCB7IHVybCwgb3B0aW9ucyB9KSB7IH1cbiAgICBnZXQocGF0aCwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdnZXQnLCBwYXRoLCBvcHRzKTtcbiAgICB9XG4gICAgcG9zdChwYXRoLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoJ3Bvc3QnLCBwYXRoLCBvcHRzKTtcbiAgICB9XG4gICAgcGF0Y2gocGF0aCwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdwYXRjaCcsIHBhdGgsIG9wdHMpO1xuICAgIH1cbiAgICBwdXQocGF0aCwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdwdXQnLCBwYXRoLCBvcHRzKTtcbiAgICB9XG4gICAgZGVsZXRlKHBhdGgsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0aG9kUmVxdWVzdCgnZGVsZXRlJywgcGF0aCwgb3B0cyk7XG4gICAgfVxuICAgIG1ldGhvZFJlcXVlc3QobWV0aG9kLCBwYXRoLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoUHJvbWlzZS5yZXNvbHZlKG9wdHMpLnRoZW4oKG9wdHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgbWV0aG9kLCBwYXRoIH0sIG9wdHMpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJlcXVlc3Qob3B0aW9ucywgcmVtYWluaW5nUmV0cmllcyA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBUElQcm9taXNlKHRoaXMsIHRoaXMubWFrZVJlcXVlc3Qob3B0aW9ucywgcmVtYWluaW5nUmV0cmllcywgdW5kZWZpbmVkKSk7XG4gICAgfVxuICAgIGFzeW5jIG1ha2VSZXF1ZXN0KG9wdGlvbnNJbnB1dCwgcmV0cmllc1JlbWFpbmluZywgcmV0cnlPZlJlcXVlc3RMb2dJRCkge1xuICAgICAgICB2YXIgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IG9wdGlvbnNJbnB1dDtcbiAgICAgICAgY29uc3QgbWF4UmV0cmllcyA9IChfYiA9IG9wdGlvbnMubWF4UmV0cmllcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5tYXhSZXRyaWVzO1xuICAgICAgICBpZiAocmV0cmllc1JlbWFpbmluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXRyaWVzUmVtYWluaW5nID0gbWF4UmV0cmllcztcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnByZXBhcmVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB7IHJlcSwgdXJsLCB0aW1lb3V0IH0gPSBhd2FpdCB0aGlzLmJ1aWxkUmVxdWVzdChvcHRpb25zLCB7XG4gICAgICAgICAgICByZXRyeUNvdW50OiBtYXhSZXRyaWVzIC0gcmV0cmllc1JlbWFpbmluZyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMucHJlcGFyZVJlcXVlc3QocmVxLCB7IHVybCwgb3B0aW9ucyB9KTtcbiAgICAgICAgLyoqIE5vdCBhbiBBUEkgcmVxdWVzdCBJRCwganVzdCBmb3IgY29ycmVsYXRpbmcgbG9jYWwgbG9nIGVudHJpZXMuICovXG4gICAgICAgIGNvbnN0IHJlcXVlc3RMb2dJRCA9ICdsb2dfJyArICgoTWF0aC5yYW5kb20oKSAqICgxIDw8IDI0KSkgfCAwKS50b1N0cmluZygxNikucGFkU3RhcnQoNiwgJzAnKTtcbiAgICAgICAgY29uc3QgcmV0cnlMb2dTdHIgPSByZXRyeU9mUmVxdWVzdExvZ0lEID09PSB1bmRlZmluZWQgPyAnJyA6IGAsIHJldHJ5T2Y6ICR7cmV0cnlPZlJlcXVlc3RMb2dJRH1gO1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBsb2dnZXJGb3IodGhpcykuZGVidWcoYFske3JlcXVlc3RMb2dJRH1dIHNlbmRpbmcgcmVxdWVzdGAsIGZvcm1hdFJlcXVlc3REZXRhaWxzKHtcbiAgICAgICAgICAgIHJldHJ5T2ZSZXF1ZXN0TG9nSUQsXG4gICAgICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlcS5oZWFkZXJzLFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmICgoX2MgPSBvcHRpb25zLnNpZ25hbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaFdpdGhUaW1lb3V0KHVybCwgcmVxLCB0aW1lb3V0LCBjb250cm9sbGVyKS5jYXRjaChjYXN0VG9FcnJvcik7XG4gICAgICAgIGNvbnN0IGhlYWRlcnNUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5FcnJvcikge1xuICAgICAgICAgICAgY29uc3QgcmV0cnlNZXNzYWdlID0gYHJldHJ5aW5nLCAke3JldHJpZXNSZW1haW5pbmd9IGF0dGVtcHRzIHJlbWFpbmluZ2A7XG4gICAgICAgICAgICBpZiAoKF9kID0gb3B0aW9ucy5zaWduYWwpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZXRlY3QgbmF0aXZlIGNvbm5lY3Rpb24gdGltZW91dCBlcnJvcnNcbiAgICAgICAgICAgIC8vIGRlbm8gdGhyb3dzIFwiVHlwZUVycm9yOiBlcnJvciBzZW5kaW5nIHJlcXVlc3QgZm9yIHVybCAoaHR0cHM6Ly9leGFtcGxlLyk6IGNsaWVudCBlcnJvciAoQ29ubmVjdCk6IHRjcCBjb25uZWN0IGVycm9yOiBPcGVyYXRpb24gdGltZWQgb3V0IChvcyBlcnJvciA2MCk6IE9wZXJhdGlvbiB0aW1lZCBvdXQgKG9zIGVycm9yIDYwKVwiXG4gICAgICAgICAgICAvLyB1bmRpY2kgdGhyb3dzIFwiVHlwZUVycm9yOiBmZXRjaCBmYWlsZWRcIiB3aXRoIGNhdXNlIFwiQ29ubmVjdFRpbWVvdXRFcnJvcjogQ29ubmVjdCBUaW1lb3V0IEVycm9yIChhdHRlbXB0ZWQgYWRkcmVzczogZXhhbXBsZTo0NDMsIHRpbWVvdXQ6IDFtcylcIlxuICAgICAgICAgICAgLy8gb3RoZXJzIGRvIG5vdCBwcm92aWRlIGVub3VnaCBpbmZvcm1hdGlvbiB0byBkaXN0aW5ndWlzaCB0aW1lb3V0cyBmcm9tIG90aGVyIGNvbm5lY3Rpb24gZXJyb3JzXG4gICAgICAgICAgICBjb25zdCBpc1RpbWVvdXQgPSBpc0Fib3J0RXJyb3IocmVzcG9uc2UpIHx8XG4gICAgICAgICAgICAgICAgL3RpbWVkPyA/b3V0L2kudGVzdChTdHJpbmcocmVzcG9uc2UpICsgKCdjYXVzZScgaW4gcmVzcG9uc2UgPyBTdHJpbmcocmVzcG9uc2UuY2F1c2UpIDogJycpKTtcbiAgICAgICAgICAgIGlmIChyZXRyaWVzUmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyRm9yKHRoaXMpLmluZm8oYFske3JlcXVlc3RMb2dJRH1dIGNvbm5lY3Rpb24gJHtpc1RpbWVvdXQgPyAndGltZWQgb3V0JyA6ICdmYWlsZWQnfSAtICR7cmV0cnlNZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIGxvZ2dlckZvcih0aGlzKS5kZWJ1ZyhgWyR7cmVxdWVzdExvZ0lEfV0gY29ubmVjdGlvbiAke2lzVGltZW91dCA/ICd0aW1lZCBvdXQnIDogJ2ZhaWxlZCd9ICgke3JldHJ5TWVzc2FnZX0pYCwgZm9ybWF0UmVxdWVzdERldGFpbHMoe1xuICAgICAgICAgICAgICAgICAgICByZXRyeU9mUmVxdWVzdExvZ0lELFxuICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uTXM6IGhlYWRlcnNUaW1lIC0gc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3Qob3B0aW9ucywgcmV0cmllc1JlbWFpbmluZywgcmV0cnlPZlJlcXVlc3RMb2dJRCAhPT0gbnVsbCAmJiByZXRyeU9mUmVxdWVzdExvZ0lEICE9PSB2b2lkIDAgPyByZXRyeU9mUmVxdWVzdExvZ0lEIDogcmVxdWVzdExvZ0lEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlckZvcih0aGlzKS5pbmZvKGBbJHtyZXF1ZXN0TG9nSUR9XSBjb25uZWN0aW9uICR7aXNUaW1lb3V0ID8gJ3RpbWVkIG91dCcgOiAnZmFpbGVkJ30gLSBlcnJvcjsgbm8gbW9yZSByZXRyaWVzIGxlZnRgKTtcbiAgICAgICAgICAgIGxvZ2dlckZvcih0aGlzKS5kZWJ1ZyhgWyR7cmVxdWVzdExvZ0lEfV0gY29ubmVjdGlvbiAke2lzVGltZW91dCA/ICd0aW1lZCBvdXQnIDogJ2ZhaWxlZCd9IChlcnJvcjsgbm8gbW9yZSByZXRyaWVzIGxlZnQpYCwgZm9ybWF0UmVxdWVzdERldGFpbHMoe1xuICAgICAgICAgICAgICAgIHJldHJ5T2ZSZXF1ZXN0TG9nSUQsXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uTXM6IGhlYWRlcnNUaW1lIC0gc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLm1lc3NhZ2UsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAoaXNUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBBUElDb25uZWN0aW9uRXJyb3IoeyBjYXVzZTogcmVzcG9uc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2VJbmZvID0gYFske3JlcXVlc3RMb2dJRH0ke3JldHJ5TG9nU3RyfV0gJHtyZXEubWV0aG9kfSAke3VybH0gJHtyZXNwb25zZS5vayA/ICdzdWNjZWVkZWQnIDogJ2ZhaWxlZCd9IHdpdGggc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfSBpbiAke2hlYWRlcnNUaW1lIC0gc3RhcnRUaW1lfW1zYDtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmV0cnkgPSBhd2FpdCB0aGlzLnNob3VsZFJldHJ5KHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGlmIChyZXRyaWVzUmVtYWluaW5nICYmIHNob3VsZFJldHJ5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0cnlNZXNzYWdlID0gYHJldHJ5aW5nLCAke3JldHJpZXNSZW1haW5pbmd9IGF0dGVtcHRzIHJlbWFpbmluZ2A7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0aGUgYm9keSBvZiB0aGlzIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgIGF3YWl0IENhbmNlbFJlYWRhYmxlU3RyZWFtKHJlc3BvbnNlLmJvZHkpO1xuICAgICAgICAgICAgICAgIGxvZ2dlckZvcih0aGlzKS5pbmZvKGAke3Jlc3BvbnNlSW5mb30gLSAke3JldHJ5TWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICBsb2dnZXJGb3IodGhpcykuZGVidWcoYFske3JlcXVlc3RMb2dJRH1dIHJlc3BvbnNlIGVycm9yICgke3JldHJ5TWVzc2FnZX0pYCwgZm9ybWF0UmVxdWVzdERldGFpbHMoe1xuICAgICAgICAgICAgICAgICAgICByZXRyeU9mUmVxdWVzdExvZ0lELFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uTXM6IGhlYWRlcnNUaW1lIC0gc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3Qob3B0aW9ucywgcmV0cmllc1JlbWFpbmluZywgcmV0cnlPZlJlcXVlc3RMb2dJRCAhPT0gbnVsbCAmJiByZXRyeU9mUmVxdWVzdExvZ0lEICE9PSB2b2lkIDAgPyByZXRyeU9mUmVxdWVzdExvZ0lEIDogcmVxdWVzdExvZ0lELCByZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJldHJ5TWVzc2FnZSA9IHNob3VsZFJldHJ5ID8gYGVycm9yOyBubyBtb3JlIHJldHJpZXMgbGVmdGAgOiBgZXJyb3I7IG5vdCByZXRyeWFibGVgO1xuICAgICAgICAgICAgbG9nZ2VyRm9yKHRoaXMpLmluZm8oYCR7cmVzcG9uc2VJbmZvfSAtICR7cmV0cnlNZXNzYWdlfWApO1xuICAgICAgICAgICAgY29uc3QgZXJyVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoZXJyKSA9PiBjYXN0VG9FcnJvcihlcnIpLm1lc3NhZ2UpO1xuICAgICAgICAgICAgY29uc3QgZXJySlNPTiA9IHNhZmVKU09OKGVyclRleHQpO1xuICAgICAgICAgICAgY29uc3QgZXJyTWVzc2FnZSA9IGVyckpTT04gPyB1bmRlZmluZWQgOiBlcnJUZXh0O1xuICAgICAgICAgICAgbG9nZ2VyRm9yKHRoaXMpLmRlYnVnKGBbJHtyZXF1ZXN0TG9nSUR9XSByZXNwb25zZSBlcnJvciAoJHtyZXRyeU1lc3NhZ2V9KWAsIGZvcm1hdFJlcXVlc3REZXRhaWxzKHtcbiAgICAgICAgICAgICAgICByZXRyeU9mUmVxdWVzdExvZ0lELFxuICAgICAgICAgICAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyTWVzc2FnZSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbk1zOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgZXJyID0gdGhpcy5tYWtlU3RhdHVzRXJyb3IocmVzcG9uc2Uuc3RhdHVzLCBlcnJKU09OLCBlcnJNZXNzYWdlLCByZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJGb3IodGhpcykuaW5mbyhyZXNwb25zZUluZm8pO1xuICAgICAgICBsb2dnZXJGb3IodGhpcykuZGVidWcoYFske3JlcXVlc3RMb2dJRH1dIHJlc3BvbnNlIHN0YXJ0YCwgZm9ybWF0UmVxdWVzdERldGFpbHMoe1xuICAgICAgICAgICAgcmV0cnlPZlJlcXVlc3RMb2dJRCxcbiAgICAgICAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgZHVyYXRpb25NczogaGVhZGVyc1RpbWUgLSBzdGFydFRpbWUsXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHsgcmVzcG9uc2UsIG9wdGlvbnMsIGNvbnRyb2xsZXIsIHJlcXVlc3RMb2dJRCwgcmV0cnlPZlJlcXVlc3RMb2dJRCwgc3RhcnRUaW1lIH07XG4gICAgfVxuICAgIGFzeW5jIGZldGNoV2l0aFRpbWVvdXQodXJsLCBpbml0LCBtcywgY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBfYiA9IGluaXQgfHwge30sIHsgc2lnbmFsLCBtZXRob2QgfSA9IF9iLCBvcHRpb25zID0gX19yZXN0KF9iLCBbXCJzaWduYWxcIiwgXCJtZXRob2RcIl0pO1xuICAgICAgICBjb25zdCBhYm9ydCA9IGNvbnRyb2xsZXIuYWJvcnQuYmluZChjb250cm9sbGVyKTtcbiAgICAgICAgaWYgKHNpZ25hbClcbiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGFib3J0LCBtcyk7XG4gICAgICAgIGNvbnN0IGlzUmVhZGFibGVCb2R5ID0gKGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0gJiYgb3B0aW9ucy5ib2R5IGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygb3B0aW9ucy5ib2R5ID09PSAnb2JqZWN0JyAmJiBvcHRpb25zLmJvZHkgIT09IG51bGwgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gb3B0aW9ucy5ib2R5KTtcbiAgICAgICAgY29uc3QgZmV0Y2hPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIH0sIChpc1JlYWRhYmxlQm9keSA/IHsgZHVwbGV4OiAnaGFsZicgfSA6IHt9KSksIHsgbWV0aG9kOiAnR0VUJyB9KSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICAgIC8vIEN1c3RvbSBtZXRob2RzIGxpa2UgJ3BhdGNoJyBuZWVkIHRvIGJlIHVwcGVyY2FzZWRcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjI5NFxuICAgICAgICAgICAgZmV0Y2hPcHRpb25zLm1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyB1c2UgdW5kZWZpbmVkIHRoaXMgYmluZGluZzsgZmV0Y2ggZXJyb3JzIGlmIGJvdW5kIHRvIHNvbWV0aGluZyBlbHNlIGluIGJyb3dzZXIvY2xvdWRmbGFyZVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2guY2FsbCh1bmRlZmluZWQsIHVybCwgZmV0Y2hPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzaG91bGRSZXRyeShyZXNwb25zZSkge1xuICAgICAgICAvLyBOb3RlIHRoaXMgaXMgbm90IGEgc3RhbmRhcmQgaGVhZGVyLlxuICAgICAgICBjb25zdCBzaG91bGRSZXRyeUhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LXNob3VsZC1yZXRyeScpO1xuICAgICAgICAvLyBJZiB0aGUgc2VydmVyIGV4cGxpY2l0bHkgc2F5cyB3aGV0aGVyIG9yIG5vdCB0byByZXRyeSwgb2JleS5cbiAgICAgICAgaWYgKHNob3VsZFJldHJ5SGVhZGVyID09PSAndHJ1ZScpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHNob3VsZFJldHJ5SGVhZGVyID09PSAnZmFsc2UnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBSZXRyeSBvbiByZXF1ZXN0IHRpbWVvdXRzLlxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDgpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gUmV0cnkgb24gbG9jayB0aW1lb3V0cy5cbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA5KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIFJldHJ5IG9uIHJhdGUgbGltaXRzLlxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gUmV0cnkgaW50ZXJuYWwgZXJyb3JzLlxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDUwMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIHJldHJ5UmVxdWVzdChvcHRpb25zLCByZXRyaWVzUmVtYWluaW5nLCByZXF1ZXN0TG9nSUQsIHJlc3BvbnNlSGVhZGVycykge1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIGxldCB0aW1lb3V0TWlsbGlzO1xuICAgICAgICAvLyBOb3RlIHRoZSBgcmV0cnktYWZ0ZXItbXNgIGhlYWRlciBtYXkgbm90IGJlIHN0YW5kYXJkLCBidXQgaXMgYSBnb29kIGlkZWEgYW5kIHdlJ2QgbGlrZSBwcm9hY3RpdmUgc3VwcG9ydCBmb3IgaXQuXG4gICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXJNaWxsaXNIZWFkZXIgPSByZXNwb25zZUhlYWRlcnMgPT09IG51bGwgfHwgcmVzcG9uc2VIZWFkZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZUhlYWRlcnMuZ2V0KCdyZXRyeS1hZnRlci1tcycpO1xuICAgICAgICBpZiAocmV0cnlBZnRlck1pbGxpc0hlYWRlcikge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dE1zID0gcGFyc2VGbG9hdChyZXRyeUFmdGVyTWlsbGlzSGVhZGVyKTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHRpbWVvdXRNcykpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0TWlsbGlzID0gdGltZW91dE1zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFib3V0IHRoZSBSZXRyeS1BZnRlciBoZWFkZXI6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9SZXRyeS1BZnRlclxuICAgICAgICBjb25zdCByZXRyeUFmdGVySGVhZGVyID0gcmVzcG9uc2VIZWFkZXJzID09PSBudWxsIHx8IHJlc3BvbnNlSGVhZGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2VIZWFkZXJzLmdldCgncmV0cnktYWZ0ZXInKTtcbiAgICAgICAgaWYgKHJldHJ5QWZ0ZXJIZWFkZXIgJiYgIXRpbWVvdXRNaWxsaXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRTZWNvbmRzID0gcGFyc2VGbG9hdChyZXRyeUFmdGVySGVhZGVyKTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHRpbWVvdXRTZWNvbmRzKSkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXRNaWxsaXMgPSB0aW1lb3V0U2Vjb25kcyAqIDEwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0TWlsbGlzID0gRGF0ZS5wYXJzZShyZXRyeUFmdGVySGVhZGVyKSAtIERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIEFQSSBhc2tzIHVzIHRvIHdhaXQgYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lIChhbmQgaXQncyBhIHJlYXNvbmFibGUgYW1vdW50KSxcbiAgICAgICAgLy8ganVzdCBkbyB3aGF0IGl0IHNheXMsIGJ1dCBvdGhlcndpc2UgY2FsY3VsYXRlIGEgZGVmYXVsdFxuICAgICAgICBpZiAoISh0aW1lb3V0TWlsbGlzICYmIDAgPD0gdGltZW91dE1pbGxpcyAmJiB0aW1lb3V0TWlsbGlzIDwgNjAgKiAxMDAwKSkge1xuICAgICAgICAgICAgY29uc3QgbWF4UmV0cmllcyA9IChfYiA9IG9wdGlvbnMubWF4UmV0cmllcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5tYXhSZXRyaWVzO1xuICAgICAgICAgICAgdGltZW91dE1pbGxpcyA9IHRoaXMuY2FsY3VsYXRlRGVmYXVsdFJldHJ5VGltZW91dE1pbGxpcyhyZXRyaWVzUmVtYWluaW5nLCBtYXhSZXRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBzbGVlcCQxKHRpbWVvdXRNaWxsaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdChvcHRpb25zLCByZXRyaWVzUmVtYWluaW5nIC0gMSwgcmVxdWVzdExvZ0lEKTtcbiAgICB9XG4gICAgY2FsY3VsYXRlRGVmYXVsdFJldHJ5VGltZW91dE1pbGxpcyhyZXRyaWVzUmVtYWluaW5nLCBtYXhSZXRyaWVzKSB7XG4gICAgICAgIGNvbnN0IGluaXRpYWxSZXRyeURlbGF5ID0gMC41O1xuICAgICAgICBjb25zdCBtYXhSZXRyeURlbGF5ID0gOC4wO1xuICAgICAgICBjb25zdCBudW1SZXRyaWVzID0gbWF4UmV0cmllcyAtIHJldHJpZXNSZW1haW5pbmc7XG4gICAgICAgIC8vIEFwcGx5IGV4cG9uZW50aWFsIGJhY2tvZmYsIGJ1dCBub3QgbW9yZSB0aGFuIHRoZSBtYXguXG4gICAgICAgIGNvbnN0IHNsZWVwU2Vjb25kcyA9IE1hdGgubWluKGluaXRpYWxSZXRyeURlbGF5ICogTWF0aC5wb3coMiwgbnVtUmV0cmllcyksIG1heFJldHJ5RGVsYXkpO1xuICAgICAgICAvLyBBcHBseSBzb21lIGppdHRlciwgdGFrZSB1cCB0byBhdCBtb3N0IDI1IHBlcmNlbnQgb2YgdGhlIHJldHJ5IHRpbWUuXG4gICAgICAgIGNvbnN0IGppdHRlciA9IDEgLSBNYXRoLnJhbmRvbSgpICogMC4yNTtcbiAgICAgICAgcmV0dXJuIHNsZWVwU2Vjb25kcyAqIGppdHRlciAqIDEwMDA7XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkUmVxdWVzdChpbnB1dE9wdGlvbnMsIHsgcmV0cnlDb3VudCA9IDAgfSA9IHt9KSB7XG4gICAgICAgIHZhciBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgaW5wdXRPcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyBtZXRob2QsIHBhdGgsIHF1ZXJ5LCBkZWZhdWx0QmFzZVVSTCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5idWlsZFVSTChwYXRoLCBxdWVyeSwgZGVmYXVsdEJhc2VVUkwpO1xuICAgICAgICBpZiAoJ3RpbWVvdXQnIGluIG9wdGlvbnMpXG4gICAgICAgICAgICB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcigndGltZW91dCcsIG9wdGlvbnMudGltZW91dCk7XG4gICAgICAgIG9wdGlvbnMudGltZW91dCA9IChfYiA9IG9wdGlvbnMudGltZW91dCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy50aW1lb3V0O1xuICAgICAgICBjb25zdCB7IGJvZHlIZWFkZXJzLCBib2R5IH0gPSB0aGlzLmJ1aWxkQm9keSh7IG9wdGlvbnMgfSk7XG4gICAgICAgIGNvbnN0IHJlcUhlYWRlcnMgPSBhd2FpdCB0aGlzLmJ1aWxkSGVhZGVycyh7IG9wdGlvbnM6IGlucHV0T3B0aW9ucywgbWV0aG9kLCBib2R5SGVhZGVycywgcmV0cnlDb3VudCB9KTtcbiAgICAgICAgY29uc3QgcmVxID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kLCBoZWFkZXJzOiByZXFIZWFkZXJzIH0sIChvcHRpb25zLnNpZ25hbCAmJiB7IHNpZ25hbDogb3B0aW9ucy5zaWduYWwgfSkpLCAoZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSAmJlxuICAgICAgICAgICAgYm9keSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0gJiYgeyBkdXBsZXg6ICdoYWxmJyB9KSksIChib2R5ICYmIHsgYm9keSB9KSksICgoX2MgPSB0aGlzLmZldGNoT3B0aW9ucykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30pKSwgKChfZCA9IG9wdGlvbnMuZmV0Y2hPcHRpb25zKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB7fSkpO1xuICAgICAgICByZXR1cm4geyByZXEsIHVybCwgdGltZW91dDogb3B0aW9ucy50aW1lb3V0IH07XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkSGVhZGVycyh7IG9wdGlvbnMsIG1ldGhvZCwgYm9keUhlYWRlcnMsIHJldHJ5Q291bnQsIH0pIHtcbiAgICAgICAgbGV0IGlkZW1wb3RlbmN5SGVhZGVycyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5pZGVtcG90ZW5jeUhlYWRlciAmJiBtZXRob2QgIT09ICdnZXQnKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuaWRlbXBvdGVuY3lLZXkpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5pZGVtcG90ZW5jeUtleSA9IHRoaXMuZGVmYXVsdElkZW1wb3RlbmN5S2V5KCk7XG4gICAgICAgICAgICBpZGVtcG90ZW5jeUhlYWRlcnNbdGhpcy5pZGVtcG90ZW5jeUhlYWRlcl0gPSBvcHRpb25zLmlkZW1wb3RlbmN5S2V5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF1dGhIZWFkZXJzID0gYXdhaXQgdGhpcy5hdXRoSGVhZGVycyhvcHRpb25zKTtcbiAgICAgICAgbGV0IGhlYWRlcnMgPSBidWlsZEhlYWRlcnMoW1xuICAgICAgICAgICAgaWRlbXBvdGVuY3lIZWFkZXJzLFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsICdVc2VyLUFnZW50JzogdGhpcy5nZXRVc2VyQWdlbnQoKSwgJ1gtU3RhaW5sZXNzLVJldHJ5LUNvdW50JzogU3RyaW5nKHJldHJ5Q291bnQpIH0sIChvcHRpb25zLnRpbWVvdXQgPyB7ICdYLVN0YWlubGVzcy1UaW1lb3V0JzogU3RyaW5nKE1hdGgudHJ1bmMob3B0aW9ucy50aW1lb3V0IC8gMTAwMCkpIH0gOiB7fSkpLCBnZXRQbGF0Zm9ybUhlYWRlcnMoKSksXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLmRlZmF1bHRIZWFkZXJzLFxuICAgICAgICAgICAgYm9keUhlYWRlcnMsXG4gICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMsXG4gICAgICAgICAgICBhdXRoSGVhZGVycyxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICByZXR1cm4gaGVhZGVycy52YWx1ZXM7XG4gICAgfVxuICAgIGJ1aWxkQm9keSh7IG9wdGlvbnM6IHsgYm9keSwgaGVhZGVyczogcmF3SGVhZGVycyB9IH0pIHtcbiAgICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4geyBib2R5SGVhZGVyczogdW5kZWZpbmVkLCBib2R5OiB1bmRlZmluZWQgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0gYnVpbGRIZWFkZXJzKFtyYXdIZWFkZXJzXSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gUGFzcyByYXcgdHlwZSB2ZXJiYXRpbVxuICAgICAgICBBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkgfHxcbiAgICAgICAgICAgIGJvZHkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgICAgICAgICAgYm9keSBpbnN0YW5jZW9mIERhdGFWaWV3IHx8XG4gICAgICAgICAgICAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgLy8gUHJlc2VydmUgbGVnYWN5IHN0cmluZyBlbmNvZGluZyBiZWhhdmlvciBmb3Igbm93XG4gICAgICAgICAgICAgICAgaGVhZGVycy52YWx1ZXMuaGFzKCdjb250ZW50LXR5cGUnKSkgfHxcbiAgICAgICAgICAgIC8vIGBCbG9iYCBpcyBzdXBlcnNldCBvZiBgRmlsZWBcbiAgICAgICAgICAgIChnbG9iYWxUaGlzLkJsb2IgJiYgYm9keSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuQmxvYikgfHxcbiAgICAgICAgICAgIC8vIGBGb3JtRGF0YWAgLT4gYG11bHRpcGFydC9mb3JtLWRhdGFgXG4gICAgICAgICAgICBib2R5IGluc3RhbmNlb2YgRm9ybURhdGEgfHxcbiAgICAgICAgICAgIC8vIGBVUkxTZWFyY2hQYXJhbXNgIC0+IGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRgXG4gICAgICAgICAgICBib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zIHx8XG4gICAgICAgICAgICAvLyBTZW5kIGNodW5rZWQgc3RyZWFtIChlYWNoIGNodW5rIGhhcyBvd24gYGxlbmd0aGApXG4gICAgICAgICAgICAoZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSAmJiBib2R5IGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGJvZHlIZWFkZXJzOiB1bmRlZmluZWQsIGJvZHk6IGJvZHkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiBib2R5IHx8XG4gICAgICAgICAgICAgICAgKFN5bWJvbC5pdGVyYXRvciBpbiBib2R5ICYmICduZXh0JyBpbiBib2R5ICYmIHR5cGVvZiBib2R5Lm5leHQgPT09ICdmdW5jdGlvbicpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgYm9keUhlYWRlcnM6IHVuZGVmaW5lZCwgYm9keTogUmVhZGFibGVTdHJlYW1Gcm9tKGJvZHkpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVyKHsgYm9keSwgaGVhZGVycyB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkJhc2VHZW1pbmlOZXh0R2VuQVBJQ2xpZW50LkRFRkFVTFRfVElNRU9VVCA9IDYwMDAwOyAvLyAxIG1pbnV0ZVxuLyoqXG4gKiBBUEkgQ2xpZW50IGZvciBpbnRlcmZhY2luZyB3aXRoIHRoZSBHZW1pbmkgTmV4dCBHZW4gQVBJIEFQSS5cbiAqL1xuY2xhc3MgR2VtaW5pTmV4dEdlbkFQSUNsaWVudCBleHRlbmRzIEJhc2VHZW1pbmlOZXh0R2VuQVBJQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbnMgPSBuZXcgSW50ZXJhY3Rpb25zKHRoaXMpO1xuICAgIH1cbn1cbl9hID0gR2VtaW5pTmV4dEdlbkFQSUNsaWVudDtcbkdlbWluaU5leHRHZW5BUElDbGllbnQuR2VtaW5pTmV4dEdlbkFQSUNsaWVudCA9IF9hO1xuR2VtaW5pTmV4dEdlbkFQSUNsaWVudC5HZW1pbmlOZXh0R2VuQVBJQ2xpZW50RXJyb3IgPSBHZW1pbmlOZXh0R2VuQVBJQ2xpZW50RXJyb3I7XG5HZW1pbmlOZXh0R2VuQVBJQ2xpZW50LkFQSUVycm9yID0gQVBJRXJyb3I7XG5HZW1pbmlOZXh0R2VuQVBJQ2xpZW50LkFQSUNvbm5lY3Rpb25FcnJvciA9IEFQSUNvbm5lY3Rpb25FcnJvcjtcbkdlbWluaU5leHRHZW5BUElDbGllbnQuQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvciA9IEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3I7XG5HZW1pbmlOZXh0R2VuQVBJQ2xpZW50LkFQSVVzZXJBYm9ydEVycm9yID0gQVBJVXNlckFib3J0RXJyb3I7XG5HZW1pbmlOZXh0R2VuQVBJQ2xpZW50Lk5vdEZvdW5kRXJyb3IgPSBOb3RGb3VuZEVycm9yO1xuR2VtaW5pTmV4dEdlbkFQSUNsaWVudC5Db25mbGljdEVycm9yID0gQ29uZmxpY3RFcnJvcjtcbkdlbWluaU5leHRHZW5BUElDbGllbnQuUmF0ZUxpbWl0RXJyb3IgPSBSYXRlTGltaXRFcnJvcjtcbkdlbWluaU5leHRHZW5BUElDbGllbnQuQmFkUmVxdWVzdEVycm9yID0gQmFkUmVxdWVzdEVycm9yO1xuR2VtaW5pTmV4dEdlbkFQSUNsaWVudC5BdXRoZW50aWNhdGlvbkVycm9yID0gQXV0aGVudGljYXRpb25FcnJvcjtcbkdlbWluaU5leHRHZW5BUElDbGllbnQuSW50ZXJuYWxTZXJ2ZXJFcnJvciA9IEludGVybmFsU2VydmVyRXJyb3I7XG5HZW1pbmlOZXh0R2VuQVBJQ2xpZW50LlBlcm1pc3Npb25EZW5pZWRFcnJvciA9IFBlcm1pc3Npb25EZW5pZWRFcnJvcjtcbkdlbWluaU5leHRHZW5BUElDbGllbnQuVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yID0gVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yO1xuR2VtaW5pTmV4dEdlbkFQSUNsaWVudC50b0ZpbGUgPSB0b0ZpbGU7XG5HZW1pbmlOZXh0R2VuQVBJQ2xpZW50LkludGVyYWN0aW9ucyA9IEludGVyYWN0aW9ucztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLy8gQ29kZSBnZW5lcmF0ZWQgYnkgdGhlIEdvb2dsZSBHZW4gQUkgU0RLIGdlbmVyYXRvciBETyBOT1QgRURJVC5cbmZ1bmN0aW9uIGNhbmNlbFR1bmluZ0pvYlBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5jZWxUdW5pbmdKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmNlbFR1bmluZ0pvYlJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuY2VsVHVuaW5nSm9iUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlVHVuaW5nSm9iQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2YWxpZGF0aW9uRGF0YXNldCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmFsaWRhdGlvbkRhdGFzZXQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmVkTW9kZWxEaXNwbGF5TmFtZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXNjcmlwdGlvbiBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXBvY2hDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXBvY2hDb3VudCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVwb2NoQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHVuaW5nVGFzaycsICdoeXBlcnBhcmFtZXRlcnMnLCAnZXBvY2hDb3VudCddLCBmcm9tRXBvY2hDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbGVhcm5pbmdSYXRlTXVsdGlwbGllcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuaW5nVGFzaycsICdoeXBlcnBhcmFtZXRlcnMnLCAnbGVhcm5pbmdSYXRlTXVsdGlwbGllciddLCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllcik7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cG9ydExhc3RDaGVja3BvaW50T25seSddKSAhPT1cbiAgICAgICAgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ByZVR1bmVkTW9kZWxDaGVja3BvaW50SWQnXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZVR1bmVkTW9kZWxDaGVja3BvaW50SWQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRhcHRlclNpemUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkYXB0ZXJTaXplIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1bmluZ01vZGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R1bmluZ01vZGUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3VzdG9tQmFzZU1vZGVsJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXN0b21CYXNlTW9kZWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhdGNoU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmF0Y2hTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQmF0Y2hTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R1bmluZ1Rhc2snLCAnaHlwZXJwYXJhbWV0ZXJzJywgJ2JhdGNoU2l6ZSddLCBmcm9tQmF0Y2hTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxlYXJuaW5nUmF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGVhcm5pbmdSYXRlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGVhcm5pbmdSYXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R1bmluZ1Rhc2snLCAnaHlwZXJwYXJhbWV0ZXJzJywgJ2xlYXJuaW5nUmF0ZSddLCBmcm9tTGVhcm5pbmdSYXRlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYWJlbHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmV0YSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmV0YSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlVGVhY2hlck1vZGVsJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYXNlVGVhY2hlck1vZGVsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1bmVkVGVhY2hlck1vZGVsU291cmNlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0dW5lZFRlYWNoZXJNb2RlbFNvdXJjZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZnRMb3NzV2VpZ2h0TXVsdGlwbGllciddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2Z0TG9zc1dlaWdodE11bHRpcGxpZXIgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0VXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRwdXRVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlVHVuaW5nSm9iQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBsZXQgZGlzY3JpbWluYXRvclZhbGlkYXRpb25EYXRhc2V0ID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgW1xuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ21ldGhvZCcsXG4gICAgXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JWYWxpZGF0aW9uRGF0YXNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JWYWxpZGF0aW9uRGF0YXNldCA9ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJztcbiAgICB9XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JWYWxpZGF0aW9uRGF0YXNldCA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21WYWxpZGF0aW9uRGF0YXNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgICAgICd2YWxpZGF0aW9uRGF0YXNldCcsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZhbGlkYXRpb25EYXRhc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYyddLCB0dW5pbmdWYWxpZGF0aW9uRGF0YXNldFRvVmVydGV4KGZyb21WYWxpZGF0aW9uRGF0YXNldCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JWYWxpZGF0aW9uRGF0YXNldCA9PT0gJ1BSRUZFUkVOQ0VfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tVmFsaWRhdGlvbkRhdGFzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICAgICAndmFsaWRhdGlvbkRhdGFzZXQnLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21WYWxpZGF0aW9uRGF0YXNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnXSwgdHVuaW5nVmFsaWRhdGlvbkRhdGFzZXRUb1ZlcnRleChmcm9tVmFsaWRhdGlvbkRhdGFzZXQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkaXNjcmltaW5hdG9yVmFsaWRhdGlvbkRhdGFzZXQgPT09ICdESVNUSUxMQVRJT04nKSB7XG4gICAgICAgIGNvbnN0IGZyb21WYWxpZGF0aW9uRGF0YXNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgICAgICd2YWxpZGF0aW9uRGF0YXNldCcsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZhbGlkYXRpb25EYXRhc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXN0aWxsYXRpb25TcGVjJ10sIHR1bmluZ1ZhbGlkYXRpb25EYXRhc2V0VG9WZXJ0ZXgoZnJvbVZhbGlkYXRpb25EYXRhc2V0KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmVkTW9kZWxEaXNwbGF5TmFtZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHVuZWRNb2RlbERpc3BsYXlOYW1lJ10sIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JFcG9jaENvdW50ID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgW1xuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ21ldGhvZCcsXG4gICAgXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JFcG9jaENvdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvckVwb2NoQ291bnQgPSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORyc7XG4gICAgfVxuICAgIGlmIChkaXNjcmltaW5hdG9yRXBvY2hDb3VudCA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21FcG9jaENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcG9jaENvdW50J10pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVwb2NoQ291bnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ2h5cGVyUGFyYW1ldGVycycsICdlcG9jaENvdW50J10sIGZyb21FcG9jaENvdW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkaXNjcmltaW5hdG9yRXBvY2hDb3VudCA9PT0gJ1BSRUZFUkVOQ0VfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tRXBvY2hDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXBvY2hDb3VudCddKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FcG9jaENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYycsICdoeXBlclBhcmFtZXRlcnMnLCAnZXBvY2hDb3VudCddLCBmcm9tRXBvY2hDb3VudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvckVwb2NoQ291bnQgPT09ICdESVNUSUxMQVRJT04nKSB7XG4gICAgICAgIGNvbnN0IGZyb21FcG9jaENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcG9jaENvdW50J10pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVwb2NoQ291bnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3RpbGxhdGlvblNwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2Vwb2NoQ291bnQnXSwgZnJvbUVwb2NoQ291bnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBkaXNjcmltaW5hdG9yTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9IGdldFZhbHVlQnlQYXRoKHJvb3RPYmplY3QsIFtcbiAgICAgICAgJ2NvbmZpZycsXG4gICAgICAgICdtZXRob2QnLFxuICAgIF0pO1xuICAgIGlmIChkaXNjcmltaW5hdG9yTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JMZWFybmluZ1JhdGVNdWx0aXBsaWVyID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvckxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgPT09ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgICAgICdsZWFybmluZ1JhdGVNdWx0aXBsaWVyJyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInXSwgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JMZWFybmluZ1JhdGVNdWx0aXBsaWVyID09PSAnUFJFRkVSRU5DRV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgW1xuICAgICAgICAgICAgICAgICdwcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYycsXG4gICAgICAgICAgICAgICAgJ2h5cGVyUGFyYW1ldGVycycsXG4gICAgICAgICAgICAgICAgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInLFxuICAgICAgICAgICAgXSwgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JMZWFybmluZ1JhdGVNdWx0aXBsaWVyID09PSAnRElTVElMTEFUSU9OJykge1xuICAgICAgICBjb25zdCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgICAgICdsZWFybmluZ1JhdGVNdWx0aXBsaWVyJyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzdGlsbGF0aW9uU3BlYycsICdoeXBlclBhcmFtZXRlcnMnLCAnbGVhcm5pbmdSYXRlTXVsdGlwbGllciddLCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JFeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPSBnZXRWYWx1ZUJ5UGF0aChyb290T2JqZWN0LCBbJ2NvbmZpZycsICdtZXRob2QnXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JFeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaXNjcmltaW5hdG9yRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvckV4cG9ydExhc3RDaGVja3BvaW50T25seSA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICAgICAnZXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5JyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICdleHBvcnRMYXN0Q2hlY2twb2ludE9ubHknXSwgZnJvbUV4cG9ydExhc3RDaGVja3BvaW50T25seSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvckV4cG9ydExhc3RDaGVja3BvaW50T25seSA9PT0gJ1BSRUZFUkVOQ0VfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ2V4cG9ydExhc3RDaGVja3BvaW50T25seScsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cG9ydExhc3RDaGVja3BvaW50T25seSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLCAnZXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5J10sIGZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JFeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPT09ICdESVNUSUxMQVRJT04nKSB7XG4gICAgICAgIGNvbnN0IGZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICAgICAnZXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5JyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXN0aWxsYXRpb25TcGVjJywgJ2V4cG9ydExhc3RDaGVja3BvaW50T25seSddLCBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGlzY3JpbWluYXRvckFkYXB0ZXJTaXplID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgW1xuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ21ldGhvZCcsXG4gICAgXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JBZGFwdGVyU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JBZGFwdGVyU2l6ZSA9ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJztcbiAgICB9XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JBZGFwdGVyU2l6ZSA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21BZGFwdGVyU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRhcHRlclNpemUnXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRhcHRlclNpemUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ2h5cGVyUGFyYW1ldGVycycsICdhZGFwdGVyU2l6ZSddLCBmcm9tQWRhcHRlclNpemUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JBZGFwdGVyU2l6ZSA9PT0gJ1BSRUZFUkVOQ0VfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tQWRhcHRlclNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FkYXB0ZXJTaXplJ10pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFkYXB0ZXJTaXplICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYycsICdoeXBlclBhcmFtZXRlcnMnLCAnYWRhcHRlclNpemUnXSwgZnJvbUFkYXB0ZXJTaXplKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkaXNjcmltaW5hdG9yQWRhcHRlclNpemUgPT09ICdESVNUSUxMQVRJT04nKSB7XG4gICAgICAgIGNvbnN0IGZyb21BZGFwdGVyU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRhcHRlclNpemUnXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRhcHRlclNpemUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3RpbGxhdGlvblNwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2FkYXB0ZXJTaXplJ10sIGZyb21BZGFwdGVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JUdW5pbmdNb2RlID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgW1xuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ21ldGhvZCcsXG4gICAgXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JUdW5pbmdNb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvclR1bmluZ01vZGUgPSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORyc7XG4gICAgfVxuICAgIGlmIChkaXNjcmltaW5hdG9yVHVuaW5nTW9kZSA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21UdW5pbmdNb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dW5pbmdNb2RlJ10pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR1bmluZ01vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ3R1bmluZ01vZGUnXSwgZnJvbVR1bmluZ01vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21DdXN0b21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjdXN0b21CYXNlTW9kZWwnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ3VzdG9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2N1c3RvbUJhc2VNb2RlbCddLCBmcm9tQ3VzdG9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JCYXRjaFNpemUgPSBnZXRWYWx1ZUJ5UGF0aChyb290T2JqZWN0LCBbXG4gICAgICAgICdjb25maWcnLFxuICAgICAgICAnbWV0aG9kJyxcbiAgICBdKTtcbiAgICBpZiAoZGlzY3JpbWluYXRvckJhdGNoU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JCYXRjaFNpemUgPSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORyc7XG4gICAgfVxuICAgIGlmIChkaXNjcmltaW5hdG9yQmF0Y2hTaXplID09PSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbUJhdGNoU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmF0Y2hTaXplJ10pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUJhdGNoU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2JhdGNoU2l6ZSddLCBmcm9tQmF0Y2hTaXplKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGlzY3JpbWluYXRvckxlYXJuaW5nUmF0ZSA9IGdldFZhbHVlQnlQYXRoKHJvb3RPYmplY3QsIFtcbiAgICAgICAgJ2NvbmZpZycsXG4gICAgICAgICdtZXRob2QnLFxuICAgIF0pO1xuICAgIGlmIChkaXNjcmltaW5hdG9yTGVhcm5pbmdSYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvckxlYXJuaW5nUmF0ZSA9ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJztcbiAgICB9XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JMZWFybmluZ1JhdGUgPT09ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tTGVhcm5pbmdSYXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ2xlYXJuaW5nUmF0ZScsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxlYXJuaW5nUmF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2xlYXJuaW5nUmF0ZSddLCBmcm9tTGVhcm5pbmdSYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmV0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmV0YSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUJldGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2JldGEnXSwgZnJvbUJldGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmFzZVRlYWNoZXJNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Jhc2VUZWFjaGVyTW9kZWwnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQmFzZVRlYWNoZXJNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXN0aWxsYXRpb25TcGVjJywgJ2Jhc2VUZWFjaGVyTW9kZWwnXSwgZnJvbUJhc2VUZWFjaGVyTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRUZWFjaGVyTW9kZWxTb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5lZFRlYWNoZXJNb2RlbFNvdXJjZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdW5lZFRlYWNoZXJNb2RlbFNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXN0aWxsYXRpb25TcGVjJywgJ3R1bmVkVGVhY2hlck1vZGVsU291cmNlJ10sIGZyb21UdW5lZFRlYWNoZXJNb2RlbFNvdXJjZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZnRMb3NzV2VpZ2h0TXVsdGlwbGllciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NmdExvc3NXZWlnaHRNdWx0aXBsaWVyJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNmdExvc3NXZWlnaHRNdWx0aXBsaWVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3RpbGxhdGlvblNwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ3NmdExvc3NXZWlnaHRNdWx0aXBsaWVyJ10sIGZyb21TZnRMb3NzV2VpZ2h0TXVsdGlwbGllcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dFVyaSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dFVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydvdXRwdXRVcmknXSwgZnJvbU91dHB1dFVyaSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR1bmluZ0pvYlBhcmFtZXRlcnNQcml2YXRlVG9NbGRldihmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlTW9kZWwnXSk7XG4gICAgaWYgKGZyb21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXNlTW9kZWwnXSwgZnJvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVUdW5lZE1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlVHVuZWRNb2RlbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVUdW5lZE1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlVHVuZWRNb2RlbCddLCBmcm9tUHJlVHVuZWRNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UcmFpbmluZ0RhdGFzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0cmFpbmluZ0RhdGFzZXQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHJhaW5pbmdEYXRhc2V0ICE9IG51bGwpIHtcbiAgICAgICAgdHVuaW5nRGF0YXNldFRvTWxkZXYoZnJvbVRyYWluaW5nRGF0YXNldCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZVR1bmluZ0pvYkNvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzUHJpdmF0ZVRvVmVydGV4KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVUdW5lZE1vZGVsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZVR1bmVkTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVUdW5lZE1vZGVsJ10sIGZyb21QcmVUdW5lZE1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRyYWluaW5nRGF0YXNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RyYWluaW5nRGF0YXNldCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UcmFpbmluZ0RhdGFzZXQgIT0gbnVsbCkge1xuICAgICAgICB0dW5pbmdEYXRhc2V0VG9WZXJ0ZXgoZnJvbVRyYWluaW5nRGF0YXNldCwgdG9PYmplY3QsIHJvb3RPYmplY3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVUdW5pbmdKb2JDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCwgcm9vdE9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldFR1bmluZ0pvYlBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRUdW5pbmdKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWx0ZXInXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21GaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ2ZpbHRlciddLCBmcm9tRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdFR1bmluZ0pvYnNDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWx0ZXInXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21GaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ2ZpbHRlciddLCBmcm9tRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0VHVuaW5nSm9ic0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic1BhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0VHVuaW5nSm9ic0NvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdFR1bmluZ0pvYnNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmluZ0pvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1bmVkTW9kZWxzJ10pO1xuICAgIGlmIChmcm9tVHVuaW5nSm9icyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVHVuaW5nSm9icztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0dW5pbmdKb2JGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5pbmdKb2JzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuaW5nSm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHVuaW5nSm9icyddKTtcbiAgICBpZiAoZnJvbVR1bmluZ0pvYnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVR1bmluZ0pvYnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHVuaW5nSm9iRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmluZ0pvYnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuZWRNb2RlbEZyb21NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCBmcm9tTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kcG9pbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21FbmRwb2ludCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZHBvaW50J10sIGZyb21FbmRwb2ludCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ0RhdGFzZXRUb01sZGV2KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2djc1VyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2ZXJ0ZXhEYXRhc2V0UmVzb3VyY2UnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlcnRleERhdGFzZXRSZXNvdXJjZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhhbXBsZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4YW1wbGVzJ10pO1xuICAgIGlmIChmcm9tRXhhbXBsZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUV4YW1wbGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGFtcGxlcycsICdleGFtcGxlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdEYXRhc2V0VG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBsZXQgZGlzY3JpbWluYXRvckdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKHJvb3RPYmplY3QsIFtcbiAgICAgICAgJ2NvbmZpZycsXG4gICAgICAgICdtZXRob2QnLFxuICAgIF0pO1xuICAgIGlmIChkaXNjcmltaW5hdG9yR2NzVXJpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvckdjc1VyaSA9ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJztcbiAgICB9XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JHY3NVcmkgPT09ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICd0cmFpbmluZ0RhdGFzZXRVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvckdjc1VyaSA9PT0gJ1BSRUZFUkVOQ0VfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYycsICd0cmFpbmluZ0RhdGFzZXRVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvckdjc1VyaSA9PT0gJ0RJU1RJTExBVElPTicpIHtcbiAgICAgICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzdGlsbGF0aW9uU3BlYycsICdwcm9tcHREYXRhc2V0VXJpJ10sIGZyb21HY3NVcmkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBkaXNjcmltaW5hdG9yVmVydGV4RGF0YXNldFJlc291cmNlID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgW1xuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ21ldGhvZCcsXG4gICAgXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JWZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaXNjcmltaW5hdG9yVmVydGV4RGF0YXNldFJlc291cmNlID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvclZlcnRleERhdGFzZXRSZXNvdXJjZSA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICAgICAndmVydGV4RGF0YXNldFJlc291cmNlJyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICd0cmFpbmluZ0RhdGFzZXRVcmknXSwgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvclZlcnRleERhdGFzZXRSZXNvdXJjZSA9PT0gJ1BSRUZFUkVOQ0VfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ3ZlcnRleERhdGFzZXRSZXNvdXJjZScsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLCAndHJhaW5pbmdEYXRhc2V0VXJpJ10sIGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JWZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgPT09ICdESVNUSUxMQVRJT04nKSB7XG4gICAgICAgIGNvbnN0IGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICAgICAndmVydGV4RGF0YXNldFJlc291cmNlJyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXN0aWxsYXRpb25TcGVjJywgJ3Byb21wdERhdGFzZXRVcmknXSwgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhhbXBsZXMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4YW1wbGVzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nSm9iRnJvbU1sZGV2KGZyb21PYmplY3QsIHJvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGF0ZSddKTtcbiAgICBpZiAoZnJvbVN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGUnXSwgdFR1bmluZ0pvYlN0YXR1cyhmcm9tU3RhdGUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5pbmdUYXNrJyxcbiAgICAgICAgJ3N0YXJ0VGltZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdGFydFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydFRpbWUnXSwgZnJvbVN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuaW5nVGFzaycsXG4gICAgICAgICdjb21wbGV0ZVRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZU1vZGVsJ10pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21UdW5lZE1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbCddLCB0dW5lZE1vZGVsRnJvbU1sZGV2KGZyb21UdW5lZE1vZGVsKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ0pvYkZyb21WZXJ0ZXgoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGF0ZSddKTtcbiAgICBpZiAoZnJvbVN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGUnXSwgdFR1bmluZ0pvYlN0YXR1cyhmcm9tU3RhdGUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0VGltZSddKTtcbiAgICBpZiAoZnJvbVN0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0VGltZSddLCBmcm9tU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZFRpbWUnXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlTW9kZWwnXSk7XG4gICAgaWYgKGZyb21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXNlTW9kZWwnXSwgZnJvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dW5lZE1vZGVsJ10pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWwnXSwgZnJvbVR1bmVkTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlVHVuZWRNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZVR1bmVkTW9kZWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZVR1bmVkTW9kZWwnXSwgZnJvbVByZVR1bmVkTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3VwZXJ2aXNlZFR1bmluZ1NwZWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdXBlcnZpc2VkVHVuaW5nU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdXBlcnZpc2VkVHVuaW5nU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJ10sIGZyb21TdXBlcnZpc2VkVHVuaW5nU3BlYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnXSwgZnJvbVByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3RpbGxhdGlvblNwZWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkaXN0aWxsYXRpb25TcGVjJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbURpc3RpbGxhdGlvblNwZWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXN0aWxsYXRpb25TcGVjJ10sIGZyb21EaXN0aWxsYXRpb25TcGVjKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmluZ0RhdGFTdGF0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmluZ0RhdGFTdGF0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UdW5pbmdEYXRhU3RhdHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5pbmdEYXRhU3RhdHMnXSwgZnJvbVR1bmluZ0RhdGFTdGF0cyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmNyeXB0aW9uU3BlYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuY3J5cHRpb25TcGVjJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuY3J5cHRpb25TcGVjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5jcnlwdGlvblNwZWMnXSwgZnJvbUVuY3J5cHRpb25TcGVjKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcnRuZXJNb2RlbFR1bmluZ1NwZWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwYXJ0bmVyTW9kZWxUdW5pbmdTcGVjJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBhcnRuZXJNb2RlbFR1bmluZ1NwZWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0bmVyTW9kZWxUdW5pbmdTcGVjJ10sIGZyb21QYXJ0bmVyTW9kZWxUdW5pbmdTcGVjKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUN1c3RvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2N1c3RvbUJhc2VNb2RlbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DdXN0b21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjdXN0b21CYXNlTW9kZWwnXSwgZnJvbUN1c3RvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBlcmltZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBlcmltZW50J10pO1xuICAgIGlmIChmcm9tRXhwZXJpbWVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4cGVyaW1lbnQnXSwgZnJvbUV4cGVyaW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dFVyaSddKTtcbiAgICBpZiAoZnJvbU91dHB1dFVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ291dHB1dFVyaSddLCBmcm9tT3V0cHV0VXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBpcGVsaW5lSm9iID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwaXBlbGluZUpvYiddKTtcbiAgICBpZiAoZnJvbVBpcGVsaW5lSm9iICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGlwZWxpbmVKb2InXSwgZnJvbVBpcGVsaW5lSm9iKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlcnZpY2VBY2NvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2VydmljZUFjY291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2VydmljZUFjY291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXJ2aWNlQWNjb3VudCddLCBmcm9tU2VydmljZUFjY291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuZWRNb2RlbERpc3BsYXlOYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWxEaXNwbGF5TmFtZSddLCBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZlb1R1bmluZ1NwZWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2ZW9UdW5pbmdTcGVjJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZlb1R1bmluZ1NwZWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2ZW9UdW5pbmdTcGVjJ10sIGZyb21WZW9UdW5pbmdTcGVjKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nT3BlcmF0aW9uRnJvbU1sZGV2KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdWYWxpZGF0aW9uRGF0YXNldFRvVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2YWxpZGF0aW9uRGF0YXNldFVyaSddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZlcnRleERhdGFzZXRSZXNvdXJjZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2YWxpZGF0aW9uRGF0YXNldFVyaSddLCBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBUdW5pbmdzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdHMgdHVuaW5nIGpvYnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGxpc3QgcmVxdWVzdC5cbiAgICAgICAgICogQHJldHVybiAtIEEgcGFnZXIgb2YgdHVuaW5nIGpvYnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHR1bmluZ0pvYnMgPSBhd2FpdCBhaS50dW5pbmdzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDJ9fSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgdHVuaW5nSm9iIG9mIHR1bmluZ0pvYnMpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyh0dW5pbmdKb2IpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX1RVTklOR19KT0JTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeCksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKHBhcmFtcyksIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGEgVHVuaW5nSm9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSByZXNvdXJjZSBuYW1lIG9mIHRoZSB0dW5pbmcgam9iLlxuICAgICAgICAgKiBAcmV0dXJuIC0gQSBUdW5pbmdKb2Igb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhwZXJpbWVudGFsIC0gVGhlIFNESydzIHR1bmluZyBpbXBsZW1lbnRhdGlvbiBpcyBleHBlcmltZW50YWwsIGFuZCBtYXlcbiAgICAgICAgICogY2hhbmdlIGluIGZ1dHVyZSB2ZXJzaW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0SW50ZXJuYWwocGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBzdXBlcnZpc2VkIGZpbmUtdHVuaW5nIGpvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgdHVuaW5nIGpvYi5cbiAgICAgICAgICogQHJldHVybiAtIEEgVHVuaW5nSm9iIG9wZXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbCAtIFRoZSBTREsncyB0dW5pbmcgaW1wbGVtZW50YXRpb24gaXMgZXhwZXJpbWVudGFsLCBhbmQgbWF5XG4gICAgICAgICAqIGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR1bmUgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5iYXNlTW9kZWwuc3RhcnRzV2l0aCgncHJvamVjdHMvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlVHVuZWRNb2RlbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR1bmVkTW9kZWxOYW1lOiBwYXJhbXMuYmFzZU1vZGVsLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByZVR1bmVkTW9kZWxDaGVja3BvaW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZVR1bmVkTW9kZWwuY2hlY2twb2ludElkID0gcGFyYW1zLmNvbmZpZy5wcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtc1ByaXZhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHsgcHJlVHVuZWRNb2RlbDogcHJlVHVuZWRNb2RlbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zUHJpdmF0ZS5iYXNlTW9kZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnR1bmVJbnRlcm5hbChwYXJhbXNQcml2YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtc1ByaXZhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50dW5lSW50ZXJuYWwocGFyYW1zUHJpdmF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zUHJpdmF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gYXdhaXQgdGhpcy50dW5lTWxkZXZJbnRlcm5hbChwYXJhbXNQcml2YXRlKTtcbiAgICAgICAgICAgICAgICBsZXQgdHVuZWRNb2RlbE5hbWUgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uWydtZXRhZGF0YSddICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uWydtZXRhZGF0YSddWyd0dW5lZE1vZGVsJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0dW5lZE1vZGVsTmFtZSA9IG9wZXJhdGlvblsnbWV0YWRhdGEnXVsndHVuZWRNb2RlbCddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcGVyYXRpb25bJ25hbWUnXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvblsnbmFtZSddLmluY2x1ZGVzKCcvb3BlcmF0aW9ucy8nKSkge1xuICAgICAgICAgICAgICAgICAgICB0dW5lZE1vZGVsTmFtZSA9IG9wZXJhdGlvblsnbmFtZSddLnNwbGl0KCcvb3BlcmF0aW9ucy8nKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdHVuaW5nSm9iID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0dW5lZE1vZGVsTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IEpvYlN0YXRlLkpPQl9TVEFURV9RVUVVRUQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHVuaW5nSm9iO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBnZXRJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHR1bmluZ0pvYkZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdHVuaW5nSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3R1bmluZ0pvYnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdFR1bmluZ0pvYnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgndHVuZWRNb2RlbHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0VHVuaW5nSm9ic1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGEgdHVuaW5nIGpvYi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGNhbmNlbCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGVtcHR5IHJlc3BvbnNlIHJldHVybmVkIGJ5IHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkudHVuaW5ncy5jYW5jZWwoe25hbWU6ICcuLi4nfSk7IC8vIFRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHJlc291cmNlIG5hbWUuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY2FuY2VsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjYW5jZWxUdW5pbmdKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfTpjYW5jZWwnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjYW5jZWxUdW5pbmdKb2JSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBDYW5jZWxUdW5pbmdKb2JSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY2FuY2VsVHVuaW5nSm9iUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfTpjYW5jZWwnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjYW5jZWxUdW5pbmdKb2JSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENhbmNlbFR1bmluZ0pvYlJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB0dW5lSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzUHJpdmF0ZVRvVmVydGV4KHBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3R1bmluZ0pvYnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB0dW5pbmdKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHR1bmVNbGRldkludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzUHJpdmF0ZVRvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3R1bmVkTW9kZWxzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdHVuaW5nT3BlcmF0aW9uRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBCcm93c2VyRG93bmxvYWRlciB7XG4gICAgYXN5bmMgZG93bmxvYWQoX3BhcmFtcywgX2FwaUNsaWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rvd25sb2FkIHRvIGZpbGUgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgYnJvd3NlciwgcGxlYXNlIHVzZSBhIGJyb3dzZXIgY29tcGxpYW50IGRvd25sb2FkIGxpa2UgYW4gPGE+IHRhZy4nKTtcbiAgICB9XG59XG5cbmNvbnN0IE1BWF9DSFVOS19TSVpFID0gMTAyNCAqIDEwMjQgKiA4OyAvLyBieXRlc1xuY29uc3QgTUFYX1JFVFJZX0NPVU5UID0gMztcbmNvbnN0IElOSVRJQUxfUkVUUllfREVMQVlfTVMgPSAxMDAwO1xuY29uc3QgREVMQVlfTVVMVElQTElFUiA9IDI7XG5jb25zdCBYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTEQgPSAneC1nb29nLXVwbG9hZC1zdGF0dXMnO1xuYXN5bmMgZnVuY3Rpb24gdXBsb2FkQmxvYihmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwbG9hZEJsb2JJbnRlcm5hbChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgY29uc3QgcmVzcG9uc2VKc29uID0gKGF3YWl0IChyZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuanNvbigpKSk7XG4gICAgaWYgKCgoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pICE9PSAnZmluYWwnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBmaWxlOiBVcGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWQuJyk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZUpzb25bJ2ZpbGUnXTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEJsb2JUb0ZpbGVTZWFyY2hTdG9yZShmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwbG9hZEJsb2JJbnRlcm5hbChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgY29uc3QgcmVzcG9uc2VKc29uID0gKGF3YWl0IChyZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuanNvbigpKSk7XG4gICAgaWYgKCgoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pICE9PSAnZmluYWwnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBmaWxlOiBVcGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWQuJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3AgPSB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZU9wZXJhdGlvbkZyb21NbGRldihyZXNwb25zZUpzb24pO1xuICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBVcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZU9wZXJhdGlvbigpO1xuICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICByZXR1cm4gdHlwZWRSZXNwO1xufVxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkQmxvYkludGVybmFsKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBsZXQgZmlsZVNpemUgPSAwO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCByZXNwb25zZSA9IG5ldyBIdHRwUmVzcG9uc2UobmV3IFJlc3BvbnNlKCkpO1xuICAgIGxldCB1cGxvYWRDb21tYW5kID0gJ3VwbG9hZCc7XG4gICAgZmlsZVNpemUgPSBmaWxlLnNpemU7XG4gICAgd2hpbGUgKG9mZnNldCA8IGZpbGVTaXplKSB7XG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgubWluKE1BWF9DSFVOS19TSVpFLCBmaWxlU2l6ZSAtIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGNodW5rID0gZmlsZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGNodW5rU2l6ZSk7XG4gICAgICAgIGlmIChvZmZzZXQgKyBjaHVua1NpemUgPj0gZmlsZVNpemUpIHtcbiAgICAgICAgICAgIHVwbG9hZENvbW1hbmQgKz0gJywgZmluYWxpemUnO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXRyeUNvdW50ID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnREZWxheU1zID0gSU5JVElBTF9SRVRSWV9ERUxBWV9NUztcbiAgICAgICAgd2hpbGUgKHJldHJ5Q291bnQgPCBNQVhfUkVUUllfQ09VTlQpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6ICcnLFxuICAgICAgICAgICAgICAgIGJvZHk6IGNodW5rLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBhcGlWZXJzaW9uOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVybDogdXBsb2FkVXJsLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1Db21tYW5kJzogdXBsb2FkQ29tbWFuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLU9mZnNldCc6IFN0cmluZyhvZmZzZXQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogU3RyaW5nKGNodW5rU2l6ZSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAoY3VycmVudERlbGF5TXMpO1xuICAgICAgICAgICAgY3VycmVudERlbGF5TXMgPSBjdXJyZW50RGVsYXlNcyAqIERFTEFZX01VTFRJUExJRVI7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IGNodW5rU2l6ZTtcbiAgICAgICAgLy8gVGhlIGB4LWdvb2ctdXBsb2FkLXN0YXR1c2AgaGVhZGVyIGZpZWxkIGNhbiBiZSBgYWN0aXZlYCwgYGZpbmFsYCBhbmRcbiAgICAgICAgLy9gY2FuY2VsbGVkYCBpbiByZXNwb3NuZS5cbiAgICAgICAgaWYgKCgoX2IgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pICE9PSAnYWN0aXZlJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhiLzQwMTM5MTQzMCkgSW52ZXN0aWdhdGUgd2h5IHRoZSB1cGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWRcbiAgICAgICAgLy8gZXZlbiB0aG91Z2ggYWxsIGNvbnRlbnQgaGFzIGJlZW4gdXBsb2FkZWQuXG4gICAgICAgIGlmIChmaWxlU2l6ZSA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxsIGNvbnRlbnQgaGFzIGJlZW4gdXBsb2FkZWQsIGJ1dCB0aGUgdXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEJsb2JTdGF0KGZpbGUpIHtcbiAgICBjb25zdCBmaWxlU3RhdCA9IHsgc2l6ZTogZmlsZS5zaXplLCB0eXBlOiBmaWxlLnR5cGUgfTtcbiAgICByZXR1cm4gZmlsZVN0YXQ7XG59XG5mdW5jdGlvbiBzbGVlcChtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZVByb21pc2UpID0+IHNldFRpbWVvdXQocmVzb2x2ZVByb21pc2UsIG1zKSk7XG59XG5cbmNsYXNzIEJyb3dzZXJVcGxvYWRlciB7XG4gICAgYXN5bmMgdXBsb2FkKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlsZSBwYXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB1cGxvYWRlci4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdXBsb2FkQmxvYihmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgfVxuICAgIGFzeW5jIHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlsZSBwYXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB1cGxvYWRlci4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdXBsb2FkQmxvYlRvRmlsZVNlYXJjaFN0b3JlKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KTtcbiAgICB9XG4gICAgYXN5bmMgc3RhdChmaWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlsZSBwYXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB1cGxvYWRlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBnZXRCbG9iU3RhdChmaWxlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgQnJvd3NlcldlYlNvY2tldEZhY3Rvcnkge1xuICAgIGNyZWF0ZSh1cmwsIGhlYWRlcnMsIGNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gbmV3IEJyb3dzZXJXZWJTb2NrZXQodXJsLCBoZWFkZXJzLCBjYWxsYmFja3MpO1xuICAgIH1cbn1cbmNsYXNzIEJyb3dzZXJXZWJTb2NrZXQge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycywgY2FsbGJhY2tzKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQodGhpcy51cmwpO1xuICAgICAgICB0aGlzLndzLm9ub3BlbiA9IHRoaXMuY2FsbGJhY2tzLm9ub3BlbjtcbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gdGhpcy5jYWxsYmFja3Mub25lcnJvcjtcbiAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gdGhpcy5jYWxsYmFja3Mub25jbG9zZTtcbiAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSB0aGlzLmNhbGxiYWNrcy5vbm1lc3NhZ2U7XG4gICAgfVxuICAgIHNlbmQobWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy53cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3QgY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cy5zZW5kKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMud3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IGNvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IEdPT0dMRV9BUElfS0VZX0hFQURFUiA9ICd4LWdvb2ctYXBpLWtleSc7XG4vLyBUT0RPKGIvMzk1MTIyNTMzKTogV2UgbmVlZCBhIHNlY3VyZSBjbGllbnQgc2lkZSBhdXRoZW50aWNhdGlvbiBtZWNoYW5pc20uXG5jbGFzcyBXZWJBdXRoIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlLZXkpIHtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBhZGRBdXRoSGVhZGVycyhoZWFkZXJzLCB1cmwpIHtcbiAgICAgICAgaWYgKGhlYWRlcnMuZ2V0KEdPT0dMRV9BUElfS0VZX0hFQURFUikgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hcGlLZXkuc3RhcnRzV2l0aCgnYXV0aF90b2tlbnMvJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXBoZW1lcmFsIHRva2VucyBhcmUgb25seSBzdXBwb3J0ZWQgYnkgdGhlIGxpdmUgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIEFQSSBrZXkgaXMgZW1wdHkgb3IgbnVsbFxuICAgICAgICBpZiAoIXRoaXMuYXBpS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FQSSBrZXkgaXMgbWlzc2luZy4gUGxlYXNlIHByb3ZpZGUgYSB2YWxpZCBBUEkga2V5LicpO1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKEdPT0dMRV9BUElfS0VZX0hFQURFUiwgdGhpcy5hcGlLZXkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgTEFOR1VBR0VfTEFCRUxfUFJFRklYID0gJ2dsLW5vZGUvJztcbi8qKlxuICogVGhlIEdvb2dsZSBHZW5BSSBTREsuXG4gKlxuICogQHJlbWFya3NcbiAqIFByb3ZpZGVzIGFjY2VzcyB0byB0aGUgR2VuQUkgZmVhdHVyZXMgdGhyb3VnaCBlaXRoZXIgdGhlIHtAbGlua1xuICogaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3ZlcnRleC1haS9kb2NzL3JlZmVyZW5jZS9yZXN0IHwgR2VtaW5pIEFQSX0gb3JcbiAqIHRoZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3ZlcnRleC1haS9kb2NzL3JlZmVyZW5jZS9yZXN0IHwgVmVydGV4IEFJXG4gKiBBUEl9LlxuICpcbiAqIFRoZSB7QGxpbmsgR29vZ2xlR2VuQUlPcHRpb25zLnZlcnRleGFpfSB2YWx1ZSBkZXRlcm1pbmVzIHdoaWNoIG9mIHRoZSBBUElcbiAqIHNlcnZpY2VzIHRvIHVzZS5cbiAqXG4gKiBXaGVuIHVzaW5nIHRoZSBHZW1pbmkgQVBJLCBhIHtAbGluayBHb29nbGVHZW5BSU9wdGlvbnMuYXBpS2V5fSBtdXN0IGFsc28gYmVcbiAqIHNldC4gV2hlbiB1c2luZyBWZXJ0ZXggQUksIGN1cnJlbnRseSBvbmx5IHtAbGluayBHb29nbGVHZW5BSU9wdGlvbnMuYXBpS2V5fVxuICogaXMgc3VwcG9ydGVkIHZpYSBFeHByZXNzIG1vZGUuIHtAbGluayBHb29nbGVHZW5BSU9wdGlvbnMucHJvamVjdH0gYW5kIHtAbGlua1xuICogR29vZ2xlR2VuQUlPcHRpb25zLmxvY2F0aW9ufSBzaG91bGQgbm90IGJlIHNldC5cbiAqXG4gKiBAZXhhbXBsZVxuICogSW5pdGlhbGl6aW5nIHRoZSBTREsgZm9yIHVzaW5nIHRoZSBHZW1pbmkgQVBJOlxuICogYGBgdHNcbiAqIGltcG9ydCB7R29vZ2xlR2VuQUl9IGZyb20gJ0Bnb29nbGUvZ2VuYWknO1xuICogY29uc3QgYWkgPSBuZXcgR29vZ2xlR2VuQUkoe2FwaUtleTogJ0dFTUlOSV9BUElfS0VZJ30pO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEluaXRpYWxpemluZyB0aGUgU0RLIGZvciB1c2luZyB0aGUgVmVydGV4IEFJIEFQSTpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge0dvb2dsZUdlbkFJfSBmcm9tICdAZ29vZ2xlL2dlbmFpJztcbiAqIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHtcbiAqICAgdmVydGV4YWk6IHRydWUsXG4gKiAgIHByb2plY3Q6ICdQUk9KRUNUX0lEJyxcbiAqICAgbG9jYXRpb246ICdQUk9KRUNUX0xPQ0FUSU9OJ1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKi9cbmNsYXNzIEdvb2dsZUdlbkFJIHtcbiAgICBnZXQgaW50ZXJhY3Rpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJhY3Rpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcmFjdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS53YXJuKCdHb29nbGVHZW5BSS5pbnRlcmFjdGlvbnM6IEludGVyYWN0aW9ucyB1c2FnZSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHZlcnNpb25zLicpO1xuICAgICAgICBjb25zdCBodHRwT3B0cyA9IHRoaXMuaHR0cE9wdGlvbnM7XG4gICAgICAgIC8vIFVuc3VwcG9ydGVkIE9wdGlvbnMgV2FybmluZ3NcbiAgICAgICAgaWYgKGh0dHBPcHRzID09PSBudWxsIHx8IGh0dHBPcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBodHRwT3B0cy5leHRyYUJvZHkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignR29vZ2xlR2VuQUkuaW50ZXJhY3Rpb25zOiBDbGllbnQgbGV2ZWwgaHR0cE9wdGlvbnMuZXh0cmFCb2R5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGludGVyYWN0aW9ucyBjbGllbnQgYW5kIHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0R2VuQ2xpZW50ID0gbmV3IEdlbWluaU5leHRHZW5BUElDbGllbnQoe1xuICAgICAgICAgICAgYmFzZVVSTDogdGhpcy5hcGlDbGllbnQuZ2V0QmFzZVVybCgpLFxuICAgICAgICAgICAgYXBpS2V5OiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIGFwaVZlcnNpb246IHRoaXMuYXBpQ2xpZW50LmdldEFwaVZlcnNpb24oKSxcbiAgICAgICAgICAgIGNsaWVudEFkYXB0ZXI6IHRoaXMuYXBpQ2xpZW50LFxuICAgICAgICAgICAgZGVmYXVsdEhlYWRlcnM6IHRoaXMuYXBpQ2xpZW50LmdldERlZmF1bHRIZWFkZXJzKCksXG4gICAgICAgICAgICB0aW1lb3V0OiBodHRwT3B0cyA9PT0gbnVsbCB8fCBodHRwT3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cE9wdHMudGltZW91dCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2ludGVyYWN0aW9ucyA9IG5leHRHZW5DbGllbnQuaW50ZXJhY3Rpb25zO1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJhY3Rpb25zO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gQVBJIEtleSBtdXN0IGJlIHNldCB3aGVuIHJ1bm5pbmcgaW4gYSBicm93c2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2ViIGNsaWVudCBvbmx5IHN1cHBvcnRzIEFQSSBrZXkgbW9kZSBmb3IgVmVydGV4IEFJLlxuICAgICAgICBpZiAob3B0aW9ucy5wcm9qZWN0IHx8IG9wdGlvbnMubG9jYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmVydGV4IEFJIHByb2plY3QgYmFzZWQgYXV0aGVudGljYXRpb24gaXMgbm90IHN1cHBvcnRlZCBvbiBicm93c2VyIHJ1bnRpbWVzLiBQbGVhc2UgZG8gbm90IHByb3ZpZGUgYSBwcm9qZWN0IG9yIGxvY2F0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVydGV4YWkgPSAoX2EgPSBvcHRpb25zLnZlcnRleGFpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBvcHRpb25zLmFwaUtleTtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmwob3B0aW9ucy5odHRwT3B0aW9ucywgb3B0aW9ucy52ZXJ0ZXhhaSwgXG4gICAgICAgIC8qdmVydGV4QmFzZVVybEZyb21FbnYqLyB1bmRlZmluZWQsIFxuICAgICAgICAvKmdlbWluaUJhc2VVcmxGcm9tRW52Ki8gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGJhc2VVcmwpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5odHRwT3B0aW9ucy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaHR0cE9wdGlvbnMgPSB7IGJhc2VVcmw6IGJhc2VVcmwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwaVZlcnNpb24gPSBvcHRpb25zLmFwaVZlcnNpb247XG4gICAgICAgIHRoaXMuaHR0cE9wdGlvbnMgPSBvcHRpb25zLmh0dHBPcHRpb25zO1xuICAgICAgICBjb25zdCBhdXRoID0gbmV3IFdlYkF1dGgodGhpcy5hcGlLZXkpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IG5ldyBBcGlDbGllbnQoe1xuICAgICAgICAgICAgYXV0aDogYXV0aCxcbiAgICAgICAgICAgIGFwaVZlcnNpb246IHRoaXMuYXBpVmVyc2lvbixcbiAgICAgICAgICAgIGFwaUtleTogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICB2ZXJ0ZXhhaTogdGhpcy52ZXJ0ZXhhaSxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zOiB0aGlzLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgdXNlckFnZW50RXh0cmE6IExBTkdVQUdFX0xBQkVMX1BSRUZJWCArICd3ZWInLFxuICAgICAgICAgICAgdXBsb2FkZXI6IG5ldyBCcm93c2VyVXBsb2FkZXIoKSxcbiAgICAgICAgICAgIGRvd25sb2FkZXI6IG5ldyBCcm93c2VyRG93bmxvYWRlcigpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSBuZXcgTW9kZWxzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5saXZlID0gbmV3IExpdmUodGhpcy5hcGlDbGllbnQsIGF1dGgsIG5ldyBCcm93c2VyV2ViU29ja2V0RmFjdG9yeSgpKTtcbiAgICAgICAgdGhpcy5iYXRjaGVzID0gbmV3IEJhdGNoZXModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmNoYXRzID0gbmV3IENoYXRzKHRoaXMubW9kZWxzLCB0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMuY2FjaGVzID0gbmV3IENhY2hlcyh0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMuZmlsZXMgPSBuZXcgRmlsZXModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLm9wZXJhdGlvbnMgPSBuZXcgT3BlcmF0aW9ucyh0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMuYXV0aFRva2VucyA9IG5ldyBUb2tlbnModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLnR1bmluZ3MgPSBuZXcgVHVuaW5ncyh0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMuZmlsZVNlYXJjaFN0b3JlcyA9IG5ldyBGaWxlU2VhcmNoU3RvcmVzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEFjdGl2aXR5SGFuZGxpbmcsIEFkYXB0ZXJTaXplLCBBcGlFcnJvciwgQXBpU3BlYywgQXV0aFR5cGUsIEJhdGNoZXMsIEJlaGF2aW9yLCBCbG9ja2VkUmVhc29uLCBDYWNoZXMsIENhbmNlbFR1bmluZ0pvYlJlc3BvbnNlLCBDaGF0LCBDaGF0cywgQ29tcHV0ZVRva2Vuc1Jlc3BvbnNlLCBDb250ZW50UmVmZXJlbmNlSW1hZ2UsIENvbnRyb2xSZWZlcmVuY2VJbWFnZSwgQ29udHJvbFJlZmVyZW5jZVR5cGUsIENvdW50VG9rZW5zUmVzcG9uc2UsIENyZWF0ZUZpbGVSZXNwb25zZSwgRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlLCBEZWxldGVGaWxlUmVzcG9uc2UsIERlbGV0ZU1vZGVsUmVzcG9uc2UsIERvY3VtZW50U3RhdGUsIER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlLCBFZGl0SW1hZ2VSZXNwb25zZSwgRWRpdE1vZGUsIEVtYmVkQ29udGVudFJlc3BvbnNlLCBFbmRTZW5zaXRpdml0eSwgRW52aXJvbm1lbnQsIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlLCBGaWxlU291cmNlLCBGaWxlU3RhdGUsIEZpbGVzLCBGaW5pc2hSZWFzb24sIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUsIEZ1bmN0aW9uUmVzcG9uc2UsIEZ1bmN0aW9uUmVzcG9uc2VCbG9iLCBGdW5jdGlvblJlc3BvbnNlRmlsZURhdGEsIEZ1bmN0aW9uUmVzcG9uc2VQYXJ0LCBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZywgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UsIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlUHJvbXB0RmVlZGJhY2ssIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlVXNhZ2VNZXRhZGF0YSwgR2VuZXJhdGVJbWFnZXNSZXNwb25zZSwgR2VuZXJhdGVWaWRlb3NPcGVyYXRpb24sIEdlbmVyYXRlVmlkZW9zUmVzcG9uc2UsIEdvb2dsZUdlbkFJLCBIYXJtQmxvY2tNZXRob2QsIEhhcm1CbG9ja1RocmVzaG9sZCwgSGFybUNhdGVnb3J5LCBIYXJtUHJvYmFiaWxpdHksIEhhcm1TZXZlcml0eSwgSHR0cEVsZW1lbnRMb2NhdGlvbiwgSHR0cFJlc3BvbnNlLCBJbWFnZVByb21wdExhbmd1YWdlLCBJbXBvcnRGaWxlT3BlcmF0aW9uLCBJbXBvcnRGaWxlUmVzcG9uc2UsIElubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZSwgSW5saW5lZFJlc3BvbnNlLCBKb2JTdGF0ZSwgTGFuZ3VhZ2UsIExpc3RCYXRjaEpvYnNSZXNwb25zZSwgTGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2UsIExpc3REb2N1bWVudHNSZXNwb25zZSwgTGlzdEZpbGVTZWFyY2hTdG9yZXNSZXNwb25zZSwgTGlzdEZpbGVzUmVzcG9uc2UsIExpc3RNb2RlbHNSZXNwb25zZSwgTGlzdFR1bmluZ0pvYnNSZXNwb25zZSwgTGl2ZSwgTGl2ZUNsaWVudFRvb2xSZXNwb25zZSwgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sLCBMaXZlTXVzaWNTZXJ2ZXJNZXNzYWdlLCBMaXZlU2VuZFRvb2xSZXNwb25zZVBhcmFtZXRlcnMsIExpdmVTZXJ2ZXJNZXNzYWdlLCBNYXNrUmVmZXJlbmNlSW1hZ2UsIE1hc2tSZWZlcmVuY2VNb2RlLCBNZWRpYU1vZGFsaXR5LCBNZWRpYVJlc29sdXRpb24sIE1vZGFsaXR5LCBNb2RlbHMsIE11c2ljR2VuZXJhdGlvbk1vZGUsIE9wZXJhdGlvbnMsIE91dGNvbWUsIFBhZ2VkSXRlbSwgUGFnZXIsIFBhcnRNZWRpYVJlc29sdXRpb25MZXZlbCwgUGVyc29uR2VuZXJhdGlvbiwgUGhpc2hCbG9ja1RocmVzaG9sZCwgUmF3UmVmZXJlbmNlSW1hZ2UsIFJlY29udGV4dEltYWdlUmVzcG9uc2UsIFJlZ2lzdGVyRmlsZXNSZXNwb25zZSwgUmVwbGF5UmVzcG9uc2UsIFJlc291cmNlU2NvcGUsIFNhZmV0eUZpbHRlckxldmVsLCBTY2FsZSwgU2VnbWVudEltYWdlUmVzcG9uc2UsIFNlZ21lbnRNb2RlLCBTZXNzaW9uLCBTaW5nbGVFbWJlZENvbnRlbnRSZXNwb25zZSwgU3RhcnRTZW5zaXRpdml0eSwgU3R5bGVSZWZlcmVuY2VJbWFnZSwgU3ViamVjdFJlZmVyZW5jZUltYWdlLCBTdWJqZWN0UmVmZXJlbmNlVHlwZSwgVGhpbmtpbmdMZXZlbCwgVG9rZW5zLCBUcmFmZmljVHlwZSwgVHVuaW5nTWV0aG9kLCBUdW5pbmdNb2RlLCBUdW5pbmdUYXNrLCBUdXJuQ29tcGxldGVSZWFzb24sIFR1cm5Db3ZlcmFnZSwgVHlwZSwgVXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVPcGVyYXRpb24sIFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzcG9uc2UsIFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzdW1hYmxlUmVzcG9uc2UsIFVwc2NhbGVJbWFnZVJlc3BvbnNlLCBVcmxSZXRyaWV2YWxTdGF0dXMsIFZhZFNpZ25hbFR5cGUsIFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5LCBWaWRlb0dlbmVyYXRpb25NYXNrTW9kZSwgVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZSwgVm9pY2VBY3Rpdml0eVR5cGUsIGNyZWF0ZUZ1bmN0aW9uUmVzcG9uc2VQYXJ0RnJvbUJhc2U2NCwgY3JlYXRlRnVuY3Rpb25SZXNwb25zZVBhcnRGcm9tVXJpLCBjcmVhdGVNb2RlbENvbnRlbnQsIGNyZWF0ZVBhcnRGcm9tQmFzZTY0LCBjcmVhdGVQYXJ0RnJvbUNvZGVFeGVjdXRpb25SZXN1bHQsIGNyZWF0ZVBhcnRGcm9tRXhlY3V0YWJsZUNvZGUsIGNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25DYWxsLCBjcmVhdGVQYXJ0RnJvbUZ1bmN0aW9uUmVzcG9uc2UsIGNyZWF0ZVBhcnRGcm9tVGV4dCwgY3JlYXRlUGFydEZyb21VcmksIGNyZWF0ZVVzZXJDb250ZW50LCBtY3BUb1Rvb2wsIHNldERlZmF1bHRCYXNlVXJscyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@google/genai/dist/web/index.mjs\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fworkspaces%2Feburondual%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);